//
//  SettingsTableViewCell.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/28/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum SettingsPages: String, CaseIterable {
    case account = "Account"
    case family = "Family"
    case subscription = "Subscription"
    case appearance = "Appearance"
    case notifications = "Notifications"
    
    case website = "Website"
    case feedback = "Feedback"
    case support = "Support"
    case releaseNotes = "Release Notes"
    case eula = "EULA"
    case privacyPolicy = "Privacy Policy"
    case termsAndConditions = "Terms and Conditions"
    
    var url: URL? {
        switch self {
        case .account:
            return nil
        case .family:
            return nil
        case .subscription:
            return nil
        case .appearance:
            return nil
        case .notifications:
            return nil
        case .releaseNotes:
            return nil
        case .website:
            return URL(string: "https://www.houndorganizer.com")
        case .feedback:
            return nil
        case .support:
            return URL(string: "https://www.houndorganizer.com/contact")
        case .eula:
            return URL(string: "https://www.houndorganizer.com/eula")
        case .privacyPolicy:
            return URL(string: "https://www.houndorganizer.com/privacy")
        case .termsAndConditions:
            return URL(string: "https://www.houndorganizer.com/terms")
        }
    }
    
    var image: UIImage? {
        switch self {
        case .account:
            return UIImage(systemName: "person.crop.circle")
        case .family:
            return UIImage(systemName: "figure.and.child.holdinghands") ?? UIImage(systemName: "person.3")
        case .subscription:
            return UIImage(systemName: "creditcard")
        case .appearance:
            return UIImage(systemName: "textformat")
        case .notifications:
            return UIImage(systemName: "iphone.radiowaves.left.and.right")
        case .releaseNotes:
            return UIImage(systemName: "doc.text")
        case .website:
            return UIImage(systemName: "globe")
        case .feedback:
            return UIImage(systemName: "square.and.pencil")
        case .support:
            return UIImage(systemName: "envelope")
        case .eula:
            return UIImage(systemName: "doc.plaintext")
        case .privacyPolicy:
            return UIImage(systemName: "shield")
        case .termsAndConditions:
            return UIImage(systemName: "text.book.closed")
        }
    }
}

final class SettingsPagesTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    let containerView: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.systemBlue
        return view
    }()
    
    private let pageImageView: HoundImageView = {
        let imageView = HoundImageView()
        
        imageView.tintColor = UIColor.systemBackground
        
        return imageView
    }()
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.textColor = UIColor.systemBackground
        return label
    }()
    
    private let chevronImageView: HoundImageView = {
        let imageView = HoundImageView()
        
        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = UIColor.systemBackground
        
        return imageView
    }()
    
    // MARK: - Properties
    
    var page: SettingsPages?
    
    static let reuseIdentifier = "SettingsPagesTVC"
    
    // MARK: - Setup
    
    func setup(page: SettingsPages) {
        self.page = page
        
        pageImageView.image = page.image
        headerLabel.text = page.rawValue
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(pageImageView)
        containerView.addSubview(headerLabel)
        containerView.addSubview(chevronImageView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        let pageImageViewInset: CGFloat = 5.0
        // pageImageView inset relative to headerLabel inset
        let pageViewRelativeVertInset = -Constant.Constraint.Spacing.absoluteVertInset + pageImageViewInset
        
        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // pageImageView
        NSLayoutConstraint.activate([
            pageImageView.topAnchor.constraint(equalTo: headerLabel.topAnchor, constant: pageViewRelativeVertInset),
            pageImageView.bottomAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: -pageViewRelativeVertInset),
            pageImageView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: pageImageViewInset),
            pageImageView.createAspectRatio(1.0)
        ])
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: pageImageView.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // chevronImageView
        NSLayoutConstraint.activate([
            chevronImageView.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            chevronImageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            chevronImageView.centerYAnchor.constraint(equalTo: containerView.centerYAnchor),
            chevronImageView.createAspectRatio(Constant.Constraint.Button.chevronAspectRatio),
            chevronImageView.createHeightMultiplier(Constant.Constraint.Button.chevronHeightMultiplier, relativeToWidthOf: contentView),
            chevronImageView.createMaxHeight(Constant.Constraint.Button.chevronMaxHeight)
        ])
    }
    
}
//
//  SettingsSubscriptionCancelReasonView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/28/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsSubscriptionCancelReasonVC: HoundScrollViewController, UITableViewDelegate, UITableViewDataSource, SettingsSubscriptionCancelReasonTVCDelegate, SettingsSubscriptionCancelSuggestionsVCDelegate {
    
    // MARK: - SettingsSubscriptionCancelReasonTVCDelegate
    
    func didSetCustomIsSelected(cell: SettingsSubscriptionCancelReasonTVC, isCustomSelected: Bool) {
        lastSelectedCell = cell
        
        // The user can only continue if they have selected a cancellation reason
        continueButton.isEnabled = isCustomSelected
    }
    
    // MARK: - SettingsSubscriptionCancelSuggestionsVCDelegate
    
    func didShowManageSubscriptions() {
        // Now that we have just shown the page to manage subscriptions, dismiss all these feedback pages
        settingsSubscriptionCancelSuggestionsViewController?.dismiss(animated: true, completion: {
            self.dismiss(animated: true)
        })
    }
    
    // MARK: - Elements
    
    private let pageHeaderView: HoundPageSheetHeaderView = {
        let view = HoundPageSheetHeaderView(huggingPriority: 350, compressionResistancePriority: 350)
        view.useLeftTextAlignment = false
        
        view.pageHeaderLabel.text = "Sorry to See You Go!"
        view.pageHeaderLabel.textColor = UIColor.systemBackground
        
        view.isDescriptionEnabled = true
        view.pageDescriptionLabel.text = "What was wrong with your Hound+ subscription?"
        view.pageDescriptionLabel.textColor = UIColor.systemBackground
        
        view.backButton.tintColor = UIColor.systemBackground
        view.backButton.backgroundCircleTintColor = nil
        
        return view
    }()
    
    private lazy var tableView: HoundTableView = {
        let tableView = HoundTableView(style: .plain, huggingPriority: 340, compressionResistancePriority: 340)
        tableView.delegate = self
        tableView.dataSource = self
        
        tableView.shouldAutomaticallyAdjustHeight = true
        tableView.backgroundColor = UIColor.clear
        
        tableView.isScrollEnabled = false
        
        tableView.register(SettingsSubscriptionCancelReasonTVC.self, forCellReuseIdentifier: SettingsSubscriptionCancelReasonTVC.reuseIdentifier)
        tableView.sectionHeaderTopPadding = 12.5
        
        return tableView
    }()
    
    private lazy var continueButton: HoundButton = {
        let button = HoundButton(huggingPriority: 330, compressionResistancePriority: 330)
        
        button.setTitle("Continue", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
         button.applyStyle(.labelBorder)
        
        // Continue button is disabled until the user selects a cancellation reason
        button.isEnabled = false
        
        let continueAction = UIAction { [weak self] _ in
            guard let self = self else { return }
            
            let vc = SettingsSubscriptionCancelSuggestionsVC()
            self.settingsSubscriptionCancelSuggestionsViewController = vc
            vc.setup(delegate: self, cancellationReason: lastSelectedCell?.cancellationReason)
            PresentationManager.enqueueViewController(vc)
        }
        button.addAction(continueAction, for: .touchUpInside)
        
        return button
    }()
    
    // MARK: - Properties
    
    /// The subscription tier that is currently selected by the user. Theoretically, this shouldn't ever be nil.
    private var lastSelectedCell: SettingsSubscriptionCancelReasonTVC?
    
    private var settingsSubscriptionCancelSuggestionsViewController: SettingsSubscriptionCancelSuggestionsVC?
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
    }
    
    // MARK: - Table View Data Source
    
    // Make each cell its own section, allows us to easily space the cells
    func numberOfSections(in tableView: UITableView) -> Int {
        return SubscriptionCancellationReason.allCases.count
    }
    
    // Make each cell its own section, allows us to easily space the cells
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
        // Only add spacing if NOT the last section
        let lastSection = SubscriptionCancellationReason.allCases.count - 1
        return section == lastSection ? 0 : Constant.Constraint.Spacing.contentIntraVert
    }

    func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {
        // Only return a view if not the last section
        let lastSection = SubscriptionCancellationReason.allCases.count - 1
        if section == lastSection {
            return nil
        }
        
        let footer = HoundHeaderFooterView()
        return footer
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: SettingsSubscriptionCancelReasonTVC.reuseIdentifier, for: indexPath) as? SettingsSubscriptionCancelReasonTVC else {
            return HoundTableViewCell()
        }
        
        if lastSelectedCell == cell {
            // cell has been used before and lastSelectedCell is a reference to this cell. However, this cell could be changing to a different SubscriptionCancellationReason in setup, so that would invaliate lastSelectedCell. Therefore, clear lastSelectedCell
            lastSelectedCell = nil
        }
        
        let cellCancellationReason: SubscriptionCancellationReason = SubscriptionCancellationReason.allCases[indexPath.section]
        let cellIsCustomSelected: Bool = {
            // We do not want to override the lastSelectedCell as this function could be called after a user selceted a cell manually by themselves
            return lastSelectedCell?.cancellationReason == cellCancellationReason
        }()
        
        // We can only have one cell selected at once, therefore clear lastSelectedCell's selection state
        if cellIsCustomSelected == true {
            lastSelectedCell?.setCustomSelected(false, animated: false)
        }
        
        cell.setup(delegate: self, cancellationReason: cellCancellationReason, isCustomSelected: cellIsCustomSelected)
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        // Let a user select cells even if they don't have the permission to as a non-family head.
        guard let selectedCell = tableView.cellForRow(at: indexPath) as? SettingsSubscriptionCancelReasonTVC else { return }
        
        // Check if lastSelectedCell and selectedCells are actually different cells
        if let lastSelectedCell = lastSelectedCell, lastSelectedCell != selectedCell {
            // If they are different cells, then that must mean a new cell is being selected to transition into the selected state. Unselect the old cell and select the new one
            lastSelectedCell.setCustomSelected(false, animated: true)
            selectedCell.setCustomSelected(true, animated: true)
        }
        // We are selecting the same cell as last time. However, a cell always needs to be selected. Therefore, we cannot deselect the current cell as that would mean we would have no cell selected at all, so always select.
        else {
            selectedCell.setCustomSelected(true, animated: true)
        }
        
        lastSelectedCell = selectedCell
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(pageHeaderView)
        containerView.addSubview(tableView)
        containerView.addSubview(continueButton)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pageHeaderView
        NSLayoutConstraint.activate([
            pageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            pageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            pageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // tableView
        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: pageHeaderView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            tableView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            tableView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // continueButton constraints
        NSLayoutConstraint.activate([
            continueButton.topAnchor.constraint(equalTo: tableView.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            continueButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            continueButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            continueButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            continueButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: containerView),
            continueButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
        
    }
    
}
//
//  SettingsSubscriptionCancelReasonTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/28/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol SettingsSubscriptionCancelReasonTVCDelegate: AnyObject {
    func didSetCustomIsSelected(cell: SettingsSubscriptionCancelReasonTVC, isCustomSelected: Bool)
}

final class SettingsSubscriptionCancelReasonTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let containerView: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.systemBackground
        view.layer.cornerRadius = Constant.Visual.Layer.defaultCornerRadius
        view.layer.cornerCurve = .continuous
        return view
    }()
    
    private let cancellationReasonLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.font = Constant.Visual.Font.emphasizedPrimaryRegularLabel
        return label
    }()
    
    private let checkmarkButton: HoundButton = {
        let button = HoundButton(huggingPriority: 250, compressionResistancePriority: 250)
        
        button.isUserInteractionEnabled = false
        
        button.isHidden = true
        button.setImage(UIImage(systemName: "checkmark.circle.fill"), for: .normal)
        button.tintColor = UIColor.systemGreen
        
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        return button
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsSubscriptionCancelReasonTVC"
    
    /// The cancellation reason this cell is displaying
    private(set) var cancellationReason: SubscriptionCancellationReason?
    
    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    private var isCustomSelected: Bool = false
    
    private weak var delegate: SettingsSubscriptionCancelReasonTVCDelegate?
    
    // MARK: - Setup
    
    func setup(delegate: SettingsSubscriptionCancelReasonTVCDelegate, cancellationReason: SubscriptionCancellationReason, isCustomSelected: Bool) {
        self.delegate = delegate
        self.cancellationReason = cancellationReason
        
        setCustomSelected(isCustomSelected, animated: false)
    }
    
    // MARK: - Functions
    
    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    func setCustomSelected(_ selected: Bool, animated: Bool) {
        isCustomSelected = selected
        
        delegate?.didSetCustomIsSelected(cell: self, isCustomSelected: isCustomSelected)
        
        UIView.animate(withDuration: animated ? Constant.Visual.Animation.selectSingleElement : 0.0) {
            self.checkmarkButton.isHidden = !self.isCustomSelected
            
            self.containerView.applyStyle(self.isCustomSelected ? .greenSelectionBorder : .labelBorder)
            
            self.cancellationReasonLabel.text = self.cancellationReason?.readableValue ?? Constant.Visual.Text.unknownText
        }
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(cancellationReasonLabel)
        containerView.addSubview(checkmarkButton)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor)
        ])

        // cancellationReasonLabel
        NSLayoutConstraint.activate([
            cancellationReasonLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            cancellationReasonLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            cancellationReasonLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori)
        ])
        
        // checkmarkButton
        NSLayoutConstraint.activate([
            checkmarkButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset / 2.0),
            checkmarkButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -(Constant.Constraint.Spacing.absoluteVertInset / 2.0)),
            checkmarkButton.leadingAnchor.constraint(greaterThanOrEqualTo: cancellationReasonLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            checkmarkButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.contentIntraHori),
            checkmarkButton.createSquareAspectRatio()
        ])
    }

}
//
//  SettingsSubscriptionCancelSuggestionsVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/28/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol SettingsSubscriptionCancelSuggestionsVCDelegate: AnyObject {
    func didShowManageSubscriptions()
}

final class SettingsSubscriptionCancelSuggestionsVC: HoundScrollViewController, UITextViewDelegate {
    
    // MARK: - UITextViewDelegate
    
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        // Don't allow new lines; treat as "done"
        guard text != "\n" else {
            self.dismissKeyboard()
            return false
        }
        
        let currentText = textView.text ?? ""
        guard let stringRange = Range(range, in: currentText) else { return false }
        let updatedText = currentText.replacingCharacters(in: stringRange, with: text)
        return updatedText.count <= Constant.Class.Feedback.subscriptionCancellationSuggestionCharacterLimit
    }
    
    // MARK: - Elements

    private let pageHeaderView: HoundPageSheetHeaderView = {
        let view = HoundPageSheetHeaderView(huggingPriority: 350, compressionResistancePriority: 350)
        view.useLeftTextAlignment = false
        
        view.pageHeaderLabel.text = "Sorry to See You Go!"
        view.pageHeaderLabel.textColor = UIColor.systemBackground
        
        view.isDescriptionEnabled = true
        view.pageDescriptionLabel.text = "What could we do to improve?"
        view.pageDescriptionLabel.textColor = UIColor.systemBackground
        
        view.backButton.tintColor = UIColor.systemBackground
        view.backButton.backgroundCircleTintColor = nil
        
        return view
    }()
    
    private lazy var suggestionTextView: HoundTextView = {
        let textView = HoundTextView(huggingPriority: 320, compressionResistancePriority: 320)
        textView.delegate = self
        
        textView.backgroundColor = UIColor.systemBackground
        textView.textColor = UIColor.label
        
        textView.font = Constant.Visual.Font.primaryRegularLabel
        
        textView.applyStyle(.labelBorder)
        
        textView.placeholder = "Share any suggestions or issues..."
        
        return textView
    }()
    
    private lazy var continueButton: HoundButton = {
        let button = HoundButton(huggingPriority: 310, compressionResistancePriority: 310)
        
        button.setTitle("Cancel Subscription", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
         button.applyStyle(.labelBorder)
        
        let action = UIAction { [weak self] _ in
            guard let self = self else {
                return
            }
            // Only allow if user is a family head
            guard UserInformation.isUserFamilyHead else {
                PresentationManager.enqueueBanner(
                    title: Constant.Visual.BannerText.notFamilyHeadInvalidPermissionTitle,
                    subtitle: Constant.Visual.BannerText.notFamilyHeadInvalidPermissionSubtitle,
                    style: .danger
                )
                return
            }
            
            SurveyFeedbackRequest.create(
                errorAlert: .automaticallyAlertForNone,
                userCancellationReason: self.cancellationReason,
                userCancellationFeedback: self.suggestionTextView.text ?? ""
            ) { _, _ in return }
            
            InAppPurchaseManager.showManageSubscriptions()
            delegate?.didShowManageSubscriptions()
        }
        button.addAction(action, for: .touchUpInside)
        
        return button
    }()
    
    // MARK: - Properties
    
    private weak var delegate: SettingsSubscriptionCancelSuggestionsVCDelegate?
    
    /// The cancellationReason passed from the previous VC
    private var cancellationReason: SubscriptionCancellationReason?
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
    }
    
    // MARK: - Setup
    
    func setup(delegate: SettingsSubscriptionCancelSuggestionsVCDelegate, cancellationReason: SubscriptionCancellationReason?) {
        self.delegate = delegate
        self.cancellationReason = cancellationReason
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBlue
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(pageHeaderView)
        containerView.addSubview(suggestionTextView)
        containerView.addSubview(continueButton)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pageHeaderView
        NSLayoutConstraint.activate([
            pageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            pageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            pageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // suggestionTextView
        NSLayoutConstraint.activate([
            suggestionTextView.topAnchor.constraint(equalTo: pageHeaderView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            suggestionTextView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            suggestionTextView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            suggestionTextView.createHeightMultiplier(Constant.Constraint.Input.textViewHeightMultiplier, relativeToWidthOf: containerView),
            suggestionTextView.createMaxHeight(Constant.Constraint.Input.textViewMaxHeight)
        ])
        
        // continueButton
        NSLayoutConstraint.activate([
            continueButton.topAnchor.constraint(equalTo: suggestionTextView.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            continueButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            continueButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            continueButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            continueButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: containerView),
            continueButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }
}
//
//  SettingsSubscriptionTierTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/15/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import StoreKit
import UIKit

protocol SettingsSubscriptionTierTVCDelegate: AnyObject {
    func didSetCustomIsSelectedToTrue(cell: SettingsSubscriptionTierTVC)
}

final class SettingsSubscriptionTierTVC: HoundTableViewCell {

    // MARK: - Elements
    
    private let containerView: HoundView = {
        let view = HoundView()
        view.shouldRoundCorners = true
        view.staticCornerRadius = Constant.Visual.Layer.defaultCornerRadius
        view.backgroundColor = UIColor.systemBackground
        return view
    }()
    
    private let alignmentViewForSavePercent: HoundView = {
        let view = HoundView()
        view.isHidden = true
        return view
    }()

    private let savePercentLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 350, compressionResistancePriority: 350)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.backgroundColor = UIColor.systemGreen
        label.font = Constant.Visual.Font.emphasizedPrimaryRegularLabel
        label.textColor = UIColor.systemBackground
        label.shouldRoundCorners = true
        label.staticCornerRadius = nil
        return label
    }()
    
    private lazy var priceStack: UIStackView = {
        let stackView = UIStackView(arrangedSubviews: [totalPriceLabel, monthlyPriceLabel])
        stackView.axis = .vertical
        stackView.alignment = .leading
        stackView.distribution = .fillProportionally
        stackView.spacing = Constant.Constraint.Spacing.contentIntraVert
        stackView.translatesAutoresizingMaskIntoConstraints = false
        return stackView
    }()
    
    private let totalPriceLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 340, compressionResistancePriority: 340)
        // font set in attributed
        return label
    }()

    private let monthlyPriceLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 330, compressionResistancePriority: 330)
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        // font set in attributed
        label.textColor = UIColor.secondaryLabel
        return label
    }()

    private let checkmarkImageView: HoundImageView = {
        let imageView = HoundImageView(huggingPriority: 320, compressionResistancePriority: 320)
        
        imageView.isHidden = true
        imageView.image = UIImage(systemName: "checkmark.circle.fill")
        imageView.tintColor = UIColor.systemGreen
        
        return imageView
    }()

    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsSubscriptionTierTVC"

    /// The SKProduct this cell is displaying
    private(set) var product: SKProduct?

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    private var isCustomSelected: Bool = false

    private weak var delegate: SettingsSubscriptionTierTVCDelegate?

    // MARK: - Setup

    func setup(delegate: SettingsSubscriptionTierTVCDelegate, product: SKProduct, isCustomSelected: Bool) {
        self.delegate = delegate
        self.product = product

        setCustomSelected(isCustomSelected, animated: false)
    }
    
    // MARK: - Functions

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    func setCustomSelected(_ selected: Bool, animated: Bool) {
        isCustomSelected = selected

        if isCustomSelected == true {
            delegate?.didSetCustomIsSelectedToTrue(cell: self)
        }
        
        // this must come first as savePercentLabel.text changes
        self.setupPriceLabels()

        UIView.animate(withDuration: animated ? Constant.Visual.Animation.selectSingleElement : 0.0) {
            self.checkmarkImageView.isHidden = !self.isCustomSelected
            self.savePercentLabel.isHidden = !self.isCustomSelected && self.savePercentLabel.text != nil

            self.containerView.applyStyle(self.isCustomSelected ? .greenSelectionBorder : .labelBorder)
        }
    }

    /// Attempts to set the attributedText for totalPriceLabel and monthlyPriceLabel given the current product, productFullPrice, and isCustomSelected
    private func setupPriceLabels() {
        guard let product = product, let monthlySubscriptionPrice = product.monthlySubscriptionPrice, let unit = product.subscriptionPeriod?.unit, let numberOfUnits = product.subscriptionPeriod?.numberOfUnits else {
            totalPriceLabel.text = Constant.Visual.Text.unknownText
            monthlyPriceLabel.text = Constant.Visual.Text.unknownText
            return
        }

        // $2.99, €1.99, ¥9.99
        let totalPriceWithCurrencySymbol = "\(product.priceLocale.currencySymbol ?? "")\(product.price)"

        // Make the number more visually appealing by rounding to the nearest x.x9.
        let roundedMonthlySubscriptionPrice = (Int(ceil(monthlySubscriptionPrice * 100)) % 10) >= 5
        ? (ceil(monthlySubscriptionPrice * 10) / 10) - 0.01 // round up to nearest x.x9
        : (floor(monthlySubscriptionPrice * 10) / 10) - 0.01 // round down to nearest x.x9

        // Converts whatever the price, unit, and numberOfUnits is into an approximate monthly price: $2.99, €1.99, ¥9.99
        let roundedMonthlyPriceWithCurrencySymbol = "\(product.priceLocale.currencySymbol ?? "")\(String(format: "%.2f", roundedMonthlySubscriptionPrice))"

        // To explain the difference between discounted and full price, take for example "6 months - $59.99  $119.99". $120 is the "full" price if you used a $20 1 month subscription for 6 months and $60 is our "discounted" price for buying the 6 month subscription
        // If the cell isn't selected, all of the text is the tertiary label color
        let discountedTotalPriceTextAttributes: [NSAttributedString.Key: Any] = [
            .font: Constant.Visual.Font.emphasizedTertiaryHeaderLabel,
            .foregroundColor: isCustomSelected ? UIColor.label : UIColor.tertiaryLabel
        ]
        let fullTotalPricePrimaryTextAttributes: [NSAttributedString.Key: Any] = [
            .font: Constant.Visual.Font.emphasizedTertiaryHeaderLabel,
            .foregroundColor: isCustomSelected ? UIColor.secondaryLabel : UIColor.tertiaryLabel,
            .strikethroughStyle: NSUnderlineStyle.single.rawValue
        ]
        let monthlyPriceTextAttributes: [NSAttributedString.Key: Any] = [
            .font: Constant.Visual.Font.secondaryRegularLabel,
            .foregroundColor: isCustomSelected ? UIColor.secondaryLabel : UIColor.tertiaryLabel
        ]

        // "" -> "6 months - $59.99"
        let precalculatedDynamicSubscriptionLengthAndPriceText = "\(convertPeriodUnit(unit: unit, numberOfUnits: numberOfUnits)) - \(totalPriceWithCurrencySymbol)"

        // "1 month - $19.99 " -> "1 months - $19.99" (NO-OP)
        // "6 months - $59.99 " -> "6 months - $59.99 $119.99"
        var fullPriceText: String?
        if let fullPrice = product.fullPrice, fullPrice != Double(truncating: product.price) {
            // e.g. 78.5 product.price / 100.0 fullPrice -> 0.785 -> 1 - 0.785 -> 0.225 -> 0.225 * 100 -> 22.5 -> 23
            var unroundedPercentageSaved = Int(
                ceil(
                    (1 - (Double(truncating: product.price) / fullPrice)) * 100.0
                )
            )

            // Round up to the nearest 5
            // 20 -> 20, 21 -> 25, 22 -> 25, 23 -> 25, 24 -> 25, 25 -> 25
            unroundedPercentageSaved = (unroundedPercentageSaved % 5 > 0)
            ? (unroundedPercentageSaved + 5) - (unroundedPercentageSaved % 5)
            : unroundedPercentageSaved

            savePercentLabel.text = " SAVE \(unroundedPercentageSaved)%   "

            // Make the number more visually appealing by rounding up to the nearest x.99. The important calculations are done so we can perform this rounding
            let fullPriceRoundedUpToNearest99 = ceil(fullPrice) > 0.0 ? ceil(fullPrice) - 0.01 : 0.0

            fullPriceText = "\(product.priceLocale.currencySymbol ?? "")\(fullPriceRoundedUpToNearest99)"
        }
        else {
            savePercentLabel.text = nil
        }

        totalPriceLabel.attributedText = {
            // "" -> "6 months - $59.99"
            let message: NSMutableAttributedString = NSMutableAttributedString(
                string: precalculatedDynamicSubscriptionLengthAndPriceText,
                attributes: discountedTotalPriceTextAttributes)

            // "1 month - $19.99 " -> "1 months - $19.99" (NO-OP)
            // "6 months - $59.99 " -> "6 months - $59.99 $119.99"
            if let fullPriceText = fullPriceText {
                // We need a space between the original text and the new text
                message.append(
                    NSAttributedString(string: " ")
                )

                message.append(
                    NSAttributedString(
                    string: fullPriceText,
                    attributes: fullTotalPricePrimaryTextAttributes
                    )
                )
            }

            return message
        }()

        // If the prodcut displayed by this cell is the active subscription, have this cell also show the active subscriptions expiration date
        let activeSubscriptionExpirationText: String = {
            guard let expiresDate = FamilyInformation.familyActiveSubscription.expiresDate else {
                return ""
            }
            
            let expiresYear = Calendar.user.component(.year, from: expiresDate)
            let currentYear = Calendar.user.component(.year, from: Date())
            
            // January 25 OR January 25, 2023
            let template = expiresYear == currentYear ? "MMMMd" : "MMMMdyyyy"

            guard FamilyInformation.familyActiveSubscription.productId == product.productIdentifier else {
                // This cell isn't the active subscription, however it is set to renew
                if FamilyInformation.familyActiveSubscription.autoRenewStatus == true && FamilyInformation.familyActiveSubscription.autoRenewProductId == product.productIdentifier {
                    return ", renewing \(expiresDate.houndFormatted(.template(template), displayTimeZone: UserConfiguration.timeZone))"
                }
                return ""
            }
            // This cell is the active subscription with an expiresDate. It could be renewing or expiring on the expiresDate

            return ", \(FamilyInformation.familyActiveSubscription.autoRenewStatus == true && FamilyInformation.familyActiveSubscription.autoRenewProductId == product.productIdentifier ? "renewing" : "expiring") \(expiresDate.houndFormatted(.template(template), displayTimeZone: UserConfiguration.timeZone))"
        }()

        monthlyPriceLabel.attributedText = {
            NSAttributedString(
                string: "\(roundedMonthlyPriceWithCurrencySymbol) / month\(activeSubscriptionExpirationText)",
                attributes: monthlyPriceTextAttributes
            )
        }()
    }

    /// Converts period unit and numberOfUnits into string, e.g. "3 days", "1 week", "6 months"
    private func convertPeriodUnit(unit: SKProduct.PeriodUnit, numberOfUnits: Int) -> String {

        // Display x year as 12x months
        guard unit != .year else {
            return "\(numberOfUnits * 12) months"
        }

        var string = "\(numberOfUnits) "

        switch unit {
        case .day:
            string.append("day")
        case .week:
            string.append("week")
        case .month:
            string.append("month")
        default:
            break
        }

        if numberOfUnits > 1 {
            string.append("s")
        }

        return string
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        contentView.addSubview(savePercentLabel)
        containerView.addSubview(alignmentViewForSavePercent)
        containerView.addSubview(priceStack)
        containerView.addSubview(checkmarkImageView)
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor)
        ])
        
        // alignmentViewForSavePercent
        NSLayoutConstraint.activate([
            alignmentViewForSavePercent.topAnchor.constraint(equalTo: containerView.topAnchor),
            alignmentViewForSavePercent.bottomAnchor.constraint(equalTo: containerView.topAnchor),
            alignmentViewForSavePercent.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            alignmentViewForSavePercent.trailingAnchor.constraint(equalTo: containerView.centerXAnchor)
        ])

        // savePercentLabel
        NSLayoutConstraint.activate([
            savePercentLabel.centerXAnchor.constraint(equalTo: alignmentViewForSavePercent.centerXAnchor),
            savePercentLabel.centerYAnchor.constraint(equalTo: alignmentViewForSavePercent.centerYAnchor)
        ])
        
        // priceStack
        NSLayoutConstraint.activate([
            priceStack.topAnchor.constraint(equalTo: containerView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            priceStack.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            priceStack.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
        
        // checkmarkImageView
        NSLayoutConstraint.activate([
            checkmarkImageView.leadingAnchor.constraint(greaterThanOrEqualTo: priceStack.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            checkmarkImageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.contentIntraHori),
            checkmarkImageView.centerYAnchor.constraint(equalTo: priceStack.centerYAnchor),
            checkmarkImageView.heightAnchor.constraint(equalTo: priceStack.heightAnchor),
            checkmarkImageView.createSquareAspectRatio()
        ])
    }

}
//
//  SettingsSubscriptionsViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/15/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import KeychainSwift
import StoreKit
import UIKit

final class SettingsSubscriptionVC: HoundScrollViewController, UITableViewDelegate, UITableViewDataSource, SettingsSubscriptionTierTVCDelegate {
    
    // MARK: - SettingsSubscriptionTierTableViewCellSettingsSubscriptionTierTVC
    
    func didSetCustomIsSelectedToTrue(cell: SettingsSubscriptionTierTVC) {
        lastSelectedCell = cell
        
        if let attributedText = continueButton.titleLabel?.attributedText {
            let mutableAttributedText = NSMutableAttributedString(attributedString: attributedText)
            let buttonTitle: String = {
                if FamilyInformation.familyActiveSubscription.autoRenewProductId == lastSelectedCell?.product?.productIdentifier {
                    return "Cancel Subscription"
                }
                
                return SettingsSubscriptionVC.userPurchasedProductFrom20965379 ? "Upgrade" : "Start Free Trial"
            }()
            mutableAttributedText.mutableString.setString(buttonTitle)
            UIView.performWithoutAnimation {
                // By default it does an unnecessary, ugly animation. The combination of performWithoutAnimation and layoutIfNeeded prevents this.
                continueButton.setAttributedTitle(mutableAttributedText, for: .normal)
                continueButton.layoutIfNeeded()
            }
        }
    }
    
    // MARK: - Elements
    
    private let houndPaw: HoundPawImageView = {
        let imageView = HoundPawImageView(huggingPriority: 290, compressionResistancePriority: 290)
        
        return imageView
    }()
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.text = "Hound+"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = UIFont.systemFont(ofSize: 47.5, weight: .bold)
        label.textColor = UIColor.systemBackground
        return label
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.text = "Grow your family with up to six members"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        label.textColor = UIColor.secondarySystemBackground
        return label
    }()
    
    private let backButton: HoundButton = {
        let button = HoundButton()
        
        button.tintColor = UIColor.systemBackground
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBlue
        
        button.shouldRoundCorners = true
        button.shouldDismissParentViewController = true
        return button
    }()
    
    private lazy var tableView: HoundTableView = {
        let tableView = HoundTableView()
        tableView.delegate = self
        tableView.dataSource = self
        
        tableView.isScrollEnabled = false
        tableView.backgroundColor = UIColor.clear
        
        tableView.shouldAutomaticallyAdjustHeight = true
        tableView.emptyStateEnabled = true
        tableView.emptyStateMessage = "No subscriptions available..."
        tableView.emptyStateMessageColor = .systemBackground
        
        // allow the save x% label for a TVC to go outside cell bound
        tableView.clipsToBounds = false
        
        return tableView
    }()
    
    private let freeTrialScaledLabel: HoundLabel = {
        let label = HoundLabel()
        label.textAlignment = .center
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.textColor = UIColor.systemBackground
        
        label.isHidden = userPurchasedProductFrom20965379
        
        label.attributedText = NSMutableAttributedString(
            string: "Start with a 1 week free trial",
            attributes: [.font: UIFont.italicSystemFont(ofSize: Constant.Visual.Font.primaryRegularLabel.pointSize)]
        )
        
        return label
    }()
    
    private lazy var continueButton: HoundButton = {
        let button = HoundButton()
        
        button.setTitle("Continue", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
         button.applyStyle(.labelBorder)
        
        button.addTarget(self, action: #selector(didTapContinue), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var redeemButton: HoundButton = {
        let button = HoundButton()
        
        button.isHidden = !UserInformation.isUserFamilyHead
        
        let attributes: [NSAttributedString.Key: Any] = [
            .font: Constant.Visual.Font.primaryRegularLabel,
            .foregroundColor: UIColor.systemBackground,
            .underlineStyle: NSUnderlineStyle.single.rawValue
        ]
        button.setAttributedTitle(NSAttributedString(string: "Redeem", attributes: attributes), for: .normal)
        
        button.addTarget(self, action: #selector(didTapRedeem), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var restoreButton: HoundButton = {
        let button = HoundButton()
        
        button.isHidden = !UserInformation.isUserFamilyHead
        
        let attributes: [NSAttributedString.Key: Any] = [
            .font: Constant.Visual.Font.primaryRegularLabel,
            .foregroundColor: UIColor.systemBackground,
            .underlineStyle: NSUnderlineStyle.single.rawValue
        ]
        button.setAttributedTitle(NSAttributedString(string: "Restore", attributes: attributes), for: .normal)
        
        button.addTarget(self, action: #selector(didTapRestoreTransactions), for: .touchUpInside)
       
        return button
    }()
    
    private lazy var redeemRestoreButtonStack: UIStackView = {
        let stackView = UIStackView(arrangedSubviews: [redeemButton, restoreButton])
        stackView.axis = .horizontal
        stackView.alignment = .fill
        stackView.distribution = .fillEqually
        stackView.spacing = Constant.Constraint.Spacing.contentIntraHori
        stackView.translatesAutoresizingMaskIntoConstraints = false
        return stackView
    }()
    
    private let subscriptionDisclaimerLabel: HoundLabel = {
        let label = HoundLabel()
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondarySystemBackground
        
        label.text = "Subscriptions can only be purchased by the family head"
        if let familyHeadFullName = FamilyInformation.familyMembers.first(where: { familyMember in
            return familyMember.isUserFamilyHead
        })?.displayFullName {
            label.text?.append(" (\(familyHeadFullName))")
        }
        label.text?.append(". Cancel anytime.")
        
        return label
    }()
    
    @objc private func didTapRedeem(_ sender: Any) {
        InAppPurchaseManager.presentCodeRedemptionSheet()
    }
    
    @objc private func didTapRestoreTransactions(_ sender: Any) {
        // The user doesn't have permission to perform this action
        guard UserInformation.isUserFamilyHead else {
            PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.notFamilyHeadInvalidPermissionTitle, subtitle: Constant.Visual.BannerText.notFamilyHeadInvalidPermissionSubtitle, style: .danger)
            return
        }
        
        restoreButton.isEnabled = false
        PresentationManager.beginFetchingInformationIndicator()
        
        InAppPurchaseManager.restorePurchases { requestWasSuccessful in
            PresentationManager.endFetchingInformationIndicator {
                self.restoreButton.isEnabled = true
                guard requestWasSuccessful else {
                    return
                }
                
                PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.successRestoreTransactionsTitle, subtitle: Constant.Visual.BannerText.successRestoreTransactionsSubtitle, style: .success)
                
                // When we reload the tableView, cells are reusable.
                self.lastSelectedCell = nil
                UIView.transition(with: self.tableView, duration: Constant.Visual.Animation.moveMultipleElements, options: .transitionCrossDissolve, animations: {
                    self.tableView.reloadData()
                })
            }
        }
    }
    
    @objc private func didTapContinue(_ sender: Any) {
        // The user doesn't have permission to perform this action
        guard UserInformation.isUserFamilyHead else {
            PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.notFamilyHeadInvalidPermissionTitle, subtitle: Constant.Visual.BannerText.notFamilyHeadInvalidPermissionSubtitle, style: .danger)
            return
        }
        
        // If the last selected cell contains a subscription that is going to be renewed, open the Apple menu to allow a user to edit their current subscription (e.g. cancel). If we attempt to purchase a product that is set to be renewed, we get the 'Youre already subscribed message'
        // The second case shouldn't happen. The last selected cell shouldn't be nil ever nor should a cell's product
        guard FamilyInformation.familyActiveSubscription.autoRenewProductId != lastSelectedCell?.product?.productIdentifier, let product = lastSelectedCell?.product else {
            PresentationManager.enqueueViewController(SettingsSubscriptionCancelReasonVC())
            return
        }
        
        continueButton.isEnabled = false
        
        // Attempt to purchase the selected product
        PresentationManager.beginFetchingInformationIndicator()
        InAppPurchaseManager.purchaseProduct(product: product) { productIdentifier in
            PresentationManager.endFetchingInformationIndicator {
                self.continueButton.isEnabled = true
                
                guard productIdentifier != nil else {
                    // ErrorManager already invoked by purchaseProduct
                    return
                }
                
                PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.successPurchasedSubscriptionTitle, subtitle: Constant.Visual.BannerText.successPurchasedSubscriptionSubtitle, style: .success)
                
                UIView.transition(with: self.tableView, duration: Constant.Visual.Animation.moveMultipleElements, options: .transitionCrossDissolve, animations: {
                    self.tableView.reloadData()
                })
            }
        }
        
    }
    
    // MARK: - Properties
    
    private static var settingsSubscriptionViewController: SettingsSubscriptionVC?
    
    /// The subscription tier that is currently selected by the user. Theoretically, this shouldn't ever be nil.
    private var lastSelectedCell: SettingsSubscriptionTierTVC?
    
    // if we don't have a value stored, then that means the value is false. A Bool (true) is only stored for this key in the case that a user purchases a product from subscription group 20965379
    private static var userPurchasedProductFrom20965379: Bool {
        let keychain = KeychainSwift()
        return keychain.getBool(Constant.Key.userPurchasedProductFromSubscriptionGroup20965379.rawValue) ?? false
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        SettingsSubscriptionVC.settingsSubscriptionViewController = self
        
        self.tableView.register(SettingsSubscriptionTierTVC.self, forCellReuseIdentifier: SettingsSubscriptionTierTVC.reuseIdentifier)
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        // The manage subscriptions page could have been presented and now has disappeared.
        SettingsSubscriptionVC.willRefreshIfNeeded()
    }
    
    // MARK: - Functions
    
    /// If a transaction was syncronized to the Hound server from the background, i.e. the system recognized there was a transaction sitting in the queue so silently contacted Hound to process it, call this function. It will refresh the page without any animations that would confuse the user
    static func willRefreshIfNeeded() {
        // If the subscriptions page is loaded and onscreen, then we reload it
        guard let settingsSubscriptionViewController = SettingsSubscriptionVC.settingsSubscriptionViewController, settingsSubscriptionViewController.viewIfLoaded?.window != nil else { return }
        // If a transaction was syncronized to the Hound server from the background, i.e. the system recognized there was a transaction sitting in the queue so silently contacted Hound to process it, we don't want to cause any visual indicators that would confuse the user. Instead we just update the information on the server then reload the labels. No fancy animations or error messages if anything fails.
        
        TransactionsRequest.get(errorAlert: .automaticallyAlertForNone) { responseStatus, _ in
            guard responseStatus == .successResponse else {
                return
            }
            
            // this is a background refresh so no animations
            settingsSubscriptionViewController.tableView.reloadData()
        }
    }
    
    /// In order to present SettingsSubscriptionVC, starts a fetching indicator. Then, performs a both a product and transactions request, to ensure those are both updated. If all of that completes successfully, returns the subscription view controller. Otherwise, automatically displays an error message and returns nil
    static func fetchProductsThenGetViewController(completionHandler: @escaping ((SettingsSubscriptionVC?) -> Void)) {
        let viewController = SettingsSubscriptionVC()
        
        PresentationManager.beginFetchingInformationIndicator()
        
        TransactionsRequest.get(errorAlert: .automaticallyAlertForAll) { responseStatus, houndError in
            PresentationManager.endFetchingInformationIndicator {
                guard responseStatus == .successResponse else {
                    houndError?.alert()
                    completionHandler(nil)
                    return
                }
                
                completionHandler(viewController)
            }

        }
    }
    
    override func didUpdateUserTimeZone() {
        self.tableView.reloadData()
    }
    
    // MARK: - Table View Data Source
    
    // Make each cell its own section, allows us to easily space the cells
    func numberOfSections(in tableView: UITableView) -> Int {
        return InAppPurchaseManager.subscriptionProducts.count
    }
    
    // Make each cell its own section, allows us to easily space the cells
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
        // Only add spacing if NOT the last section
        let lastSection = InAppPurchaseManager.subscriptionProducts.count - 1
        return section == lastSection ? 0 : Constant.Constraint.Spacing.contentTallIntraVert
    }

    func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {
        // Only return a view if not the last section
        let lastSection = InAppPurchaseManager.subscriptionProducts.count - 1
        if section == lastSection {
            return nil
        }
        
        let footer = HoundHeaderFooterView()
        return footer
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: SettingsSubscriptionTierTVC.reuseIdentifier, for: indexPath) as? SettingsSubscriptionTierTVC else {
            return HoundTableViewCell()
        }
        
        if lastSelectedCell == cell {
            // cell has been used before and lastSelectedCell is a reference to this cell. However, this cell could be changing to a different SKProduct in setup, so that would invaliate lastSelectedCell. Therefore, clear lastSelectedCell
            lastSelectedCell = nil
        }
        
        // If true, then one of the cells we are going to display is an active subscription, meaning its already been purchased.
        let renewingSubscriptionIsPartOfSubscriptionProducts = InAppPurchaseManager.subscriptionProducts.first { product in
            FamilyInformation.familyActiveSubscription.autoRenewProductId == product.productIdentifier
        } != nil
        
        let cellProduct: SKProduct = InAppPurchaseManager.subscriptionProducts[indexPath.section]
        let cellIsCustomSelected: Bool = {
            // We do not want to override the lastSelectedCell as this function could be called after a user selceted a cell manually by themselves
            guard lastSelectedCell == nil else {
                return lastSelectedCell?.product?.productIdentifier == cellProduct.productIdentifier
            }
            
            if renewingSubscriptionIsPartOfSubscriptionProducts {
                // One of the cells are we going to display is the active subscription, and this cell is that active subscription cell
                return cellProduct.productIdentifier == FamilyInformation.familyActiveSubscription.autoRenewProductId
            }
            else {
                // None of the cells are we going to display are the active subscription, SKProduct at index 0 is presumed to be the most important, so we select that one.
                return indexPath.section == 0
            }
        }()
        
        // We can only have one cell selected at once, therefore clear lastSelectedCell's selection state
        if cellIsCustomSelected == true {
            lastSelectedCell?.setCustomSelected(false, animated: false)
        }
        
        cell.setup(delegate: self, product: cellProduct, isCustomSelected: cellIsCustomSelected)
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        // Let a user select cells even if they don't have the permission to as a non-family head.
        guard let selectedCell = tableView.cellForRow(at: indexPath) as? SettingsSubscriptionTierTVC else { return }
        
        // Check if lastSelectedCell and selectedCells are actually different cells
        if let lastSelectedCell = lastSelectedCell, lastSelectedCell != selectedCell {
            // If they are different cells, then that must mean a new cell is being selected to transition into the selected state. Unselect the old cell and select the new one
            lastSelectedCell.setCustomSelected(false, animated: true)
            selectedCell.setCustomSelected(true, animated: true)
        }
        // We are selecting the same cell as last time. However, a cell always needs to be selected. Therefore, we cannot deselect the current cell as that would mean we would have no cell selected at all, so always select.
        else {
            selectedCell.setCustomSelected(true, animated: true)
        }
        
        lastSelectedCell = selectedCell
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(tableView)
        containerView.addSubview(continueButton)
        containerView.addSubview(houndPaw)
        containerView.addSubview(headerLabel)
        containerView.addSubview(descriptionLabel)
        containerView.addSubview(freeTrialScaledLabel)
        containerView.addSubview(backButton)
        containerView.addSubview(subscriptionDisclaimerLabel)
        containerView.addSubview(redeemRestoreButtonStack)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // backButton
        NSLayoutConstraint.activate([
            backButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            backButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteCircleHoriInset),
            backButton.createHeightMultiplier(Constant.Constraint.Button.circleHeightMultiplier, relativeToWidthOf: view),
            backButton.createMaxHeight(Constant.Constraint.Button.circleMaxHeight),
            backButton.createSquareAspectRatio()
        ])

        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.centerXAnchor.constraint(equalTo: containerView.centerXAnchor),
            headerLabel.trailingAnchor.constraint(lessThanOrEqualTo: backButton.leadingAnchor, constant: -Constant.Constraint.Spacing.contentIntraHori)
        ])

        // pawWithHands
        NSLayoutConstraint.activate([
            houndPaw.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            houndPaw.centerXAnchor.constraint(equalTo: containerView.centerXAnchor),
            houndPaw.createHeightMultiplier(Constant.Constraint.Text.pawHeightMultiplier, relativeToWidthOf: view),
            houndPaw.createMaxHeight(Constant.Constraint.Text.pawMaxHeight),
            houndPaw.createSquareAspectRatio()
        ])

        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: houndPaw.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])

        // freeTrialScaledLabel
        if freeTrialScaledLabel.isHidden {
            // If the user has purchased a product from subscription group 20965379, then we don't show the free trial label
            NSLayoutConstraint.activate([
                freeTrialScaledLabel.heightAnchor.constraint(equalToConstant: 0),
                freeTrialScaledLabel.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor, constant: 0),
                freeTrialScaledLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
                freeTrialScaledLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
            ])
        }
        else {
            NSLayoutConstraint.activate([
                freeTrialScaledLabel.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
                freeTrialScaledLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
                freeTrialScaledLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
            ])
        }

        // tableView
        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: freeTrialScaledLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            tableView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            tableView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])

        // continueButton
        NSLayoutConstraint.activate([
            continueButton.topAnchor.constraint(equalTo: tableView.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            continueButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            continueButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            continueButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            continueButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
        
        // redeemRestoreButtonStack
        if restoreButton.isHidden && redeemButton.isHidden {
            NSLayoutConstraint.activate([
                redeemRestoreButtonStack.topAnchor.constraint(equalTo: continueButton.bottomAnchor, constant: 0),
                redeemRestoreButtonStack.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
                redeemRestoreButtonStack.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
            ])
        }
        else {
            NSLayoutConstraint.activate([
                redeemRestoreButtonStack.topAnchor.constraint(equalTo: continueButton.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
                redeemRestoreButtonStack.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
                redeemRestoreButtonStack.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
            ])
        }

        // subscriptionDisclaimerLabel
        NSLayoutConstraint.activate([
            subscriptionDisclaimerLabel.topAnchor.constraint(equalTo: redeemRestoreButtonStack.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            subscriptionDisclaimerLabel.leadingAnchor.constraint(equalTo: tableView.leadingAnchor),
            subscriptionDisclaimerLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            subscriptionDisclaimerLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }

}
//
//  SettingsAppearanceVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/16/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

private enum InterfaceStyleOption: CaseIterable {
    case light, dark, system
    
    var title: String {
        switch self {
        case .light: return "Light"
        case .dark: return "Dark"
        case .system: return "System"
        }
    }
    
    var userInterfaceStyle: UIUserInterfaceStyle {
        switch self {
        case .light: return .light
        case .dark: return .dark
        case .system: return .unspecified
        }
    }
    
    static func index(for style: UIUserInterfaceStyle) -> Int {
        switch style {
        case .light: return allCases.firstIndex(of: .light) ?? 0
        case .dark: return allCases.firstIndex(of: .dark) ?? 0
        default: return allCases.firstIndex(of: .system) ?? 0
        }
    }
    
    static func from(index: Int) -> InterfaceStyleOption {
        return allCases[safe: index] ?? .system
    }
}

enum SettingsAppearanceDropDownTypes: String, HoundDropDownType {
    case timeZone = "DropDownTimeZone"
}

final class SettingsAppearanceVC: HoundScrollViewController,
                                  HoundDropDownDataSource,
                                  HoundDropDownManagerDelegate {
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
    // MARK: - Elements
    
    private let pageHeaderView: HoundPageSheetHeaderView = {
        let view = HoundPageSheetHeaderView(huggingPriority: 360, compressionResistancePriority: 360)
        view.pageHeaderLabel.text = "Appearance"
        return view
    }()
    
    private let interfaceStyleHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Theme"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let interfaceStyleSegmentedControl: HoundSegmentedControl = {
        let segmentedControl = HoundSegmentedControl()
        segmentedControl.selectedSegmentTintColor = UIColor.systemBlue
        
        InterfaceStyleOption.allCases.enumerated().forEach { index, option in
            segmentedControl.insertSegment(withTitle: option.title, at: index, animated: false)
        }
        
        let attributes: [NSAttributedString.Key: Any] = [.font: Constant.Visual.Font.emphasizedPrimaryRegularLabel, .foregroundColor: UIColor.systemBackground]
        
        segmentedControl.setTitleTextAttributes(attributes, for: .normal)
        segmentedControl.backgroundColor = UIColor.systemGray4
        segmentedControl.selectedSegmentIndex = InterfaceStyleOption.index(for: UserConfiguration.interfaceStyle)
        
        return segmentedControl
    }()
    
    private let measurementHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Measurement System"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let measurementSystemSegmentedControl: HoundSegmentedControl = {
        let segmentedControl = HoundSegmentedControl()
        segmentedControl.selectedSegmentTintColor = UIColor.systemBlue
        
        MeasurementSystem.allCases.enumerated().forEach { index, ms in
            segmentedControl.insertSegment(withTitle: ms.readableMeasurementSystem(), at: index, animated: false)
        }
        
        let attributes: [NSAttributedString.Key: Any] = [.font: Constant.Visual.Font.emphasizedPrimaryRegularLabel, .foregroundColor: UIColor.systemBackground]
        
        segmentedControl.setTitleTextAttributes(attributes, for: .normal)
        segmentedControl.backgroundColor = UIColor.systemGray4
        segmentedControl.selectedSegmentIndex = UserConfiguration.measurementSystem.rawValue
        
        return segmentedControl
    }()
    
    private let hapticsHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Haptics"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var hapticsEnabledSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 260, compressionResistancePriority: 260)
        uiSwitch.isOn = UserConfiguration.isHapticsEnabled
        return uiSwitch
    }()
    
    private let usesDeviceTimeZoneHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Use Device Time Zone"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var usesDeviceTimeZoneSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isOn = UserConfiguration.usesDeviceTimeZone
        return uiSwitch
    }()
    
    private lazy var timeZoneLabel: HoundLabel = {
        let label = HoundLabel()
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a time zone..."
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(dropDownManager.showHideDropDownGesture(identifier: .timeZone, delegate: self))
        dropDownManager.register(identifier: .timeZone, label: label, autoscroll: .firstOpen)
        return label
    }()
    
    private lazy var dropDownManager = HoundDropDownManager<SettingsAppearanceDropDownTypes>(rootView: containerView, dataSource: self, delegate: self)
    
    @objc private func didUpdateInterfaceStyle(_ sender: Any) {
        guard let sender = sender as? HoundSegmentedControl else { return }
        
        /// Assumes the segmented control is configured for interfaceStyle selection (0: light, 1: dark, 2: unspecified). Using the selectedSegmentIndex, queries the server to update the interfaceStyle UserConfiguration. If successful, then changes UI to new interface style and saves new UserConfiguration value. If unsuccessful, reverts the selectedSegmentIndex to the position before the change, doesn't change the UI interface style, and doesn't save the new UserConfiguration value
        
        let selectedOption = InterfaceStyleOption.from(index: sender.selectedSegmentIndex)
        let beforeUpdateInterfaceStyle = UserConfiguration.interfaceStyle
        
        UserConfiguration.interfaceStyle = selectedOption.userInterfaceStyle
        
        let body: JSONRequestBody = [Constant.Key.userConfigurationInterfaceStyle.rawValue: .int(selectedOption.userInterfaceStyle.rawValue)]
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.interfaceStyle = beforeUpdateInterfaceStyle
                sender.selectedSegmentIndex = InterfaceStyleOption.index(for: beforeUpdateInterfaceStyle)
                return
            }
        }
    }
    
    @objc private func didUpdateMeasurementSystem(_ sender: Any) {
        guard let sender = sender as? HoundSegmentedControl else { return }
        
        /// Assumes the segmented control is configured for measurementSystem selection (0: imperial, 1: metric, 2: both).
        let beforeUpdateMeasurementSystem = UserConfiguration.measurementSystem
        
        UserConfiguration.measurementSystem = MeasurementSystem(rawValue: sender.selectedSegmentIndex) ?? UserConfiguration.measurementSystem
        
        let body: JSONRequestBody = [Constant.Key.userConfigurationMeasurementSystem.rawValue: .int(UserConfiguration.measurementSystem.rawValue)]
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.measurementSystem = beforeUpdateMeasurementSystem
                sender.selectedSegmentIndex = beforeUpdateMeasurementSystem.rawValue
                return
            }
        }
    }
    
    @objc private func didToggleHapticsEnabled(_ sender: Any) {
        let beforeUpdate = UserConfiguration.isHapticsEnabled
        
        UserConfiguration.isHapticsEnabled = hapticsEnabledSwitch.isOn
        
        let body: JSONRequestBody = [Constant.Key.userConfigurationIsHapticsEnabled.rawValue: .bool(UserConfiguration.isHapticsEnabled)]
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                UserConfiguration.isHapticsEnabled = beforeUpdate
                self.hapticsEnabledSwitch.setOn(beforeUpdate, animated: true)
                return
            }
        }
    }
    
    @objc private func didToggleUsesDeviceTimeZone(_ sender: Any) {
        let newUses = usesDeviceTimeZoneSwitch.isOn
        let beforeUpdateUses = UserConfiguration.usesDeviceTimeZone
        
        let newTz = usesDeviceTimeZoneSwitch.isOn ? (UserConfiguration.userTimeZone ?? UserConfiguration.timeZone) : UserConfiguration.userTimeZone
        let beforeUpdateTz = UserConfiguration.userTimeZone
        
        UserConfiguration.usesDeviceTimeZone = newUses
        // if setting usesDeviceTimeZone to true, then we need a userTimeZone
        UserConfiguration.userTimeZone = newTz
        synchronizeTimeZoneUI(animated: true)
        
        let body: JSONRequestBody = [
            Constant.Key.userConfigurationUsesDeviceTimeZone.rawValue: .bool(newUses),
            Constant.Key.userConfigurationUserTimeZone.rawValue: .string(newTz?.identifier),
            /// userConfigurationDeviceTimeZone is unique in the fact that it is a read-only property that can update, so we must notify server of changes to it. TimeZoneManager should do that, but we send it here as well just in case
            Constant.Key.userConfigurationDeviceTimeZone.rawValue: .string(UserConfiguration.deviceTimeZone.identifier)
        ]
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                UserConfiguration.usesDeviceTimeZone = beforeUpdateUses
                UserConfiguration.userTimeZone = beforeUpdateTz
                self.synchronizeTimeZoneUI(animated: true)
                return
            }
        }
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        self.synchronizeTimeZoneUI(animated: false)
    }
    
    // MARK: - Functions
    
    private func synchronizeTimeZoneUI(animated: Bool) {
        timeZoneLabel.isEnabled = !UserConfiguration.usesDeviceTimeZone
        // use UserConfiguration.timeZone b/c if no UserConfiguration.userTimeZone, then this defaults to current TZ
        // don't provide currentTimeZone because that adds on (current) to the end
        timeZoneLabel.text = UserConfiguration.timeZone.displayName(currentTimeZone: nil)
        usesDeviceTimeZoneSwitch.setOn(UserConfiguration.usesDeviceTimeZone, animated: animated)
    }
    
    // MARK: - HoundDropDownManagerDelegate
    
    @objc func didTapScreen(sender: UITapGestureRecognizer) {
        dropDownManager.hideDropDownIfNotTapped(sender: sender)
    }
    
    func willShowDropDown(_ identifier: any HoundDropDownType, animated: Bool) {
        guard let type = identifier as? SettingsAppearanceDropDownTypes else { return }
        switch type {
        case .timeZone:
            let rows = min(6.5, CGFloat(TimeZone.houndTimeZones.count))
            dropDownManager.show(identifier: .timeZone, numberOfRowsToShow: rows, animated: animated)
        }
    }
    
    // MARK: - HoundDropDownDataSource
    
    func setupCellForDropDown(cell: HoundDropDownTVC, indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let type = identifier as? SettingsAppearanceDropDownTypes else { return }
        switch type {
        case .timeZone:
            let tz = TimeZone.houndTimeZones[indexPath.row]
            // we only want to show (current) if the cell's tz genuinely matches the current device tz (not just the selected one)
            cell.label.text = tz.displayName(currentTimeZone: UserConfiguration.deviceTimeZone)
            // use UserConfiguration.timeZone b/c if no UserConfiguration.userTimeZone, then this defaults to current TZ
            cell.setCustomSelected(tz == UserConfiguration.timeZone, animated: false)
        }
    }
    
    func numberOfRows(section: Int, identifier: any HoundDropDownType) -> Int {
        guard let type = identifier as? SettingsAppearanceDropDownTypes else { return 0 }
        switch type {
        case .timeZone:
            return TimeZone.houndTimeZones.count
        }
    }
    
    func numberOfSections(identifier: any HoundDropDownType) -> Int {
        1
    }
    
    func selectItemInDropDown(indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let type = identifier as? SettingsAppearanceDropDownTypes else { return }
        guard let dropDown = dropDownManager.dropDown(for: type), let cell = dropDown.dropDownTableView?.cellForRow(at: indexPath) as? HoundDropDownTVC else { return }
        switch type {
        case .timeZone:
            if let prevTz = UserConfiguration.userTimeZone,
               let prevIndex = TimeZone.houndTimeZones.firstIndex(where: { $0.identifier == prevTz.identifier }),
               prevIndex != indexPath.row {
                let prevIndexPath = IndexPath(row: prevIndex, section: 0)
                if let prevCell = dropDown.dropDownTableView?.cellForRow(at: prevIndexPath) as? HoundDropDownTVC {
                    prevCell.setCustomSelected(false)
                }
            }
            
            let beforeUpdateTz = UserConfiguration.userTimeZone
            
            let newTz = TimeZone.houndTimeZones[indexPath.row]
            cell.setCustomSelected(true)
            UserConfiguration.userTimeZone = newTz
            // set currentTimeZone to nil so it doesn't append (current) to the end
            timeZoneLabel.text = newTz.displayName(currentTimeZone: nil)
            dropDown.hideDropDown(animated: true)
            
            let body: JSONRequestBody = [
                Constant.Key.userConfigurationUserTimeZone.rawValue: .string(newTz.identifier)
            ]
            
            UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    UserConfiguration.userTimeZone = beforeUpdateTz
                    self.synchronizeTimeZoneUI(animated: true)
                    return
                }
            }
        }
    }
    
    func firstSelectedIndexPath(identifier: any HoundDropDownType) -> IndexPath? {
        guard let type = identifier as? SettingsAppearanceDropDownTypes else { return nil }
        switch type {
        case .timeZone:
            let tz = UserConfiguration.timeZone
            if let idx = TimeZone.houndTimeZones.firstIndex(of: tz) {
                return IndexPath(row: idx, section: 0)
            }
        }
        return nil
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(pageHeaderView)
        containerView.addSubview(interfaceStyleSegmentedControl)
        containerView.addSubview(interfaceStyleHeaderLabel)
        containerView.addSubview(measurementHeaderLabel)
        containerView.addSubview(measurementSystemSegmentedControl)
        containerView.addSubview(usesDeviceTimeZoneHeaderLabel)
        containerView.addSubview(usesDeviceTimeZoneSwitch)
        containerView.addSubview(timeZoneLabel)
        containerView.addSubview(hapticsHeaderLabel)
        containerView.addSubview(hapticsEnabledSwitch)
        
        let didTapScreenGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapScreen(sender:))
        )
        didTapScreenGesture.delegate = self
        didTapScreenGesture.cancelsTouchesInView = false
        containerView.addGestureRecognizer(didTapScreenGesture)
        
        interfaceStyleSegmentedControl.addTarget(self, action: #selector(didUpdateInterfaceStyle), for: .valueChanged)
        measurementSystemSegmentedControl.addTarget(self, action: #selector(didUpdateMeasurementSystem), for: .valueChanged)
        hapticsEnabledSwitch.addTarget(self, action: #selector(didToggleHapticsEnabled), for: .valueChanged)
        usesDeviceTimeZoneSwitch.addTarget(self, action: #selector(didToggleUsesDeviceTimeZone), for: .valueChanged)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pageHeaderView
        NSLayoutConstraint.activate([
            pageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            pageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            pageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // interfaceStyleHeaderLabel
        NSLayoutConstraint.activate([
            interfaceStyleHeaderLabel.topAnchor.constraint(equalTo: pageHeaderView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            interfaceStyleHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            interfaceStyleHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // interfaceStyleSegmentedControl
        NSLayoutConstraint.activate([
            interfaceStyleSegmentedControl.topAnchor.constraint(equalTo: interfaceStyleHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            interfaceStyleSegmentedControl.leadingAnchor.constraint(equalTo: interfaceStyleHeaderLabel.leadingAnchor),
            interfaceStyleSegmentedControl.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            interfaceStyleSegmentedControl.createHeightMultiplier(Constant.Constraint.Input.segmentedHeightMultiplier, relativeToWidthOf: view),
            interfaceStyleSegmentedControl.createMaxHeight(Constant.Constraint.Input.segmentedMaxHeight)
        ])
        
        // measurementHeaderLabel
        NSLayoutConstraint.activate([
            measurementHeaderLabel.topAnchor.constraint(equalTo: interfaceStyleSegmentedControl.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            measurementHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            measurementHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // measurementSystemSegmentedControl
        NSLayoutConstraint.activate([
            measurementSystemSegmentedControl.topAnchor.constraint(equalTo: measurementHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            measurementSystemSegmentedControl.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            measurementSystemSegmentedControl.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            measurementSystemSegmentedControl.createHeightMultiplier(Constant.Constraint.Input.segmentedHeightMultiplier, relativeToWidthOf: view),
            measurementSystemSegmentedControl.createMaxHeight(Constant.Constraint.Input.segmentedMaxHeight)
        ])
        
        // usesDeviceTimeZoneHeaderLabel
        NSLayoutConstraint.activate([
            usesDeviceTimeZoneHeaderLabel.topAnchor.constraint(equalTo: measurementSystemSegmentedControl.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            usesDeviceTimeZoneHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // usesDeviceTimeZoneSwitch
        NSLayoutConstraint.activate([
            usesDeviceTimeZoneSwitch.centerYAnchor.constraint(equalTo: usesDeviceTimeZoneHeaderLabel.centerYAnchor),
            usesDeviceTimeZoneSwitch.leadingAnchor.constraint(equalTo: usesDeviceTimeZoneHeaderLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            usesDeviceTimeZoneSwitch.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // timeZoneLabel
        NSLayoutConstraint.activate([
            timeZoneLabel.topAnchor.constraint(equalTo: usesDeviceTimeZoneHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            timeZoneLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            timeZoneLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            timeZoneLabel.createHeightMultiplier(Constant.Constraint.Input.textFieldHeightMultiplier, relativeToWidthOf: view),
            timeZoneLabel.createMaxHeight(Constant.Constraint.Input.textFieldMaxHeight)
        ])
        
        // hapticsHeaderLabel
        NSLayoutConstraint.activate([
            hapticsHeaderLabel.topAnchor.constraint(equalTo: timeZoneLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            // extra space for dropdown to fully extend
            hapticsHeaderLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset - 250.0),
            hapticsHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // hapticsEnabledSwitch
        NSLayoutConstraint.activate([
            hapticsEnabledSwitch.centerYAnchor.constraint(equalTo: hapticsHeaderLabel.centerYAnchor),
            hapticsEnabledSwitch.leadingAnchor.constraint(equalTo: hapticsHeaderLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            hapticsEnabledSwitch.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
    }
    
}
//
//  SettingsNotifsCategoriesFamilyTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesFamilyTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Family"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let alwaysOnSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isEnabled = false
        uiSwitch.isOn = true
        return uiSwitch
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 230, compressionResistancePriority: 230)
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        
        label.attributedText = {
            let message = NSMutableAttributedString(
                string: "Receive notifications about your Hound family. ",
                attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
            )
            
            message.append(NSAttributedString(
                string: "This category cannot be turned off.",
                attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel])
            )
            
            message.append(NSAttributedString(
                string: " Examples include: a user joining, leaving, or locking your family.",
                attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel])
            )
            
            return message
        }()
        
        return label
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesFamilyTVC"
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(alwaysOnSwitch)
        contentView.addSubview(descriptionLabel)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // alwaysOnSwitch
        NSLayoutConstraint.activate([
            alwaysOnSwitch.centerYAnchor.constraint(equalTo: headerLabel.centerYAnchor),
            alwaysOnSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            alwaysOnSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsNotifsCategoriesReminderTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesReminderTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Reminder"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 230, compressionResistancePriority: 230)
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        
        label.attributedText = {
            let message = NSMutableAttributedString(
                string: "Recieve notifications about any of your family's reminders. ",
                attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
            )
            
            message.append(NSAttributedString(
                string: "Notifications are also customizable for each individual reminder.",
                attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel])
            )
            
            message.append(NSAttributedString(
                string: " Examples include: a reminder's alarm sounding.",
                attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel])
            )
            
            return message
        }()
        
        return label
    }()
    
    private lazy var isReminderNotificationEnabledSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isOn = true
        uiSwitch.addTarget(self, action: #selector(didToggleIsReminderNotificationEnabled), for: .valueChanged)
        return uiSwitch
    }()
    
    private lazy var disabledTapGesture: UITapGestureRecognizer = {
        let gesture = UITapGestureRecognizer(target: self, action: #selector(showDisabledBanner))
        gesture.cancelsTouchesInView = false
        return gesture
    }()
    
    @objc private func didToggleIsReminderNotificationEnabled(_ sender: Any) {
        let beforeUpdatesReminderNotificationEnabled = UserConfiguration.isReminderNotificationEnabled
        
        UserConfiguration.isReminderNotificationEnabled = isReminderNotificationEnabledSwitch.isOn
        
        let body: JSONRequestBody = [Constant.Key.userConfigurationIsReminderNotificationEnabled.rawValue: .bool(UserConfiguration.isReminderNotificationEnabled)]
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.isReminderNotificationEnabled = beforeUpdatesReminderNotificationEnabled
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    @objc private func showDisabledBanner(_ sender: Any) {
        guard UserConfiguration.isNotificationEnabled == false else { return }
        PresentationManager.enqueueBanner(
            title: Constant.Visual.BannerText.noEditNotificationSettingsTitle,
            subtitle: Constant.Visual.BannerText.noEditNotificationSettingsSubtitle,
            style: .warning
        )
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesReminderTVC"
    
    // MARK: - Main
    
    override func prepareForReuse() {
        super.prepareForReuse()
        synchronizeValues(animated: false)
    }
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    /// Updates the displayed values to reflect the values stored.
    private func synchronizeValues(animated: Bool) {
        isReminderNotificationEnabledSwitch.isEnabled = UserConfiguration.isNotificationEnabled
        
        isReminderNotificationEnabledSwitch.setOn(UserConfiguration.isReminderNotificationEnabled, animated: animated)
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(isReminderNotificationEnabledSwitch)
        contentView.addSubview(descriptionLabel)
        contentView.addGestureRecognizer(disabledTapGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // isReminderNotificationEnabledSwitch
        NSLayoutConstraint.activate([
            isReminderNotificationEnabledSwitch.centerYAnchor.constraint(equalTo: headerLabel.centerYAnchor),
            isReminderNotificationEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            isReminderNotificationEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsNotifsCategoriesLogTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesLogTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Log"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var isLogNotificationEnabledSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isOn = true
        uiSwitch.addTarget(self, action: #selector(didToggleIsLogNotificationEnabled), for: .valueChanged)
        return uiSwitch
    }()
    
    private lazy var disabledTapGesture: UITapGestureRecognizer = {
        let gesture = UITapGestureRecognizer(target: self, action: #selector(showDisabledBanner))
        gesture.cancelsTouchesInView = false
        return gesture
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 230, compressionResistancePriority: 230)
        label.text = "Receive notifications about your family's logs. Examples include: a user creating a log."
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    @objc private func didToggleIsLogNotificationEnabled(_ sender: Any) {
        let beforeUpdatesLogNotificationEnabled = UserConfiguration.isLogNotificationEnabled
        
        UserConfiguration.isLogNotificationEnabled = isLogNotificationEnabledSwitch.isOn
        
        let body: JSONRequestBody = [Constant.Key.userConfigurationIsLogNotificationEnabled.rawValue: .bool(UserConfiguration.isLogNotificationEnabled)]
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.isLogNotificationEnabled = beforeUpdatesLogNotificationEnabled
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesLogTVC"
    
    // MARK: - Main
    
    override func prepareForReuse() {
        super.prepareForReuse()
        synchronizeValues(animated: false)
    }
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    /// Updates the displayed values to reflect the values stored.
    private func synchronizeValues(animated: Bool) {
        isLogNotificationEnabledSwitch.isEnabled = UserConfiguration.isNotificationEnabled
        
        isLogNotificationEnabledSwitch.setOn(UserConfiguration.isLogNotificationEnabled, animated: animated)
    }
    
    @objc private func showDisabledBanner(_ sender: Any) {
        guard UserConfiguration.isNotificationEnabled == false else { return }
        PresentationManager.enqueueBanner(
            title: Constant.Visual.BannerText.noEditNotificationSettingsTitle,
            subtitle: Constant.Visual.BannerText.noEditNotificationSettingsSubtitle,
            style: .warning
        )
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(isLogNotificationEnabledSwitch)
        contentView.addSubview(descriptionLabel)
        contentView.addGestureRecognizer(disabledTapGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // isLogNotificationEnabledSwitch
        NSLayoutConstraint.activate([
            isLogNotificationEnabledSwitch.centerYAnchor.constraint(equalTo: headerLabel.centerYAnchor),
            isLogNotificationEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            isLogNotificationEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
import UIKit

final class SettingsNotifsCategoriesVC: HoundViewController, UITableViewDelegate, UITableViewDataSource {
    
    // MARK: - Properties
    
    private lazy var tableView = {
        let tableView = HoundTableView(style: .grouped)
        tableView.backgroundColor = .systemBackground
        tableView.delegate = self
        tableView.dataSource = self
        
        settingsNotifsCategoriesTVCReuseIdentifiers.forEach { identifier in
            switch identifier {
            case SettingsNotifsCategoriesAccountTVC.reuseIdentifier:
                tableView.register(SettingsNotifsCategoriesAccountTVC.self, forCellReuseIdentifier: identifier)
            case SettingsNotifsCategoriesFamilyTVC.reuseIdentifier:
                tableView.register(SettingsNotifsCategoriesFamilyTVC.self, forCellReuseIdentifier: identifier)
            case SettingsNotifsCategoriesLogTVC.reuseIdentifier:
                tableView.register(SettingsNotifsCategoriesLogTVC.self, forCellReuseIdentifier: identifier)
            case SettingsNotifsCategoriesReminderTVC.reuseIdentifier:
                tableView.register(SettingsNotifsCategoriesReminderTVC.self, forCellReuseIdentifier: identifier)
            default:
                fatalError("You must register all table view cells")
            }
        }
        
        return tableView
    }()
    
    private let settingsNotifsCategoriesTVCReuseIdentifiers = [
        SettingsNotifsCategoriesAccountTVC.reuseIdentifier,
        SettingsNotifsCategoriesFamilyTVC.reuseIdentifier,
        SettingsNotifsCategoriesLogTVC.reuseIdentifier,
        SettingsNotifsCategoriesReminderTVC.reuseIdentifier
    ]
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
    }
    
    // MARK: - Functions
    
    func synchronizeAllIsEnabled() {
        // NO-OP class SettingsNotifsCategoriesAccountTVC
        // NO-OP class SettingsNotifsCategoriesFamilyTVC
        
        if let logRow = settingsNotifsCategoriesTVCReuseIdentifiers.firstIndex(of: SettingsNotifsCategoriesLogTVC.reuseIdentifier) {
            let logIndexPath = IndexPath(row: logRow, section: 0)
            tableView.reloadRows(at: [logIndexPath], with: .fade)
        }
        
        if let reminderRow = settingsNotifsCategoriesTVCReuseIdentifiers.firstIndex(of: SettingsNotifsCategoriesReminderTVC.reuseIdentifier) {
            let reminderIndexPath = IndexPath(row: reminderRow, section: 0)
            tableView.reloadRows(at: [reminderIndexPath], with: .fade)
        }
    }
    
    func synchronizeAllValues(animated: Bool) {
        synchronizeAllIsEnabled()
        // NO-OP class SettingsNotifsCategoriesAccountTVC
        // NO-OP class SettingsNotifsCategoriesFamilyTVC
        
        if let logRow = settingsNotifsCategoriesTVCReuseIdentifiers.firstIndex(of: SettingsNotifsCategoriesLogTVC.reuseIdentifier) {
            let logIndexPath = IndexPath(row: logRow, section: 0)
            tableView.reloadRows(at: [logIndexPath], with: .fade)
        }
        
        if let reminderRow = settingsNotifsCategoriesTVCReuseIdentifiers.firstIndex(of: SettingsNotifsCategoriesReminderTVC.reuseIdentifier) {
            let reminderIndexPath = IndexPath(row: reminderRow, section: 0)
            tableView.reloadRows(at: [reminderIndexPath], with: .fade)
        }
    }
    
    // MARK: - UITableViewDataSource
    
    func numberOfSections(in tableView: UITableView) -> Int {
        1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        settingsNotifsCategoriesTVCReuseIdentifiers.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard indexPath.row < settingsNotifsCategoriesTVCReuseIdentifiers.count else {
            return HoundTableViewCell()
        }
        let identifier = settingsNotifsCategoriesTVCReuseIdentifiers[indexPath.row]
        let cell = tableView.dequeueReusableCell(withIdentifier: identifier, for: indexPath)
        return cell
    }
    
    // MARK: - UITableViewDelegate
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = PageSheetHeaderFooterView()
        headerView.setup(title: "Categories")
        return headerView
    }
    
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return UITableView.automaticDimension
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(tableView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // tableView
        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: view.topAnchor),
            tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        ])
    }
}
//
//  SettingsNotifsCategoriesAccountTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesAccountTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Account"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let alwaysOnSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isEnabled = false
        uiSwitch.isOn = true
        return uiSwitch
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 230, compressionResistancePriority: 230)
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        
        label.attributedText = {
            let message = NSMutableAttributedString(
                string: "Receive notifications about your account. ",
                attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
            )
            
            message.append(NSAttributedString(
                string: "This category cannot be turned off.",
                attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel])
            )
            
            message.append(NSAttributedString(
                string: " Examples include: getting kicked from your Hound family, accidentally terminating Hound while Loud Alarms is enabled.",
                attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel])
            )
            
            return message
        }()
        
        return label
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesAccountTVC"
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(alwaysOnSwitch)
        contentView.addSubview(descriptionLabel)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // alwaysOnSwitch
        NSLayoutConstraint.activate([
            alwaysOnSwitch.centerYAnchor.constraint(equalTo: headerLabel.centerYAnchor),
            alwaysOnSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            alwaysOnSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsNotifsAlarmsTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsTVC: HoundTableViewCell {
    private let headerLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Configure Alarms"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.text = "By default, your reminder alarms will repeatedly ring, play the 'Radar' sound effect, and snooze for five minutes"
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    private let chevronImageView: HoundImageView = {
        let imageView = HoundImageView(huggingPriority: 300, compressionResistancePriority: 300)
        
        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = UIColor.systemGray4
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsAlarmsTVC"
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(descriptionLabel)
        contentView.addSubview(chevronImageView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            descriptionLabel.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor),
            descriptionLabel.trailingAnchor.constraint(equalTo: headerLabel.trailingAnchor)
        ])
        
        // chevronImageView
        NSLayoutConstraint.activate([
            chevronImageView.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            chevronImageView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            chevronImageView.centerYAnchor.constraint(equalTo: contentView.centerYAnchor),
            chevronImageView.createAspectRatio(Constant.Constraint.Button.chevronAspectRatio),
            chevronImageView.createHeightMultiplier(Constant.Constraint.Button.chevronHeightMultiplier, relativeToWidthOf: contentView),
            chevronImageView.createMaxHeight(Constant.Constraint.Button.chevronMaxHeight)
        ])
        
    }
    
}
//
//  SettingsNotifsAlarmsNotificationSoundTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/14/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsNotificationSoundTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let notificationSoundLabel: HoundLabel = {
        let label = HoundLabel()
        label.contentMode = .left
        label.text = "Notification Sound"
        label.font = Constant.Visual.Font.weakSecondaryRegularLabel
        return label
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsAlarmsNotificationSoundTVC"
    
    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    private(set) var isCustomSelected: Bool = false
    
    // MARK: - Setup
    
    func setup(notificationSound: String) {
        notificationSoundLabel.text = notificationSound
    }
    
    // MARK: - Functions
    
    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    func setCustomSelected(_ selected: Bool, animated: Bool) {
        // DO NOT INVOKE DEFAULT IMPLEMENTATION OF super.setSelected(selected, animated: animated)
        guard selected != isCustomSelected else { return }
        
        isCustomSelected = selected
        
        UIView.animate(withDuration: animated ? Constant.Visual.Animation.selectSingleElement : 0.0) {
            self.contentView.backgroundColor = selected ? UIColor.systemBlue : UIColor.systemBackground
            self.notificationSoundLabel.textColor = selected ? UIColor.systemBackground : UIColor.label
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(notificationSoundLabel)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // notificationSoundLabel
        NSLayoutConstraint.activate([
            notificationSoundLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            notificationSoundLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            notificationSoundLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            notificationSoundLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsNotifsAlarmsNotificationSoundsTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsNotificationSoundsTVC: HoundTableViewCell, UITableViewDelegate, UITableViewDataSource {
    
    // MARK: - Properties
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Alarm Sound"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var tableView: HoundTableView = {
        let tableView = HoundTableView(style: .plain, huggingPriority: 260, compressionResistancePriority: 260)
        tableView.delegate = self
        tableView.dataSource = self
        tableView.register(SettingsNotifsAlarmsNotificationSoundTVC.self, forCellReuseIdentifier: SettingsNotifsAlarmsNotificationSoundTVC.reuseIdentifier)
        
        tableView.isScrollEnabled = false
        tableView.backgroundColor = UIColor.systemBackground
        tableView.separatorColor = UIColor.systemGray2
        
        tableView.applyStyle(.thinLabelBorder)
        
        return tableView
    }()
    
    private lazy var disabledTapGesture: UITapGestureRecognizer = {
        let gesture = UITapGestureRecognizer(target: self, action: #selector(showDisabledBanner))
        gesture.cancelsTouchesInView = false
        return gesture
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.text = "Changes the sound your alarms play. Tap on one of them to hear what it sounds like!"
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    @objc private func showDisabledBanner(_ sender: Any) {
        guard UserConfiguration.isNotificationEnabled == false else { return }
        PresentationManager.enqueueBanner(
            title: Constant.Visual.BannerText.noEditNotificationSettingsTitle,
            subtitle: Constant.Visual.BannerText.noEditNotificationSettingsSubtitle,
            style: .warning
        )
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsAlarmsNotificationSoundsTVC"
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
        
        // NEEDs to called after being added to view heirarchy (if you call in constructor then youre attempting to layout visible cells when not in view hierarchy)
        tableView.shouldAutomaticallyAdjustHeight = true
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    /// Updates the displayed values to reflect the values stored.
    private func synchronizeValues(animated: Bool) {
        tableView.isUserInteractionEnabled = UserConfiguration.isNotificationEnabled
        
        // set all cells to unselected
        for cellRow in 0..<NotificationSound.allCases.count {
            let cellIndexPath = IndexPath(row: cellRow, section: 0)
            let cell = tableView.cellForRow(at: cellIndexPath) as? SettingsNotifsAlarmsNotificationSoundTVC
            cell?.setCustomSelected(false, animated: true)
        }
        
        // set user configuration notification sound cell to selected
        guard let currentNotificationSoundCellRow = NotificationSound.allCases.firstIndex(of: UserConfiguration.notificationSound) else { return }
        let currentNotificationSoundCellIndexPath = IndexPath(row: currentNotificationSoundCellRow, section: 0)
        let currentNotificationSoundCell = tableView.cellForRow(at: currentNotificationSoundCellIndexPath) as? SettingsNotifsAlarmsNotificationSoundTVC
        currentNotificationSoundCell?.setCustomSelected(true, animated: true)
    }
    
    // MARK: - Table View Data Source
    
    func numberOfSections(in tableView: UITableView) -> Int {
        1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return NotificationSound.allCases.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        guard let cell = tableView.dequeueReusableCell(withIdentifier: SettingsNotifsAlarmsNotificationSoundTVC.reuseIdentifier, for: indexPath) as? SettingsNotifsAlarmsNotificationSoundTVC else {
            return HoundTableViewCell()
        }
        
        let notificationSound = NotificationSound.allCases[indexPath.row]
        
        cell.setup(notificationSound: notificationSound == NotificationSound.radar ? "Radar (Default)" : notificationSound.rawValue)
        cell.setCustomSelected(notificationSound == UserConfiguration.notificationSound, animated: false)
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        guard let selectedCell = tableView.cellForRow(at: indexPath) as? SettingsNotifsAlarmsNotificationSoundTVC,
              let currentNotificationSoundIndex = NotificationSound.allCases.firstIndex(of: UserConfiguration.notificationSound) else {
            // we need the selected cell and current notification sound index before we proceed
            AudioManager.stopAudio()
            return
        }
        
        let selectedNotificationSound = NotificationSound.allCases[indexPath.row]
        
        guard selectedNotificationSound != UserConfiguration.notificationSound else {
            // cell selected is the same as the current sound saved, toggle the audio
            if AudioManager.isPlaying {
                AudioManager.stopAudio()
            }
            else {
                AudioManager.playAudio(audioPath: "\(UserConfiguration.notificationSound.rawValue.lowercased())")
            }
            
            return
        }
        
        // the new cell selected is different that the current sound saved
        
        // find the current notification sound cell and unselect it, as the user just selected a new one
        let currentNotificationSoundIndexPath = IndexPath(row: currentNotificationSoundIndex, section: 0)
        let currentNotificationSoundCell = tableView.cellForRow(at: currentNotificationSoundIndexPath) as? SettingsNotifsAlarmsNotificationSoundTVC
        currentNotificationSoundCell?.setCustomSelected(false, animated: true)
        
        // highlight the new selected cell
        selectedCell.setCustomSelected(true, animated: true)
        
        // leave this code right here, don't move below or its value will be incorrect
        let beforeUpdateNotificationSound = UserConfiguration.notificationSound
        
        // assign user configuration to new value and play its audio
        UserConfiguration.notificationSound = selectedNotificationSound
        AudioManager.playAudio(audioPath: "\(UserConfiguration.notificationSound.rawValue.lowercased())")
        
        // contact server to attempt to persist change
        let body: JSONRequestBody = [Constant.Key.userConfigurationNotificationSound.rawValue: .string(UserConfiguration.notificationSound.rawValue)]
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.notificationSound = beforeUpdateNotificationSound
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(tableView)
        contentView.addSubview(descriptionLabel)
        contentView.addGestureRecognizer(disabledTapGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // tableView
        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            tableView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            tableView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: tableView.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsNotifsAlarmsVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsVC: HoundViewController, UITableViewDelegate, UITableViewDataSource {
    
    // MARK: - Properties
    
    private lazy var tableView = {
        let tableView = HoundTableView(style: .grouped)
        tableView.backgroundColor = .systemBackground
        tableView.delegate = self
        tableView.dataSource = self
        
        settingsNotifsCategoriesTVCReuseIdentifiers.forEach { settingsNotifsTVCReuseIdentifier in
            switch settingsNotifsTVCReuseIdentifier {
            case SettingsNotifsAlarmsLoudNotificationsTVC.reuseIdentifier:
                tableView.register(SettingsNotifsAlarmsLoudNotificationsTVC.self, forCellReuseIdentifier: SettingsNotifsAlarmsLoudNotificationsTVC.reuseIdentifier)
            case SettingsNotifsAlarmsSnoozeLengthTVC.reuseIdentifier:
                tableView.register(SettingsNotifsAlarmsSnoozeLengthTVC.self, forCellReuseIdentifier: SettingsNotifsAlarmsSnoozeLengthTVC.reuseIdentifier)
            case SettingsNotifsAlarmsNotificationSoundsTVC.reuseIdentifier:
                tableView.register(SettingsNotifsAlarmsNotificationSoundsTVC.self, forCellReuseIdentifier: SettingsNotifsAlarmsNotificationSoundsTVC.reuseIdentifier)
            default: fatalError("You must register all table view cells")
            }
        }
        
        return tableView
    }()
    
    private let settingsNotifsCategoriesTVCReuseIdentifiers = [
        SettingsNotifsAlarmsLoudNotificationsTVC.reuseIdentifier,
        SettingsNotifsAlarmsSnoozeLengthTVC.reuseIdentifier,
        SettingsNotifsAlarmsNotificationSoundsTVC.reuseIdentifier
    ]
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        AudioManager.stopAudio()
    }
    
    // MARK: - Functions
    
    func synchronizeAllIsEnabled() {
        for index in settingsNotifsCategoriesTVCReuseIdentifiers.indices {
            let indexPath = IndexPath(row: index, section: 0)
            tableView.reloadRows(at: [indexPath], with: .fade)
        }
    }
    
    func synchronizeAllValues(animated: Bool) {
        synchronizeAllIsEnabled()
        for index in settingsNotifsCategoriesTVCReuseIdentifiers.indices {
            let indexPath = IndexPath(row: index, section: 0)
            tableView.reloadRows(at: [indexPath], with: .fade)
        }
    }
    
    // MARK: - Table View Data Source
    
    func numberOfSections(in tableView: UITableView) -> Int {
        1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return settingsNotifsCategoriesTVCReuseIdentifiers.count
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = PageSheetHeaderFooterView()
        headerView.setup(title: "Alarms")
        return headerView
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard indexPath.row < settingsNotifsCategoriesTVCReuseIdentifiers.count else {
            return HoundTableViewCell()
        }
        let identifier = settingsNotifsCategoriesTVCReuseIdentifiers[indexPath.row]
        let cell = tableView.dequeueReusableCell(withIdentifier: identifier, for: indexPath)
        return cell
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(tableView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: view.topAnchor),
            tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        ])
    }
}
//
//  SettingsNotifsAlarmsSnoozeLengthTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsSnoozeLengthTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Alarm Snooze"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var snoozeLengthDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker(huggingPriority: 280, compressionResistancePriority: 280)
        datePicker.datePickerMode = .countDownTimer
        datePicker.addTarget(self, action: #selector(didUpdateSnoozeLength), for: .valueChanged)
        return datePicker
    }()
    
    private lazy var disabledTapGesture: UITapGestureRecognizer = {
        let gesture = UITapGestureRecognizer(target: self, action: #selector(showDisabledBanner))
        gesture.cancelsTouchesInView = false
        return gesture
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.text = "If you snooze an alarm, this is the length of time until it sounds again."
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    @objc private func didUpdateSnoozeLength(_ sender: Any) {
        let beforeUpdateSnoozeLength = UserConfiguration.snoozeLength
        
        UserConfiguration.snoozeLength = snoozeLengthDatePicker.countDownDuration
        
        let body: JSONRequestBody = [Constant.Key.userConfigurationSnoozeLength.rawValue: .double(UserConfiguration.snoozeLength)]
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.snoozeLength = beforeUpdateSnoozeLength
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsAlarmsSnoozeLengthTVC"
    
    // MARK: - Main
    
    override func prepareForReuse() {
        super.prepareForReuse()
        synchronizeValues(animated: false)
    }
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    /// Updates the displayed values to reflect the values stored.
    private func synchronizeValues(animated: Bool) {
        snoozeLengthDatePicker.isEnabled = UserConfiguration.isNotificationEnabled
        
        snoozeLengthDatePicker.countDownDuration = UserConfiguration.snoozeLength
        
        // fixes issue with first time datepicker updates not triggering function
        DispatchQueue.main.asyncAfter(deadline: .now()) {
            self.snoozeLengthDatePicker.countDownDuration = UserConfiguration.snoozeLength
        }
    }
    
    @objc private func showDisabledBanner(_ sender: Any) {
        guard UserConfiguration.isNotificationEnabled == false else { return }
        PresentationManager.enqueueBanner(
            title: Constant.Visual.BannerText.noEditNotificationSettingsTitle,
            subtitle: Constant.Visual.BannerText.noEditNotificationSettingsSubtitle,
            style: .warning
        )
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(snoozeLengthDatePicker)
        contentView.addSubview(descriptionLabel)
        contentView.addGestureRecognizer(disabledTapGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // snoozeLengthDatePicker
        NSLayoutConstraint.activate([
            snoozeLengthDatePicker.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            snoozeLengthDatePicker.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            snoozeLengthDatePicker.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            snoozeLengthDatePicker.createHeightMultiplier(Constant.Constraint.Input.datePickerHeightMultiplier, relativeToWidthOf: contentView),
            snoozeLengthDatePicker.createMaxHeight(Constant.Constraint.Input.datePickerMaxHeight)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: snoozeLengthDatePicker.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsNotifsAlarmsLoudNotificationsTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsLoudNotificationsTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Loud Alarms"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var isLoudNotificationEnabledSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isOn = UserConfiguration.isNotificationEnabled
        uiSwitch.addTarget(self, action: #selector(didToggleIsLoudNotificationEnabled), for: .valueChanged)
        return uiSwitch
    }()
    
    private lazy var disabledTapGesture: UITapGestureRecognizer = {
        let gesture = UITapGestureRecognizer(target: self, action: #selector(showDisabledBanner))
        gesture.cancelsTouchesInView = false
        return gesture
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel()
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        
        label.attributedText = {
            let message = NSMutableAttributedString(
                string: "Alarms will ring and repeatedly vibrate despite your phone being silenced, locked, or in focus mode. ",
                attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
            )
            
            message.append(NSAttributedString(
                string: "If Hound is terminated, Loud Alarms will not work properly.",
                attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel])
            )
            
            return message
        }()
        return label
    }()
    
    @objc private func didToggleIsLoudNotificationEnabled(_ sender: Any) {
        let beforeUpdateIsLoudNotificationEnabled = UserConfiguration.isLoudNotificationEnabled
        
        UserConfiguration.isLoudNotificationEnabled = isLoudNotificationEnabledSwitch.isOn
        
        let body: JSONRequestBody = [Constant.Key.userConfigurationIsLoudNotificationEnabled.rawValue: .bool(UserConfiguration.isLoudNotificationEnabled)]
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.isLoudNotificationEnabled = beforeUpdateIsLoudNotificationEnabled
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    @objc private func showDisabledBanner(_ sender: Any) {
        guard UserConfiguration.isNotificationEnabled == false else { return }
        PresentationManager.enqueueBanner(
            title: Constant.Visual.BannerText.noEditNotificationSettingsTitle,
            subtitle: Constant.Visual.BannerText.noEditNotificationSettingsSubtitle,
            style: .warning
        )
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsAlarmsLoudNotificationsTVC"
    
    // MARK: - Main
    
    override func prepareForReuse() {
        super.prepareForReuse()
        synchronizeValues(animated: false)
    }
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    /// Updates the displayed values to reflect the values stored.
    private func synchronizeValues(animated: Bool) {
        isLoudNotificationEnabledSwitch.isEnabled = UserConfiguration.isNotificationEnabled
        
        isLoudNotificationEnabledSwitch.setOn(UserConfiguration.isLoudNotificationEnabled, animated: animated)
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(isLoudNotificationEnabledSwitch)
        contentView.addSubview(descriptionLabel)
        contentView.addGestureRecognizer(disabledTapGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // isLoudNotificationEnabledSwitch
        NSLayoutConstraint.activate([
            isLoudNotificationEnabledSwitch.centerYAnchor.constraint(equalTo: headerLabel.centerYAnchor),
            isLoudNotificationEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            isLoudNotificationEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsNotifsSilentModeTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsSilentModeTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 300)
        label.text = "Silent Hours"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var isSilentModeEnabledSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 300, compressionResistancePriority: 300)
        uiSwitch.isOn = UserConfiguration.isSilentModeEnabled
        uiSwitch.addTarget(self, action: #selector(didToggleIsSilentModeEnabled), for: .valueChanged)
        return uiSwitch
    }()
    
    private lazy var silentModeStartHoursDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker(huggingPriority: 280, compressionResistancePriority: 280)
        datePicker.datePickerMode = .time
        datePicker.minuteInterval = Constant.Development.minuteInterval
        datePicker.preferredDatePickerStyle = .compact
        datePicker.timeZone = Calendar.user.timeZone
        datePicker.addTarget(self, action: #selector(didUpdateSilentModeStartHours), for: .valueChanged)
        return datePicker
    }()
    
    private lazy var silentModeEndHoursDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker(huggingPriority: 270, compressionResistancePriority: 270)
        datePicker.datePickerMode = .time
        datePicker.minuteInterval = Constant.Development.minuteInterval
        datePicker.preferredDatePickerStyle = .compact
        datePicker.timeZone = Calendar.user.timeZone
        datePicker.addTarget(self, action: #selector(didUpdateSilentModeEndHours), for: .valueChanged)
        return datePicker
    }()
    
    private let timeRangeToLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.text = "to"
        label.font = Constant.Visual.Font.primaryRegularLabel
        return label
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 260, compressionResistancePriority: 260)
        label.text = "Configure a time range where you won't recieve notifications (including alarms)."
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    private lazy var disabledTapGesture: UITapGestureRecognizer = {
        let gesture = UITapGestureRecognizer(target: self, action: #selector(showDisabledBanner))
        gesture.cancelsTouchesInView = false
        return gesture
    }()
    
    @objc private func showDisabledBanner(_ sender: Any) {
        guard UserConfiguration.isNotificationEnabled == false else { return }
        PresentationManager.enqueueBanner(
            title: Constant.Visual.BannerText.noEditNotificationSettingsTitle,
            subtitle: Constant.Visual.BannerText.noEditNotificationSettingsSubtitle,
            style: .warning
        )
    }
    
    @objc private func didToggleIsSilentModeEnabled(_ sender: Any) {
        let beforeUpdateIsSilentModeEnabled = UserConfiguration.isSilentModeEnabled
        
        UserConfiguration.isSilentModeEnabled = isSilentModeEnabledSwitch.isOn
        
        let body: JSONRequestBody = [Constant.Key.userConfigurationIsSilentModeEnabled.rawValue: .bool(UserConfiguration.isSilentModeEnabled)]
        
        // cant choose silent mode time when silent mode is disabled
        synchronizeDatePickers(animated: true)
        
        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.isSilentModeEnabled = beforeUpdateIsSilentModeEnabled
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    @objc private func didUpdateSilentModeStartHours(_ sender: Any) {
        let beforeUpdateSilentModeStartHour = UserConfiguration.silentModeStartHour
        let beforeUpdateSilentModeStartMinute = UserConfiguration.silentModeStartMinute

        let calendar = Calendar.user
        UserConfiguration.silentModeStartHour = calendar.component(.hour, from: silentModeStartHoursDatePicker.date)
        UserConfiguration.silentModeStartMinute = calendar.component(.minute, from: silentModeStartHoursDatePicker.date)

        let body: JSONRequestBody = [
            Constant.Key.userConfigurationSilentModeStartHour.rawValue: .int(UserConfiguration.silentModeStartHour),
            Constant.Key.userConfigurationSilentModeStartMinute.rawValue: .int(UserConfiguration.silentModeStartMinute)
        ]

        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                UserConfiguration.silentModeStartHour = beforeUpdateSilentModeStartHour
                UserConfiguration.silentModeStartMinute = beforeUpdateSilentModeStartMinute
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    @objc private func didUpdateSilentModeEndHours(_ sender: Any) {
        let beforeUpdateSilentModeEndHour = UserConfiguration.silentModeEndHour
        let beforeUpdateSilentModeEndMinute = UserConfiguration.silentModeEndMinute

        let calendar = Calendar.user
        UserConfiguration.silentModeEndHour = calendar.component(.hour, from: silentModeEndHoursDatePicker.date)
        UserConfiguration.silentModeEndMinute = calendar.component(.minute, from: silentModeEndHoursDatePicker.date)

        let body: JSONRequestBody = [
            Constant.Key.userConfigurationSilentModeEndHour.rawValue: .int(UserConfiguration.silentModeEndHour),
            Constant.Key.userConfigurationSilentModeEndMinute.rawValue: .int(UserConfiguration.silentModeEndMinute)
        ]

        UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                UserConfiguration.silentModeEndHour = beforeUpdateSilentModeEndHour
                UserConfiguration.silentModeEndMinute = beforeUpdateSilentModeEndMinute
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsSilentModeTVC"
    
    // MARK: - Main
    
    override func prepareForReuse() {
        super.prepareForReuse()
        synchronizeValues(animated: false)
    }
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    /// Updates the displayed values to reflect the values stored.
    private func synchronizeValues(animated: Bool) {
        isSilentModeEnabledSwitch.isEnabled = UserConfiguration.isNotificationEnabled
        isSilentModeEnabledSwitch.setOn(UserConfiguration.isSilentModeEnabled, animated: animated)
        synchronizeDatePickers(animated: animated)
    }
    
    private func synchronizeDatePickers(animated: Bool) {
        silentModeStartHoursDatePicker.isEnabled = UserConfiguration.isNotificationEnabled && UserConfiguration.isSilentModeEnabled
        silentModeEndHoursDatePicker.isEnabled = UserConfiguration.isNotificationEnabled && UserConfiguration.isSilentModeEnabled

        let calendar = Calendar.user
        silentModeStartHoursDatePicker.setDate(
            calendar.date(
                bySettingHour: UserConfiguration.silentModeStartHour,
                minute: UserConfiguration.silentModeStartMinute,
                second: 0, of: Date()
            ) ?? Date(),
            animated: animated
        )
        silentModeEndHoursDatePicker.setDate(
            calendar.date(
                bySettingHour: UserConfiguration.silentModeEndHour,
                minute: UserConfiguration.silentModeEndMinute,
                second: 0, of: Date()
            ) ?? Date(),
            animated: animated
        )
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(isSilentModeEnabledSwitch)
        contentView.addSubview(silentModeStartHoursDatePicker)
        contentView.addSubview(timeRangeToLabel)
        contentView.addSubview(silentModeEndHoursDatePicker)
        contentView.addSubview(descriptionLabel)
        contentView.addGestureRecognizer(disabledTapGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // isNotificationEnabledSwitch
        NSLayoutConstraint.activate([
            isSilentModeEnabledSwitch.centerYAnchor.constraint(equalTo: headerLabel.centerYAnchor),
            isSilentModeEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            isSilentModeEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // silentModeStartHoursDatePicker
        NSLayoutConstraint.activate([
            silentModeStartHoursDatePicker.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            silentModeStartHoursDatePicker.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            silentModeStartHoursDatePicker.createHeightMultiplier(Constant.Constraint.Input.segmentedHeightMultiplier, relativeToWidthOf: contentView),
            silentModeStartHoursDatePicker.createMaxHeight(Constant.Constraint.Input.segmentedMaxHeight),
            silentModeStartHoursDatePicker.createAspectRatio(2.75)
        ])
        
        // timeRangeToLabel
        NSLayoutConstraint.activate([
            timeRangeToLabel.leadingAnchor.constraint(equalTo: silentModeStartHoursDatePicker.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            timeRangeToLabel.centerYAnchor.constraint(equalTo: silentModeStartHoursDatePicker.centerYAnchor),
            timeRangeToLabel.heightAnchor.constraint(equalTo: silentModeStartHoursDatePicker.heightAnchor)
        ])
        
        // silentModeStartHoursDatePicker
        NSLayoutConstraint.activate([
            silentModeEndHoursDatePicker.leadingAnchor.constraint(equalTo: timeRangeToLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            silentModeEndHoursDatePicker.trailingAnchor.constraint(lessThanOrEqualTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            silentModeEndHoursDatePicker.centerYAnchor.constraint(equalTo: silentModeStartHoursDatePicker.centerYAnchor),
            silentModeEndHoursDatePicker.heightAnchor.constraint(equalTo: silentModeStartHoursDatePicker.heightAnchor),
            silentModeEndHoursDatePicker.widthAnchor.constraint(equalTo: silentModeStartHoursDatePicker.widthAnchor)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: silentModeStartHoursDatePicker.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsNotifsUseNotificationsTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol SettingsNotifsUseNotificationsTVCDelegate: AnyObject {
    func didToggleIsNotificationEnabled()
}

final class SettingsNotifsUseNotificationsTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Use Notifications"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let isNotificationEnabledSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 260, compressionResistancePriority: 260)
        
        uiSwitch.isOn = UserConfiguration.isNotificationEnabled
        
        return uiSwitch
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 240, compressionResistancePriority: 240)
        label.text = "Notifications help you stay up to date about the status of your dogs, reminders, and Hound family. "
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    @objc private func didToggleIsNotificationEnabled(_ sender: Any) {
        let beforeUpdateIsNotificationEnabled = UserConfiguration.isNotificationEnabled
        
        UNUserNotificationCenter.current().getNotificationSettings { permission in
            // needed as  UNUserNotificationCenter.current().getNotificationSettings on other thread
            DispatchQueue.main.async {
                switch permission.authorizationStatus {
                case .authorized:
                    // even if we get .authorized, they doesn't mean the user wants to enabled notifications. the user could have authorized notifications months ago and now gone to this page to tap the switch, flipping it from on to off.
                    UserConfiguration.isNotificationEnabled.toggle()
                    // the switch has been manually flicked by the user to invoke this, so don't call synchronizeValues as that would cause the switch to be animated for a second time
                    self.synchronizeUseNotificationsDescriptionLabel()
                    self.delegate?.didToggleIsNotificationEnabled()
                    
                    let body: JSONRequestBody = [Constant.Key.userConfigurationIsNotificationEnabled.rawValue: .bool(UserConfiguration.isNotificationEnabled)]
                    
                    UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
                        guard responseStatus != .failureResponse else {
                            // Revert local values to previous state due to an error
                            UserConfiguration.isNotificationEnabled = beforeUpdateIsNotificationEnabled
                            self.synchronizeValues(animated: true)
                            self.delegate?.didToggleIsNotificationEnabled()
                            return
                        }
                    }
                case .denied:
                    // nothing to update (as permissions denied) so we don't tell the server anything
                    
                    // Permission is denied, so we want to flip the switch back to its proper off position
                    let switchDisableTimer = Timer(fire: Date().addingTimeInterval(0.25), interval: -1, repeats: false) { _ in
                        self.synchronizeValues(animated: true)
                    }
                    
                    RunLoop.main.add(switchDisableTimer, forMode: .common)
                    
                    // Attempt to re-direct the user to their iPhone's settings for Hound, so they can enable notifications
                    guard let url = URL(string: UIApplication.openSettingsURLString), UIApplication.shared.canOpenURL(url) else {
                        // If we can't redirect the user, then just user a generic pop-up
                        PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.notificationsDisabledTitle, subtitle: Constant.Visual.BannerText.notificationsDisabledSubtitle, style: .danger)
                        return
                    }
                    
                    UIApplication.shared.open(url)
                case .notDetermined:
                    // don't advise the user if they want to turn on notifications. we already know that the user wants to turn on notification because they just toggle a switch to turn them on
                    NotificationPermissionsManager.requestNotificationAuthorization(shouldAdviseUserBeforeRequestingNotifications: false) {
                        // the request get notifications is complete
                        self.synchronizeValues(animated: true)
                        self.delegate?.didToggleIsNotificationEnabled()
                    }
                case .provisional:
                    HoundLogger.general.fault("UNUserNotificationCenter.current().getNotificationSettings: .provisional")
                case .ephemeral:
                    HoundLogger.general.fault("UNUserNotificationCenter.current().getNotificationSettings: .ephemeral")
                @unknown default:
                    HoundLogger.general.fault("UNUserNotificationCenter.current().getNotificationSettings: @unknown notification authorization status")
                }
            }
        }
        
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsUseNotificationsTVC"
    
    private weak var delegate: SettingsNotifsUseNotificationsTVCDelegate?
    
    // MARK: - Main
    
    override func prepareForReuse() {
        super.prepareForReuse()
        synchronizeValues(animated: false)
    }
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Setup
    
    func setup(delegate: SettingsNotifsUseNotificationsTVCDelegate) {
        self.delegate = delegate
    }
    
    // MARK: - Functions
    
    /// Updates the displayed values to reflect the values stored.
    private func synchronizeValues(animated: Bool) {
        isNotificationEnabledSwitch.setOn(UserConfiguration.isNotificationEnabled, animated: animated)
        
        synchronizeUseNotificationsDescriptionLabel()
    }
    
    private func synchronizeUseNotificationsDescriptionLabel() {
        let dogCount = DogManager.globalDogManager?.dogs.count ?? 1
        
        descriptionLabel.attributedText = {
            let message = NSMutableAttributedString(
                string: "Notifications help you stay up to date about both the status of your dog\(dogCount <= 1 ? "" : "s") and Hound family. ",
                attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
            )
            
            if UserConfiguration.isNotificationEnabled == false {
                message.append(NSMutableAttributedString(
                    string: "You can't modify the settings below until you enable notifications.",
                    attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel])
                )
            }
            
            return message
        }()
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(isNotificationEnabledSwitch)
        contentView.addSubview(descriptionLabel)
        
        isNotificationEnabledSwitch.addTarget(self, action: #selector(didToggleIsNotificationEnabled), for: .valueChanged)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // isNotificationEnabledSwitch
        NSLayoutConstraint.activate([
            isNotificationEnabledSwitch.centerYAnchor.constraint(equalTo: headerLabel.centerYAnchor),
            isNotificationEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            isNotificationEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsNotifsTableHeaderV.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/30/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class PageSheetHeaderFooterView: HoundHeaderFooterView {
    
    // MARK: - Elements
    
    private let pageSheetHeaderView = HoundPageSheetHeaderView()
    
    // MARK: - Setup
    
    func setup(title: String) {
        pageSheetHeaderView.pageHeaderLabel.text = title
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(pageSheetHeaderView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        NSLayoutConstraint.activate([
            pageSheetHeaderView.topAnchor.constraint(equalTo: contentView.topAnchor),
            // Use .high priority to avoid breaking during table view height estimation
            pageSheetHeaderView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.contentTallIntraVert).withPriority(.defaultHigh),
            pageSheetHeaderView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            pageSheetHeaderView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor)
        ])
    }
    
}
//
//  SettingsNotifsCategoriesTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Notification Categories"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.text = "By default, Hound will send notifications about your account, family, logs, and reminders."
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    private let chevronImageView: HoundImageView = {
        let imageView = HoundImageView(huggingPriority: 300, compressionResistancePriority: 300)
        
        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = UIColor.systemGray4
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesTVC"
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(descriptionLabel)
        contentView.addSubview(chevronImageView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            headerLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: contentView)
        ])
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            descriptionLabel.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor),
            descriptionLabel.trailingAnchor.constraint(equalTo: headerLabel.trailingAnchor)
        ])
        
        // chevronImageView
        NSLayoutConstraint.activate([
            chevronImageView.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            chevronImageView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            chevronImageView.centerYAnchor.constraint(equalTo: contentView.centerYAnchor),
            chevronImageView.createAspectRatio(Constant.Constraint.Button.chevronAspectRatio),
            chevronImageView.createHeightMultiplier(Constant.Constraint.Button.chevronHeightMultiplier, relativeToWidthOf: contentView),
            chevronImageView.createMaxHeight(Constant.Constraint.Button.chevronMaxHeight)
        ])
        
    }
    
}
import UIKit

final class SettingsNotifsVC: HoundViewController, UITableViewDelegate, UITableViewDataSource, SettingsNotifsUseNotificationsTVCDelegate {
    
    // MARK: - SettingsNotifsUseNotificationsTVCDelegate
    
    func didToggleIsNotificationEnabled() {
        synchronizeAllIsEnabled()
    }
    
    // MARK: - Properties
    
    private static var settingsNotifsVC: SettingsNotifsVC?
    
    private var settingsNotifsCategoriesVC: SettingsNotifsCategoriesVC?
    
    private var settingsNotifsAlarmsVC: SettingsNotifsAlarmsVC?
    
    private lazy var tableView = {
        let tableView = HoundTableView()
        tableView.delegate = self
        tableView.dataSource = self
        
        settingsNotifsTVCReuseIdentifiers.forEach { identifier in
            switch identifier {
            case SettingsNotifsUseNotificationsTVC.reuseIdentifier:
                tableView.register(SettingsNotifsUseNotificationsTVC.self, forCellReuseIdentifier: identifier)
            case SettingsNotifsSilentModeTVC.reuseIdentifier:
                tableView.register(SettingsNotifsSilentModeTVC.self, forCellReuseIdentifier: identifier)
            case SettingsNotifsCategoriesTVC.reuseIdentifier:
                tableView.register(SettingsNotifsCategoriesTVC.self, forCellReuseIdentifier: identifier)
            case SettingsNotifsAlarmsTVC.reuseIdentifier:
                tableView.register(SettingsNotifsAlarmsTVC.self, forCellReuseIdentifier: identifier)
            default:
                fatalError("You must register all table view cells")
            }
        }
        
        return tableView
    }()
    
    private let settingsNotifsTVCReuseIdentifiers = [
        SettingsNotifsUseNotificationsTVC.reuseIdentifier,
        SettingsNotifsSilentModeTVC.reuseIdentifier,
        SettingsNotifsCategoriesTVC.reuseIdentifier,
        SettingsNotifsAlarmsTVC.reuseIdentifier
    ]
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        SettingsNotifsVC.settingsNotifsVC = self
    }
    
    // MARK: - Functions
    
    func synchronizeAllIsEnabled() {
        if let silentModeRow = settingsNotifsTVCReuseIdentifiers.firstIndex(of: SettingsNotifsSilentModeTVC.reuseIdentifier) {
            let silentModeCellIndexPath = IndexPath(row: silentModeRow, section: 0)
            tableView.reloadRows(at: [silentModeCellIndexPath], with: .fade)
        }
        settingsNotifsCategoriesVC?.synchronizeAllIsEnabled()
        settingsNotifsAlarmsVC?.synchronizeAllIsEnabled()
    }
    
    func synchronizeAllValues(animated: Bool) {
        synchronizeAllIsEnabled()
        if let useNotificationsRow = settingsNotifsTVCReuseIdentifiers.firstIndex(of: SettingsNotifsUseNotificationsTVC.reuseIdentifier) {
            let useNotificationsIndexPath = IndexPath(row: useNotificationsRow, section: 0)
            tableView.reloadRows(at: [useNotificationsIndexPath], with: .fade)
        }
        
        if let silentModeRow = settingsNotifsTVCReuseIdentifiers.firstIndex(of: SettingsNotifsSilentModeTVC.reuseIdentifier) {
            let silentModeCellIndexPath = IndexPath(row: silentModeRow, section: 0)
            tableView.reloadRows(at: [silentModeCellIndexPath], with: .fade)
        }
        settingsNotifsCategoriesVC?.synchronizeAllValues(animated: animated)
        settingsNotifsAlarmsVC?.synchronizeAllValues(animated: animated)
    }
    
    static func didSynchronizeNotificationAuthorization() {
        SettingsNotifsVC.settingsNotifsVC?.synchronizeAllValues(animated: true)
    }
    
    // MARK: - Table View Data Source
    
    func numberOfSections(in tableView: UITableView) -> Int {
        1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        settingsNotifsTVCReuseIdentifiers.count
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = PageSheetHeaderFooterView()
        headerView.setup(title: "Notifications")
        return headerView
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard indexPath.row < settingsNotifsTVCReuseIdentifiers.count else {
            return HoundTableViewCell()
        }
        let identifier = settingsNotifsTVCReuseIdentifiers[indexPath.row]
        let cell = tableView.dequeueReusableCell(withIdentifier: identifier, for: indexPath)
        if let cell = cell as? SettingsNotifsUseNotificationsTVC {
            cell.setup(delegate: self)
        }
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        let identifier = settingsNotifsTVCReuseIdentifiers[indexPath.row]
        switch identifier {
        case SettingsNotifsCategoriesTVC.reuseIdentifier:
            let vc = SettingsNotifsCategoriesVC()
            PresentationManager.enqueueViewController(vc)
        case SettingsNotifsAlarmsTVC.reuseIdentifier:
            let vc = SettingsNotifsAlarmsVC()
            PresentationManager.enqueueViewController(vc)
        default:
            break
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(tableView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: view.topAnchor),
            tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        ])
    }
}
//
//  SettingsFamilyVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/16/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsFamilyVC: HoundScrollViewController, UITableViewDelegate, UITableViewDataSource {
    
    // MARK: - Elements
    
    private let pageHeaderView: HoundPageSheetHeaderView = {
        let view = HoundPageSheetHeaderView(huggingPriority: 380, compressionResistancePriority: 380)
        view.pageHeaderLabel.text = "Family"
        return view
    }()
    
    private let familyCodeHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let familyCodeDescriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        
        label.attributedText = {
            let message: NSMutableAttributedString = NSMutableAttributedString(
                string: "The family code is the key your family. Have a prospective family member input the code above to join your family (case-insensitive).",
                attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel])
            
            // Add a disclaimer for the user that they
            if FamilyInformation.familyActiveSubscription.numberOfFamilyMembers <= 1 {
                message.append(
                    NSAttributedString(
                        string: " Currently, your Hound plan is for individual use only. To add family members, try out a free trial of Hound+!",
                        attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel]
                    )
                )
            }
            
            return message
        }()
        
        return label
    }()
    
    private let shareFamilyButton: HoundButton = {
        let button = HoundButton(huggingPriority: 230, compressionResistancePriority: 230)
        
        button.setTitle("Invite to Family", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        return button
    }()
    
    @objc private func didTouchUpInsideShareFamily(_ sender: Any) {
        guard let familyCode = familyCode else { return }
        
        ExportActivityViewManager.shareFamilyCode(familyCode: familyCode)
    }
    
    private let membersHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.text = "Members"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let familyMembersTableView: HoundTableView = {
        let tableView = HoundTableView(style: .plain, huggingPriority: 240, compressionResistancePriority: 240)
        tableView.isScrollEnabled = false
        tableView.backgroundColor = UIColor.systemBackground
        tableView.shouldAutomaticallyAdjustHeight = true
        tableView.applyStyle(.thinLabelBorder)
        return tableView
    }()
    
    private let leaveFamilyButton: HoundButton = {
        let button = HoundButton(huggingPriority: 230, compressionResistancePriority: 230)
        
        button.setTitle("Leave Family", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        return button
    }()
    
    private let leaveFamilyDescriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 220, compressionResistancePriority: 220)
        label.text = "Family members can freely join or leave families. The head can only leave by deleting the family, which requires all other members to leave first (or be kicked)."
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    @objc private func didTouchUpInsideLeaveFamily(_ sender: Any) {
        // We don't want to check the status of a family's subscription locally.
        // In order for a user to cancel a subscription, they must use Apple's subscription interface
        // This inherently doesn't update Hound, only the server.
        // Therefore the Hound app will always be outdated on this information.
        guard let leaveFamilyAlertController = leaveFamilyAlertController else { return }
        
        PresentationManager.enqueueAlert(leaveFamilyAlertController)
    }
    
    // MARK: - Properties
    
    private var leaveFamilyAlertController: UIAlertController?
    
    private var familyCode: String? {
        var familyCode = FamilyInformation.familyCode
        if let code = familyCode {
            familyCode?.insert("-", at: code.index(code.startIndex, offsetBy: 4))
        }
        return familyCode
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        self.familyMembersTableView.register(SettingsFamilyHeadTVC.self, forCellReuseIdentifier: SettingsFamilyHeadTVC.reuseIdentifier)
        self.familyMembersTableView.register(SettingsFamilyMemberTVC.self, forCellReuseIdentifier: SettingsFamilyMemberTVC.reuseIdentifier)
        self.familyMembersTableView.delegate = self
        self.familyMembersTableView.dataSource = self
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        repeatableSetup()
    }
    
    // MARK: - Functions
    
    /// These properties can be reassigned. Does not reload anything, rather just configures.
    private func repeatableSetup() {
        
        // MARK: Family Code
        familyCodeHeaderLabel.text = "Code: \(familyCode ?? "NO CODE⚠️")"
        
        // MARK: Family Members
        
        familyMembersTableView.allowsSelection = UserInformation.isUserFamilyHead
        
        // MARK: Leave Family Button
        
        let leaveFamilyAlertController = UIAlertController(title: "placeholder", message: nil, preferredStyle: .alert)
        
        // user is not the head of the family, so the button is enabled for them
        if UserInformation.isUserFamilyHead == false {
            leaveFamilyButton.isEnabled = true
            
            leaveFamilyButton.setTitle("Leave Family", for: .normal)
            
            leaveFamilyAlertController.title = "Are you sure you want to leave your family?"
            let leaveAlertAction = UIAlertAction(title: "Leave Family", style: .destructive) { _ in
                PresentationManager.beginFetchingInformationIndicator()
                FamilyRequest.delete(errorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                    PresentationManager.endFetchingInformationIndicator {
                        guard responseStatus == .successResponse else {
                            return
                        }
                        
                        // family was successfully left, revert to server sync view controller
                        self.dismissToViewController(ofClass: ServerSyncVC.self, completionHandler: nil)
                    }
                }
            }
            leaveFamilyAlertController.addAction(leaveAlertAction)
        }
        // user is the head of the family, further checks needed
        else {
            // user must kicked other members before they can destroy their family
            leaveFamilyButton.isEnabled = FamilyInformation.familyMembers.count == 1
            leaveFamilyButton.setTitle("Delete Family", for: .normal)
            
            leaveFamilyAlertController.title = "Are you sure you want to delete your family?"
            
            let deleteAlertAction = UIAlertAction(title: "Delete Family", style: .destructive) { _ in
                PresentationManager.beginFetchingInformationIndicator()
                FamilyRequest.delete(errorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                    PresentationManager.endFetchingInformationIndicator {
                        guard responseStatus == .successResponse else {
                            return
                        }
                        // family was successfully deleted, revert to server sync view controller
                        self.dismissToViewController(ofClass: ServerSyncVC.self, completionHandler: nil)
                    }
                }
            }
            leaveFamilyAlertController.addAction(deleteAlertAction)
        }
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
        leaveFamilyAlertController.addAction(cancelAlertAction)
        self.leaveFamilyAlertController = leaveFamilyAlertController
    }
    
    // MARK: - Table View Data Source
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return FamilyInformation.familyMembers.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        guard let familyMember = FamilyInformation.familyMembers[safe: indexPath.row] else {
            return HoundTableViewCell()
        }
        
        let cell = indexPath.row == 0
        ? tableView.dequeueReusableCell(withIdentifier: SettingsFamilyHeadTVC.reuseIdentifier, for: indexPath)
        : tableView.dequeueReusableCell(withIdentifier: SettingsFamilyMemberTVC.reuseIdentifier, for: indexPath)
        
        if let cell = cell as? SettingsFamilyHeadTVC {
            cell.setup(displayFullName: familyMember.displayFullName ?? Constant.Visual.Text.unknownName)
            cell.containerView.roundCorners(setCorners: .all)
        }
        
        if let cell = cell as? SettingsFamilyMemberTVC {
            cell.setup(displayFullName: familyMember.displayFullName ?? Constant.Visual.Text.unknownName)
            cell.containerView.roundCorners(setCorners: .none)
        }
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        self.familyMembersTableView.deselectRow(at: indexPath, animated: true)
        // the first row is the family head who should be able to be selected
        guard indexPath.row != 0 else { return }
        
        // construct the alert controller which will confirm if the user wants to kick the family member
        let familyMember = FamilyInformation.familyMembers[indexPath.row]
        let kickFamilyMemberAlertController = UIAlertController(title: "Do you want to kick \(familyMember.displayFullName ?? Constant.Visual.Text.unknownName) from your family?", message: nil, preferredStyle: .alert)
        
        let kickAlertAction = UIAlertAction(title: "Kick \(familyMember.displayFullName ?? Constant.Visual.Text.unknownName)", style: .destructive) { _ in
            // the user wants to kick the family member so query the server
            let body: JSONRequestBody = [Constant.Key.familyKickUserId.rawValue: .string(familyMember.userId)]
            PresentationManager.beginFetchingInformationIndicator()
            FamilyRequest.delete(errorAlert: .automaticallyAlertForAll, body: body) { responseStatusFamilyDelete, _ in
                PresentationManager.endFetchingInformationIndicator {
                    guard responseStatusFamilyDelete == .successResponse else {
                        return
                    }
                    
                    // Refresh this page
                    FamilyRequest.get(errorAlert: .automaticallyAlertForAll) { responseStatusFamilyGet, _ in
                        guard responseStatusFamilyGet == .successResponse else {
                            return
                        }
                        
                        self.repeatableSetup()
                        self.familyMembersTableView.deleteRows(at: [indexPath], with: .automatic)
                        UIView.animate(withDuration: Constant.Visual.Animation.moveMultipleElements) {
                            self.view.setNeedsLayout()
                            self.view.layoutIfNeeded()
                        }
                    }
                }
            }
        }
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
        
        kickFamilyMemberAlertController.addAction(kickAlertAction)
        kickFamilyMemberAlertController.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(kickFamilyMemberAlertController)
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(familyMembersTableView)
        containerView.addSubview(familyCodeHeaderLabel)
        containerView.addSubview(familyCodeDescriptionLabel)
        containerView.addSubview(leaveFamilyButton)
        containerView.addSubview(leaveFamilyDescriptionLabel)
        containerView.addSubview(pageHeaderView)
        containerView.addSubview(shareFamilyButton)
        containerView.addSubview(membersHeaderLabel)
        
        shareFamilyButton.addTarget(self, action: #selector(didTouchUpInsideShareFamily), for: .touchUpInside)
        leaveFamilyButton.addTarget(self, action: #selector(didTouchUpInsideLeaveFamily), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pageHeaderView
        NSLayoutConstraint.activate([
            pageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            pageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            pageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // familyCodeHeaderLabel
        NSLayoutConstraint.activate([
            familyCodeHeaderLabel.topAnchor.constraint(equalTo: pageHeaderView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            familyCodeHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            familyCodeHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            familyCodeHeaderLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            familyCodeHeaderLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view)
        ])
        
        // familyCodeDescriptionLabel
        NSLayoutConstraint.activate([
            familyCodeDescriptionLabel.topAnchor.constraint(equalTo: familyCodeHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            familyCodeDescriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            familyCodeDescriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // shareFamilyButton
        NSLayoutConstraint.activate([
            shareFamilyButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            shareFamilyButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            shareFamilyButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            shareFamilyButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight),
            shareFamilyButton.topAnchor.constraint(equalTo: familyCodeDescriptionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert)
        ])
        
        // membersHeaderLabel
        NSLayoutConstraint.activate([
            membersHeaderLabel.topAnchor.constraint(equalTo: shareFamilyButton.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            membersHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            membersHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            membersHeaderLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            membersHeaderLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view)
        ])
        
        // familyMembersTableView
        NSLayoutConstraint.activate([
            familyMembersTableView.topAnchor.constraint(equalTo: membersHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            familyMembersTableView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            familyMembersTableView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // leaveFamilyButton
        NSLayoutConstraint.activate([
            leaveFamilyButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            leaveFamilyButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            leaveFamilyButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            leaveFamilyButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight),
            leaveFamilyButton.topAnchor.constraint(equalTo: familyMembersTableView.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert)
        ])
        
        NSLayoutConstraint.activate([
            leaveFamilyDescriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            leaveFamilyDescriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            leaveFamilyDescriptionLabel.topAnchor.constraint(equalTo: leaveFamilyButton.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            leaveFamilyDescriptionLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
    
}
//
//  SettingsFamilyHeadTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/5/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsFamilyHeadTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    // public so corners can be rounded
    let containerView: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.systemBlue
        return view
    }()
    
    private let iconView: HoundImageView = {
        let iconView = HoundImageView()
        
        iconView.image = UIImage(systemName: "crown")
        iconView.tintColor = UIColor.systemBackground
        
        return iconView
    }()
    
    private let displayFullNameLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        label.textColor = UIColor.systemBackground
        return label
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsFamilyHeadTVC"
    
    // MARK: - Setup
    
    func setup(displayFullName: String) {
        displayFullNameLabel.text = displayFullName
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(iconView)
        containerView.addSubview(displayFullNameLabel)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        let inset: CGFloat = 5
        let iconSize: CGFloat = 50
        
        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor)
        ])
        
        // iconView
        NSLayoutConstraint.activate([
            iconView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: inset),
            iconView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -inset),
            iconView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: inset),
            iconView.createSquareAspectRatio(),
            iconView.heightAnchor.constraint(equalToConstant: iconSize)
        ])
        
        // displayFullNameLabel
        NSLayoutConstraint.activate([
            displayFullNameLabel.centerYAnchor.constraint(equalTo: iconView.centerYAnchor),
            displayFullNameLabel.heightAnchor.constraint(equalTo: iconView.heightAnchor),
            displayFullNameLabel.leadingAnchor.constraint(equalTo: iconView.trailingAnchor, constant: inset),
            displayFullNameLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -inset)
        ])
    }

}
//
//  SettingsFamilyMemberTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/5/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsFamilyMemberTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    let containerView: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.systemBackground
        return view
    }()
    
    private let displayFullNameLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.font = Constant.Visual.Font.emphasizedSecondaryHeaderLabel
        return label
    }()
    
    private var chevronLeadingConstraint: GeneralLayoutConstraint!
    private var chevronTrailingConstraint: GeneralLayoutConstraint!
    private let chevronImageView: HoundImageView = {
        let imageView = HoundImageView(huggingPriority: 300, compressionResistancePriority: 300)

        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = UIColor.systemGray4
        
        return imageView
    }()
    
    private let iconView: HoundImageView = {
        let imageView = HoundImageView(huggingPriority: 290, compressionResistancePriority: 290)

        imageView.image = UIImage(systemName: "person.fill")
        imageView.tintColor = UIColor.label
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsFamilyMemberTVC"
    
    // MARK: - Setup
    
    func setup(displayFullName: String) {
        displayFullNameLabel.text = displayFullName
        
        // if the user is not the family head, that means the cell should not be selectable nor should we show the chevron that indicates selectability
        isUserInteractionEnabled = UserInformation.isUserFamilyHead
        
        if UserInformation.isUserFamilyHead {
            chevronImageView.isHidden = false
            chevronLeadingConstraint.restore()
            chevronTrailingConstraint.restore()
        }
        else {
            chevronImageView.isHidden = true
            chevronLeadingConstraint.constant = 0.0
            chevronTrailingConstraint.constant = 0.0
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        contentView.backgroundColor = UIColor.secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(iconView)
        containerView.addSubview(chevronImageView)
        containerView.addSubview(displayFullNameLabel)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        let iconSize: CGFloat = 30
        
        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor)
        ])
        
        // iconView
        NSLayoutConstraint.activate([
            iconView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            iconView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            iconView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            iconView.widthAnchor.constraint(equalTo: iconView.heightAnchor),
            iconView.heightAnchor.constraint(equalToConstant: iconSize)
        ])
        
        // displayFullNameLabel
        NSLayoutConstraint.activate([
            displayFullNameLabel.centerYAnchor.constraint(equalTo: iconView.centerYAnchor),
            displayFullNameLabel.heightAnchor.constraint(equalTo: iconView.heightAnchor),
            displayFullNameLabel.leadingAnchor.constraint(equalTo: iconView.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori)
        ])
        
        // chevronImageView
        chevronLeadingConstraint = GeneralLayoutConstraint(chevronImageView.leadingAnchor.constraint(equalTo: displayFullNameLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori))
        chevronTrailingConstraint = GeneralLayoutConstraint(containerView.trailingAnchor.constraint(equalTo: chevronImageView.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori))
        NSLayoutConstraint.activate([
            chevronLeadingConstraint.constraint,
            chevronTrailingConstraint.constraint,
            chevronImageView.centerYAnchor.constraint(equalTo: containerView.centerYAnchor),
            chevronImageView.createAspectRatio(Constant.Constraint.Button.chevronAspectRatio),
            chevronImageView.createHeightMultiplier(Constant.Constraint.Button.chevronHeightMultiplier, relativeToWidthOf: contentView),
            chevronImageView.createMaxHeight(Constant.Constraint.Button.chevronMaxHeight)
        ])
    }

}
//
//  SettingsAccountVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/16/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol SettingsAccountVCDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
}

final class SettingsAccountVC: HoundScrollViewController {
    
    // MARK: - Elements
    
    private let pageHeaderView: HoundPageSheetHeaderView = {
        let view = HoundPageSheetHeaderView(huggingPriority: 360, compressionResistancePriority: 360)
        view.pageHeaderLabel.text = "Account"
        return view
    }()
    
    private let userNameHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 350, compressionResistancePriority: 350)
        label.text = "Name"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let userNameLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 340, compressionResistancePriority: 340)
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    private let userEmailHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 320, compressionResistancePriority: 320)
        label.text = "Email"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let userEmailLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 310, compressionResistancePriority: 310)
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    private lazy var copyUserEmailButton: HoundButton = {
        let button = HoundButton(huggingPriority: 330, compressionResistancePriority: 330)
        
        button.setImage(UIImage(systemName: "doc.on.clipboard"), for: .normal)
        
        button.addTarget(self, action: #selector(didTapCopyUserEmail), for: .touchUpInside)
        
        return button
    }()
    
    @objc private func didTapCopyUserEmail(_ sender: Any) {
        guard let userEmail = UserInformation.userEmail else { return }
        
        UIPasteboard.general.setPasteboard(string: userEmail)
    }
    
    private let userIdHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Support ID"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private let userIdLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    private lazy var copyUserIdButton: HoundButton = {
        let button = HoundButton(huggingPriority: 300, compressionResistancePriority: 300)
        
        button.setImage(UIImage(systemName: "doc.on.clipboard"), for: .normal)
        
        button.addTarget(self, action: #selector(didTapCopyUserId), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var redownloadDataButton: HoundButton = {
        let button = HoundButton(huggingPriority: 270, compressionResistancePriority: 270)
       
        button.setTitle("Redownload Data", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        button.addTarget(self, action: #selector(didTapRedownloadData), for: .touchUpInside)
        
        return button
    }()
    
    private let redownloadDataDescriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 260, compressionResistancePriority: 260)
        label.text = "Deletes local storage of all dogs, reminders, logs, and automations to fully redownload them from the Hound server, ensuring that the data displayed locally reflects the data stored server-side."
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = UIColor.secondaryLabel
        
        return label
    }()
    
    private lazy var signOutButton: HoundButton = {
        let button = HoundButton(huggingPriority: 265, compressionResistancePriority: 265)
        
        button.setTitle("Sign Out", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        button.addTarget(self, action: #selector(didTapSignOut), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var deleteAccountButton: HoundButton = {
        let button = HoundButton(huggingPriority: 270, compressionResistancePriority: 270)
        
        button.setTitle("Delete Account", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemRed
        
        button.shouldRoundCorners = true
        
        button.addTarget(self, action: #selector(didTapDeleteAccount), for: .touchUpInside)
        
        return button
    }()
    
    @objc private func didTapCopyUserId(_ sender: Any) {
        guard let userId = UserInformation.userId else { return }
        
        UIPasteboard.general.setPasteboard(string: userId)
    }
    
    @objc private func didTapRedownloadData(_ sender: Any) {
        PresentationManager.beginFetchingInformationIndicator()
        
        // store the date of our old sync if the request fails (as we will be overriding the typical way of doing it)
        let currentUserConfigurationPreviousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization
        // manually set previousDogManagerSynchronization to default value so we will retrieve everything from the server
        LocalConfiguration.previousDogManagerSynchronization = nil
        redownloadDataButton.isLoading = true
        
        DogsRequest.get(errorAlert: .automaticallyAlertOnlyForFailure, dogManager: DogManager()) { dogManager, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                self.redownloadDataButton.isLoading = false
                guard responseStatus != .failureResponse, let dogManager = dogManager else {
                    // Revert previousDogManagerSynchronization previous value. This is necessary as we circumvented the DogsRequest automatic handling of it to allow us to retrieve all entries.
                    LocalConfiguration.previousDogManagerSynchronization = currentUserConfigurationPreviousDogManagerSynchronization
                    return
                }
                
                if responseStatus == .successResponse {
                    PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.successRedownloadDataTitle, subtitle: Constant.Visual.BannerText.successRedownloadDataSubtitle, style: .success)
                }
                else {
                    if OfflineModeManager.shared.hasDisplayedOfflineModeBanner == true {
                        // If OfflineModeManager has displayed its banner that indicates its turning on, then we are safe to display this banner. Otherwise, we would run the risk of both of these banners displaying if its the first time enterin offline mode.
                        PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.infoRedownloadOnHoldTitle, subtitle: Constant.Visual.BannerText.infoRedownloadOnHoldSubtitle, style: .info)
                    }
                }
                
                // successful query to fully redownload the dogManager, no need to mess with previousDogManagerSynchronization as that is automatically handled
                self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: dogManager)
            }
        }
    }
    
    @objc private func didTapSignOut(_ sender: Any) {
        
        let signOutAlertController = UIAlertController(title: "Are you sure you want to sign out?", message: nil, preferredStyle: .alert)
        
        let signOutAlertAction = UIAlertAction(title: "Sign Out", style: .default) { _ in
            PersistenceManager.clearStorageToReloginToAccount()
            self.dismissToViewController(ofClass: ServerSyncVC.self, completionHandler: nil)
        }
        signOutAlertController.addAction(signOutAlertAction)
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
        signOutAlertController.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(signOutAlertController)
    }
    
    @objc private func didTapDeleteAccount(_ sender: Any) {
        
        let deleteAccountAlertController = UIAlertController(title: "Are you sure you want to delete your account?", message: nil, preferredStyle: .alert)
        
        let deleteAlertAction = UIAlertAction(title: "Delete Account", style: .destructive) { _ in
            PresentationManager.beginFetchingInformationIndicator()
            self.deleteAccountButton.isLoading = true
            
            UserRequest.delete(errorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                PresentationManager.endFetchingInformationIndicator {
                    self.deleteAccountButton.isLoading = false
                    guard responseStatus == .successResponse else {
                        return
                    }
                    
                    // family was successfully deleted, revert to server sync view controller
                    self.dismissToViewController(ofClass: ServerSyncVC.self, completionHandler: nil)
                }
            }
        }
        deleteAccountAlertController.addAction(deleteAlertAction)
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
        deleteAccountAlertController.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(deleteAccountAlertController)
    }
    
    // MARK: - Properties
    
    private weak var delegate: SettingsAccountVCDelegate?
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
       
        userNameLabel.text = UserInformation.displayFullName
        
        userEmailLabel.text = UserInformation.userEmail ?? Constant.Visual.Text.unknownEmail
        copyUserEmailButton.isEnabled = UserInformation.userEmail != nil
        
        userIdLabel.text = UserInformation.userId ?? Constant.Visual.Text.unknownUserId
        copyUserIdButton.isEnabled = UserInformation.userId != nil
    }
    
    // MARK: - Setup
    
    func setup(delegate: SettingsAccountVCDelegate) {
        self.delegate = delegate
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(userNameHeaderLabel)
        containerView.addSubview(userNameLabel)
        containerView.addSubview(userEmailHeaderLabel)
        containerView.addSubview(redownloadDataButton)
        containerView.addSubview(redownloadDataDescriptionLabel)
        containerView.addSubview(userEmailLabel)
        containerView.addSubview(userIdHeaderLabel)
        containerView.addSubview(userIdLabel)
        containerView.addSubview(copyUserIdButton)
        containerView.addSubview(copyUserEmailButton)
        containerView.addSubview(signOutButton)
        containerView.addSubview(deleteAccountButton)
        containerView.addSubview(pageHeaderView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pageHeaderView
        NSLayoutConstraint.activate([
            pageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            pageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            pageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // userNameHeaderLabel
        NSLayoutConstraint.activate([
            userNameHeaderLabel.topAnchor.constraint(equalTo: pageHeaderView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            userNameHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            userNameHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            userNameHeaderLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            userNameHeaderLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view)
        ])
        
        // userNameLabel
        NSLayoutConstraint.activate([
            userNameLabel.topAnchor.constraint(equalTo: userNameHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            userNameLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            userNameLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // userEmailHeaderLabel
        NSLayoutConstraint.activate([
            userEmailHeaderLabel.topAnchor.constraint(equalTo: userNameLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            userEmailHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            userEmailHeaderLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            userEmailHeaderLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view)
        ])
        
        // copyUserEmailButton
        NSLayoutConstraint.activate([
            copyUserEmailButton.centerYAnchor.constraint(equalTo: userEmailHeaderLabel.centerYAnchor),
            copyUserEmailButton.leadingAnchor.constraint(equalTo: userEmailHeaderLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            copyUserEmailButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -2.0 * Constant.Constraint.Spacing.absoluteHoriInset),
            copyUserEmailButton.heightAnchor.constraint(equalTo: userEmailHeaderLabel.heightAnchor, multiplier: 1.5),
            copyUserEmailButton.createSquareAspectRatio()
        ])
        
        // userEmailLabel
        NSLayoutConstraint.activate([
            userEmailLabel.topAnchor.constraint(equalTo: userEmailHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            userEmailLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            userEmailLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // userIdHeaderLabel
        NSLayoutConstraint.activate([
            userIdHeaderLabel.topAnchor.constraint(equalTo: userEmailLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            userIdHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            userIdHeaderLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            userIdHeaderLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view)
        ])
        
        // copyUserIdButton
        NSLayoutConstraint.activate([
            copyUserIdButton.centerYAnchor.constraint(equalTo: userIdHeaderLabel.centerYAnchor),
            copyUserIdButton.leadingAnchor.constraint(equalTo: userIdHeaderLabel.trailingAnchor, constant: Constant.Constraint.Spacing.contentIntraHori),
            copyUserIdButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -2.0 * Constant.Constraint.Spacing.absoluteHoriInset),
            copyUserIdButton.heightAnchor.constraint(equalTo: userIdHeaderLabel.heightAnchor, multiplier: 1.5),
            copyUserIdButton.createSquareAspectRatio()
        ])
        
        // userIdLabel
        NSLayoutConstraint.activate([
            userIdLabel.topAnchor.constraint(equalTo: userIdHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            userIdLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            userIdLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // redownloadDataButton
        NSLayoutConstraint.activate([
            redownloadDataButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            redownloadDataButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            redownloadDataButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            redownloadDataButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight),
            redownloadDataButton.topAnchor.constraint(equalTo: userIdLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert)
        ])
        
        // redownloadDataDescriptionLabel
        NSLayoutConstraint.activate([
            redownloadDataDescriptionLabel.topAnchor.constraint(equalTo: redownloadDataButton.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            redownloadDataDescriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            redownloadDataDescriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // signOutButton
        NSLayoutConstraint.activate([
            signOutButton.topAnchor.constraint(equalTo: redownloadDataDescriptionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            signOutButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            signOutButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            signOutButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            signOutButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
        
        // deleteAccountButton
        NSLayoutConstraint.activate([
            deleteAccountButton.topAnchor.constraint(equalTo: signOutButton.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            deleteAccountButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            deleteAccountButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            deleteAccountButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            deleteAccountButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            deleteAccountButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
        
    }

}
//
//  SettingsViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/5/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import StoreKit
import UIKit

protocol SettingsPagesTableVCDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
}

final class SettingsPagesTableVC: HoundTableViewController, SettingsAccountVCDelegate, FamilyUpgradeIntroductionVCDelegate {
    
    // MARK: - SettingsAccountVCDelegate
    
    func didUpdateDogManager(sender: Sender, dogManager: DogManager) {
        delegate?.didUpdateDogManager(sender: Sender(origin: sender, localized: self), dogManager: dogManager)
    }
    
    // MARK: - FamilyUpgradeIntroductionVCDelegate
    
    func didTouchUpInsideUpgrade() {
        SettingsSubscriptionVC.fetchProductsThenGetViewController { vc in
            guard let vc = vc else {
                // Error message automatically handled
                return
            }
            
            PresentationManager.enqueueViewController(vc)
        }
    }
    
    // MARK: - Properties
    
    private weak var delegate: SettingsPagesTableVCDelegate?
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        self.tableView.register(SettingsPagesTVC.self, forCellReuseIdentifier: SettingsPagesTVC.reuseIdentifier)
        self.tableView.contentInset.top = Constant.Constraint.Spacing.absoluteVertInset
        self.tableView.contentInset.bottom = Constant.Constraint.Spacing.absoluteVertInset
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        if LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController == false && FamilyInformation.familyActiveSubscription.productId == Constant.Class.Subscription.defaultSubscription.productId {
            let vc = FamilyUpgradeIntroductionVC()
            vc.setup(delegate: self)
            PresentationManager.enqueueViewController(vc)
        }
    }
    
    // MARK: - Setup
    
    func setup(delegate: SettingsPagesTableVCDelegate) {
        self.delegate = delegate
    }
    
    // MARK: - Table View Data Source
    
    override func numberOfSections(in tableView: UITableView) -> Int {
        2
    }
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        var numberOfRows = 0
        
        // We have two sections of settings pages, splitting them based upon whether they are a setting inside hound or a webpage we redirect the user two
        SettingsPages.allCases.forEach { settingsPage in
            switch settingsPage {
            case .account, .family, .subscription, .appearance, .notifications:
                numberOfRows += (section == 0 ? 1 : 0)
            case .website, .feedback, .support, .releaseNotes, .eula, .privacyPolicy, .termsAndConditions:
                numberOfRows += (section == 1 ? 1 : 0)
            }
        }
        
        return numberOfRows
    }
    
    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = HoundTableHeaderFooterView()
        
        headerView.setTitle(section == 0 ? "Preferences" : "Links")
        
        return headerView
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let settingsPage = SettingsPages.allCases[safe: (indexPath.section * 5) + indexPath.row]
        guard let settingsPage = settingsPage else {
            return HoundTableViewCell()
        }
        
        let settingsPagesTableViewCell = tableView.dequeueReusableCell(withIdentifier: SettingsPagesTVC.reuseIdentifier, for: indexPath) as? SettingsPagesTVC
        
        guard let settingsPagesTableViewCell = settingsPagesTableViewCell else {
            return HoundTableViewCell()
        }
        
        settingsPagesTableViewCell.setup(page: settingsPage)
        
        switch settingsPage {
        case .account:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .top)
        case .notifications:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .bottom)
        case .website:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .top)
        case .termsAndConditions:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .bottom)
        default:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .none)
        }
        
        return settingsPagesTableViewCell
    }
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let settingsPagesTableViewCell = tableView.cellForRow(at: indexPath) as? SettingsPagesTVC
        
        guard let settingsPagesTableViewCell = settingsPagesTableViewCell, let page = settingsPagesTableViewCell.page else { return }
        
        switch page {
        case .account:
            let vc = SettingsAccountVC()
            vc.setup(delegate: self)
            PresentationManager.enqueueViewController(vc)
        case .family:
            let vc = SettingsFamilyVC()
            PresentationManager.enqueueViewController(vc)
        case .subscription:
            SettingsSubscriptionVC.fetchProductsThenGetViewController { vc in
                guard let vc = vc else {
                    // Error message automatically handled
                    return
                }
                
                PresentationManager.enqueueViewController(vc)
            }
        case .appearance:
            let vc = SettingsAppearanceVC()
            PresentationManager.enqueueViewController(vc)
        case .notifications:
            let vc = SettingsNotifsVC()
            PresentationManager.enqueueViewController(vc)
        case .website, .support, .eula, .privacyPolicy, .termsAndConditions:
            if let url = page.url {
                UIApplication.shared.open(url)
            }
        case .feedback:
            let vc = SurveyAppExperienceVC()
            PresentationManager.enqueueViewController(vc)
        case .releaseNotes:
            let vc = ReleaseNotesVC()
            vc.setup(version: AppVersion.current)
            PresentationManager.enqueueViewController(vc)
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        tableView.backgroundColor = UIColor.secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
    }
    
    override func setupConstraints() {
        super.setupConstraints()
    }
}
//
//  HoundIntroductionDogNameView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/3/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol HoundIntroductionDogNameViewDelegate: AnyObject {
    func willContinue(dogName: String?)
}

final class HoundIntroductionDogNameView: HoundView, UITextFieldDelegate, UIGestureRecognizerDelegate {

    // MARK: - UITextFieldDelegate

    func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
        dogManager?.dogs.first == nil
    }

    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        self.dismissKeyboard()
        dogNameTextField.isEnabled = false
        continueButton.isEnabled = false
        delegate?.willContinue(dogName: inputDogName)
        return false
    }

    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        guard let currentText = textField.text, let stringRange = Range(range, in: currentText) else {
            return true
        }
        let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
        return updatedText.count <= Constant.Class.Dog.dogNameCharacterLimit
    }

    // MARK: - UIGestureRecognizerDelegate

    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }

    // MARK: - Elements

    private let introductionView = HoundIntroductionView()

    private let dogNameTextField: HoundTextField = {
        let textField = HoundTextField(huggingPriority: 350, compressionResistancePriority: 350)
        textField.placeholder = "Bella"
        textField.shouldInsetText = true
        textField.textAlignment = .center
        textField.backgroundColor = UIColor.systemBackground
        textField.applyStyle(.thinGrayBorder)
        return textField
    }()

    private let continueButton: HoundButton = {
        let button = HoundButton(huggingPriority: 290, compressionResistancePriority: 290)
        button.isEnabled = false
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        button.setTitle("Continue", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.backgroundColor = UIColor.systemBackground
        button.applyStyle(.labelBorder)
        return button
    }()

    private var mainStack: UIStackView!

    // MARK: - Properties

    private weak var delegate: HoundIntroductionDogNameViewDelegate?

    private var inputDogName: String? {
        guard dogManager?.dogs.first == nil else {
            return nil
        }
        let trimmedText = dogNameTextField.text?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        return trimmedText.isEmpty ? Constant.Class.Dog.defaultDogName : trimmedText
    }

    private var dogManager: DogManager?

    // MARK: - Setup

    func setup(delegate: HoundIntroductionDogNameViewDelegate, dogManager: DogManager) {
        self.delegate = delegate
        self.dogManager = dogManager

        dogNameTextField.delegate = self
        dogNameTextField.isEnabled = dogManager.dogs.isEmpty
        continueButton.isEnabled = true

        introductionView.backgroundImageView.image = UIImage(named: "autumnParkFamilyWithDog")

        if let dog = dogManager.dogs.first {
            introductionView.pageHeaderLabel.text = "We See You Have a Pack!"
            introductionView.pageDescriptionLabel.text = "You can manage \(dog.dogName)\(dogManager.dogs.count > 1 ? " (and other dogs)" : "") on the next page"
            dogNameTextField.placeholder = dog.dogName
        }
        else {
            introductionView.pageHeaderLabel.text = "What Is Your Dog’s Name?"
            introductionView.pageDescriptionLabel.text = "We will generate a basic dog for you"
            dogNameTextField.placeholder = Constant.Class.Dog.defaultDogName
            dismissKeyboardOnTap(delegate: self)
        }
    }

    // MARK: - Functions

    @objc private func didTouchUpInsideContinue(_ sender: Any) {
        self.dismissKeyboard()
        dogNameTextField.isEnabled = false
        continueButton.isEnabled = false
        delegate?.willContinue(dogName: inputDogName)
    }

    // MARK: - Setup Elements

    override func setupGeneratedViews() {
        self.backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        addSubview(introductionView)

        mainStack = UIStackView(arrangedSubviews: [dogNameTextField, continueButton])
        mainStack.axis = .vertical
        mainStack.spacing = Constant.Constraint.Spacing.contentSectionVert
        mainStack.translatesAutoresizingMaskIntoConstraints = false

        introductionView.contentView.addSubview(mainStack)

        continueButton.addTarget(self, action: #selector(didTouchUpInsideContinue), for: .touchUpInside)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: bottomAnchor),

            mainStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            mainStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            mainStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            mainStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor),
            
            dogNameTextField.heightAnchor.constraint(equalTo: continueButton.heightAnchor),

            continueButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: self),
            continueButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }
}
//
//  HoundIntroductionDogIconView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol HoundIntroductionDogIconViewDelegate: AnyObject {
    func willFinish(dogIcon: UIImage?)
}

final class HoundIntroductionDogIconView: HoundView, UIImagePickerControllerDelegate, UINavigationControllerDelegate {

    // MARK: - UIImagePickerControllerDelegate

    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
        if let dogIcon = DogIconManager.processDogIcon(info: info) {
            dogIconButton.setTitle(nil, for: .normal)
            dogIconButton.setImage(dogIcon, for: .normal)
        }
        picker.dismiss(animated: true)
    }

    // MARK: - Elements

    private let introductionView = HoundIntroductionView()

    private let dogIconButton: HoundButton = {
        let button = HoundButton(huggingPriority: 230, compressionResistancePriority: 230)
        button.setTitle("Choose", for: .normal)
        button.setTitleColor(.placeholderText, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.circleButton
        button.backgroundColor = UIColor.systemBackground
        button.applyStyle(.thinGrayBorder)
        return button
    }()

    private let finishButton: HoundButton = {
        let button = HoundButton(huggingPriority: 290, compressionResistancePriority: 290)
        button.setTitle("Finish", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        button.backgroundColor = UIColor.systemBackground
         button.applyStyle(.labelBorder)
        return button
    }()

    private var mainStack: UIStackView!

    // MARK: - Properties

    private weak var delegate: HoundIntroductionDogIconViewDelegate?

    private var dogIcon: UIImage? {
        dogIconButton.imageView?.image
    }

    // MARK: - Setup

    func setup(delegate: HoundIntroductionDogIconViewDelegate, dogName: String) {
        self.delegate = delegate

        introductionView.backgroundImageView.image = UIImage(named: "blueShorelineManThrowingStickForDog")
        introductionView.pageHeaderLabel.text = "Select an Icon For \(dogName)"
        introductionView.pageDescriptionLabel.text = "It's optional, but adding a cute picture for them is a wonderful choice"

        dogIconButton.isEnabled = true
        finishButton.isEnabled = true

        DogIconManager.didSelectDogIconController.delegate = self
    }

    // MARK: - Functions

    @objc private func didTouchUpInsideDogIcon(_ sender: Any) {
        PresentationManager.enqueueActionSheet(DogIconManager.openCameraOrGalleryForDogIconActionSheet, sourceView: dogIconButton)
    }

    @objc private func didTouchUpInsideFinish(_ sender: Any) {
        dogIconButton.isEnabled = false
        finishButton.isEnabled = false
        delegate?.willFinish(dogIcon: dogIcon)
    }

    // MARK: - Setup Elements

    override func setupGeneratedViews() {
        backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        addSubview(introductionView)

        mainStack = UIStackView(arrangedSubviews: [dogIconButton, finishButton])
        mainStack.axis = .vertical
        mainStack.spacing = Constant.Constraint.Spacing.contentSectionVert
        mainStack.alignment = .center
        mainStack.translatesAutoresizingMaskIntoConstraints = false

        introductionView.contentView.addSubview(mainStack)

        dogIconButton.addTarget(self, action: #selector(didTouchUpInsideDogIcon), for: .touchUpInside)
        finishButton.addTarget(self, action: #selector(didTouchUpInsideFinish), for: .touchUpInside)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: bottomAnchor),

            mainStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            mainStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            mainStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            mainStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor),

            dogIconButton.createSquareAspectRatio(),
            dogIconButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier * 1.25, relativeToWidthOf: self),
            dogIconButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight * 1.25),

            finishButton.leadingAnchor.constraint(equalTo: mainStack.leadingAnchor),
            finishButton.trailingAnchor.constraint(equalTo: mainStack.trailingAnchor),
            finishButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: self),
            finishButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }
}
//
//  HoundIntroductionVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/26/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class HoundIntroductionVC: HoundViewController,
                                             UIScrollViewDelegate,
                                             HoundIntroductionDogNameViewDelegate,
                                             HoundIntroductionDogIconViewDelegate {
    
    // MARK: - Elements
    
    private let scrollView: HoundScrollView = {
        let scrollView = HoundScrollView()
        scrollView.isPagingEnabled = true
        scrollView.isScrollEnabled = false
        return scrollView
    }()
    
    private let dogNamePage: HoundIntroductionDogNameView = {
        let page = HoundIntroductionDogNameView(frame: .zero)
        return page
    }()
    
    private let dogIconPage: HoundIntroductionDogIconView = {
        let page = HoundIntroductionDogIconView(frame: .zero)
        return page
    }()
    
    // MARK: - Properties
    
    private var didSetupCustomSubviews: Bool = false
    private var pages: [UIView] { [dogNamePage, dogIconPage] }
    private var currentPageIndex: Int = 0
    
    private enum PageDirection {
        case next
        case previous
    }
    
    /// The dogName that was entered by the user on dogNamePage. nil if the family already had a dog and the user wasn't allowed to input a dogName
    private var dogNameInput: String?
    /// The dogIcon that was entered by the user on dogIconPage. nil if user didn't input a dogIcon
    private var dogIconInput: UIImage?
    
    // MARK: Dog Manager
    
    private var dogManager: DogManager = DogManager.globalDogManager ?? DogManager()
    
    func setDogManager(sender: Sender, dogManager: DogManager) {
        self.dogManager = dogManager
    }
    
    // MARK: - HoundIntroductionDogNameViewDelegate
    
    func willContinue(dogName: String?) {
        // Store the entered dog name
        self.dogNameInput = dogName
        
        // Configure the dogIconPage for the next step
        let defaultName = dogManager.dogs.first?.dogName ?? Constant.Class.Dog.defaultDogName
        let nameToUse = dogName ?? defaultName
        dogIconPage.setup(delegate: self, dogName: nameToUse)
        
        // Advance the scroll view to the next page
        goToPage(pageDirection: .next, animated: true)
    }
    
    // MARK: - HoundIntroductionDogIconViewDelegate
    
    func willFinish(dogIcon: UIImage?) {
        self.dogIconInput = dogIcon
        
        // If the family already has at least one dog, simply update its icon
        if let existingDog = dogManager.dogs.first {
            existingDog.dogIcon = self.dogIconInput
            
            // Persist the new dog icon locally
            if let icon = existingDog.dogIcon {
                DogIconManager.addIcon(dogUUID: existingDog.dogUUID, dogIcon: icon)
            }
            
            // Manually present MainTabBarController
            let mainTabBarController = MainTabBarController()
            mainTabBarController.setDogManager(sender: Sender(origin: self, localized: self),
                                               dogManager: dogManager)
            PresentationManager.enqueueViewController(mainTabBarController)
            
        }
        else {
            // No dogs exist yet: create a new Dog object and send request
            let newDog = Dog()
            newDog.changeDogName(dogName: dogNameInput ?? Constant.Class.Dog.defaultDogName)
            newDog.dogIcon = dogIconInput
            
            PresentationManager.beginFetchingInformationIndicator()
            DogsRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dog: newDog) { responseStatus, _ in
                PresentationManager.endFetchingInformationIndicator {
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    
                    // Add the newly created dog to our local manager
                    self.dogManager.addDog(dog: newDog)
                    
                    // Manually present MainTabBarController
                    let mainTabBarController = MainTabBarController()
                    mainTabBarController.setDogManager(sender: Sender(origin: self, localized: self),
                                                       dogManager: self.dogManager)
                    PresentationManager.enqueueViewController(mainTabBarController)
                }
            }
        }
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        scrollView.delegate = self
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard didSetupCustomSubviews == false else { return }
        
        didSetupCustomSubviews = true
        
        dogNamePage.setup(delegate: self, dogManager: dogManager)
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        // Mark the introduction as completed locally
        LocalConfiguration.localHasCompletedHoundIntroductionViewController = true
    }
    
    // MARK: - Functions
    
    private func goToPage(pageDirection: PageDirection, animated: Bool) {
        let delta = (pageDirection == .next ? 1 : -1)
        let targetIndex = min(max(currentPageIndex + delta, 0), pages.count - 1)
        currentPageIndex = targetIndex
        
        let offset = CGPoint(
            x: scrollView.frame.width * CGFloat(targetIndex),
            y: 0
        )
        scrollView.isScrollEnabled = true
        scrollView.setContentOffset(offset, animated: animated)
        scrollView.isScrollEnabled = false
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        pages.forEach { scrollView.addSubview($0) }
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // scrollView
        let scrollViewTop = scrollView.topAnchor.constraint(equalTo: view.topAnchor)
        let scrollViewBottom = scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        let scrollViewLeading = scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor)
        let scrollViewTrailing = scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        
        // dogNamePage
        let dogNamePageTop = dogNamePage.topAnchor.constraint(equalTo: scrollView.contentLayoutGuide.topAnchor)
        let dogNamePageBottom = dogNamePage.bottomAnchor.constraint(equalTo: scrollView.contentLayoutGuide.bottomAnchor)
        let dogNamePageLeading = dogNamePage.leadingAnchor.constraint(equalTo: scrollView.contentLayoutGuide.leadingAnchor)
        let dogNamePageWidth = dogNamePage.widthAnchor.constraint(equalTo: scrollView.frameLayoutGuide.widthAnchor)
        let dogNamePageHeight = dogNamePage.heightAnchor.constraint(equalTo: scrollView.frameLayoutGuide.heightAnchor)

        // dogIconPage
        let dogIconPageTop = dogIconPage.topAnchor.constraint(equalTo: scrollView.contentLayoutGuide.topAnchor)
        let dogIconPageBottom = dogIconPage.bottomAnchor.constraint(equalTo: scrollView.contentLayoutGuide.bottomAnchor)
        let dogIconPageLeading = dogIconPage.leadingAnchor.constraint(equalTo: dogNamePage.trailingAnchor)
        let dogIconPageWidth = dogIconPage.widthAnchor.constraint(equalTo: scrollView.frameLayoutGuide.widthAnchor)
        let dogIconPageHeight = dogIconPage.heightAnchor.constraint(equalTo: scrollView.frameLayoutGuide.heightAnchor)
        let dogIconPageTrailing = dogIconPage.trailingAnchor.constraint(equalTo: scrollView.contentLayoutGuide.trailingAnchor)

        NSLayoutConstraint.activate([
            // scrollView
            scrollViewTop,
            scrollViewBottom,
            scrollViewLeading,
            scrollViewTrailing,

            // dogNamePage
            dogNamePageTop,
            dogNamePageBottom,
            dogNamePageLeading,
            dogNamePageWidth,
            dogNamePageHeight,

            // dogIconPage
            dogIconPageTop,
            dogIconPageBottom,
            dogIconPageLeading,
            dogIconPageWidth,
            dogIconPageHeight,
            dogIconPageTrailing
        ])
    }

}
//
//  ServerFamilyIntroductionVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/3/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol ServerFamilyIntroductionVCDelegate: AnyObject {
    /// Invoked by FamilyRequest completionHandler either when successfully created or joined a family. If this function is invoked, this view has completed
    func didCreateOrJoinFamily()
}

final class ServerFamilyIntroductionVC: HoundViewController, UITextFieldDelegate {
    
    // MARK: - UITextFieldDelegate
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn newRange: NSRange, replacementString newString: String) -> Bool {
        // attempt to read the range they are trying to change
        guard let previousText = textField.text, let newStringRange = Range(newRange, in: previousText) else {
            return true
        }
        
        // add their newString in the newRange to the previousText and uppercase it all
        var uppercasedUpdatedText = previousText
            .replacingCharacters(in: newStringRange, with: newString)
            .uppercased()
        
        // The user can delete whatever they want. We only want to check when they add a character
        guard uppercasedUpdatedText.count > previousText.count else {
            // The user deleted a character. Therefore, the join button should always be disabled as code can't exceed length of 8
            familyCodeJoinAction?.isEnabled = uppercasedUpdatedText.replacingOccurrences(of: "-", with: "").count == familyCodeWithoutDashLength
            return true
        }
        
        // MARK: Verify new character is a valid character
        // A family code input can only contain the alphabet, numbers, and a dash (exclude 0, O, I, L). We automatically convert lowercase to uppercase.
        let acceptableCharacters = "ABCDEFGHJKMNPQRSTUVWXYZ123456789-"
        var containsInvalidCharacter = false
        uppercasedUpdatedText.forEach { character in
            if acceptableCharacters.firstIndex(of: character) == nil {
                containsInvalidCharacter = true
            }
        }
        guard !containsInvalidCharacter else {
            return false
        }
        
        // MARK: Verify dash (-) placement and count
        // If uppercasedUpdatedText has a dash and previousText doesn't have a dash, the user added a dash.
        if let dashIndexInNew = uppercasedUpdatedText.firstIndex(of: "-"),
           previousText.firstIndex(of: "-") == nil {
            let indexOfAddedDash = uppercasedUpdatedText.distance(from: uppercasedUpdatedText.startIndex, to: dashIndexInNew)
            // If the dash isn't exactly in index 4, reject the change
            if indexOfAddedDash != 4 {
                return false
            }
        }
        // If the previousText's first dash and uppercasedUpdatedText's last dash are in different indices, then the user is trying to add another dash
        else if previousText.firstIndex(of: "-") != uppercasedUpdatedText.lastIndex(of: "-") {
            return false
        }
        // If uppercasedUpdatedText doesn't have a dash and its length is ≥ 4, insert a dash at position 4
        else if uppercasedUpdatedText.firstIndex(of: "-") == nil && uppercasedUpdatedText.count >= 4 {
            let dashIndexPosition = uppercasedUpdatedText.index(uppercasedUpdatedText.startIndex, offsetBy: 4)
            uppercasedUpdatedText.insert("-", at: dashIndexPosition)
        }
        
        // MARK: Verify length
        if uppercasedUpdatedText.replacingOccurrences(of: "-", with: "").count > familyCodeWithoutDashLength {
            return false
        }
        
        // MARK: Check family code completion
        // To reach this point, the updated text only contains valid characters at valid positions
        familyCodeJoinAction?.isEnabled = uppercasedUpdatedText.replacingOccurrences(of: "-", with: "").count == familyCodeWithoutDashLength
        
        // Update the text field's text
        textField.text = uppercasedUpdatedText
        
        // Return false because we manually set the text field's text
        return false
    }
    
    // MARK: - Elements
    
    private let introductionView = HoundIntroductionView()
    
    private lazy var createFamilyButton: HoundButton = {
        let button = HoundButton()
        
        button.setTitle("Create", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        button.addTarget(self, action: #selector(willCreateFamily), for: .touchUpInside)
        
        return button
    }()
    
    private let subDescriptionLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "As the head of your own Hound family, you'll manage its members and any in-app purchases."
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.tertiaryColorDescLabel
        label.textColor = UIColor.tertiaryLabel
        return label
    }()
    
    private lazy var joinFamilyButton: HoundButton = {
        let button = HoundButton()
        
        button.setTitle("Join", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        button.addTarget(self, action: #selector(willJoinFamily), for: .touchUpInside)
        
        return button
    }()
    
    /// Stack view containing createFamilyButton and subDescriptionLabel
    private var createStack: UIStackView!
    
    /// Stack view containing both the createStack and joinFamilyButton
    private var mainStack: UIStackView!
    
    // MARK: - Properties
    
    private weak var delegate: ServerFamilyIntroductionVCDelegate?
    
    /// Keep track of this alert action so we can later reference it to enable and disable it
    private var familyCodeJoinAction: UIAlertAction?
    
    /// A family's join code is eight characters long
    private let familyCodeWithoutDashLength = 8
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        introductionView.backgroundImageView.image = UIImage(named: "lightBeachFamilyPicnicWithDog")
        
        introductionView.pageHeaderLabel.text = "Family"
        
        introductionView.pageDescriptionLabel.text = "To use Hound, you must create or join a family. Families allow multiple users to collaborate on their dogs' care."
    }
    
    // MARK: - Setup
    
    func setup(delegate: ServerFamilyIntroductionVCDelegate) {
        self.delegate = delegate
    }
    
    // MARK: - Functions
    
    @objc private func willCreateFamily(_ sender: Any) {
        PresentationManager.beginFetchingInformationIndicator()
        FamilyRequest.create(errorAlert: .automaticallyAlertForNone) { responseStatus, houndError in
            PresentationManager.endFetchingInformationIndicator {
                // The user is already in a family so can't create a new one
                if houndError?.name == Constant.Error.FamilyResponseError.joinInFamilyAlready(requestId: -1, responseId: -1).name {
                    self.dismiss(animated: true, completion: nil)
                    return
                }
                
                guard responseStatus == .successResponse else {
                    // Manually alert because we want to intercept the possible joinInFamilyAlready error
                    houndError?.alert()
                    return
                }
                
                self.delegate?.didCreateOrJoinFamily()
                self.dismiss(animated: true, completion: nil)
            }
        }
    }
    
    @objc private func willJoinFamily(_ sender: Any) {
        let familyCodeAlertController = UIAlertController(
            title: "Join a Family",
            message: "The code is case-insensitive",
            preferredStyle: .alert
        )
        familyCodeAlertController.addTextField { textField in
            textField.placeholder = "Enter a family code..."
            textField.autocapitalizationType = .allCharacters
            textField.delegate = self
            textField.returnKeyType = .done
            textField.enablesReturnKeyAutomatically = true
        }
        let joinAction = UIAlertAction(title: "Join", style: .default) { [weak familyCodeAlertController] _ in
            guard let textField = familyCodeAlertController?.textFields?.first else { return }
            
            // Uppercase everything then strip dashes, whitespace, newlines
            let familyCode = (textField.text ?? "")
                .uppercased()
                .replacingOccurrences(of: "-", with: "")
                .trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Code is empty
            if familyCode.isEmpty {
                Constant.Error.FamilyRequestError.familyCodeBlank().alert()
            }
            // Code isn't long enough
            else if familyCode.count != self.familyCodeWithoutDashLength {
                Constant.Error.FamilyRequestError.familyCodeInvalid().alert()
            }
            // Client-side code is OK
            else {
                PresentationManager.beginFetchingInformationIndicator()
                FamilyRequest.update(
                    errorAlert: .automaticallyAlertForNone,
                    body: [Constant.Key.familyCode.rawValue: .string(familyCode)]
                ) { responseStatus, houndError in
                    PresentationManager.endFetchingInformationIndicator {
                        // Already in a family
                        if houndError?.name == Constant.Error.FamilyResponseError.joinInFamilyAlready(requestId: -1, responseId: -1).name {
                            self.dismiss(animated: true, completion: nil)
                            return
                        }
                        // Family limit too low
                        if houndError?.name == Constant.Error.FamilyResponseError.limitFamilyMemberTooLow(requestId: -1, responseId: -1).name {
                            let vc = LimitTooLowViewController()
                            PresentationManager.enqueueViewController(vc)
                            return
                        }
                        guard responseStatus == .successResponse else {
                            // Manually alert for all other errors
                            houndError?.alert()
                            return
                        }
                        self.delegate?.didCreateOrJoinFamily()
                        self.dismiss(animated: true, completion: nil)
                    }
                }
            }
        }
        joinAction.isEnabled = false
        familyCodeJoinAction = joinAction
        
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        familyCodeAlertController.addAction(joinAction)
        familyCodeAlertController.addAction(cancelAction)
        
        PresentationManager.enqueueAlert(familyCodeAlertController)
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        
        view.addSubview(introductionView)
        
        createStack = UIStackView(arrangedSubviews: [createFamilyButton, subDescriptionLabel])
        createStack.axis = .vertical
        createStack.alignment = .center
        createStack.distribution = .fill
        createStack.spacing = Constant.Constraint.Spacing.contentIntraVert
        createStack.translatesAutoresizingMaskIntoConstraints = false
        
        mainStack = UIStackView(arrangedSubviews: [createStack, joinFamilyButton])
        mainStack.axis = .vertical
        mainStack.alignment = .center
        mainStack.distribution = .fill
        mainStack.spacing = 30
        mainStack.translatesAutoresizingMaskIntoConstraints = false
        
        introductionView.contentView.addSubview(mainStack)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // introductionView
        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: view.topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
        
        // mainStack
        NSLayoutConstraint.activate([
            mainStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            mainStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            mainStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            mainStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor)
        ])
        
        // createFamilyButton
        NSLayoutConstraint.activate([
            createFamilyButton.widthAnchor.constraint(equalTo: mainStack.widthAnchor),
            createFamilyButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            createFamilyButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
        
        // subDescriptionLabel
        NSLayoutConstraint.activate([
            subDescriptionLabel.widthAnchor.constraint(equalTo: mainStack.widthAnchor)
        ])
        
        // joinFamilyButton
        NSLayoutConstraint.activate([
            joinFamilyButton.widthAnchor.constraint(equalTo: mainStack.widthAnchor),
            joinFamilyButton.heightAnchor.constraint(equalTo: createFamilyButton.heightAnchor)
        ])
    }
}
//
//  RemindersIntroductionVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/6/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol RemindersIntroductionVCDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
}

final class RemindersIntroductionVC: HoundViewController {
    
    // MARK: - Elements

    private let introductionView = HoundIntroductionView()

    private lazy var setUpRemindersButton: HoundButton = {
        let button = HoundButton(huggingPriority: 270, compressionResistancePriority: 270)

        button.setTitle("Set Up Reminders", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        button.backgroundColor = UIColor.systemBlue
        button.shouldRoundCorners = true
        button.addTarget(self, action: #selector(didTouchUpInsideSetUpReminders), for: .touchUpInside)

        return button
    }()

    private lazy var maybeLaterButton: HoundButton = {
        let button = HoundButton(huggingPriority: 260, compressionResistancePriority: 260)

        button.setTitle("Maybe Later", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        button.backgroundColor = UIColor.systemBackground
        button.applyStyle(.labelBorder)
        button.addTarget(self, action: #selector(didTouchUpInsideMaybeLater), for: .touchUpInside)

        return button
    }()

    /// Stack view containing the two buttons
    private var buttonStack: UIStackView!

    // MARK: - Properties

    private weak var delegate: RemindersIntroductionVCDelegate?
    private var dogManager = DogManager()

    // MARK: - Main

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true

        introductionView.backgroundImageView.image = UIImage(named: "creamBackyardCoupleTeachingDogTrick")
        introductionView.pageHeaderLabel.text = "Reminders"
        introductionView.pageDescriptionLabel.text = "We'll create reminders (and automations) that are useful for most dogs. Do you want to use them?"
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        LocalConfiguration.localHasCompletedRemindersIntroductionViewController = true
    }

    // MARK: - Setup

    func setup(delegate: RemindersIntroductionVCDelegate, dogManager: DogManager) {
        self.delegate = delegate
        self.dogManager = dogManager
    }

    // MARK: - Functions

    @objc private func didTouchUpInsideSetUpReminders(_ sender: Any) {
        setUpRemindersButton.isEnabled = false
        maybeLaterButton.isEnabled = false

        NotificationPermissionsManager.requestNotificationAuthorization(shouldAdviseUserBeforeRequestingNotifications: true) {
            guard let dog = self.dogManager.dogs.first else {
                self.dismiss(animated: true, completion: nil)
                return
            }

            let reminders = Constant.Class.Reminder.defaultReminders
            let triggers = Constant.Class.Trigger.defaultTriggers
            PresentationManager.beginFetchingInformationIndicator()

            let numTasks = (reminders.isEmpty ? 0 : 1) + (triggers.isEmpty ? 0 : 1)
            guard numTasks > 0 else {
                PresentationManager.endFetchingInformationIndicator {
                    self.dismiss(animated: true, completion: nil)
                }
                return
            }

            let completionTracker = CompletionTracker(numberOfTasks: numTasks) {
                // do nothing when an individual task completes
            } completedAllTasksCompletionHandler: {
                PresentationManager.endFetchingInformationIndicator {
                    dog.dogReminders.addReminders(reminders: reminders)
                    dog.dogTriggers.addTriggers(dogTriggers: triggers)
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    self.dismiss(animated: true, completion: nil)
                }
            } failedTaskCompletionHandler: {
                PresentationManager.endFetchingInformationIndicator {
                    self.setUpRemindersButton.isEnabled = true
                    self.maybeLaterButton.isEnabled = true
                }
            }

            if !reminders.isEmpty {
                RemindersRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, reminders: reminders) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    completionTracker.completedTask()
                }
            }
            if !triggers.isEmpty {
                TriggersRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, dogTriggers: triggers) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    completionTracker.completedTask()
                }
            }
        }
    }

    @objc private func didTouchUpInsideMaybeLater(_ sender: Any) {
        setUpRemindersButton.isEnabled = false
        maybeLaterButton.isEnabled = false

        NotificationPermissionsManager.requestNotificationAuthorization(shouldAdviseUserBeforeRequestingNotifications: true) {
            self.dismiss(animated: true, completion: nil)
        }
    }

    // MARK: - Setup Elements

    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(introductionView)

        buttonStack = UIStackView(arrangedSubviews: [setUpRemindersButton, maybeLaterButton])
        buttonStack.axis = .vertical
        buttonStack.spacing = Constant.Constraint.Spacing.contentSectionVert
        buttonStack.translatesAutoresizingMaskIntoConstraints = false

        introductionView.contentView.addSubview(buttonStack)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: view.topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: view.bottomAnchor),

            buttonStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            buttonStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            buttonStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            buttonStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor),

            setUpRemindersButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            setUpRemindersButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight),

            maybeLaterButton.heightAnchor.constraint(equalTo: setUpRemindersButton.heightAnchor)
        ])
    }
}
//
//  FamilyUpgradeIntroductionVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/15/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import KeychainSwift
import UIKit

protocol FamilyUpgradeIntroductionVCDelegate: AnyObject {
    func didTouchUpInsideUpgrade()
}

final class FamilyUpgradeIntroductionVC: HoundViewController {

    // MARK: - Elements

    private let introductionView = HoundIntroductionView()

    private lazy var upgradeButton: HoundButton = {
        let button = HoundButton(huggingPriority: 270, compressionResistancePriority: 270)
        button.setTitle(self.userPurchasedProductFromSubscriptionGroup20965379 ? "Upgrade" : "Start Free Trial", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        button.backgroundColor = UIColor.systemBlue
        button.shouldRoundCorners = true
        button.addTarget(self, action: #selector(didTouchUpInsideUpgrade), for: .touchUpInside)
        return button
    }()

    private lazy var maybeLaterButton: HoundButton = {
        let button = HoundButton(huggingPriority: 260, compressionResistancePriority: 260)
        button.setTitle("Maybe Later", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        button.backgroundColor = UIColor.systemBackground
        button.applyStyle(.labelBorder)
        button.shouldDismissParentViewController = true
        return button
    }()

    /// Stack view containing both buttons
    private var buttonStack: UIStackView!

    // MARK: - Properties

    private weak var delegate: FamilyUpgradeIntroductionVCDelegate?

    private var userPurchasedProductFromSubscriptionGroup20965379: Bool {
        KeychainSwift().getBool(Constant.Key.userPurchasedProductFromSubscriptionGroup20965379.rawValue) ?? false
    }

    // MARK: - Main

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true

        introductionView.backgroundImageView.image = UIImage(named: "darkGreenForestWithMountainsFamilyWalkingDog")
        introductionView.pageHeaderLabel.text = "Family"

        introductionView.pageDescriptionLabel.attributedText = {
            let message: NSMutableAttributedString = NSMutableAttributedString(
                string: "No need to go it alone! Grow your Hound family to ",
                attributes: [.font: Constant.Visual.Font.primaryRegularLabel])

            message.append(NSAttributedString(
                string: "six members",
                attributes: [.font: Constant.Visual.Font.emphasizedPrimaryRegularLabel]))

            message.append(NSAttributedString(
                string: " with Hound+. ",
                attributes: [.font: Constant.Visual.Font.primaryRegularLabel]))

            if self.userPurchasedProductFromSubscriptionGroup20965379 == false {
                message.append(NSAttributedString(
                    string: "Try it out today with a one week free trial.",
                    attributes: [.font: Constant.Visual.Font.primaryRegularLabel]))
            }

            return message
        }()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController = true
    }

    // MARK: - Setup

    func setup(delegate: FamilyUpgradeIntroductionVCDelegate) {
        self.delegate = delegate
    }

    // MARK: - Functions

    @objc private func didTouchUpInsideUpgrade(_ sender: Any) {
        self.dismiss(animated: true) {
            self.delegate?.didTouchUpInsideUpgrade()
        }
    }

    // MARK: - Setup Elements

    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(introductionView)

        buttonStack = UIStackView(arrangedSubviews: [upgradeButton, maybeLaterButton])
        buttonStack.axis = .vertical
        buttonStack.spacing = Constant.Constraint.Spacing.contentSectionVert
        buttonStack.translatesAutoresizingMaskIntoConstraints = false

        introductionView.contentView.addSubview(buttonStack)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: view.topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: view.bottomAnchor),

            buttonStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            buttonStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            buttonStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            buttonStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor),

            upgradeButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            upgradeButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight),

            maybeLaterButton.heightAnchor.constraint(equalTo: upgradeButton.heightAnchor)
        ])
    }
}
//
//  ServerLoginIntroductionVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/3/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import AuthenticationServices
import UIKit

final class ServerLoginIntroductionVC: HoundViewController,
                                       ASAuthorizationControllerDelegate,
                                       ASAuthorizationControllerPresentationContextProviding,
                                       UITextFieldDelegate {
    
    // MARK: - ASAuthorizationControllerPresentationContextProviding
    
    func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
        // Return the window into which the authorization controller should present
        return self.view.window ?? ASPresentationAnchor()
    }
    
    // MARK: - ASAuthorizationControllerDelegate
    
    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
        guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential else {
            Constant.Error.SignInWithAppleError.other().alert()
            return
        }
        
        // Persist Apple ID info (only available on first sign–in) into UserInformation & UserDefaults
        UserInformation.userIdentifier = appleIDCredential.user
        UserInformation.userEmail = appleIDCredential.email ?? UserInformation.userEmail
        UserInformation.userFirstName = appleIDCredential.fullName?.givenName ?? UserInformation.userFirstName
        UserInformation.userLastName = appleIDCredential.fullName?.familyName ?? UserInformation.userLastName
        UserInformation.persist(toUserDefaults: UserDefaults.standard)
        
        signInUser()
    }
    
    func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
        // Handle errors from Sign In with Apple
        guard let authError = error as? ASAuthorizationError else { return }
        switch authError.code {
        case .canceled:
            // The user cancelled Apple sign–in; no alert needed
            break
        case .unknown:
            Constant.Error.SignInWithAppleError.notSignedIn().alert()
        default:
            Constant.Error.SignInWithAppleError.other().alert()
        }
    }
    
    // MARK: - Elements
    
    private let introductionView = HoundIntroductionView()
    
    /// "Sign In/Up with Apple" button; its type depends on whether userIdentifier exists
    private lazy var signInWithAppleButton: ASAuthorizationAppleIDButton = {
        let buttonType: ASAuthorizationAppleIDButton.ButtonType = (UserInformation.userIdentifier != nil) ? .signIn : .signUp
        let button = ASAuthorizationAppleIDButton(type: buttonType, style: .whiteOutline)
        button.translatesAutoresizingMaskIntoConstraints = false
        button.layer.cornerRadius = CGFloat.greatestFiniteMagnitude
        button.cornerRadius = CGFloat.greatestFiniteMagnitude
        button.addTarget(self, action: #selector(didTouchUpInsideSignInWithApple), for: .touchUpInside)
        button.layer.borderWidth = HoundBorderStyle.labelBorder.borderWidth
        button.layer.borderColor = HoundBorderStyle.labelBorder.borderColor.cgColor
        return button
    }()
    
    /// Description below the Apple button
    private let signInWithAppleDescriptionLabel: HoundLabel = {
        let label = HoundLabel()
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.tertiaryColorDescLabel
        label.textColor = UIColor.tertiaryLabel
        label.textAlignment = .center
        let mode = (UserInformation.userIdentifier == nil) ? "Up" : "In"
        label.text = """
            Currently, Hound only offers accounts through the "Sign \(mode) With Apple" feature. \
            As per Apple, this requires you have an Apple ID with two‐factor authentication enabled.
            """
        return label
    }()
    
    /// Stack view containing sign-in button and description
    private var signInStack: UIStackView!
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        introductionView.backgroundImageView.image = UIImage(named: "darkTealMeadowsMenWalkingDogs")
        
        introductionView.pageHeaderLabel.text = "Welcome to Hound"
        
        if UserInformation.userIdentifier != nil {
            introductionView.pageDescriptionLabel.text = """
                Sign in to your existing Hound account below. If you don't have one, \
                creating or joining a family will come soon...
                """
        }
        else {
            introductionView.pageDescriptionLabel.text = """
                Create your Hound account below. Creating or joining a family will come soon...
                """
        }
    }
    
    // MARK: - Functions
    
    @objc private func didTouchUpInsideSignInWithApple() {
        let appleIDProvider = ASAuthorizationAppleIDProvider()
        let request = appleIDProvider.createRequest()
        request.requestedScopes = [.fullName, .email]
        
        let authorizationController = ASAuthorizationController(authorizationRequests: [request])
        authorizationController.delegate = self
        authorizationController.presentationContextProvider = self
        authorizationController.performRequests()
    }
    
    /// Kick off the user sign‐in / sign‐up flow, showing activity indicator and dismissing on success.
    private func signInUser() {
        PresentationManager.beginFetchingInformationIndicator()
        
        UserRequest.create(errorAlert: .automaticallyAlertForNone) { responseStatus, houndErrorCreate in
            guard responseStatus != .failureResponse else {
                // If creation failed, try “get” in case the account already exists:
                UserRequest.get(errorAlert: .automaticallyAlertOnlyForFailure) { responseStatus, houndErrorGet in
                    PresentationManager.endFetchingInformationIndicator {
                        guard responseStatus != .failureResponse else {
                            // Show error from GET if it failed:
                            (houndErrorGet ?? Constant.Error.GeneralResponseError.getFailureResponse(requestId: -1, responseId: -1)).alert()
                            return
                        }
                        // If GET succeeded, but userId is still missing, that’s unexpected:
                        guard UserInformation.userId != nil else {
                            (houndErrorGet ?? Constant.Error.GeneralResponseError.getNoResponse()).alert()
                            return
                        }
                        self.dismiss(animated: true, completion: nil)
                    }
                }
                return
            }
            
            // On successful create (or no‐response but userId set):
            guard UserInformation.userId != nil else {
                (houndErrorCreate ?? Constant.Error.GeneralResponseError.getNoResponse()).alert()
                return
            }
            
            // All good; dismiss:
            PresentationManager.endFetchingInformationIndicator {
                self.dismiss(animated: true, completion: nil)
            }
        }
    }

    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        
        view.addSubview(introductionView)
        
        signInStack = UIStackView(arrangedSubviews: [signInWithAppleButton, signInWithAppleDescriptionLabel])
        signInStack.axis = .vertical
        signInStack.alignment = .center
        signInStack.distribution = .fill
        signInStack.spacing = 12.5
        signInStack.translatesAutoresizingMaskIntoConstraints = false
        introductionView.contentView.addSubview(signInStack)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // introductionView
        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: view.topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
        
        // signInStack
        NSLayoutConstraint.activate([
            signInStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            signInStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            signInStack.widthAnchor.constraint(equalTo: introductionView.contentView.widthAnchor)
        ])
        
        // signInWithAppleButton
        NSLayoutConstraint.activate([
            signInWithAppleButton.widthAnchor.constraint(equalTo: introductionView.contentView.widthAnchor),
            signInWithAppleButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            signInWithAppleButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
        
        // signInWithAppleDescriptionLabel
        NSLayoutConstraint.activate([
            signInWithAppleDescriptionLabel.widthAnchor.constraint(equalTo: signInWithAppleDescriptionLabel.widthAnchor)
        ])
    }

}
//
//  ServerSyncVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/3/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

// UI VERIFIED 6/24/25
final class ServerSyncVC: HoundViewController, ServerFamilyIntroductionVCDelegate {
    
    // MARK: - ServerFamilyIntroductionVCDelegate
    
    func didCreateOrJoinFamily() {
        DogManager.globalDogManager = nil
    }
    
    // MARK: - Elements
    
    private let welcomeBackLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryHeaderLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let houndPaw: HoundPawImageView = {
        let imageView = HoundPawImageView(huggingPriority: 300, compressionResistancePriority: 300)

        return imageView
    }()
    
    private let getRequestsProgressView: HoundProgressView = {
        let progressView = HoundProgressView()
        progressView.progressTintColor = UIColor.systemBackground
        progressView.trackTintColor = UIColor.systemGray2
        return progressView
    }()
    
    private let troubleshootLoginButton: HoundButton = {
        let button = HoundButton()
        button.isHidden = true
        
        button.setTitle("Go to Login Page", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        return button
    }()
    
    @objc private func didTapTroubleshootLogin(_ sender: Any) {
        if troubleshootLoginButton.tag == Constant.Visual.ViewTag.serverSyncViewControllerRetryLogin {
            self.repeatableSetup()
        }
        else if troubleshootLoginButton.tag == Constant.Visual.ViewTag.serverSyncViewControllerGoToLoginPage {
            let vc = ServerLoginIntroductionVC()
            PresentationManager.enqueueViewController(vc)
        }
    }
    
    // MARK: - Properties
    
    /// What fraction of the loading/progress bar the types request is worth when completed
    private var getGlobalTypesProgressFractionOfWhole = (0.5 / 3.0)
    @objc private dynamic var getGlobalTypesProgress: Progress?
    private var getGlobalTypesProgressObserver: NSKeyValueObservation?
    
    /// What fraction of the loading/progress bar the user request is worth when completed
    private var getUserProgressFractionOfWhole = (0.5 / 3.0)
    @objc private dynamic var getUserProgress: Progress?
    private var getUserProgressObserver: NSKeyValueObservation?
    
    /// What fraction of the loading/progress bar the family request is worth when completed
    private var getFamilyProgressFractionOfWhole = (0.5 / 3.0)
    @objc private dynamic var getFamilyProgress: Progress?
    private var getFamilyProgressObserver: NSKeyValueObservation?
    
    /// What fraction of the loading/progress bar the dogs request is worth when completed
    private var getDogsProgressFractionOfWhole = 0.5
    @objc private dynamic var getDogsProgress: Progress?
    private var getDogsProgressObserver: NSKeyValueObservation?
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        // if no userIdentifier, then they need to sign in so don't show welcome back
        welcomeBackLabel.isHidden = UserInformation.userIdentifier == nil || (UserInformation.userFirstName == nil && UserInformation.userLastName == nil)
        welcomeBackLabel.text = "Welcome Back, \(UserInformation.userFirstName ?? UserInformation.userLastName ?? Constant.Visual.Text.unknownName)"
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        self.repeatableSetup()
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        
        // As soon as this view disappears, we want to halt the observers to clean up / deallocate resources.
        getGlobalTypesProgressObserver?.invalidate()
        getGlobalTypesProgressObserver = nil
        getUserProgressObserver?.invalidate()
        getUserProgressObserver = nil
        getFamilyProgressObserver?.invalidate()
        getFamilyProgressObserver = nil
        getDogsProgressObserver?.invalidate()
        getDogsProgressObserver = nil
    }
    
    // MARK: - Functions
    
    private func repeatableSetup() {
        // reset troubleshootLoginButton incase it is needed again for another issue
        troubleshootLoginButton.tag = 0
        troubleshootLoginButton.isHidden = true
        
        getGlobalTypesProgress = nil
        getGlobalTypesProgressObserver = nil
        getUserProgress = nil
        getUserProgressObserver = nil
        getFamilyProgress = nil
        getFamilyProgressObserver = nil
        getDogsProgress = nil
        getDogsProgressObserver = nil
        
        // Before fetching user or any other information, we need types from the server
        self.getGlobalTypes()
    }
    
    /// If we recieved a failure response from a request, redirect the user to the login page in an attempt to recover
    private func failureResponseForRequest() {
        troubleshootLoginButton.tag = Constant.Visual.ViewTag.serverSyncViewControllerGoToLoginPage
        troubleshootLoginButton.setTitle("Go to Login Page", for: .normal)
        troubleshootLoginButton.isHidden = false
    }
    
    private func noResponseForRequest() {
        troubleshootLoginButton.tag = Constant.Visual.ViewTag.serverSyncViewControllerRetryLogin
        troubleshootLoginButton.setTitle("Retry Login", for: .normal)
        troubleshootLoginButton.isHidden = false
    }
    
    // MARK: Get Functions
    
    private func getGlobalTypes() {
        getGlobalTypesProgress = GlobalTypesRequest.get(errorAlert: .automaticallyAlertOnlyForFailure) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                self.failureResponseForRequest()
                return
            }
            
            guard GlobalTypes.shared != nil else {
                // If the user just has no internet, then show a button that lets them try again
                if responseStatus == .noResponse {
                    self.noResponseForRequest()
                }
                else {
                    self.failureResponseForRequest()
                }
                return
            }
            
            if UserInformation.userIdentifier != nil {
                self.getUser()
            }
            // placeholder userId, therefore we need to have them login to even know who they are
            else {
                
                // we have the user sign into their apple id, then attempt to first create an account then get an account (if the creates fails) then throw an error message (if the get fails too).
                // if all succeeds, then the user information and user configuration is loaded
                let vc = ServerLoginIntroductionVC()
                PresentationManager.enqueueViewController(vc)
            }
        }
        
        if getGlobalTypesProgress != nil {
            // We can't use if let getGlobalTypesProgress = getGlobalTypesProgress here. We need to observe the actual getUserProgress (not an if let "copy" of it) variable that is defined in this class for the KeyValueObservation to work.
            getGlobalTypesProgressObserver = observe(\.getGlobalTypesProgress?.fractionCompleted, options: [.new]) { _, change in
                self.didObserveProgressChange()
                
                // If the get request progress is complete (indicated by the fractionCompleted being 1.0), then we can invalidate the observer as it is no longer needed
                if let optionalNewValue = change.newValue, let newValue = optionalNewValue, newValue == 1.0 {
                    self.getGlobalTypesProgressObserver?.invalidate()
                }
            }
        }
        
    }
    
    private func getUser() {
        getUserProgress = UserRequest.get(errorAlert: .automaticallyAlertOnlyForFailure) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                self.failureResponseForRequest()
                return
            }
            
            // This is a special case. If previousDogManagerSynchronization is nil, the user's local data was cleared. This, in conjunction with no response, would mean we would open the app up to a blank screen. This would terrify the user that their data is lost. Therefore, force them to wait for a connection
            guard responseStatus != .noResponse || LocalConfiguration.previousDogManagerSynchronization == nil else {
                self.noResponseForRequest()
                return
            }
            
            guard UserInformation.userIdentifier != nil && UserInformation.userId != nil else {
                // If the user just has no internet, then show a button that lets them try again
                if responseStatus == .noResponse {
                    self.noResponseForRequest()
                }
                // If the suer has internet and still no userId, they need to login
                else {
                    self.failureResponseForRequest()
                }
                return
            }
            
            if UserInformation.familyId != nil {
                // Continue fetching the users family information
                self.getFamilyInformation()
            }
            else {
                // User needs to join a family because they have no familyId
                let vc = ServerFamilyIntroductionVC()
                vc.setup(delegate: self)
                PresentationManager.enqueueViewController(vc)
            }
        }
        
        if getUserProgress != nil {
            // We can't use if let getUserProgress = getUserProgress here. We need to observe the actual getUserProgress (not an if let "copy" of it) variable that is defined in this class for the KeyValueObservation to work.
            getUserProgressObserver = observe(\.getUserProgress?.fractionCompleted, options: [.new]) { _, change in
                self.didObserveProgressChange()
                
                // If the get request progress is complete (indicated by the fractionCompleted being 1.0), then we can invalidate the observer as it is no longer needed
                if let optionalNewValue = change.newValue, let newValue = optionalNewValue, newValue == 1.0 {
                    self.getUserProgressObserver?.invalidate()
                }
            }
        }
        
    }
    
    private func getFamilyInformation() {
        getFamilyProgress = FamilyRequest.get(errorAlert: .automaticallyAlertOnlyForFailure) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                self.failureResponseForRequest()
                return
            }
            
            self.getDogs()
        }
        
        if getFamilyProgress != nil {
            // We can't use if let getFamilyProgress = getFamilyProgress here. We need to observe the actual getFamilyProgress (not an if let "copy" of it) variable that is defined in this class for the KeyValueObservation to work.
            getFamilyProgressObserver = observe(\.getFamilyProgress?.fractionCompleted, options: [.new]) { _, change in
                self.didObserveProgressChange()
                
                // If the get request progress is complete (indicated by the fractionCompleted being 1.0), then we can invalidate the observer as it is no longer needed
                if let optionalNewValue = change.newValue, let newValue = optionalNewValue, newValue == 1.0 {
                    self.getFamilyProgressObserver?.invalidate()
                }
            }
        }
    }
    
    private func getDogs() {
        let dogManager = DogManager.globalDogManager ?? DogManager()
        // we want to use our own custom error message
        getDogsProgress = DogsRequest.get(errorAlert: .automaticallyAlertOnlyForFailure, dogManager: dogManager) { newDogManager, responseStatus, _ in
            guard responseStatus != .failureResponse else {
                self.failureResponseForRequest()
                return
            }
            
            DogManager.globalDogManager = newDogManager
            
            // hasn't shown configuration to create/update dog
            if LocalConfiguration.localHasCompletedHoundIntroductionViewController == false {
                // Created family, no dogs present
                // OR joined family, no dogs present
                // OR joined family, dogs already present
                let vc = HoundIntroductionVC()
                PresentationManager.enqueueViewController(vc)
                
            }
            // has shown configuration before
            else {
                let vc = MainTabBarController()
                PresentationManager.enqueueViewController(vc)
            }
        }
        
        if getDogsProgress != nil {
            // We can't use if let getDogsProgress = getDogsProgress here. We need to observe the actual getDogsProgress (not an if let "copy" of it) variable that is defined in this class for the KeyValueObservation to work.
            getDogsProgressObserver = observe(\.getDogsProgress?.fractionCompleted, options: [.new]) { _, change in
                self.didObserveProgressChange()
                
                // If the get request progress is complete (indicated by the fractionCompleted being 1.0), then we can invalidate the observer as it is no longer needed
                if let optionalNewValue = change.newValue, let newValue = optionalNewValue, newValue == 1.0 {
                    self.getDogsProgressObserver?.invalidate()
                }
            }
        }
        
    }
    
    // The .fractionCompleted variable on one of the progress objects was updated. Therefore, we must update our loading bar
    private func didObserveProgressChange() {
        DispatchQueue.main.async {
            let globalTypesProgress = (self.getGlobalTypesProgress?.fractionCompleted ?? 0.0) * self.getGlobalTypesProgressFractionOfWhole
            
            let userProgress = (self.getUserProgress?.fractionCompleted ?? 0.0) * self.getUserProgressFractionOfWhole
            
            let familyProgress =
            (self.getFamilyProgress?.fractionCompleted ?? 0.0) * self.getFamilyProgressFractionOfWhole
            
            let dogsProgress =
            (self.getDogsProgress?.fractionCompleted ?? 0.0) * self.getDogsProgressFractionOfWhole
            
            self.getRequestsProgressView.setProgress(Float(globalTypesProgress + userProgress + familyProgress + dogsProgress), animated: true)
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(welcomeBackLabel)
        view.addSubview(houndPaw)
        view.addSubview(getRequestsProgressView)
        view.addSubview(troubleshootLoginButton)
        troubleshootLoginButton.addTarget(self, action: #selector(didTapTroubleshootLogin), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        welcomeBackLabel.snp.makeConstraints { make in
            make.top.equalTo(view.safeAreaLayoutGuide).offset(Constant.Constraint.Spacing.absoluteVertInset)
            make.bottom.equalTo(houndPaw.snp.top).inset(Constant.Constraint.Spacing.contentIntraVert)
            make.horizontalEdges.equalTo(view).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        // pawWithHands
        NSLayoutConstraint.activate([
            houndPaw.centerXAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerXAnchor),
            houndPaw.centerYAnchor.constraint(equalTo: view.centerYAnchor),
            houndPaw.createHeightMultiplier(Constant.Constraint.Text.pawHeightMultiplier, relativeToWidthOf: view),
            houndPaw.createMaxHeight(Constant.Constraint.Text.pawMaxHeight),
            houndPaw.createSquareAspectRatio()
        ])
        
        // getRequestsProgressView
        NSLayoutConstraint.activate([
            getRequestsProgressView.topAnchor.constraint(equalTo: houndPaw.bottomAnchor, constant: 35),
            getRequestsProgressView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            getRequestsProgressView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            getRequestsProgressView.heightAnchor.constraint(equalTo: troubleshootLoginButton.heightAnchor, multiplier: 0.1)
        ])
        
        // troubleshootLoginButton
        NSLayoutConstraint.activate([
            troubleshootLoginButton.topAnchor.constraint(equalTo: getRequestsProgressView.bottomAnchor, constant: 35),
            troubleshootLoginButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            troubleshootLoginButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            troubleshootLoginButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            troubleshootLoginButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }

}
//
//  AppVersionOutdatedVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/31/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

class AppVersionOutdatedVC: BluePawVC {
    
    // MARK: - Elements
    
    private let openAppStoreButton: HoundButton = {
        let button = HoundButton()
        
        button.setTitle("Open App Store", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
         button.applyStyle(.labelBorder)
        
        return button
    }()
    
    @objc private func didTapOpenAppStore(_ sender: Any) {
        // Open the page for hound on the user's device, don't include a localized url (e.g. with the /us/) so it localizes to a users zone
        guard let url = URL(string: "https://apps.apple.com/app/hound-family-dog-organizer/id1564604025") else { return }
        UIApplication.shared.open(url)
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        headerLabel.text = "New Hound Update Available"
        descriptionLabel.text = "It looks like you're using an outdated version of Hound. Update now for the latest features and improvements!"
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(openAppStoreButton)
        
        openAppStoreButton.addTarget(self, action: #selector(didTapOpenAppStore), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // openAppStoreButton
        NSLayoutConstraint.activate([
            openAppStoreButton.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            openAppStoreButton.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            openAppStoreButton.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
            openAppStoreButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            openAppStoreButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }

}
//
//  BluePawVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/24/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class BluePawVC: HoundViewController {

    // MARK: - Elements
    
    private let houndPaw: HoundPawImageView = {
        let imageView = HoundPawImageView(huggingPriority: 340, compressionResistancePriority: 340)
        
        return imageView
    }()
    
    let headerLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 330, compressionResistancePriority: 330)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.primaryHeaderLabel
        label.textColor = UIColor.systemBackground
        return label
    }()
    
    let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 320, compressionResistancePriority: 320)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.tertiaryHeaderLabel
        label.textColor = UIColor.secondarySystemBackground
        return label
    }()
    
    let backButton: HoundButton = {
        let button = HoundButton(huggingPriority: 350, compressionResistancePriority: 350)
        
        button.tintColor = UIColor.systemBackground
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBlue
        
        button.shouldDismissParentViewController = true
        return button
    }()

    let contentView: HoundView = {
        let view = HoundView(huggingPriority: 310, compressionResistancePriority: 310)
        
        return view
    }()
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBlue
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(houndPaw)
        view.addSubview(headerLabel)
        view.addSubview(descriptionLabel)
        view.addSubview(backButton)
        view.addSubview(contentView)
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        // backButton
        NSLayoutConstraint.activate([
            backButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            backButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteCircleHoriInset),
            backButton.createHeightMultiplier(Constant.Constraint.Button.circleHeightMultiplier, relativeToWidthOf: view),
            backButton.createMaxHeight(Constant.Constraint.Button.circleMaxHeight),
            backButton.createSquareAspectRatio()
        ])

        // pawWithHands
        NSLayoutConstraint.activate([
            houndPaw.centerXAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerXAnchor),
            houndPaw.createSquareAspectRatio(),
            houndPaw.createHeightMultiplier(Constant.Constraint.Text.pawHeightMultiplier, relativeToWidthOf: view),
            houndPaw.createMaxHeight(Constant.Constraint.Text.pawMaxHeight)
        ])

        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: houndPaw.bottomAnchor, constant: 20),
            headerLabel.centerYAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerYAnchor),
            headerLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])

        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 12.5),
            descriptionLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])

        // contentView
        NSLayoutConstraint.activate([
            contentView.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor),
            contentView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            contentView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            contentView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }

}
//
//  ReleaseNotesVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class ReleaseNotesVC: HoundScrollViewController {
    
    // MARK: - Elements
    private let pageHeaderView: HoundPageSheetHeaderView = {
        let view = HoundPageSheetHeaderView(huggingPriority: 350, compressionResistancePriority: 350)
        view.useLeftTextAlignment = false
        
        view.isDescriptionEnabled = true
        view.pageDescriptionLabel.text = "🎉  🦮  🎉  🦮  🎉  🦮  🎉"
        return view
    }()
    
    private let notesLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 340, compressionResistancePriority: 340)
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.textColor = UIColor.label
        return label
    }()
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
    }
    
    func setup(version: AppVersion) {
        pageHeaderView.pageHeaderLabel.text = "What's New in v\(version.rawValue)"
        notesLabel.attributedText = version.releaseNotes
    }
    
    // MARK: - Setup Elements
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(pageHeaderView)
        containerView.addSubview(notesLabel)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        NSLayoutConstraint.activate([
            pageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            pageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            pageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        NSLayoutConstraint.activate([
            notesLabel.topAnchor.constraint(equalTo: pageHeaderView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            notesLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            notesLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            notesLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
}
//
//  SurveyAppExperienceVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/4/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import StoreKit
import UIKit

class SurveyAppExperienceVC: HoundScrollViewController, UITextViewDelegate {
    
    // MARK: - UITextViewDelegate
    
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        // Don't allow the user to add a new line. If they do, we interpret that as the user hitting the done button.
        guard text != "\n" else {
            self.dismissKeyboard()
            return false
        }
        
        // get the current text, or use an empty string if that failed
        let currentText = textView.text ?? ""
        
        // attempt to read the range they are trying to change, or exit if we can't
        guard let stringRange = Range(range, in: currentText) else { return false }
        
        // add their new text to the existing text
        let updatedText = currentText.replacingCharacters(in: stringRange, with: text)
        
        // make sure the result is under logNoteCharacterLimit
        return updatedText.count <= Constant.Class.Feedback.appExperienceSuggestionCharacterLimit
    }
    
    // MARK: - Elements
    
    private let pageHeaderView: HoundPageSheetHeaderView = {
        let view = HoundPageSheetHeaderView(huggingPriority: 350, compressionResistancePriority: 350)
        view.useLeftTextAlignment = false
        
        view.pageHeaderLabel.text = "How Are You Enjoying Hound?"
        view.pageHeaderLabel.textColor = UIColor.systemBackground
        
        view.backButton.tintColor = UIColor.systemBackground
        view.backButton.backgroundCircleTintColor = nil
        
        return view
    }()
    
    private lazy var oneStarButton: HoundButton = {
        let button = HoundButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = UIColor.white
        button.addTarget(self, action: #selector(didTapStar), for: .touchUpInside)
        return button
    }()
    
    private lazy var twoStarButton: HoundButton = {
        let button = HoundButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = UIColor.white
        button.addTarget(self, action: #selector(didTapStar), for: .touchUpInside)
        return button
    }()
    
    private lazy var threeStarButton: HoundButton = {
        let button = HoundButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = UIColor.white
        button.addTarget(self, action: #selector(didTapStar), for: .touchUpInside)
        return button
    }()
    
    private lazy var fourStarButton: HoundButton = {
        let button = HoundButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = UIColor.white
        button.addTarget(self, action: #selector(didTapStar), for: .touchUpInside)
        return button
    }()
    
    private lazy var fiveStarButton: HoundButton = {
        let button = HoundButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = UIColor.white
        button.addTarget(self, action: #selector(didTapStar), for: .touchUpInside)
        return button
    }()
    
    /// Stack view containing all star rating buttons
    private lazy var starsStackView: UIStackView = {
        let stackView = UIStackView(arrangedSubviews: [oneStarButton, twoStarButton, threeStarButton, fourStarButton, fiveStarButton])
        stackView.axis = .horizontal
        stackView.alignment = .center
        stackView.distribution = .equalSpacing
        stackView.translatesAutoresizingMaskIntoConstraints = false
        return stackView
    }()
    
    @objc private func didTapStar(_ sender: Any) {
        guard let tappedStar = sender as? HoundButton else { return }
        
        indexOfUserStarRating = orderedStarButtons.firstIndex(of: tappedStar)
    }
    
    private let descriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.text = "What could we do to improve?"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        label.textColor = UIColor.systemBackground
        return label
    }()
    
    private let suggestionTextView: HoundTextView = {
        let textView = HoundTextView(huggingPriority: 260, compressionResistancePriority: 260)
        
        textView.backgroundColor = UIColor.systemBackground
        textView.textColor = UIColor.label
        textView.font = Constant.Visual.Font.primaryRegularLabel
        textView.placeholder = "Share any thoughts, suggestions, or issues..."
        
        textView.applyStyle(.labelBorder)
        return textView
    }()
    
    private lazy var submitButton: HoundButton = {
        let button = HoundButton()
        
        button.setTitle("Submit", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        // Continue button is disabled until the user selects a rating
        button.isEnabled = false
        
        button.addTarget(self, action: #selector(didTapSubmit), for: .touchUpInside)
        
        return button
    }()
    
    @objc private func didTapSubmit(_ sender: Any) {
        guard let indexOfUserStarRating = indexOfUserStarRating else { return }
        
        let numStars = (indexOfUserStarRating + 1)
        
        // for numberOfStars, adjust the index 0-4 of the star rating to its actual 1-5 value.
        SurveyFeedbackRequest.create(errorAlert: .automaticallyAlertForNone, numberOfStars: numStars, appExperienceFeedback: suggestionTextView.text ?? "") { _, _ in
            return
        }
        
        HapticsManager.notification(.success)
        self.dismiss(animated: true) {
            // After we successfully submit this survey and dismiss the view, thank the user
            PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.surveyFeedbackAppExperienceTitle, subtitle: Constant.Visual.BannerText.surveyFeedbackAppExperienceSubtitle, style: .success)
            
            guard numStars >= 4 else {
                return
            }
            
            guard let window = UIApplication.keyWindow?.windowScene else {
                HoundLogger.general.error("SurveyAppExperienceVC.didTapSubmit: Window not established for user to rate Hound")
                return
            }
            
            // Delay this call slightly so that current ui elements have time to complete
            DispatchQueue.main.async {
                HoundLogger.general.notice("SurveyAppExperienceVC.didTapSubmit: Asking user to rate Hound")
                
                if #available(iOS 16, *) {
                    AppStore.requestReview(in: window)
                }
                else {
                    SKStoreReviewController.requestReview(in: window)
                }
               
                LocalConfiguration.localPreviousDatesUserReviewRequested.append(Date())
                PersistenceManager.persistRateReviewRequestedDates()
            }
        }
    }
    
    // MARK: - Properties
    
    /// An ordered array of the star buttons, where index 0 is 1 star and index 4 is 5 stars
    private var orderedStarButtons: [HoundButton] {
        return [oneStarButton, twoStarButton, threeStarButton, fourStarButton, fiveStarButton]
    }
    
    private var storedIndexOfUserStarRating: Int?
    /// The index of what star the user rated Hound (1 star = 0 & 5 stars = 4)
    private var indexOfUserStarRating: Int? {
        get {
            return storedIndexOfUserStarRating
        }
        set {
            let oldValue = storedIndexOfUserStarRating
            storedIndexOfUserStarRating = newValue
            
            guard let indexOfUserStarRating = indexOfUserStarRating, oldValue != indexOfUserStarRating else {
                // The rating is being set to nil or the new rating is the same as the old rating, so clear all of the stars and the rating
                storedIndexOfUserStarRating = nil
                
                UIView.animate(withDuration: Constant.Visual.Animation.selectSingleElement) {
                    // A star isn't selected so the user can't submit
                    self.submitButton.isEnabled = false
                    self.orderedStarButtons.forEach { starButton in
                        starButton.isUserInteractionEnabled = false
                        starButton.setImage(UIImage(systemName: "star"), for: .normal)
                    }
                } completion: { _ in
                    self.orderedStarButtons.forEach { starButton in
                        starButton.isUserInteractionEnabled = true
                    }
                }
                return
            }
            
            // Find the number of stars the user rated
            // If the user rated 3 stars, then we want to change stars 1, 2, and 3 to being the selected filled star image, and change stars 4 and 5 to the unfilled star iamge
            let selectedStarButtons = indexOfUserStarRating >= orderedStarButtons.count ? orderedStarButtons : Array(orderedStarButtons.prefix(through: indexOfUserStarRating))
            let unselectedStarButtons = orderedStarButtons.filter { starButton in
                return selectedStarButtons.contains(starButton) == false
            }
            
            UIView.animate(withDuration: Constant.Visual.Animation.selectSingleElement) {
                // A star is selected so the user can now submit
                self.submitButton.isEnabled = true
                selectedStarButtons.forEach { selectedStarButton in
                    selectedStarButton.isUserInteractionEnabled = false
                    selectedStarButton.setImage(UIImage(systemName: "star.fill"), for: .normal)
                }
                unselectedStarButtons.forEach { unselectedStarButton in
                    unselectedStarButton.isUserInteractionEnabled = false
                    unselectedStarButton.setImage(UIImage(systemName: "star"), for: .normal)
                }
            } completion: { _ in
                selectedStarButtons.forEach { selectedStarButton in
                    selectedStarButton.isUserInteractionEnabled = true
                }
                unselectedStarButtons.forEach { unselectedStarButton in
                    unselectedStarButton.isUserInteractionEnabled = true
                }
            }
        }
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        // When this view controller is constructed, check that we requested survey feedback for app exp
        LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.append(Date())
        
        self.suggestionTextView.delegate = self
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(pageHeaderView)
        containerView.addSubview(starsStackView)
        containerView.addSubview(descriptionLabel)
        containerView.addSubview(suggestionTextView)
        containerView.addSubview(submitButton)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pageHeaderView
        NSLayoutConstraint.activate([
            pageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            pageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            pageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // starsStackView
        NSLayoutConstraint.activate([
            starsStackView.topAnchor.constraint(equalTo: pageHeaderView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            starsStackView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset * 2.0),
            starsStackView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // Make all stars equal size and square
        for starButton in orderedStarButtons {
            NSLayoutConstraint.activate([
                starButton.createHeightMultiplier(Constant.Constraint.Button.circleHeightMultiplier * 1.5, relativeToWidthOf: view),
                starButton.createMaxHeight(Constant.Constraint.Button.circleMaxHeight * 1.5),
                starButton.createSquareAspectRatio()
            ])
        }
        
        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: starsStackView.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            descriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // suggestionTextView
        NSLayoutConstraint.activate([
            suggestionTextView.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            suggestionTextView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            suggestionTextView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            suggestionTextView.createHeightMultiplier(Constant.Constraint.Input.textViewHeightMultiplier, relativeToWidthOf: view),
            suggestionTextView.createMaxHeight(Constant.Constraint.Input.textViewMaxHeight)
        ])
        
        // submitButton
        NSLayoutConstraint.activate([
            submitButton.topAnchor.constraint(equalTo: suggestionTextView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            submitButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            submitButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            submitButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            submitButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight),
            submitButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
}
//
//  LimitExceededViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/6/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

class LimitExceededViewController: BluePawVC {

    // MARK: - Elements
    
    private let upgradeSubscriptionOrBackButton: HoundButton = {
        let button = HoundButton(huggingPriority: 310, compressionResistancePriority: 310)
        
        button.setTitle("Upgrade Subscription", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
         button.applyStyle(.labelBorder)
       
        return button
    }()
    
    @objc private func didTapPurchaseSubscriptionOrBack(_ sender: Any) {
        // Functionality of this button varies depending on if you are a family member or not
        if UserInformation.isUserFamilyHead {
            SettingsSubscriptionVC.fetchProductsThenGetViewController { vc in
                guard let vc = vc else {
                    // Error message automatically handled
                    return
                }
                
                PresentationManager.enqueueViewController(vc)
            }
        }
        else {
            self.dismiss(animated: true)
        }
    }
    
    // MARK: - Properties
    
    /// By how many family members the family is exceeding its family member limit
    private var numberOfExceededFamilyMembers: Int {
        return FamilyInformation.familyMembers.count - FamilyInformation.familyActiveSubscription.numberOfFamilyMembers
    }
    
    /// Inside viewIsAppearing, if the family isn't exceeding its family member limit, then we will automatically dismiss the view. This helps track an edge case where the view may be dismissed on its first appearance when the user's local active family subscription is outdated
    private var isFirstTimeAppearing: Bool = true
    
    // MARK: - Main

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        headerLabel.text = "Family Member Limit Exceeded"
        
        if UserInformation.isUserFamilyHead {
            // We make the primary button allow the family head to purchase a subscription and enable a secondary button to allow them to dismiss
            upgradeSubscriptionOrBackButton.setTitle("Upgrade Subscription", for: .normal)
            backButton.isHidden = false
        }
        else {
            // We make the primary button the dismiss button for non family members
            upgradeSubscriptionOrBackButton.setTitle("Back", for: .normal)
            backButton.isHidden = true
        }
        
        descriptionLabel.text = {
            return Constant.Error.FamilyResponseError.limitFamilyMemberExceeded(requestId: -1, responseId: -1).description
        }()
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard isFirstTimeAppearing == false else {
            isFirstTimeAppearing = false
            return
        }
        
        // If this isn't the views first time appearing, that means this view was presented, then likely another view appeared on top (e.g. the screen to buy a new subscription). Therefore, its possible the user bought a new subscription which would solve the issue of why this view controller was presented
        
        // Check if the user's family is in compliance now
        if numberOfExceededFamilyMembers <= 0 {
            self.dismiss(animated: true)
        }
    }

    // MARK: - Setup Elements

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(upgradeSubscriptionOrBackButton)
        
        upgradeSubscriptionOrBackButton.addTarget(self, action: #selector(didTapPurchaseSubscriptionOrBack), for: .touchUpInside)
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        // upgradeSubscriptionOrBackButton
        NSLayoutConstraint.activate([
            upgradeSubscriptionOrBackButton.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 35),
            upgradeSubscriptionOrBackButton.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            upgradeSubscriptionOrBackButton.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
            upgradeSubscriptionOrBackButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: contentView),
            upgradeSubscriptionOrBackButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }
}
//
//  LimitTooLowViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/6/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

class LimitTooLowViewController: BluePawVC {
    
    // MARK: - Elements
    
    private let bigBackButton: HoundButton = {
        let button = HoundButton()
        
        button.setTitle("Back", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
         button.applyStyle(.labelBorder)
        
        button.shouldDismissParentViewController = true
        
        return button
    }()
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        backButton.isHidden = true
        headerLabel.text = "Hound+ Subscription Needed"
        descriptionLabel.text = "You're trying to join a Hound family with a limited number of family members! Please have the family head upgrade to a Hound+ subscription before attempting to join."
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(bigBackButton)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // backButton
        NSLayoutConstraint.activate([
            bigBackButton.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 35),
            bigBackButton.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            bigBackButton.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
            bigBackButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: contentView),
            bigBackButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }
}
//
//  LogInfoBubbleTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

final class LogInfoBubbleCVC: UICollectionViewCell {
    
    // MARK: - Elements
    
    let label: HoundLabel = {
        let label = HoundLabel()
        label.backgroundColor = UIColor.secondarySystemBackground
        label.font = Constant.Visual.Font.secondaryRegularLabel
        label.textAlignment = .center
        label.shouldRoundCorners = true
        label.staticCornerRadius = nil
        label.shouldInsetText = true
        label.customTextInsets.left = Constant.Constraint.Spacing.contentTightIntraHori
        label.customTextInsets.right = Constant.Constraint.Spacing.contentTightIntraHori
        label.customTextInsets.top = 0
        label.customTextInsets.bottom = 0
        return label
    }()
    
    // MARK: - Properties
    
    private var maxWidthConstraint: Constraint?
    
    static let reuseIdentifier = "LogInfoBubbleCVC"
    
    // MARK: - Main
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        contentView.addSubview(label)
        label.snp.makeConstraints { make in
            make.edges.equalToSuperview()
            maxWidthConstraint = make.width.lessThanOrEqualTo(CGFloat.greatestFiniteMagnitude).priority(.required).constraint
        }
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func awakeFromNib() {
        super.awakeFromNib()
        fatalError("XIB is not supported")
    }
    
    // MARK: - Setup
    
    func setup(text: String) {
        label.text = text
    }
    
    func setMaxWidth(_ width: CGFloat) {
        maxWidthConstraint?.update(offset: width)
    }
}
//
//  LogsFilterVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/20/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

// TODO QOL add a leave without save warning

protocol LogsFilterDelegate: AnyObject {
    func didUpdateLogsFilter(logsFilter: LogsFilter)
}

enum LogsFilterDropDownTypes: String, HoundDropDownType {
    case filterTimeRange = "DropDownFilterTimeRange"
    case filterDogs = "DropDownFilterDogs"
    case filterLogActions = "DropDownFilterLogActions"
    case filterFamilyMembers = "DropDownFilterFamilyMembers"
}

class LogsFilterVC: HoundScrollViewController,
                    HoundDropDownDataSource,
                    HoundDropDownManagerDelegate,
                    UITextFieldDelegate {
    
    // MARK: - UITextFieldDelegate
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        self.dismissKeyboard()
        return false
    }
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
    // MARK: - Elements
    
    private let pageHeaderView: HoundPageSheetHeaderView = {
        let view = HoundPageSheetHeaderView(huggingPriority: 350, compressionResistancePriority: 350)
        view.pageHeaderLabel.text = "Filter"
        return view
    }()
    
    private let timeRangeSectionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 340, compressionResistancePriority: 340)
        label.text = "Time Range"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    // TODO UI remove field header label it adds nothing
    private let timeRangeFieldHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 335, compressionResistancePriority: 335)
        label.text = "Field"
        label.font = Constant.Visual.Font.primaryRegularLabel
        return label
    }()
    
    // TODO UI this should start blank and have a placeholder. if user tries to save filter w/ from/to on but no field, show an error message
    private lazy var timeRangeFieldLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 335, compressionResistancePriority: 335)
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.shouldInsetText = true
        
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: LogsFilterDropDownTypes.filterTimeRange,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .filterTimeRange, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    
    private let timeRangeFromHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 335, compressionResistancePriority: 335)
        label.text = "From"
        label.font = Constant.Visual.Font.primaryRegularLabel
        return label
    }()
    
    private lazy var fromDatePicker: HoundDatePicker = {
        let picker = HoundDatePicker(huggingPriority: 330, compressionResistancePriority: 330)
        picker.datePickerMode = .dateAndTime
        picker.minuteInterval = Constant.Development.minuteInterval
        picker.preferredDatePickerStyle = .compact
        picker.addTarget(self, action: #selector(didChangeFromDate(_:)), for: .valueChanged)
        return picker
    }()
    
    private lazy var fromDateSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 325, compressionResistancePriority: 325)
        uiSwitch.addTarget(self, action: #selector(didToggleFromDate), for: .valueChanged)
        return uiSwitch
    }()
    
    private let timeRangeToHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 320, compressionResistancePriority: 320)
        label.text = "to"
        label.font = Constant.Visual.Font.primaryRegularLabel
        return label
    }()
    
    private lazy var toDatePicker: HoundDatePicker = {
        let picker = HoundDatePicker(huggingPriority: 310, compressionResistancePriority: 310)
        picker.datePickerMode = .dateAndTime
        picker.minuteInterval = Constant.Development.minuteInterval
        picker.preferredDatePickerStyle = .compact
        picker.addTarget(self, action: #selector(didChangeToDate(_:)), for: .valueChanged)
        return picker
    }()
    
    private lazy var toDateSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 305, compressionResistancePriority: 305)
        uiSwitch.addTarget(self, action: #selector(didToggleToDate), for: .valueChanged)
        return uiSwitch
    }()
    
    private let likesOnlySectionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 235, compressionResistancePriority: 235)
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        label.text = "Only Show Likes"
        return label
    }()
    
    private lazy var likesOnlySwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 230, compressionResistancePriority: 230)
        uiSwitch.addTarget(self, action: #selector(didToggleLikesOnly), for: .valueChanged)
        return uiSwitch
    }()
    
    private let searchSectionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.text = "Search Text"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var searchTextField: HoundTextField = {
        let textField = HoundTextField(huggingPriority: 295, compressionResistancePriority: 295)
        textField.delegate = self
        textField.placeholder = "Search notes, units, and more..."
        textField.shouldInsetText = true
        textField.backgroundColor = UIColor.systemBackground
        textField.applyStyle(.thinGrayBorder)
        textField.addTarget(self, action: #selector(didChangeSearchText(_:)), for: .editingChanged)
        textField.returnKeyType = .done
        return textField
    }()
    
    private let dogsSectionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Dogs"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var filterDogsLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a dog (or dogs)..."
        label.shouldInsetText = true
        
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: LogsFilterDropDownTypes.filterDogs,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .filterDogs, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    
    private let logActionsSectionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.text = "Actions"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var filterLogActionsSectionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 260, compressionResistancePriority: 260)
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select an action (or actions)..."
        label.shouldInsetText = true
        
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: LogsFilterDropDownTypes.filterLogActions,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .filterLogActions, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    
    private let familyMembersSectionLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Family Members"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    
    private lazy var filterFamilyMembersLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 240, compressionResistancePriority: 240)
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a family member (or members)..."
        label.shouldInsetText = true
        
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: LogsFilterDropDownTypes.filterFamilyMembers,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .filterFamilyMembers, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    
    private lazy var resetButton: HoundButton = {
        let button = HoundButton(huggingPriority: 220, compressionResistancePriority: 220)
        
        button.setTitle("Reset", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        button.shouldDismissParentViewController = true
        
        button.addTarget(self, action: #selector(didTapResetFilter), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var applyButton: HoundButton = {
        let button = HoundButton(huggingPriority: 230, compressionResistancePriority: 230)
        
        button.setTitle("Apply", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBlue
        
        button.shouldRoundCorners = true
        
        button.shouldDismissParentViewController = true
        
        button.addTarget(self, action: #selector(didTapApplyFilter), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var dropDownManager = HoundDropDownManager<LogsFilterDropDownTypes>(
        rootView: containerView,
        dataSource: self,
        delegate: self
    )
    
    @objc private func didChangeFromDate(_ sender: UIDatePicker) {
        filter?.apply(timeRangeFromDate: sender.date)
        if sender.date > toDatePicker.date {
            toDatePicker.setDate(sender.date, animated: true)
            filter?.apply(timeRangeToDate: toDateSwitch.isOn ? sender.date : nil)
        }
        fromDateSwitch.setOn(true, animated: true)
    }
    
    @objc private func didChangeToDate(_ sender: UIDatePicker) {
        filter?.apply(timeRangeToDate: sender.date)
        if sender.date < fromDatePicker.date {
            fromDatePicker.setDate(sender.date, animated: true)
            filter?.apply(timeRangeFromDate: fromDateSwitch.isOn ? sender.date : nil)
        }
        toDateSwitch.setOn(true, animated: true)
    }
    
    @objc private func didToggleFromDate(_ sender: HoundSwitch) {
        filter?.apply(timeRangeFromDate: sender.isOn ? fromDatePicker.date : nil)
        fromDatePicker.isEnabled = sender.isOn
    }
    
    @objc private func didToggleToDate(_ sender: HoundSwitch) {
        filter?.apply(timeRangeToDate: sender.isOn ? toDatePicker.date : nil)
        toDatePicker.isEnabled = sender.isOn
    }
    
    @objc private func didToggleLikesOnly(_ sender: HoundSwitch) {
        filter?.apply(onlyShowLikes: sender.isOn)
    }
    
    @objc private func didChangeSearchText(_ sender: UITextField) {
        filter?.apply(searchText: sender.text ?? "")
    }
    
    @objc private func didTapResetFilter(_ sender: Any) {
        filter?.reset()
        if let filter = filter {
            delegate?.didUpdateLogsFilter(logsFilter: filter)
        }
    }
    
    @objc private func didTapApplyFilter(_ sender: Any) {
        guard let filter = filter else { return }
        delegate?.didUpdateLogsFilter(logsFilter: filter)
    }
    
    // MARK: - Properties
    
    private weak var delegate: LogsFilterDelegate?
    
    private var filter: LogsFilter?
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        self.enableSwipeBackToDismiss = true
        
        updateDynamicUIElements()
    }
    
    private var didSetupCustomSubviews: Bool = false
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard didSetupCustomSubviews == false else { return }
        
        didSetupCustomSubviews = true
        
        updateDynamicUIElements()
    }
    
    // MARK: - Setup
    
    func setup(delegate: LogsFilterDelegate, filter: LogsFilter) {
        self.delegate = delegate
        self.filter = (filter.copy() as? LogsFilter) ?? filter
        updateDynamicUIElements()
    }
    
    // MARK: - Functions
    
    private func updateDynamicUIElements() {
        if let filter = filter {
            searchTextField.text = filter.searchText
        }
        
        if let filter = filter {
            likesOnlySwitch.setOn(filter.onlyShowLikes, animated: false)
        }
        
        if let filter = filter, filter.filteredDogsUUIDs.count >= 1 {
            filterDogsLabel.text = {
                if filter.filteredDogsUUIDs.count == 1, let dogUUID = filter.filteredDogsUUIDs.first {
                    // The user only has one dog selected to filter by
                    return filter.dogManager.findDog(dogUUID: dogUUID)?.dogName ?? Constant.Visual.Text.unknownName
                }
                else if filter.filteredDogsUUIDs.count > 1 && filter.filteredDogsUUIDs.count < filter.availableDogs.count {
                    // The user has multiple, but not all, dogs selected to filter by
                    return "Multiple"
                }
                
                // The user has all dogs selected to filter by
                return "All"
            }()
        }
        else {
            // The user has no dogs selected to filter by, so we interpret this as including all dogs in the filter
            filterDogsLabel.text = nil
        }
        
        if let filter = filter, filter.filteredLogActionActionTypeIds.count >= 1 {
            filterLogActionsSectionLabel.text = {
                if filter.filteredLogActionActionTypeIds.count == 1, let logActionTypeId = filter.filteredLogActionActionTypeIds.first {
                    // The user only has one log action selected to filter by
                    return LogActionType.find(logActionTypeId: logActionTypeId).convertToReadableName(customActionName: nil, includeMatchingEmoji: true)
                }
                else if filter.filteredLogActionActionTypeIds.count > 1 && filter.filteredLogActionActionTypeIds.count < filter.availableLogActions.count {
                    // The user has multiple, but not all, log actions selected to filter by
                    return "Multiple"
                }
                
                // The user has all log actions selected to filter by
                return "All"
            }()
        }
        else {
            // The user has no log actions selected to filter by, so we interpret this as including all log actions in the filter
            filterLogActionsSectionLabel.text = nil
        }
        
        if let filter = filter, filter.filteredFamilyMemberUserIds.count >= 1 {
            filterFamilyMembersLabel.text = {
                if filter.filteredFamilyMemberUserIds.count == 1, let userId = filter.filteredFamilyMemberUserIds.first {
                    // The user only has one family member selected to filter by
                    return FamilyInformation.findFamilyMember(userId: userId)?.displayFullName ?? Constant.Visual.Text.unknownName
                }
                else if filter.filteredFamilyMemberUserIds.count > 1 && filter.filteredFamilyMemberUserIds.count < filter.availableFamilyMembers.count {
                    // The user has multiple, but not all, family members selected to filter by
                    return "Multiple"
                }
                
                // The user has all family members selected to filter by
                return "All"
            }()
        }
        else {
            // The user has no family member selected to filter by, so we interpret this as including all family members in the filter
            filterFamilyMembersLabel.text = nil
        }
        
        if let filter = filter {
            let noDate = Date()
            let fromDate = filter.timeRangeFromDate ?? filter.timeRangeToDate ?? noDate
            let toDate = filter.timeRangeToDate ?? filter.timeRangeFromDate ?? noDate
            
            timeRangeFieldLabel.text = filter.timeRangeField.readableValue
            
            fromDatePicker.setDate(fromDate, animated: false)
            toDatePicker.setDate(toDate, animated: false)
            
            fromDateSwitch.setOn(filter.isFromDateEnabled, animated: false)
            fromDatePicker.isEnabled = filter.isFromDateEnabled
            toDateSwitch.setOn(filter.isToDateEnabled, animated: false)
            toDatePicker.isEnabled = filter.isToDateEnabled
        }
        
        self.view.setNeedsLayout()
        self.view.layoutIfNeeded()
    }
    
    // MARK: - Drop Down
    
    @objc private func didTapScreen(sender: UITapGestureRecognizer) {
        dropDownManager.hideDropDownIfNotTapped(sender: sender)
        if let senderView = sender.view {
            let point = sender.location(in: senderView)
            if let deepestTouchedView = senderView.hitTest(point, with: nil),
               deepestTouchedView.isDescendant(of: searchTextField) == false {
                dismissKeyboard()
            }
        }
    }
    
    func willShowDropDown(_ identifier: any HoundDropDownType, animated: Bool) {
        guard let type = identifier as? LogsFilterDropDownTypes else { return }
        
        let rows: CGFloat = {
            switch type {
            case .filterTimeRange: return CGFloat(filter?.availableTimeRangeFields.count ?? 0)
            case .filterDogs: return CGFloat(filter?.availableDogs.count ?? 0)
            case .filterLogActions: return CGFloat(filter?.availableLogActions.count ?? 0)
            case .filterFamilyMembers: return CGFloat(filter?.availableFamilyMembers.count ?? 0)
            }
        }()
        
        dropDownManager.show(
            identifier: type,
            numberOfRowsToShow: min(6.5, rows),
            animated: animated
        )
    }
    
    // MARK: - Drop Down Data Source
    
    func setupCellForDropDown(cell: HoundDropDownTVC, indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let filter = filter else { return }
        guard let type = identifier as? LogsFilterDropDownTypes else { return }
        switch type {
        case .filterTimeRange:
            let timeRangeField = filter.availableTimeRangeFields[indexPath.row]
            cell.setCustomSelected(filter.timeRangeField == timeRangeField, animated: false)
            cell.label.text = timeRangeField.readableValue
        case .filterDogs:
            let dog = filter.availableDogs[indexPath.row]
            cell.setCustomSelected(filter.filteredDogsUUIDs.contains(dog.dogUUID), animated: false)
            cell.label.text = dog.dogName
        case .filterLogActions:
            let logActionType = filter.availableLogActions[indexPath.row]
            cell.setCustomSelected(filter.filteredLogActionActionTypeIds.contains(logActionType.logActionTypeId), animated: false)
            cell.label.text = logActionType.convertToReadableName(customActionName: nil, includeMatchingEmoji: true)
        case .filterFamilyMembers:
            let familyMember = filter.availableFamilyMembers[indexPath.row]
            cell.setCustomSelected(filter.filteredFamilyMemberUserIds.contains(familyMember.userId), animated: false)
            cell.label.text = familyMember.displayFullName ?? Constant.Visual.Text.unknownName
        }
    }
    
    func numberOfRows(section: Int, identifier: any HoundDropDownType) -> Int {
        guard let filter = filter else {
            return 0
        }
        guard let type = identifier as? LogsFilterDropDownTypes else { return 0 }
        switch type {
        case .filterTimeRange:
            return filter.availableTimeRangeFields.count
        case .filterDogs:
            return filter.availableDogs.count
        case .filterLogActions:
            return filter.availableLogActions.count
        case .filterFamilyMembers:
            return filter.availableFamilyMembers.count
        }
    }
    
    func numberOfSections(identifier: any HoundDropDownType) -> Int {
        guard let type = identifier as? LogsFilterDropDownTypes else { return 0 }
        switch type {
        case .filterTimeRange, .filterDogs, .filterLogActions, .filterFamilyMembers:
            return 1
        }
    }
    
    func selectItemInDropDown(indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let filter = filter else { return }
        guard let type = identifier as? LogsFilterDropDownTypes else { return }
        guard let dropDown = dropDownManager.dropDown(for: type) else { return }
        guard let cell = dropDown.dropDownTableView?.cellForRow(at: indexPath) as? HoundDropDownTVC else { return }
        
        switch type {
        case .filterTimeRange:
            let type = filter.availableTimeRangeFields[indexPath.row]
            
            // prevent deselectiong of time range field. we shuld always have one selected
            guard type != filter.timeRangeField else {
                return
            }
            
            cell.setCustomSelected(true)
            filter.apply(timeRangeField: type)
            dropDown.hideDropDown(animated: true)
        case .filterDogs:
            let dogSelected = filter.availableDogs[indexPath.row]
            let beforeSelectNumberOfDogsSelected = filter.availableDogs.count
            if cell.isCustomSelected == true {
                filter.remove(filterDogUUID: dogSelected.dogUUID)
            }
            else {
                filter.add(filterDogUUID: dogSelected.dogUUID)
            }
            cell.setCustomSelected(!cell.isCustomSelected)
            if beforeSelectNumberOfDogsSelected == 0 || filter.filteredDogsUUIDs.count == filter.availableDogs.count {
                dropDown.hideDropDown(animated: true)
            }
        case .filterLogActions:
            let selectedLogAction = filter.availableLogActions[indexPath.row]
            let beforeSelectNumberOfLogActionsSelected = filter.availableLogActions.count
            if cell.isCustomSelected == true {
                filter.remove(logActionTypeId: selectedLogAction.logActionTypeId)
            }
            else {
                filter.add(logActionTypeId: selectedLogAction.logActionTypeId)
            }
            cell.setCustomSelected(!cell.isCustomSelected)
            if beforeSelectNumberOfLogActionsSelected == 0 || filter.filteredLogActionActionTypeIds.count == filter.availableLogActions.count {
                dropDown.hideDropDown(animated: true)
            }
        case .filterFamilyMembers:
            let familyMemberSelected = filter.availableFamilyMembers[indexPath.row]
            let beforeSelectNumberOfFamilyMembersSelected = filter.availableFamilyMembers.count
            if cell.isCustomSelected == true {
                filter.remove(userId: familyMemberSelected.userId)
            }
            else {
                filter.add(userId: familyMemberSelected.userId)
            }
            cell.setCustomSelected(!cell.isCustomSelected)
            if beforeSelectNumberOfFamilyMembersSelected == 0 || filter.filteredFamilyMemberUserIds.count == filter.availableFamilyMembers.count {
                dropDown.hideDropDown(animated: true)
            }
        }
        updateDynamicUIElements()
    }
    
    func firstSelectedIndexPath(identifier: any HoundDropDownType) -> IndexPath? {
        guard let filter = filter else { return nil }
        guard let type = identifier as? LogsFilterDropDownTypes else { return nil }
        switch type {
        case .filterTimeRange:
            if let idx = filter.availableTimeRangeFields
                .firstIndex(where: { $0 == filter.timeRangeField }) {
                return IndexPath(row: idx, section: 0)
            }
        case .filterDogs:
            if let idx = filter.filteredDogsUUIDs
                .compactMap({ uuid in filter.availableDogs.firstIndex(where: { $0.dogUUID == uuid }) })
                .min() {
                return IndexPath(row: idx, section: 0)
            }
        case .filterLogActions:
            if let idx = filter.filteredLogActionActionTypeIds
                .compactMap({ id in filter.availableLogActions.firstIndex(where: { $0.logActionTypeId == id }) })
                .min() {
                return IndexPath(row: idx, section: 0)
            }
        case .filterFamilyMembers:
            if let idx = filter.filteredFamilyMemberUserIds
                .compactMap({ userId in filter.availableFamilyMembers.firstIndex(where: { $0.userId == userId }) })
                .min() {
                return IndexPath(row: idx, section: 0)
            }
        }
        return nil
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(pageHeaderView)
        
        containerView.addSubview(timeRangeSectionLabel)
        
        containerView.addSubview(timeRangeFieldHeaderLabel)
        containerView.addSubview(timeRangeFieldLabel)
        
        containerView.addSubview(timeRangeFromHeaderLabel)
        containerView.addSubview(fromDatePicker)
        containerView.addSubview(fromDateSwitch)
        
        containerView.addSubview(timeRangeToHeaderLabel)
        containerView.addSubview(toDatePicker)
        containerView.addSubview(toDateSwitch)
        
        containerView.addSubview(likesOnlySectionLabel)
        containerView.addSubview(likesOnlySwitch)
        
        containerView.addSubview(searchSectionLabel)
        containerView.addSubview(searchTextField)
        
        containerView.addSubview(filterDogsLabel)
        containerView.addSubview(dogsSectionLabel)
        
        containerView.addSubview(filterLogActionsSectionLabel)
        containerView.addSubview(logActionsSectionLabel)
        
        containerView.addSubview(filterFamilyMembersLabel)
        containerView.addSubview(familyMembersSectionLabel)
        
        containerView.addSubview(resetButton)
        containerView.addSubview(applyButton)
        
        let didTapScreenGesture = UITapGestureRecognizer(target: self, action: #selector(didTapScreen(sender:)))
        didTapScreenGesture.delegate = self
        didTapScreenGesture.cancelsTouchesInView = false
        view.addGestureRecognizer(didTapScreenGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pageHeaderView
        NSLayoutConstraint.activate([
            pageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            pageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            pageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // timeRangeSectionLabel
        NSLayoutConstraint.activate([
            timeRangeSectionLabel.topAnchor.constraint(equalTo: pageHeaderView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            timeRangeSectionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            timeRangeSectionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            timeRangeSectionLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            timeRangeSectionLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view)
        ])
        
        // timeRangeFieldHeaderLabel
        NSLayoutConstraint.activate([
            timeRangeFieldHeaderLabel.topAnchor.constraint(equalTo: timeRangeSectionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            timeRangeFieldHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            timeRangeFieldHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // timeRangeFieldLabel
        NSLayoutConstraint.activate([
            timeRangeFieldLabel.topAnchor.constraint(equalTo: timeRangeFieldHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            timeRangeFieldLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            timeRangeFieldLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            timeRangeFieldLabel.createHeightMultiplier(Constant.Constraint.Input.textFieldHeightMultiplier, relativeToWidthOf: view),
            timeRangeFieldLabel.createMaxHeight(Constant.Constraint.Input.textFieldMaxHeight)
        ])
        
        // timeRangeFromHeaderLabel
        NSLayoutConstraint.activate([
            timeRangeFromHeaderLabel.topAnchor.constraint(equalTo: timeRangeFieldLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            timeRangeFromHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            timeRangeFromHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // fromDatePicker
        NSLayoutConstraint.activate([
            fromDatePicker.topAnchor.constraint(equalTo: timeRangeFromHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            fromDatePicker.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            fromDatePicker.trailingAnchor.constraint(lessThanOrEqualTo: fromDateSwitch.leadingAnchor, constant: -Constant.Constraint.Spacing.contentIntraHori),
            fromDatePicker.createHeightMultiplier(Constant.Constraint.Input.segmentedHeightMultiplier, relativeToWidthOf: view),
            fromDatePicker.createMaxHeight(Constant.Constraint.Input.segmentedMaxHeight),
            fromDatePicker.createAspectRatio(2.75 * 2)
        ])
        
        // fromDateSwitch
        NSLayoutConstraint.activate([
            fromDateSwitch.centerYAnchor.constraint(equalTo: fromDatePicker.centerYAnchor),
            fromDateSwitch.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // timeRangeToHeaderLabel
        NSLayoutConstraint.activate([
            timeRangeToHeaderLabel.topAnchor.constraint(equalTo: fromDatePicker.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            timeRangeToHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            timeRangeToHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // toDatePicker
        NSLayoutConstraint.activate([
            toDatePicker.topAnchor.constraint(equalTo: timeRangeToHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            toDatePicker.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            toDatePicker.trailingAnchor.constraint(lessThanOrEqualTo: toDateSwitch.leadingAnchor, constant: -Constant.Constraint.Spacing.contentIntraHori),
            toDatePicker.createHeightMultiplier(Constant.Constraint.Input.segmentedHeightMultiplier, relativeToWidthOf: view),
            toDatePicker.createMaxHeight(Constant.Constraint.Input.segmentedMaxHeight),
            toDatePicker.createAspectRatio(2.75 * 2)
        ])
        
        // toDateSwitch
        NSLayoutConstraint.activate([
            toDateSwitch.centerYAnchor.constraint(equalTo: toDatePicker.centerYAnchor),
            toDateSwitch.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // likesOnlySectionLabel
        NSLayoutConstraint.activate([
            likesOnlySectionLabel.topAnchor.constraint(equalTo: toDatePicker.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            likesOnlySectionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            likesOnlySectionLabel.trailingAnchor.constraint(lessThanOrEqualTo: likesOnlySwitch.leadingAnchor, constant: -Constant.Constraint.Spacing.contentIntraHori),
            likesOnlySectionLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view),
            likesOnlySectionLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight)
        ])
        
        // likesOnlySwitch
        NSLayoutConstraint.activate([
            likesOnlySwitch.centerYAnchor.constraint(equalTo: likesOnlySectionLabel.centerYAnchor),
            likesOnlySwitch.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        ])
        
        // searchSectionLabel
        NSLayoutConstraint.activate([
            searchSectionLabel.topAnchor.constraint(equalTo: likesOnlySectionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            searchSectionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            searchSectionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            searchSectionLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view),
            searchSectionLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight)
        ])
        
        // searchTextField
        NSLayoutConstraint.activate([
            searchTextField.topAnchor.constraint(equalTo: searchSectionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            searchTextField.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            searchTextField.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            searchTextField.createHeightMultiplier(Constant.Constraint.Input.textFieldHeightMultiplier, relativeToWidthOf: view),
            searchTextField.createMaxHeight(Constant.Constraint.Input.textFieldMaxHeight)
        ])
        
        // dogsSectionLabel
        NSLayoutConstraint.activate([
            dogsSectionLabel.topAnchor.constraint(equalTo: searchTextField.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            dogsSectionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            dogsSectionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            dogsSectionLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            dogsSectionLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view)
        ])
        
        // filterDogsLabel
        NSLayoutConstraint.activate([
            filterDogsLabel.topAnchor.constraint(equalTo: dogsSectionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            filterDogsLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            filterDogsLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            filterDogsLabel.createMaxHeight(Constant.Constraint.Input.textFieldMaxHeight),
            filterDogsLabel.createHeightMultiplier(Constant.Constraint.Input.textFieldHeightMultiplier, relativeToWidthOf: view)
        ])
        
        // logActionsSectionLabel
        NSLayoutConstraint.activate([
            logActionsSectionLabel.topAnchor.constraint(equalTo: filterDogsLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            logActionsSectionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            logActionsSectionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            logActionsSectionLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            logActionsSectionLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view)
        ])
        
        // filterLogActionsSectionLabel
        NSLayoutConstraint.activate([
            filterLogActionsSectionLabel.topAnchor.constraint(equalTo: logActionsSectionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            filterLogActionsSectionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            filterLogActionsSectionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            filterLogActionsSectionLabel.createMaxHeight(Constant.Constraint.Input.textFieldMaxHeight),
            filterLogActionsSectionLabel.createHeightMultiplier(Constant.Constraint.Input.textFieldHeightMultiplier, relativeToWidthOf: view)
            
        ])
        
        // familyMembersSectionLabel
        NSLayoutConstraint.activate([
            familyMembersSectionLabel.topAnchor.constraint(equalTo: filterLogActionsSectionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            familyMembersSectionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            familyMembersSectionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            familyMembersSectionLabel.createMaxHeight(Constant.Constraint.Text.sectionLabelMaxHeight),
            familyMembersSectionLabel.createHeightMultiplier(Constant.Constraint.Text.sectionLabelHeightMultipler, relativeToWidthOf: view)
            
        ])
        
        // filterFamilyMembersLabel
        NSLayoutConstraint.activate([
            filterFamilyMembersLabel.topAnchor.constraint(equalTo: familyMembersSectionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            filterFamilyMembersLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            filterFamilyMembersLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            filterFamilyMembersLabel.createMaxHeight(Constant.Constraint.Input.textFieldMaxHeight),
            filterFamilyMembersLabel.createHeightMultiplier(Constant.Constraint.Input.textFieldHeightMultiplier, relativeToWidthOf: view)
        ])
        
        // applyButton
        NSLayoutConstraint.activate([
            applyButton.topAnchor.constraint(equalTo: filterFamilyMembersLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            applyButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            applyButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            applyButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            applyButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
        
        // resetButton
        NSLayoutConstraint.activate([
            resetButton.topAnchor.constraint(equalTo: applyButton.bottomAnchor, constant: Constant.Constraint.Spacing.contentSectionVert),
            resetButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset * 2.0),
            resetButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            resetButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            resetButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: view),
            resetButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }
    
}
//
//  LogsSortVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/4/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

// TODO QOL add a leave without save warning

protocol LogsSortDelegate: AnyObject {
    func didUpdateLogsSort(logsSort: LogsSort)
}

enum LogsSortDropDownTypes: String, HoundDropDownType {
    case sortField = "SortField"
    case sortDirection = "SortDirection"
}

class LogsSortVC: HoundScrollViewController,
                  HoundDropDownDataSource,
                  HoundDropDownManagerDelegate {
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
    // MARK: - Elements
    
    private let pageHeaderView: HoundPageSheetHeaderView = {
        let view = HoundPageSheetHeaderView(huggingPriority: 350, compressionResistancePriority: 350)
        view.pageHeaderLabel.text = "Sort"
        return view
    }()
    
    // TODO UI think of better names that "Field" and "Order" for this
    private let sortFieldHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Field"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    private lazy var sortFieldLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.shouldInsetText = true
        
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: LogsSortDropDownTypes.sortField,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .sortField, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    private lazy var sortFieldStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(sortFieldHeaderLabel)
        stack.addArrangedSubview(sortFieldLabel)
        return stack
    }()
    
    private let sortDirectionHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Order"
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        return label
    }()
    private lazy var sortDirectionLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.shouldInsetText = true
        
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: LogsSortDropDownTypes.sortDirection,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .sortDirection, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    private lazy var sortDirectionStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(sortDirectionHeaderLabel)
        stack.addArrangedSubview(sortDirectionLabel)
        return stack
    }()
    
    private lazy var applyButton: HoundButton = {
        let button = HoundButton(huggingPriority: 230, compressionResistancePriority: 230)
        
        button.setTitle("Apply", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBlue
        
        button.shouldRoundCorners = true
        
        button.shouldDismissParentViewController = true
        
        button.addTarget(self, action: #selector(didTapApply), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var resetButton: HoundButton = {
        let button = HoundButton(huggingPriority: 220, compressionResistancePriority: 220)
        
        button.setTitle("Reset", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.labelBorder)
        
        button.shouldDismissParentViewController = true
        
        button.addTarget(self, action: #selector(didTapReset), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var dropDownManager = HoundDropDownManager<LogsSortDropDownTypes>(
        rootView: containerView,
        dataSource: self,
        delegate: self
    )
    
    @objc private func didTapApply(_ sender: Any) {
        guard let sort = sort else { return }
        delegate?.didUpdateLogsSort(logsSort: sort)
    }
    
    @objc private func didTapReset(_ sender: Any) {
        sort?.reset()
        if let sort = sort {
            delegate?.didUpdateLogsSort(logsSort: sort)
        }
    }
    
    // MARK: - Properties
    
    private weak var delegate: LogsSortDelegate?
    
    private var sort: LogsSort?
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        self.enableSwipeBackToDismiss = true
        
        updateDynamicUIElements()
    }
    
    private var didSetupCustomSubviews: Bool = false
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard didSetupCustomSubviews == false else { return }
        
        didSetupCustomSubviews = true
        
        updateDynamicUIElements()
    }
    
    // MARK: - Setup
    
    func setup(delegate: LogsSortDelegate, sort: LogsSort) {
        self.delegate = delegate
        self.sort = (sort.copy() as? LogsSort) ?? self.sort
    }
    
    // MARK: - Functions
    
    private func updateDynamicUIElements() {
        if let sort = sort {
            sortFieldLabel.text = sort.sortField.readableValue
            sortDirectionLabel.text = sort.sortDirection.readableValue
        }
    }
    
    // MARK: - Drop Down
    
    @objc private func didTapScreen(sender: UITapGestureRecognizer) {
        dropDownManager.hideDropDownIfNotTapped(sender: sender)
    }
    
    func willShowDropDown(_ identifier: any HoundDropDownType, animated: Bool) {
        guard let sort = sort else { return }
        guard let type = identifier as? LogsSortDropDownTypes else { return }
        
        let rows: CGFloat = {
            switch type {
            case .sortField: return CGFloat(sort.availableFields.count)
            case .sortDirection: return CGFloat(sort.availableDirections.count)
            }
        }()
        
        dropDownManager.show(
            identifier: type,
            numberOfRowsToShow: min(6.5, rows),
            animated: animated
        )
    }
    
    // MARK: - Drop Down Data Source
    
    func setupCellForDropDown(cell: HoundDropDownTVC, indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let sort = sort else { return }
        guard let type = identifier as? LogsSortDropDownTypes else { return }
        switch type {
        case .sortField:
            let field = sort.availableFields[indexPath.row]
            cell.setCustomSelected(sort.sortField == field, animated: false)
            cell.label.text = field.readableValue
        case .sortDirection:
            let direction = sort.availableDirections[indexPath.row]
            cell.setCustomSelected(sort.sortDirection == direction, animated: false)
            cell.label.text = direction.readableValue
        }
    }
    
    func numberOfRows(section: Int, identifier: any HoundDropDownType) -> Int {
        guard let sort = sort else {
            return 0
        }
        guard let type = identifier as? LogsSortDropDownTypes else { return 0 }
        switch type {
        case .sortField:
            return sort.availableFields.count
        case .sortDirection:
            return sort.availableDirections.count
        }
    }
    
    func numberOfSections(identifier: any HoundDropDownType) -> Int {
        guard let type = identifier as? LogsSortDropDownTypes else { return 0 }
        switch type {
        case .sortField, .sortDirection:
            return 1
        }
    }
    
    func selectItemInDropDown(indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let sort = sort else { return }
        guard let type = identifier as? LogsSortDropDownTypes else { return }
        guard let dropDown = dropDownManager.dropDown(for: type) else { return }
        guard let cell = dropDown.dropDownTableView?.cellForRow(at: indexPath) as? HoundDropDownTVC else { return }
        
        switch type {
        case .sortField:
            let type = sort.availableFields[indexPath.row]
            
            // prevent deselection. we shuld always have one selected
            guard type != sort.sortField else {
                return
            }
            
            cell.setCustomSelected(true)
            sort.sortField = type
            dropDown.hideDropDown(animated: true)
        case .sortDirection:
            let type = sort.availableDirections[indexPath.row]
            
            // prevent deselection. we shuld always have one selected
            guard type != sort.sortDirection else {
                return
            }
            
            cell.setCustomSelected(true)
            sort.sortDirection = type
            dropDown.hideDropDown(animated: true)
        }
        updateDynamicUIElements()
    }
    
    func firstSelectedIndexPath(identifier: any HoundDropDownType) -> IndexPath? {
        guard let sort = sort else { return nil }
        guard let type = identifier as? LogsSortDropDownTypes else { return nil }
        switch type {
        case .sortField:
            if let idx = sort.availableFields
                .firstIndex(where: { $0 == sort.sortField }) {
                return IndexPath(row: idx, section: 0)
            }
        case .sortDirection:
            if let idx = sort.availableDirections
                .firstIndex(where: { $0 == sort.sortDirection }) {
                return IndexPath(row: idx, section: 0)
            }
        }
        return nil
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        containerView.addSubview(pageHeaderView)
        
        containerView.addSubview(sortFieldStack)
        
        containerView.addSubview(sortDirectionStack)
        
        containerView.addSubview(applyButton)
        containerView.addSubview(resetButton)
        
        let didTapScreenGesture = UITapGestureRecognizer(target: self, action: #selector(didTapScreen(sender:)))
        didTapScreenGesture.delegate = self
        didTapScreenGesture.cancelsTouchesInView = false
        view.addGestureRecognizer(didTapScreenGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        pageHeaderView.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.top)
            make.leading.equalTo(containerView.snp.leading)
            make.trailing.equalTo(containerView.snp.trailing)
        }
        
        sortFieldStack.snp.makeConstraints { make in
            make.top.equalTo(pageHeaderView.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.horizontalEdges.equalTo(containerView).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        sortFieldLabel.snp.makeConstraints { make in
            make.height.equalTo(containerView.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        
        sortDirectionStack.snp.makeConstraints { make in
            make.top.equalTo(sortFieldStack.snp.bottom).offset(Constant.Constraint.Spacing.contentSectionVert)
            make.horizontalEdges.equalTo(containerView).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        sortDirectionLabel.snp.makeConstraints { make in
            make.height.equalTo(containerView.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        
        applyButton.snp.makeConstraints { make in
            make.top.equalTo(sortDirectionStack.snp.bottom).offset(Constant.Constraint.Spacing.contentSectionVert)
            make.horizontalEdges.equalTo(containerView).inset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.height.equalTo(containerView.snp.width).multipliedBy(Constant.Constraint.Button.wideHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.wideMaxHeight)
        }
        
        resetButton.snp.makeConstraints { make in
            make.top.equalTo(applyButton.snp.bottom).offset(Constant.Constraint.Spacing.contentSectionVert)
            make.bottom.equalTo(containerView.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset)
            make.horizontalEdges.equalTo(containerView).inset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.height.equalTo(containerView.snp.width).multipliedBy(Constant.Constraint.Button.wideHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.wideMaxHeight)
        }
    }
    
}
//
//  LogsVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/17/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol LogsVCDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
}

// UI VERIFIED 6/25/25
final class LogsVC: HoundViewController,
                    LogsTableVCDelegate,
                    LogsAddLogDelegate,
                    LogsFilterDelegate, LogsSortDelegate {
    
    // MARK: - UIGestureRecognizerDelegate
    
    /// Allow multiple gesture recognizers to be recognized at once
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer,
                           shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
    // MARK: - LogsAddLogDelegate & LogsTableVCDelegate
    
    /// Called when the dogManager is updated from add-log or table view
    func didUpdateDogManager(sender: Sender, dogManager: DogManager) {
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    // MARK: - LogsTableVCDelegate
    
    /// Called when a log is selected in the table view
    func didSelectLog(dogUUID: UUID, log: Log) {
        let vc = LogsAddLogVC()
        logsAddLogViewController = vc
        vc.setup(
            delegate: self,
            dogManager: self.dogManager,
            dogUUIDToUpdate: dogUUID,
            logToUpdate: log
        )
        PresentationManager.enqueueViewController(vc)
    }
    
    /// Show or hide the “No logs recorded” label, and update its text based on dog count
    func shouldUpdateNoLogsRecorded(isHidden: Bool) {
        noLogsRecordedLabel.isHidden = isHidden
        guard !dogManager.dogs.isEmpty else {
            noLogsRecordedLabel.text = "No logs created yet!\n\nTry creating a dog and adding some logs to it..."
            return
        }
        
        if logsTableViewController.logsFilter.hasActiveFilter && familyHasAtLeastOneLog {
            noLogsRecordedLabel.text = "No logs found with the current filter!\n\nTry changing or clearing it..."
        }
        else if dogManager.dogs.count == 1, let dog = dogManager.dogs.first {
            noLogsRecordedLabel.text = "No logs created yet!\n\nTry adding some to \(dog.dogName)..."
        }
        else {
            noLogsRecordedLabel.text = "No logs created yet!\n\nTry adding some to one of your dogs..."
        }
    }
    
    /// Adjust button alphas and hide/show based on scroll offset and log availability
    func shouldUpdateAlphaForButtons(alpha: Double) {
        addLogButton.alpha = alpha
        exportLogsButton.alpha = alpha
        sortLogsButton.alpha = alpha
        filterLogsButton.alpha = alpha
        resetFilterAndSortButton.alpha = alpha
        
        addLogButton.isHidden = (addLogButton.alpha == 0.0) || dogManager.dogs.isEmpty
        exportLogsButton.isHidden = (exportLogsButton.alpha == 0.0) || !familyHasAtLeastOneLog
        sortLogsButton.isHidden = (sortLogsButton.alpha == 0.0) || !familyHasAtLeastOneLog
        updateFilterLogsButton()
        updateResetFilterAndSortButton()
    }
    
    func updateFilterLogsButton() {
        filterLogsButton.isHidden = (filterLogsButton.alpha == 0.0) || !familyHasAtLeastOneLog
    }
    
    func updateResetFilterAndSortButton() {
        resetFilterAndSortButton.isHidden = (resetFilterAndSortButton.alpha == 0.0) || !familyHasAtLeastOneLog || (!logsTableViewController.logsFilter.hasActiveFilter && !logsTableViewController.logsSort.hasActiveSort)
    }
    
    // MARK: - LogsFilterDelegate
    
    /// Pass updated filter to the logs table view controller
    func didUpdateLogsFilter(logsFilter: LogsFilter) {
        logsTableViewController.logsFilter = logsFilter
        UIView.animate(withDuration: Constant.Visual.Animation.showOrHideSingleElement) { [weak self] in
            guard let self = self else {
                return
            }
            filterLogsButton.badgeVisible = logsFilter.hasActiveFilter
            filterLogsButton.badgeValue = logsFilter.numActiveFilters
            updateResetFilterAndSortButton()
        }
    }
    
    // MARK: - LogsSortDelegate
    
    func didUpdateLogsSort(logsSort: LogsSort) {
        logsTableViewController.logsSort = logsSort
        UIView.animate(withDuration: Constant.Visual.Animation.showOrHideSingleElement) { [weak self] in
            guard let self = self else { return }
            if logsSort.sortDirection == .descending {
                self.sortLogsButton.imageView?.transform = .identity
            }
            else {
                self.sortLogsButton.imageView?.transform = CGAffineTransform(rotationAngle: .pi)
            }
            
            sortLogsButton.badgeVisible = logsSort.hasActiveSort
            updateResetFilterAndSortButton()
        }
    }
    
    // MARK: - Elements
    
    /// Container view to hold background or other layering (was UIContainerView in storyboard)
    let logsTableViewController: LogsTableVC = LogsTableVC(style: .grouped)
    
    /// Label displayed when no logs exist; hidden by default
    private let noLogsRecordedLabel: HoundLabel = {
        let label = HoundLabel()
        label.isHidden = true
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        label.textColor = UIColor.systemBlue
        return label
    }()
    
    private lazy var addLogButton: HoundButton = {
        let button = HoundButton(huggingPriority: 260, compressionResistancePriority: 260)
        
        button.setImage(UIImage(systemName: "plus.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.tintColor = UIColor.systemBlue
        button.backgroundCircleTintColor = UIColor.secondarySystemBackground
        
        let action = UIAction { [weak self] _ in
            guard let self = self else { return }
            
            let vc = LogsAddLogVC()
            vc.setup(delegate: self, dogManager: dogManager, dogUUIDToUpdate: nil, logToUpdate: nil)
            PresentationManager.enqueueViewController(vc)
        }
        button.addAction(action, for: .touchUpInside)
        
        return button
    }()
    
    private lazy var resetFilterAndSortButton: HoundButton = {
        let button = HoundButton(huggingPriority: 230, compressionResistancePriority: 230)
        
        button.tintColor = UIColor.systemRed
        button.setImage(
            UIImage(systemName: "xmark.circle.fill"),
            for: .normal
        )
        button.backgroundCircleTintColor = UIColor.secondarySystemBackground
        
        button.isHidden = true
        
        let action = UIAction { [weak self] _ in
            guard let self = self else { return }
            
            let filter = logsTableViewController.logsFilter
            filter.reset()
            didUpdateLogsFilter(logsFilter: filter)
            
            let sort = logsTableViewController.logsSort
            sort.reset()
            didUpdateLogsSort(logsSort: sort)
        }
        button.addAction(action, for: .touchUpInside)
        
        return button
    }()
    
    private lazy var filterLogsButton: HoundButton = {
        let button = HoundButton(huggingPriority: 240, compressionResistancePriority: 240)
        
        button.tintColor = UIColor.systemBlue
        button.setImage(
            UIImage(systemName: "line.3.horizontal.decrease.circle.fill"),
            for: .normal
        )
        button.backgroundCircleTintColor = UIColor.secondarySystemBackground
        
        let action = UIAction { [weak self] _ in
            guard let self = self else { return }
            
            let vc = LogsFilterVC()
            vc.setup(delegate: self, filter: logsTableViewController.logsFilter)
            PresentationManager.enqueueViewController(vc)
        }
        button.addAction(action, for: .touchUpInside)
        
        return button
    }()
    
    private lazy var sortLogsButton: HoundButton = {
        let button = HoundButton(huggingPriority: 240, compressionResistancePriority: 240)
        
        button.tintColor = UIColor.systemBlue
        button.setImage(
            UIImage(systemName: "arrow.down.circle.fill"),
            for: .normal
        )
        button.backgroundCircleTintColor = UIColor.secondarySystemBackground
        
        let action = UIAction { [weak self] _ in
            guard let self = self else { return }
            
            let vc = LogsSortVC()
            vc.setup(delegate: self, sort: logsTableViewController.logsSort)
            PresentationManager.enqueueViewController(vc)
        }
        button.addAction(action, for: .touchUpInside)
        
        return button
    }()
    
    /// Button to export logs; tint color and background set
    private lazy var exportLogsButton: HoundButton = {
        let button = HoundButton(huggingPriority: 250, compressionResistancePriority: 250)
        
        button.tintColor = UIColor.systemBlue
        button.setImage(
            UIImage(systemName: "square.and.arrow.up.circle.fill"),
            for: .normal
        )
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = UIColor.secondarySystemBackground
        
        let action = UIAction { [weak self] _ in
            guard let self = self else { return }
            
            var dogUUIDLogTuples: [(UUID, Log)] = []
            
            // Flatten the 2D array into a single array
            logsTableViewController.allLogsGroupedByDate.forEach {
                dogUUIDLogTuples += $0
            }
            
            ExportActivityViewManager.exportLogs(dogUUIDLogTuples: dogUUIDLogTuples)
        }
        button.addAction(action, for: .touchUpInside)
        
        return button
    }()
    
    /// Action for the export logs button; collects all logs and invokes export manager
    @objc private func didTouchUpInsideExportLogs(_ sender: Any) {
        
    }
    
    // MARK: - Properties
    
    /// Returns true if at least one dog has at least one log
    private var familyHasAtLeastOneLog: Bool {
        return dogManager.dogs.contains(where: { !$0.dogLogs.dogLogs.isEmpty })
    }
    
    private var logsAddLogViewController: LogsAddLogVC?
    
    private var logsFilterViewController: LogsFilterVC?
    
    private weak var delegate: LogsVCDelegate?
    
    // MARK: - Dog Manager
    
    private(set) var dogManager: DogManager = DogManager()
    
    /// Set the dogManager and update UI elements and child controllers
    func setDogManager(sender: Sender, dogManager: DogManager) {
        self.dogManager = dogManager
        
        addLogButton.isHidden = dogManager.dogs.isEmpty
        exportLogsButton.isHidden = !familyHasAtLeastOneLog
        filterLogsButton.isHidden = !familyHasAtLeastOneLog
        sortLogsButton.isHidden = !familyHasAtLeastOneLog
        
        if (sender.localized is LogsTableVC) == false {
            logsTableViewController.setDogManager(
                sender: Sender(origin: sender, localized: self),
                dogManager: dogManager
            )
        }
        if (sender.localized is MainTabBarController) == true {
            //            if logsAddLogViewController?.viewIfLoaded?.window == nil {
            //                // If add‐log VC isn’t currently visible, dismiss it when dog data changes
            //                logsAddLogViewController?.dismiss(animated: true)
            //            }
            // Dismiss filter VC if data changes, so filters remain valid
            //            logsFilterViewController?.dismiss(animated: true)
        }
        if (sender.localized is MainTabBarController) == false {
            delegate?.didUpdateDogManager(
                sender: Sender(origin: sender, localized: self),
                dogManager: dogManager
            )
        }
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        logsTableViewController.setup(delegate: self)
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        
        // don't use .maxY because this adds height + safe area inset, but logsTableVC already accounts for safe area inset, so that offsets it too much
        let exportButtonBottom = exportLogsButton.convert(exportLogsButton.bounds, to: view).height
        
        logsTableViewController.tableView.contentInset.top = exportButtonBottom + Constant.Constraint.Spacing.absoluteVertInset
        logsTableViewController.tableView.contentOffset.y = -view.safeAreaInsets.top - logsTableViewController.tableView.contentInset.top
        logsTableViewController.tableView.contentInset.bottom = Constant.Constraint.Spacing.absoluteVertInset
    }
    
    // MARK: - Setup
    
    func setup(delegate: LogsVCDelegate) {
        self.delegate = delegate
    }
    
    // MARK: - Setup Elements
    
    /// Add all subviews and set up targets
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.secondarySystemBackground
        super.setupGeneratedViews()
    }
    
    /// Add subviews and attach button targets immediately after each view is added
    override func addSubViews() {
        super.addSubViews()
        embedChild(logsTableViewController)
        
        view.addSubview(noLogsRecordedLabel)
        view.addSubview(addLogButton)
        
        view.addSubview(exportLogsButton)
        
        view.addSubview(resetFilterAndSortButton)
        view.addSubview(filterLogsButton)
        view.addSubview(sortLogsButton)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // logsTableViewController.view
        NSLayoutConstraint.activate([
            logsTableViewController.view.topAnchor.constraint(equalTo: view.topAnchor),
            logsTableViewController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            logsTableViewController.view.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            logsTableViewController.view.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        ])
        
        // addLogButton
        NSLayoutConstraint.activate([
            addLogButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteCircleHoriInset),
            addLogButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteCircleHoriInset),
            addLogButton.createSquareAspectRatio(),
            addLogButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier, relativeToWidthOf: view),
            addLogButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight)
        ])
        
        // exportLogsButton
        NSLayoutConstraint.activate([
            exportLogsButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            exportLogsButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteCircleHoriInset),
            exportLogsButton.createHeightMultiplier(Constant.Constraint.Button.circleHeightMultiplier, relativeToWidthOf: view),
            exportLogsButton.createMaxHeight(Constant.Constraint.Button.circleMaxHeight),
            exportLogsButton.createSquareAspectRatio()
        ])
        
        // sortLogsButton
        NSLayoutConstraint.activate([
            sortLogsButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            sortLogsButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteCircleHoriInset),
            sortLogsButton.createHeightMultiplier(Constant.Constraint.Button.circleHeightMultiplier, relativeToWidthOf: view),
            sortLogsButton.createMaxHeight(Constant.Constraint.Button.circleMaxHeight),
            sortLogsButton.createSquareAspectRatio()
        ])
        
        // filterLogsButton
        NSLayoutConstraint.activate([
            filterLogsButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            filterLogsButton.trailingAnchor.constraint(equalTo: sortLogsButton.leadingAnchor, constant: -Constant.Constraint.Spacing.contentTightIntraHori),
            filterLogsButton.createHeightMultiplier(Constant.Constraint.Button.circleHeightMultiplier, relativeToWidthOf: view),
            filterLogsButton.createMaxHeight(Constant.Constraint.Button.circleMaxHeight),
            filterLogsButton.createSquareAspectRatio()
        ])
        
        // resetFilterAndSortButton
        NSLayoutConstraint.activate([
            resetFilterAndSortButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            resetFilterAndSortButton.trailingAnchor.constraint(equalTo: filterLogsButton.leadingAnchor, constant: -Constant.Constraint.Spacing.contentTightIntraHori),
            resetFilterAndSortButton.createHeightMultiplier(Constant.Constraint.Button.circleHeightMultiplier, relativeToWidthOf: view),
            resetFilterAndSortButton.createMaxHeight(Constant.Constraint.Button.circleMaxHeight),
            resetFilterAndSortButton.createSquareAspectRatio()
        ])
        
        // noLogsRecordedLabel
        NSLayoutConstraint.activate([
            noLogsRecordedLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            noLogsRecordedLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            noLogsRecordedLabel.centerYAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerYAnchor)
        ])
    }
}
//
//  LogsTableVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/17/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol LogsTableVCDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
    func didSelectLog(dogUUID: UUID, log: Log)
    func shouldUpdateNoLogsRecorded(isHidden: Bool)
    func shouldUpdateAlphaForButtons(alpha: Double)
    func updateFilterLogsButton()
}

final class LogsTableVC: HoundTableViewController, LogTVCDelegate {
    
    // MARK: - LogTVCDelegate
    
    func didUpdateLogLikes(dogUUID: UUID, log: Log) {
        // TODO update dog manager n stuff
    }
    
    // MARK: - UIScrollViewDelegate
    
    override func scrollViewDidScroll(_ scrollView: UIScrollView) {
        guard let referenceContentOffsetY = referenceContentOffsetY else { return }
        
        // Sometimes the default contentOffset.y isn't 0.0; adjust it to 0.0
        let adjustedContentOffsetY = scrollView.contentOffset.y - referenceContentOffsetY
        // When contentOffset.y reaches alphaConstant, UI element's alpha becomes 0
        let alphaConstant: Double = 100.0
        let alpha: Double = max(1.0 - (adjustedContentOffsetY / alphaConstant), 0.0)
        delegate?.shouldUpdateAlphaForButtons(alpha: alpha)
    }
    
    // MARK: - Properties
    
    /// Array of tuples [[(dogUUID, log)]].
    /// Logs are grouped by date; first element is future, last is oldest.
    private(set) var allLogsGroupedByDate: [[(UUID, Log)]] = [] {
        didSet {
            delegate?.shouldUpdateNoLogsRecorded(isHidden: !allLogsGroupedByDate.isEmpty)
        }
    }
    
    private var storedLogsSort: LogsSort = LogsSort()
    var logsSort: LogsSort {
        get {
            storedLogsSort
        }
        set {
            self.storedLogsSort = newValue
            
            // Only reload data if view is visible; otherwise mark for later update
            guard self.viewIfLoaded?.window != nil else {
                tableViewDataSourceHasBeenUpdated = true
                return
            }
            
            reloadTable()
        }
    }
    
    private var storedLogsFilter: LogsFilter = LogsFilter(dogManager: DogManager())
    var logsFilter: LogsFilter {
        get {
            storedLogsFilter
        }
        set {
            self.storedLogsFilter = newValue
            
            // Only reload data if view is visible; otherwise mark for later update
            guard self.viewIfLoaded?.window != nil else {
                tableViewDataSourceHasBeenUpdated = true
                return
            }
            
            reloadTable()
        }
    }
    
    /// Track if we need to refresh data when view appears
    private var tableViewDataSourceHasBeenUpdated: Bool = false
    
    /// Allows temporarily disabling table reloads when setDogManager is called.
    private var allowReloadTable: Bool = true
    
    private weak var delegate: LogsTableVCDelegate?
    
    // MARK: Page Loader
    
    /// How many logs to load each time user scrolls to bottom
    private var logsDisplayedLimitIncrementation = 500
    /// Number of logs currently displayed; initial value is twice the incrementation
    lazy var logsDisplayedLimit: Int = logsDisplayedLimitIncrementation * 2
    
    // MARK: - Dog Manager
    
    private(set) var dogManager: DogManager = DogManager()
    
    /// Update dogManager and refresh UI accordingly
    func setDogManager(sender: Sender, dogManager: DogManager) {
        self.dogManager = dogManager
        logsFilter.apply(dogManager: dogManager)
        
        if (sender.localized is LogsTableVC) == true {
            delegate?.didUpdateDogManager(sender: Sender(origin: sender, localized: self), dogManager: dogManager)
        }
        
        reloadTable()
        
        delegate?.updateFilterLogsButton()
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // self.enableDummyHeaderView = true
        self.tableView.register(LogTVC.self, forCellReuseIdentifier: LogTVC.reuseIdentifier)
        // tableView.contentInset is set in LogsVC
        
        self.tableView.refreshControl = UIRefreshControl()
        self.tableView.refreshControl?.addTarget(self, action: #selector(refreshTableData), for: .valueChanged)
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        // If data was updated offscreen, reload table now
        if tableViewDataSourceHasBeenUpdated {
            reloadTable()
            tableViewDataSourceHasBeenUpdated = false
        }
        else {
            reloadTable()
        }
    }
    
    // MARK: - Setup
    
    func setup(delegate: LogsTableVCDelegate) {
        self.delegate = delegate
    }
    
    // MARK: - Functions
    
    /// Fetch new logs from server, then reload table
    @objc private func refreshTableData() {
        PresentationManager.beginFetchingInformationIndicator()
        DogsRequest.get(
            errorAlert: .automaticallyAlertOnlyForFailure,
            dogManager: dogManager
        ) { newDogManager, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                // End refresh animation first to avoid visual glitch
                self.tableView.refreshControl?.endRefreshing()
                
                guard responseStatus != .failureResponse, let newDogManager = newDogManager else {
                    return
                }
                
                if responseStatus == .successResponse {
                    PresentationManager.enqueueBanner(
                        title: Constant.Visual.BannerText.successRefreshLogsTitle,
                        subtitle: Constant.Visual.BannerText.successRefreshLogsSubtitle,
                        style: .success
                    )
                }
                else {
                    if OfflineModeManager.shared.hasDisplayedOfflineModeBanner == true {
                        // Only show if offline banner already shown
                        PresentationManager.enqueueBanner(
                            title: Constant.Visual.BannerText.infoRefreshOnHoldTitle,
                            subtitle: Constant.Visual.BannerText.infoRefreshOnHoldSubtitle,
                            style: .info
                        )
                    }
                }
                
                self.setDogManager(
                    sender: Sender(origin: self, localized: self),
                    dogManager: newDogManager
                )
            }
        }
    }
    
    private func refreshVisibleCells() {
        for cell in tableView.visibleCells {
            guard let indexPath = tableView.indexPath(for: cell),
                  let logCell = cell as? LogTVC else { continue }
            let (dogUUID, log) = allLogsGroupedByDate[indexPath.section][indexPath.row]
            guard let dog = dogManager.findDog(dogUUID: dogUUID) else { continue }
            logCell.setup(delegate: self, dogName: dog.dogName, dogUUID: dogUUID, log: log, sort: logsSort, filter: logsFilter)
        }
    }
    
    private func reloadTable() {
        // Avoid recomputation if no logs
        allLogsGroupedByDate = dogManager.allLogsGroupedByDate(filter: logsFilter, sort: logsSort, limit: logsDisplayedLimit)
        tableView.isUserInteractionEnabled = !allLogsGroupedByDate.isEmpty
        guard allowReloadTable else { return }
        tableView.reloadData()
        DispatchQueue.main.async { [weak self] in
            self?.refreshVisibleCells()
        }
    }
    
    func scrollToTop(animated: Bool) {
        guard let referenceContentOffsetY = referenceContentOffsetY else { return }
        tableView.setContentOffset(CGPoint(x: 0, y: referenceContentOffsetY), animated: animated)
    }
    
    override func didUpdateUserTimeZone() {
        reloadTable()
    }
    
    // MARK: - Table View Data Source
    
    override func numberOfSections(in tableView: UITableView) -> Int {
        return allLogsGroupedByDate.count
    }
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        // No logs => no rows
        guard !allLogsGroupedByDate.isEmpty else {
            return 0
        }
        
        return allLogsGroupedByDate[section].count
    }
    
    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = HoundTableHeaderFooterView()
        
        // all of these logs are of the same day (for whatever day were grouping by)
        let logForSection = allLogsGroupedByDate[section].first?.1
        guard let log = logForSection else {
            return headerView
        }
        // depending upon what field were sorting by, this dictates the header
        let date = self.logsSort.sortField.date(log)
        let currentYear = Calendar.user.component(.year, from: Date())
        let dateYear = Calendar.user.component(.year, from: date)
        
        // today
        if Calendar.user.isDateInToday(date) {
            headerView.setTitle("Today")
        }
        // yesterday
        else if Calendar.user.isDateInYesterday(date) {
            headerView.setTitle("Yesterday")
        }
        else if Calendar.user.isDateInTomorrow(date) {
            headerView.setTitle("Tomorrow")
        }
        else {
            // Wednesday, January 25 or Wednesday, January 25 2023
            let template = dateYear == currentYear ? "EEEEMMMMd" : "EEEEMMMMdyyyy"
            headerView.setTitle(date.houndFormatted(.template(template), displayTimeZone: UserConfiguration.timeZone))
        }
        
        return headerView
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard !allLogsGroupedByDate.isEmpty else {
            return HoundTableViewCell()
        }
        
        let (dogUUID, log) = allLogsGroupedByDate[indexPath.section][indexPath.row]
        
        guard let dog = dogManager.findDog(dogUUID: dogUUID) else {
            return HoundTableViewCell()
        }
        
        guard let cell = tableView.dequeueReusableCell(
            withIdentifier: LogTVC.reuseIdentifier,
            for: indexPath
        ) as? LogTVC else {
            return HoundTableViewCell()
        }
        
        cell.setup(delegate: self, dogName: dog.dogName, dogUUID: dogUUID, log: log, sort: logsSort, filter: logsFilter)
        
        // Reset rounding before applying new corners
        cell.containerView.roundCorners(setCorners: .none)
        
        // Top cell: round top corners
        if indexPath.row == 0 {
            cell.containerView.roundCorners(addCorners: .top)
        }
        // Bottom cell: round bottom corners
        if indexPath.row == allLogsGroupedByDate[indexPath.section].count - 1 {
            cell.containerView.roundCorners(addCorners: .bottom)
        }
        
        return cell
    }
    
    // Allow swipe-to-delete
    override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        return true
    }
    
    // Handle deletion of a log
    override func tableView(
        _ tableView: UITableView,
        commit editingStyle: UITableViewCell.EditingStyle,
        forRowAt indexPath: IndexPath
    ) {
        guard editingStyle == .delete else { return }
        
        let (dogUUID, log) = allLogsGroupedByDate[indexPath.section][indexPath.row]
        
        LogsRequest.delete(
            errorAlert: .automaticallyAlertOnlyForFailure,
            dogUUID: dogUUID,
            logUUID: log.logUUID
        ) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                return
            }
            
            let previousLogs = self.allLogsGroupedByDate
            
            self.dogManager.findDog(dogUUID: dogUUID)?
                .dogLogs.removeLog(logUUID: log.logUUID)
            
            self.allowReloadTable = false
            self.setDogManager(
                sender: Sender(origin: self, localized: self),
                dogManager: self.dogManager
            )
            self.allowReloadTable = true
            
            let newLogs = self.allLogsGroupedByDate
            self.tableView.isUserInteractionEnabled = !newLogs.isEmpty
            
            if previousLogs[indexPath.section].count > 1 && indexPath.row == previousLogs[indexPath.section].count - 1 {
                // there is an above log and it needs its corners counred since its the new bottom
                let aboveLogCell = self.tableView.cellForRow(at: IndexPath(row: indexPath.row - 1, section: indexPath.section)) as? LogTVC
                UIView.animate(withDuration: Constant.Visual.Animation.showOrHideSingleElement) {
                    aboveLogCell?.containerView.roundCorners(addCorners: .bottom)
                }
            }
            
            self.tableView.beginUpdates()
            if previousLogs[indexPath.section].count == 1 {
                self.tableView.deleteSections([indexPath.section], with: .automatic)
            }
            else {
                self.tableView.deleteRows(at: [indexPath], with: .automatic)
            }
            self.tableView.endUpdates()
            
            UIView.animate(withDuration: Constant.Visual.Animation.moveMultipleElements) {
                self.view.setNeedsLayout()
                self.view.layoutIfNeeded()
            }
        }
    }
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let (dogUUID, log) = allLogsGroupedByDate[indexPath.section][indexPath.row]
        
        PresentationManager.beginFetchingInformationIndicator()
        LogsRequest.get(
            errorAlert: .automaticallyAlertOnlyForFailure,
            dogUUID: dogUUID,
            log: log
        ) { responseLog, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                self.tableView.deselectRow(at: indexPath, animated: true)
                
                guard responseStatus != .failureResponse else {
                    return
                }
                
                guard let responseLog = responseLog else {
                    // Log was deleted on server; update local manager
                    self.dogManager.findDog(dogUUID: dogUUID)?.dogLogs.removeLog(logUUID: log.logUUID)
                    self.setDogManager(
                        sender: Sender(origin: self, localized: self),
                        dogManager: self.dogManager
                    )
                    return
                }
                
                self.delegate?.didSelectLog(dogUUID: dogUUID, log: responseLog)
            }
        }
    }
    
    private var isLoadingMoreLogs = false
    
    override func tableView(
        _ tableView: UITableView,
        willDisplay cell: UITableViewCell,
        forRowAt indexPath: IndexPath
    ) {
        guard !isLoadingMoreLogs else { return }
        // Check if user has scrolled near bottom to load more logs
        var possibleLogsDisplayed = 0
        var currentLogsDisplayed = 0
        
        for (index, array) in allLogsGroupedByDate.enumerated() {
            possibleLogsDisplayed += array.count
            if index <= indexPath.section {
                currentLogsDisplayed += array.count
            }
        }
        
        // If at limit and near bottom, increase limit and reload
        guard possibleLogsDisplayed >= logsDisplayedLimit && currentLogsDisplayed >= (possibleLogsDisplayed - logsDisplayedLimitIncrementation)
        else { return }
        
        isLoadingMoreLogs = true
        logsDisplayedLimit += logsDisplayedLimitIncrementation
        
        DispatchQueue.main.async { [weak self] in
            self?.reloadTable()
            self?.isLoadingMoreLogs = false
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        tableView.backgroundColor = UIColor.secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
    }
    
    override func setupConstraints() {
        super.setupConstraints()
    }
}
//
//  LogTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/18/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

protocol LogTVCDelegate: AnyObject {
    func didUpdateLogLikes(dogUUID: UUID, log: Log)
}

// TODO BUG there some weird stuff w the collection view going on
// if you sort by an odd way then spam refresh, every refresh the info bubbles update with different info

final class LogTVC: HoundTableViewCell, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
    
    // MARK: - UICollectionViewDataSource
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return infoItems.count
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: LogInfoBubbleCVC.reuseIdentifier, for: indexPath) as? LogInfoBubbleCVC else {
            return UICollectionViewCell()
        }
        cell.setup(text: infoItems[indexPath.item])
        
        let layout = collectionView.collectionViewLayout as? UICollectionViewFlowLayout
        let sectionInset = layout?.sectionInset ?? .zero
        let maxWidth = collectionView.bounds.width - sectionInset.left - sectionInset.right
        cell.setMaxWidth(maxWidth)
        
        return cell
    }
    
    // MARK: - Elements
    
    let containerView: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.systemBackground
        return view
    }()
    
    private let logActionIconLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.textAlignment = .center
        // same as ReminderTVC
        label.font = UIFont.systemFont(ofSize: 42.5, weight: .medium)
        return label
    }()
    
    private let dogNameLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.font = Constant.Visual.Font.emphasizedPrimaryRegularLabel
        return label
    }()
    private let logStartToEndDateLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.textAlignment = .right
        label.font = Constant.Visual.Font.secondaryRegularLabel
        return label
    }()
    private lazy var dogNameLogDateStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(dogNameLabel)
        stack.addArrangedSubview(logStartToEndDateLabel)
        stack.axis = .horizontal
        stack.spacing = Constant.Constraint.Spacing.contentIntraHori
        stack.alignment = .center
        return stack
    }()
    
    private lazy var logActionTextLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.font = Constant.Visual.Font.primaryRegularLabel
        return label
    }()
    private let logDurationLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.textAlignment = .right
        label.font = Constant.Visual.Font.secondaryRegularLabel
        return label
    }()
    private lazy var logActionLogDurationStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logActionTextLabel)
        stack.addArrangedSubview(logDurationLabel)
        stack.axis = .horizontal
        stack.spacing = Constant.Constraint.Spacing.contentIntraHori
        stack.alignment = .center
        return stack
    }()
    
    private lazy var dogNameLogDateLogActionLogDurationStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(dogNameLogDateStack)
        stack.addArrangedSubview(logActionLogDurationStack)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    
    private lazy var topStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logActionIconLabel)
        stack.addArrangedSubview(dogNameLogDateLogActionLogDurationStack)
        stack.axis = .horizontal
        stack.spacing = Constant.Constraint.Spacing.contentIntraHori
        stack.distribution = .fill
        stack.alignment = .center
        return stack
    }()
    
    private lazy var likeButton: HoundButton = {
        let button = HoundButton(type: .system)
        // TODO UI make this a better color
        button.tintColor = .systemGray2
        
        let action = UIAction { [weak self] _  in
            guard let self = self else { return }
            guard let dogUUID = self.dogUUID, let log = self.log else { return }
            guard let userId = UserInformation.userId else { return }
            
            let currentlyLiked = log.likedByUserIds.contains(userId)
            log.setLogLike(!currentlyLiked)
            delegate?.didUpdateLogLikes(dogUUID: dogUUID, log: log)
            updateLikeButtonBadge(animated: true)
            
            button.isEnabled = false
            LogsRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, log: log) { responseStatus, _ in
                button.isEnabled = true
                // if success response or no response, then its fine and acceptable (offline mode can handle it)
                guard responseStatus == .failureResponse else {
                    return
                }
                
                // undo the like b/c it failed
                log.setLogLike(currentlyLiked)
                self.delegate?.didUpdateLogLikes(dogUUID: dogUUID, log: log)
                self.updateLikeButtonBadge(animated: true)
            }
        }
        
        button.addAction(action, for: .touchUpInside)
        return button
    }()
    
    private lazy var infoBubbleCollectionView: UICollectionView = {
        let layout = HoundLeftAlignedCollectionViewFlowLayout()
        layout.minimumInteritemSpacing = Constant.Constraint.Spacing.contentIntraHori
        layout.minimumLineSpacing = Constant.Constraint.Spacing.contentIntraVert
        layout.estimatedItemSize = UICollectionViewFlowLayout.automaticSize
        layout.scrollDirection = .vertical

        let collectionView = HoundIntrinsicCollectionView(frame: .zero, collectionViewLayout: layout)
        collectionView.backgroundColor = .clear
        collectionView.register(LogInfoBubbleCVC.self, forCellWithReuseIdentifier: LogInfoBubbleCVC.reuseIdentifier)
        collectionView.isScrollEnabled = false
        collectionView.dataSource = self
        collectionView.delegate = self
        
        return collectionView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "LogTVC"
    
    private var infoItems: [String] = []
    
    private weak var delegate: LogTVCDelegate?
    private var dogUUID: UUID?
    private var log: Log?
    
    // MARK: - Setup
    
    /// Configure the cell’s labels and adjust dynamic constraints based on the provided Log
    func setup(delegate: LogTVCDelegate, dogName: String, dogUUID: UUID, log: Log, sort: LogsSort, filter: LogsFilter) {
        self.delegate = delegate
        self.dogUUID = dogUUID
        self.log = log
        
        // depending on the different sort methods, the logs displayed will be grouped and displayed by different dates, thus affecting the headers (e.g. you have a group "Today" of logs but that could be Today for start date, or created date, etc...
        // thus if times are relative, e.g. 8:50AM, they need to be relative to this header
        let cellGroupedByDate = sort.sortField.date(log)
        
        func convertDateToRelative(_ convert: Date) -> String {
            if Calendar.user.isDate(convert, inSameDayAs: cellGroupedByDate) {
                // date is same day as the header for this grouping of logs in the table
                // e.g. both may 15th, so we can simply display 8:50AM
                return convert.houndFormatted(.formatStyle(date: .omitted, time: .shortened), displayTimeZone: UserConfiguration.timeZone)
            }
            else {
                // date is a different day/month and potentially year from the header
                // e.g. this grouping is for may 15th but this date is from may 25th
                let cellGroupedByDateYear = Calendar.user.component(.year, from: cellGroupedByDate)
                let currentYear = Calendar.user.component(.year, from: Date())
                return convert.houndFormatted(.template(cellGroupedByDateYear == currentYear ? "MMMd" : "MMMdyy"), displayTimeZone: UserConfiguration.timeZone)
            }
        }
        
        logActionIconLabel.text = log.logActionType.emoji
        
        dogNameLabel.text = dogName
        
        logActionTextLabel.text = log.logActionType.convertToReadableName(customActionName: log.logCustomActionName, includeMatchingEmoji: false)
        
        // e.g., “7:53 AM”
        logStartToEndDateLabel.text = convertDateToRelative(log.logStartDate)
        
        if let logEndDate = log.logEndDate {
            logStartToEndDateLabel.text = logStartToEndDateLabel.text?.appending(" - \(convertDateToRelative(logEndDate))")
        }
        
        logDurationLabel.text = {
            guard let logEndDate = log.logEndDate else {
                return nil
            }
            return log.logStartDate.distance(to: logEndDate).readable(capitalizeWords: false, abbreviationLevel: .short, maxComponents: 2, enforceSequentialComponents: true)
        }()
        
        updateLikeButtonBadge(animated: false)
        
        infoItems = []
        if sort.sortField == .createdDate || filter.timeRangeField == .createdDate {
            let dateString = convertDateToRelative(log.logCreated)
            infoItems.append("Created: \(dateString)")
        }
        if sort.sortField == .modifiedDate || filter.timeRangeField == .modifiedDate {
            let dateString = convertDateToRelative(log.logLastModified ?? log.logCreated)
            infoItems.append("Modified: \(dateString)")
        }
        if let unitType = log.logUnitType, let numUnits = log.logNumberOfLogUnits, let unit = unitType.pluralReadableValueWithNumUnits(logNumberOfLogUnits: numUnits) {
            infoItems.append(unit)
        }
        let trimmedNote = log.logNote.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedNote.isEmpty == false {
            infoItems.append(trimmedNote)
        }
        
        remakeInfoBubbleConstraints()
        
        remakeLikeButtonConstraints()
    }
    
    // MARK: - Functions
    
    private func updateLikeButtonBadge(animated: Bool) {
        UIView.animate(withDuration: animated ? Constant.Visual.Animation.selectSingleElement : 0.0) {
            if let userId = UserInformation.userId, self.log?.likedByUserIds.contains(userId) == true {
                self.likeButton.setImage(UIImage(systemName: "heart.fill"), for: .normal)
            }
            else {
                self.likeButton.setImage(UIImage(systemName: "heart"), for: .normal)
            }
            self.likeButton.badgeValue = self.log?.likedByUserIds.count
            self.likeButton.badgeVisible = self.log?.likedByUserIds.isEmpty == false
        }
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(topStack)
        containerView.addSubview(infoBubbleCollectionView)
        containerView.addSubview(likeButton)
    }
    
    private func remakeLikeButtonConstraints() {
        let shouldBeInStack = infoItems.isEmpty && logDurationLabel.text == nil

        likeButton.snp.remakeConstraints { make in
            if shouldBeInStack {
                // TODO TEST this might become funky for big screen sizes and overlap with stuff
                make.centerY.equalTo(logActionLogDurationStack.snp.centerY)
            }
            else {
                make.top.greaterThanOrEqualTo(topStack.snp.bottom).offset(Constant.Constraint.Spacing.contentTightIntraVert)
                make.leading.equalTo(infoBubbleCollectionView.snp.trailing).offset(Constant.Constraint.Spacing.contentIntraHori)
            }
            make.bottom.equalTo(containerView.snp.bottom).inset(Constant.Constraint.Spacing.contentIntraVert)
            make.trailing.equalTo(containerView.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
            
            make.height.equalTo(contentView.snp.width).multipliedBy(Constant.Constraint.Button.tinyHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.tinyMaxHeight)
            make.width.equalTo(likeButton.snp.height)
        }
    }
    
    private func remakeInfoBubbleConstraints() {
        // topStack can conflict with infoBubbleCollectionView before its remade
        infoBubbleCollectionView.snp.removeConstraints()
        
        infoBubbleCollectionView.isHidden = infoItems.isEmpty
        
        infoBubbleCollectionView.snp.makeConstraints { make in
            make.leading.equalTo(containerView).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }

        guard !infoItems.isEmpty else {
            return
        }

        infoBubbleCollectionView.snp.makeConstraints { make in
            make.top.equalTo(topStack.snp.bottom).offset(Constant.Constraint.Spacing.contentIntraVert)
            make.bottom.equalTo(containerView.snp.bottom).inset(Constant.Constraint.Spacing.contentIntraVert)
        }
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        containerView.snp.makeConstraints { make in
            make.top.equalTo(contentView.snp.top)
            // Use .high priority to avoid breaking during table view height estimation
            make.bottom.equalTo(contentView.snp.bottom).priority(.high)
            make.horizontalEdges.equalTo(contentView.snp.horizontalEdges).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        topStack.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.top).offset(Constant.Constraint.Spacing.contentIntraVert)
            make.leading.trailing.equalTo(containerView).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        remakeInfoBubbleConstraints()
        
        remakeLikeButtonConstraints()
    }
    
}
//  LogsAddLogVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/30/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

protocol LogsAddLogDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
}

enum LogsAddLogDropDownTypes: String, HoundDropDownType {
    case parentDog = "DropDownParentDog"
    case logActionType = "DropDownLogAction"
    case logUnit = "DropDownLogUnit"
    case logStartDate = "DropDownLogStartDate"
    case logEndDate = "DropDownLogEndDate"
}

final class LogsAddLogVC: HoundScrollViewController,
                          UITextFieldDelegate,
                          UITextViewDelegate,
                          HoundDropDownDataSource, HoundDropDownManagerDelegate {
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
    // MARK: - UITextFieldDelegate
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        if textField.isEqual(logCustomActionNameTextField) {
            showNextRequiredDropDown(animated: true)
        }
        dismissKeyboard()
        return false
    }
    
    func textFieldDidBeginEditing(_ textField: UITextField) {
        scrollDescendantViewToVisibleIfNeeded(textField)
    }
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        if textField.isEqual(logCustomActionNameTextField) {
            return processLogCustomActionNameTextField(shouldChangeCharactersIn: range, replacementString: string)
        }
        else if textField.isEqual(logNumberOfLogUnitsTextField) {
            return processLogNumberOfLogUnitsTextField(shouldChangeCharactersIn: range, replacementString: string)
        }
        
        return false
    }
    
    private func processLogCustomActionNameTextField(shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        guard let currentText = logCustomActionNameTextField.text, let stringRange = Range(range, in: currentText) else {
            return true
        }
        
        let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
        
        return updatedText.count <= Constant.Class.Log.logCustomActionNameCharacterLimit
    }
    
    private func processLogNumberOfLogUnitsTextField(shouldChangeCharactersIn newRange: NSRange, replacementString newString: String) -> Bool {
        guard let previousText = logNumberOfLogUnitsTextField.text, let newStringRange = Range(newRange, in: previousText) else {
            return true
        }
        
        var updatedText = previousText.replacingCharacters(in: newStringRange, with: newString)
        
        // The user can delete whatever they want. We only want to check when they add a character
        guard updatedText.count > previousText.count else {
            return true
        }
        
        // when a user inputs number of logs, it should not have a grouping separator, e.g. 12,345.67 should just be 12345.67
        updatedText = updatedText.replacingOccurrences(of: Locale.current.groupingSeparator ?? ",", with: "")
        
        // number of logs units is a decimal so it can only contain 0-9 and a period (also technically a , for countries that use that instead of a .)
        let decimalSeparator: Character = Locale.current.decimalSeparator?.first ?? "."
        
        var acceptableCharacters = "0123456789"
        acceptableCharacters.append(decimalSeparator)
        
        var containsInvalidCharacter = false
        updatedText.forEach { character in
            if acceptableCharacters.firstIndex(of: character) == nil {
                containsInvalidCharacter = true
            }
        }
        guard containsInvalidCharacter == false else {
            return false
        }
        
        // MARK: Verify period/command count
        let occurancesOfDecimalSeparator = {
            var count = 0
            updatedText.forEach { char in
                if char == decimalSeparator {
                    count += 1
                }
            }
            return count
        }()
        
        if occurancesOfDecimalSeparator > 1 {
            // If updated text has more than one period/comma, it will be an invalid decimal number
            return false
        }
        
        // MARK: Verify number of digits after period or comma
        let maxComponentsBeforeDecimalSeparator = 5
        let maxComponentsAfterDecimalSeparator = 2
        let splitText = updatedText.split(separator: decimalSeparator)
        
        if occurancesOfDecimalSeparator == 0, let component = splitText.first {
            // e.g. text is "xxx" with no separator
            if component.count > maxComponentsBeforeDecimalSeparator {
                return false
            }
        }
        else if splitText.count == 1, let component = splitText.first {
            // e.g. text is either "xx." or ".xx" with the separator at the exact from or end
            if updatedText.last == decimalSeparator {
                // e.g. text is "xx."
                if component.count > maxComponentsBeforeDecimalSeparator {
                    return false
                }
            }
            else if updatedText.first == decimalSeparator {
                // e.g. text is ".xx"
                if component.count > maxComponentsAfterDecimalSeparator {
                    return false
                }
            }
        }
        else if splitText.count == 2 {
            // e.g. text is "123.456" with separator in the middle
            if let componentBeforeDecimalSeparator = splitText[safe: 0] {
                // "123"
                // We only want to allow five numbers before the decimal place
                if componentBeforeDecimalSeparator.count > maxComponentsBeforeDecimalSeparator {
                    return false
                }
            }
            if let componentAfterDecimalSeparator = splitText[safe: 1] {
                // "456"
                if componentAfterDecimalSeparator.count > maxComponentsAfterDecimalSeparator {
                    return false
                }
            }
        }
        
        // At the end of the function, update the text field's text to the updated text
        logNumberOfLogUnitsTextField.text = updatedText
        // Return false because we manually set the text field's text
        return false
    }
    
    // MARK: - UITextViewDelegate
    
    func textViewDidBeginEditing(_ textView: UITextView) {
        scrollDescendantViewToVisibleIfNeeded(textView)
    }
    
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        // Don't allow the user to add a new line. If they do, we interpret that as the user hitting the done button.
        guard text != "\n" else {
            dismissKeyboard()
            return false
        }
        
        let currentText = textView.text ?? ""
        
        guard let stringRange = Range(range, in: currentText) else { return false }
        
        let updatedText = currentText.replacingCharacters(in: stringRange, with: text)
        
        return updatedText.count <= Constant.Class.Log.logNoteCharacterLimit
    }
    
    // if extra space is added, removes it and ends editing, makes done button function like done instead of adding new line
    func textViewDidChange(_ textView: UITextView) {
        if textView.text.contains("\n") {
            textView.text = textView.text.trimmingCharacters(in: .newlines)
            dismissKeyboard()
        }
    }
    
    // MARK: - LogsAddLogUIInteractionActionsDelegate
    
    func logNoteDidBeginEditing() {
        let convertedFrame = containerView.convert(logNoteTextView.frame, from: logNoteTextView.superview)
        scrollView.scrollRectToVisible(convertedFrame.insetBy(dx: 0, dy: Constant.Constraint.Spacing.absoluteVertInset), animated: true)
    }
    
    // MARK: - Elements
    
    // MARK: editPageHeaderView
    private lazy var editPageHeaderView: HoundEditPageHeaderView = {
        let view = HoundEditPageHeaderView(huggingPriority: 300, compressionResistancePriority: 300)
        
        view.trailingButton.setImage(UIImage(systemName: "trash.circle"), for: .normal)
        
        view.trailingButton.addTarget(self, action: #selector(didTouchUpInsideRemoveLog), for: .touchUpInside)
        
        return view
    }()
    
    // MARK: familyMemberLabel
    private lazy var familyMemberHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "Logged by"
        return label
    }()
    private lazy var familyMemberLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 285, compressionResistancePriority: 285)
        label.applyStyle(.thinGrayBorder)
        // only for showing family member, not actually editable
        label.isEnabled = false
        label.shouldInsetText = true
        return label
    }()
    private lazy var familyMemberDescriptionLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        return label
    }()
    private lazy var familyMemberStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(familyMemberHeaderLabel)
        stack.addArrangedSubview(familyMemberLabel)
        stack.addArrangedSubview(familyMemberDescriptionLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    
    // MARK: parentDogLabel
    private lazy var parentDogHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        // label.text set in setup
        return label
    }()
    private lazy var parentDogLabel: HoundLabel = {
        let label = HoundLabel()
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a dog (or dogs)..."
        label.shouldInsetText = true
        
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(dropDownManager.showHideDropDownGesture(identifier: LogsAddLogDropDownTypes.parentDog, delegate: self))
        dropDownManager.register(identifier: .parentDog, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    private lazy var parentDogStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(parentDogHeaderLabel)
        stack.addArrangedSubview(parentDogLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    
    // MARK: logActionLabel
    private lazy var logActionHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "What action did you perform?"
        return label
    }()
    private lazy var logActionLabel: HoundLabel = {
        let label = HoundLabel()
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select an action..."
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(dropDownManager.showHideDropDownGesture(identifier: LogsAddLogDropDownTypes.logActionType, delegate: self))
        dropDownManager.register(identifier: .logActionType, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    private lazy var logActionStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logActionHeaderLabel)
        stack.addArrangedSubview(logActionLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    
    // MARK: logCustomActionNameTextField
    private lazy var logCustomActionNameHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "What would you like to call this action?"
        return label
    }()
    private lazy var logCustomActionNameTextField: HoundTextField = {
        let textField = HoundTextField()
        textField.delegate = self
        textField.applyStyle(.thinGrayBorder)
        textField.placeholder = "Add a custom name... (optional)"
        textField.shouldInsetText = true
        return textField
    }()
    private lazy var logCustomActionNameStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logCustomActionNameHeaderLabel)
        stack.addArrangedSubview(logCustomActionNameTextField)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    
    // MARK: logStartDate
    private lazy var logStartDateHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "When did it happen?"
        return label
    }()
    private lazy var logStartDateLabel: HoundLabel = {
        let label = HoundLabel()
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a start date..."
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(dropDownManager.showHideDropDownGesture(identifier: LogsAddLogDropDownTypes.logStartDate, delegate: self))
        dropDownManager.register(identifier: .logStartDate, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    private lazy var logStartDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker()
        datePicker.datePickerMode = .dateAndTime
        datePicker.minuteInterval = 1
        datePicker.preferredDatePickerStyle = .wheels
        
        datePicker.addTarget(self, action: #selector(didUpdateLogStartDate), for: .valueChanged)
        
        return datePicker
    }()
    private lazy var nestedLogStartDateStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logStartDateLabel)
        stack.addArrangedSubview(logStartDatePicker)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    private lazy var logStartDateStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logStartDateHeaderLabel)
        stack.addArrangedSubview(nestedLogStartDateStack)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    
    // MARK: logEndDate
    private lazy var logEndDateHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "When did it end?"
        return label
    }()
    private lazy var logEndDateLabel: HoundLabel = {
        let label = HoundLabel()
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select an end date... (optional)"
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(dropDownManager.showHideDropDownGesture(identifier: LogsAddLogDropDownTypes.logEndDate, delegate: self))
        dropDownManager.register(identifier: .logEndDate, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    private lazy var logEndDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker()
        datePicker.datePickerMode = .dateAndTime
        datePicker.minuteInterval = 1
        datePicker.preferredDatePickerStyle = .wheels
        
        datePicker.addTarget(self, action: #selector(didUpdateLogEndDate), for: .valueChanged)
        
        return datePicker
    }()
    private lazy var nestedLogEndDateStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logEndDateLabel)
        stack.addArrangedSubview(logEndDatePicker)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    private lazy var logEndDateStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logEndDateHeaderLabel)
        stack.addArrangedSubview(nestedLogEndDateStack)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    
    // MARK: logUnit
    private lazy var logUnitHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "How many units?"
        return label
    }()
    private lazy var logNumberOfLogUnitsTextField: HoundTextField = {
        let textField = HoundTextField()
        textField.delegate = self
        textField.applyStyle(.thinGrayBorder)
        textField.placeholder = "0" + (Locale.current.decimalSeparator ?? ".") + "0"
        
        textField.textAlignment = .center
        textField.keyboardType = .decimalPad
        
        textField.addTarget(self, action: #selector(didUpdateLogNumberOfLogUnits), for: .editingChanged)
        
        return textField
    }()
    private lazy var logUnitLabel: HoundLabel = {
        let label = HoundLabel()
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a unit... (optional)"
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(dropDownManager.showHideDropDownGesture(identifier: LogsAddLogDropDownTypes.logUnit, delegate: self))
        dropDownManager.register(identifier: .logUnit, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    private lazy var nestedLogUnitStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logNumberOfLogUnitsTextField)
        stack.addArrangedSubview(logUnitLabel)
        stack.axis = .horizontal
        stack.spacing = Constant.Constraint.Spacing.contentIntraHori
        return stack
    }()
    private lazy var logUnitStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logUnitHeaderLabel)
        stack.addArrangedSubview(nestedLogUnitStack)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    
    // MARK: logNote
    private lazy var logNoteHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "Anything else?"
        return label
    }()
    private lazy var logNoteTextView: HoundTextView = {
        let textView = HoundTextView()
        textView.delegate = self
        textView.textColor = UIColor.label
        textView.applyStyle(.thinGrayBorder)
        textView.placeholder = "Add any notes... (optional)"
        return textView
    }()
    private lazy var logNoteStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(logNoteHeaderLabel)
        stack.addArrangedSubview(logNoteTextView)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    
    private lazy var stackView: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(familyMemberStack)
        stack.addArrangedSubview(parentDogStack)
        stack.addArrangedSubview(logActionStack)
        stack.addArrangedSubview(logCustomActionNameStack)
        stack.addArrangedSubview(logStartDateStack)
        stack.addArrangedSubview(logEndDateStack)
        stack.addArrangedSubview(logUnitStack)
        stack.addArrangedSubview(logNoteStack)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTallIntraVert
        return stack
    }()
    
    private lazy var dropDownManager = HoundDropDownManager<LogsAddLogDropDownTypes>(rootView: containerView, dataSource: self, delegate: self)
    
    private lazy var backButton: HoundButton = {
        let button = HoundButton()
        
        button.tintColor = UIColor.systemGray2
        button.setImage(UIImage(systemName: "arrow.backward.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.addTarget(self, action: #selector(didTouchUpInsideBack), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var saveLogButton: HoundButton = {
        let button = HoundButton()
        
        button.tintColor = UIColor.systemBlue
        button.setImage(UIImage(systemName: "checkmark.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.addTarget(self, action: #selector(didTouchUpInsideSaveLog), for: .touchUpInside)
        
        return button
    }()
    
    @objc private func didUpdateLogStartDate(_ sender: Any) {
        // By updating selectedLogStartDate, it can invalidate the quick time select options in the open drop down.
        // If a user then selects an invalid option, it will lead to incorrect data or crashing.
        self.dropDownManager.hide(identifier: LogsAddLogDropDownTypes.logEndDate, animated: true)
        self.selectedLogStartDate = logStartDatePicker.date
        self.dismissKeyboard()
    }
    
    @objc private func didUpdateLogEndDate(_ sender: Any) {
        // By updating selectedLogEndDate, it can invalidate the quick time select options in the open drop down.
        // If a user then selects an invalid option, it will lead to incorrect data or crashing.
        self.dropDownManager.hide(identifier: LogsAddLogDropDownTypes.logStartDate, animated: true)
        self.selectedLogEndDate = logEndDatePicker.date
        self.dismissKeyboard()
    }
    
    @objc func didUpdateLogNumberOfLogUnits() {
        // When the user enters a number into log units, it could update the plurality of the logUnitLabel
        // (e.g. no number but "pills" then the user enters 1 so "pills" should become "pill").
        // So by setting logUnitTypeSelected it updates logUnitLabel.
        updateDynamicUIElements()
    }
    
    @objc private func didTouchUpInsideBack(_ sender: Any) {
        guard didUpdateInitialValues else {
            self.dismiss(animated: true)
            return
        }
        
        let unsavedInformationConfirmation = UIAlertController(
            title: "Are you sure you want to exit?",
            message: nil,
            preferredStyle: .alert
        )
        
        let exitAlertAction = UIAlertAction(
            title: "Yes, I don't want to save changes",
            style: .default
        ) { _ in
            self.dismiss(animated: true)
        }
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        unsavedInformationConfirmation.addAction(exitAlertAction)
        unsavedInformationConfirmation.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(unsavedInformationConfirmation)
    }
    
    @objc private func didTouchUpInsideSaveLog(_ sender: Any) {
        guard selectedDogUUIDs.count >= 1 else {
            HapticsManager.notification(.error)
            parentDogLabel.errorMessage = Constant.Error.LogError.parentDogMissing
            return
        }
        guard let selectedLogAction = selectedLogAction else {
            if !logActionLabel.isHidden {
                HapticsManager.notification(.error)
                logActionLabel.errorMessage = Constant.Error.LogError.logActionMissing
            }
            return
        }
        guard let selectedLogStartDate = selectedLogStartDate else {
            if !logStartDateLabel.isHidden {
                logStartDateLabel.errorMessage = Constant.Error.LogError.logStartDateMissing
            }
            if !logStartDatePicker.isHidden {
                logStartDatePicker.errorMessage = Constant.Error.LogError.logStartDateMissing
            }
            HapticsManager.notification(.error)
            return
        }
        
        if let selectedLogEndDate = selectedLogEndDate, selectedLogEndDate < selectedLogStartDate {
            if !logStartDateLabel.isHidden {
                logStartDateLabel.errorMessage = Constant.Error.LogError.logStartTooLate
            }
            if !logStartDatePicker.isHidden {
                logStartDatePicker.errorMessage = Constant.Error.LogError.logStartTooLate
            }
            if !logEndDateLabel.isHidden {
                logEndDateLabel.errorMessage = Constant.Error.LogError.logEndTooEarly
            }
            if !logEndDatePicker.isHidden {
                logEndDatePicker.errorMessage = Constant.Error.LogError.logEndTooEarly
            }
            HapticsManager.notification(.error)
            return
        }
        
        // Check to see if we are updating or adding a log
        guard let dogUUIDToUpdate = dogUUIDToUpdate, let logToUpdate = logToUpdate else {
            willAddLog(selectedLogAction: selectedLogAction, selectedLogStartDate: selectedLogStartDate)
            return
        }
        
        willUpdateLog(dogUUIDToUpdate: dogUUIDToUpdate,
                      logToUpdate: logToUpdate,
                      selectedLogAction: selectedLogAction,
                      selectedLogStartDate: selectedLogStartDate)
    }
    
    @objc private func didTouchUpInsideRemoveLog(_ sender: Any) {
        guard let dogUUIDToUpdate = dogUUIDToUpdate else { return }
        guard let logToUpdate = logToUpdate else { return }
        
        let removeLogConfirmation = UIAlertController(
            title: "Are you sure you want to delete this log?",
            message: nil,
            preferredStyle: .alert
        )
        
        let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
            
            // The user decided to delete so we must query server
            LogsRequest.delete(
                errorAlert: .automaticallyAlertOnlyForFailure,
                dogUUID: dogUUIDToUpdate,
                logUUID: logToUpdate.logUUID
            ) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }
                
                self.dogManager.findDog(dogUUID: dogUUIDToUpdate)?
                    .dogLogs.removeLog(logUUID: logToUpdate.logUUID)
                
                self.delegate?.didUpdateDogManager(
                    sender: Sender(origin: self, localized: self),
                    dogManager: self.dogManager
                )
                
                HapticsManager.notification(.warning)
                self.dismiss(animated: true) {
                    // Wait for the view to be dismissed, then see if we should request any sort of review from the user
                    ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
                }
            }
        }
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        removeLogConfirmation.addAction(removeAlertAction)
        removeLogConfirmation.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(removeLogConfirmation)
    }
    
    // MARK: - Properties
    
    private weak var delegate: LogsAddLogDelegate?
    
    private var dogManager: DogManager = DogManager()
    private var dogUUIDToUpdate: UUID?
    private var logToUpdate: Log?
    
    private var initialSelectedDogUUIDs: [UUID] = []
    private var initialLogActionType: LogActionType?
    private var initialLogCustomActionName: String?
    private var initialLogUnitType: LogUnitType?
    private var initialLogNumberOfLogUnits: String?
    private var initialLogNote: String?
    private var initialLogStartDate: Date?
    private var initialLogEndDate: Date?
    private var didUpdateInitialValues: Bool {
        if initialLogActionType != selectedLogAction { return true }
        if selectedLogAction?.allowsCustom == true && initialLogCustomActionName != logCustomActionNameTextField.text {
            return true
        }
        if initialLogUnitType != selectedLogUnitType { return true }
        if initialLogNumberOfLogUnits != logNumberOfLogUnitsTextField.text { return true }
        if initialLogNote != logNoteTextView.text { return true }
        if initialLogStartDate != selectedLogStartDate { return true }
        if initialLogEndDate != selectedLogEndDate { return true }
        if initialSelectedDogUUIDs != selectedDogUUIDs { return true }
        return false
    }
    
    private var selectedDogUUIDs: [UUID] = [] {
        didSet {
            if !selectedDogUUIDs.isEmpty {
                parentDogLabel.errorMessage = nil
            }
            parentDogLabel.text = {
                guard !selectedDogUUIDs.isEmpty else {
                    // If no parent dog selected, leave text blank so placeholder displays
                    return nil
                }
                
                // If only one dog selected, show that dog's name
                if selectedDogUUIDs.count == 1,
                   let lastRemainingDogUUID = self.selectedDogUUIDs.first,
                   let lastRemainingDog = dogManager.dogs.first(where: { $0.dogUUID == lastRemainingDogUUID }) {
                    return lastRemainingDog.dogName
                }
                // If multiple but not all dogs selected, show "Multiple"
                else if selectedDogUUIDs.count > 1 && selectedDogUUIDs.count < dogManager.dogs.count {
                    return "Multiple"
                }
                // If all dogs selected, show "All"
                else if selectedDogUUIDs.count == dogManager.dogs.count {
                    return "All"
                }
                
                return nil
            }()
        }
    }
    
    /// Options for the log action drop down consisting of base types and their previous custom names
    private var availableLogActions: [(LogActionType, String?)] = []
    /// The selected log action type
    private var selectedLogAction: LogActionType? {
        didSet {
            if selectedLogAction != nil {
                logActionLabel.errorMessage = nil
            }
            // READ ME BEFORE CHANGING CODE BELOW: this is for the label for the logActionType dropdown,
            // so we only want the names to be the defaults. I.e. if our log is "Custom" with "someCustomActionName",
            // the logActionLabel should only show "Custom" and then the logCustomActionNameTextField should be "someCustomActionName".
            logActionLabel.text = selectedLogAction?.convertToReadableName(customActionName: nil, includeMatchingEmoji: true)
            
            // If log action changed to something where the current logUnit is no longer valid, clear selectedLogUnitType
            if let selected = selectedLogAction {
                let validUnits = selected.associatedLogUnitTypes
                if let currentUnit = selectedLogUnitType, !validUnits.contains(currentUnit) {
                    selectedLogUnitType = nil
                }
            }
            else {
                selectedLogUnitType = nil
            }
            
            updateDynamicUIElements()
        }
    }
    
    private var selectedLogUnitType: LogUnitType?
    
    private var availableLogStartDateOptions: [TimeAgoQuickSelect] = []
    private var selectedLogStartDate: Date? {
        didSet {
            // If start date is after end date, update end date and clear errors
            if let start = selectedLogStartDate, let end = selectedLogEndDate, start > end {
                selectedLogEndDate = start
                updateLogStartEndDateErrors()
            }
            
            guard let start = selectedLogStartDate else {
                logStartDateLabel.text = nil
                return
            }
            updateLogStartEndDateErrors()
            
            logStartDateLabel.text = formatDateRelativeToNow(start, addExtraAtForToday: false)
            logStartDatePicker.date = start
        }
    }
    private var isShowingLogStartDatePicker = false {
        didSet {
            if isShowingLogStartDatePicker {
                logStartDatePicker.date = selectedLogStartDate
                ?? Date.roundDate(
                    targetDate: Date(),
                    roundingInterval: Double(60 * logStartDatePicker.minuteInterval),
                    roundingMethod: .toNearestOrAwayFromZero
                )
                selectedLogStartDate = logStartDatePicker.date
            }
            logStartDatePicker.isHidden = !isShowingLogStartDatePicker
            logStartDateLabel.isHidden = isShowingLogStartDatePicker
            
            updateDynamicUIElements()
        }
    }
    
    private var availableLogEndDateOptions: [AfterTimeQuickSelect] = []
    private var selectedLogEndDate: Date? {
        didSet {
            // Ensure end date is not before start date
            if let end = selectedLogEndDate, let start = selectedLogStartDate, end < start {
                selectedLogStartDate = end
                updateLogStartEndDateErrors()
            }
            guard let end = selectedLogEndDate else {
                logEndDateLabel.text = nil
                return
            }
            updateLogStartEndDateErrors()
            
            logEndDateLabel.text = formatDateRelativeToNow(end, addExtraAtForToday: false)
            logEndDatePicker.date = end
        }
    }
    private var isShowingLogEndDatePicker = false {
        didSet {
            if isShowingLogEndDatePicker {
                logEndDatePicker.date = selectedLogEndDate
                ?? Date.roundDate(
                    targetDate: Date(),
                    roundingInterval: Double(60 * logEndDatePicker.minuteInterval),
                    roundingMethod: .toNearestOrAwayFromZero
                )
                selectedLogEndDate = logEndDatePicker.date
            }
            logEndDatePicker.isHidden = !isShowingLogEndDatePicker
            logEndDateLabel.isHidden = isShowingLogEndDatePicker
            
            updateDynamicUIElements()
        }
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        self.enableSwipeBackToDismiss = true
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        
        let saveButtonTop = saveLogButton.convert(saveLogButton.bounds, to: view).minY
        let backButtonTop = backButton.convert(backButton.bounds, to: view).minY
        let buttonTop = min(saveButtonTop, backButtonTop)
        
        let distanceFromBottom = view.bounds.height - buttonTop
        
        let minInset = distanceFromBottom + Constant.Constraint.Spacing.absoluteVertInset
        
        scrollView.contentInset.bottom = max(scrollView.contentInset.bottom, minInset)
    }
    
    // MARK: - Setup
    
    func setup(delegate: LogsAddLogDelegate,
               dogManager: DogManager,
               dogUUIDToUpdate: UUID?,
               logToUpdate: Log?) {
        self.delegate = delegate
        self.dogManager = dogManager
        self.dogUUIDToUpdate = dogUUIDToUpdate
        self.logToUpdate = logToUpdate
        
        if let dogUUIDToUpdate = dogUUIDToUpdate, logToUpdate != nil {
            editPageHeaderView.setTitle("Edit Log")
            editPageHeaderView.isTrailingButtonEnabled = true
            if let dog = dogManager.findDog(dogUUID: dogUUIDToUpdate) {
                selectedDogUUIDs = [dog.dogUUID]
                initialSelectedDogUUIDs = selectedDogUUIDs
            }
            else {
                selectedDogUUIDs = []
                initialSelectedDogUUIDs = selectedDogUUIDs
            }
            
            // parent dog is set once log is created
            parentDogLabel.isEnabled = false
        }
        else {
            editPageHeaderView.setTitle("Create Log")
            editPageHeaderView.isTrailingButtonEnabled = false
            // If the family only has one dog, then force the parent dog selected to be that single dog.
            // Otherwise, leave list empty so user must select.
            if dogManager.dogs.count == 1, let uuid = dogManager.dogs.first?.dogUUID {
                selectedDogUUIDs = [uuid]
                initialSelectedDogUUIDs = selectedDogUUIDs
            }
            else {
                selectedDogUUIDs = []
                initialSelectedDogUUIDs = selectedDogUUIDs
            }
            
            parentDogLabel.isEnabled = dogManager.dogs.count != 1
        }
        
        parentDogHeaderLabel.text = logToUpdate != nil ? "Dog taken care of"
        : dogManager.dogs.count <= 1
        ? "Which dog did you take care of?"
        : "Which dog(s) did you take care of?"
        
        familyMemberLabel.text = FamilyInformation.findFamilyMember(userId: logToUpdate?.logCreatedBy)?.displayFullName
        familyMemberDescriptionLabel.text = {
            guard let logToUpdate = logToUpdate else {
                return ""
            }
            
            var text = "Logged \(formatDateRelativeToNow(logToUpdate.logCreated, addExtraAtForToday: true))"
            
            let modifiedDate = logToUpdate.logLastModified
            let modifiedBy = FamilyInformation.findFamilyMember(userId: logToUpdate.logLastModifiedBy)?.displayFullName
            
            if modifiedDate != nil || modifiedBy != nil {
                text += ". Last Modified"
                if let modifiedDate = modifiedDate {
                    text += " \(formatDateRelativeToNow(modifiedDate, addExtraAtForToday: true))"
                }
                if let modifiedBy = modifiedBy {
                    text += " by \(modifiedBy)"
                }
            }
            return text
        }()
        familyMemberStack.isHidden = logToUpdate == nil
        
        selectedLogAction = logToUpdate?.logActionType
        initialLogActionType = logToUpdate?.logActionType
        availableLogActions = {
            var options: [(LogActionType, String?)] = []
            for type in GlobalTypes.shared.logActionTypes {
                options.append((type, nil))
                let matching = LocalConfiguration.localPreviousLogCustomActionNames.filter { $0.logActionTypeId == type.logActionTypeId }
                for prev in matching {
                    options.append((type, prev.logCustomActionName))
                }
            }
            return options
        }()
        
        logCustomActionNameTextField.text = logToUpdate?.logCustomActionName
        initialLogCustomActionName = logToUpdate?.logCustomActionName
        
        let convertedLogUnits: (LogUnitType, Double)? = {
            guard let unitType = logToUpdate?.logUnitType,
                  let numberOfUnits = logToUpdate?.logNumberOfLogUnits else {
                return nil
            }
            return LogUnitTypeConverter.convert(logUnitType: unitType, numberOfLogUnits: numberOfUnits,
                                                toTargetSystem: UserConfiguration.measurementSystem)
        }()
        
        selectedLogUnitType = convertedLogUnits?.0
        initialLogUnitType = convertedLogUnits?.0
        
        logNumberOfLogUnitsTextField.text = LogUnitType.readableRoundedNumUnits(logNumberOfLogUnits: convertedLogUnits?.1)
        initialLogNumberOfLogUnits = LogUnitType.readableRoundedNumUnits(logNumberOfLogUnits: convertedLogUnits?.1)
        
        selectedLogStartDate = logToUpdate?.logStartDate
        initialLogStartDate = logToUpdate?.logStartDate
        availableLogStartDateOptions = {
            // If selectedLogEndDate is nil, all options are valid
            guard let endDate = selectedLogEndDate else {
                return TimeAgoQuickSelect.allCases
            }
            return TimeAgoQuickSelect.optionsOccurringBeforeDate(
                startingPoint: Date(),
                occurringOnOrBefore: endDate
            )
        }()
        
        selectedLogEndDate = logToUpdate?.logEndDate
        initialLogEndDate = selectedLogEndDate
        availableLogEndDateOptions = {
            // If selectedLogStartDate is nil, all options are valid
            guard let start = logToUpdate?.logStartDate else {
                return AfterTimeQuickSelect.allCases
            }
            return AfterTimeQuickSelect.optionsOccurringAfterDate(
                startingPoint: Date(),
                occurringOnOrAfter: start
            )
        }()
        
        logNoteTextView.text = logToUpdate?.logNote
        initialLogNote = logNoteTextView.text
        
        updateDynamicUIElements()
        
        showNextRequiredDropDown(animated: false)
    }
    
    // MARK: - Functions
    
    private func updateDynamicUIElements() {
        let familyMemberIsHidden = dogUUIDToUpdate == nil || logToUpdate == nil
        if familyMemberStack.isHidden != familyMemberIsHidden {
            familyMemberStack.isHidden = familyMemberIsHidden
            remakeFamilyMemberConstraints()
        }
        
        let customActionNameIsHidden = selectedLogAction == nil || !(selectedLogAction?.allowsCustom ?? false)
        if logCustomActionNameStack.isHidden != customActionNameIsHidden {
            logCustomActionNameStack.isHidden = customActionNameIsHidden
            remakeCustomActionNameConstraints()
        }
        
        if logStartDateLabel.isHidden != isShowingLogStartDatePicker || logStartDatePicker.isHidden != !isShowingLogStartDatePicker {
            logStartDateLabel.isHidden = isShowingLogStartDatePicker
            logStartDatePicker.isHidden = !isShowingLogStartDatePicker
            remakeStartDateConstraints()
        }
        
        if logEndDateLabel.isHidden != isShowingLogEndDatePicker || logEndDatePicker.isHidden != !isShowingLogEndDatePicker {
            logEndDateLabel.isHidden = isShowingLogEndDatePicker
            logEndDatePicker.isHidden = !isShowingLogEndDatePicker
            remakeEndDateConstraints()
        }
        
        logUnitLabel.text = selectedLogUnitType?.pluralReadableValueNoNumUnits(
            logNumberOfLogUnits: LogUnitType.convertStringToDouble(
                logNumberOfLogUnits: logNumberOfLogUnitsTextField.text
            )
        )
        logUnitLabel.isEnabled = selectedLogAction != nil
        logNumberOfLogUnitsTextField.isEnabled = selectedLogAction != nil
        
        let logUnitIsHidden = selectedLogAction != nil && (selectedLogAction?.associatedLogUnitTypes.isEmpty ?? true)
        if logUnitStack.isHidden != logUnitIsHidden {
            logUnitStack.isHidden = logUnitIsHidden
            remakeLogUnitConstraints()
        }
        
        UIView.animate(withDuration: Constant.Visual.Animation.showOrHideSingleElement) {
            self.view.setNeedsLayout()
            self.view.layoutIfNeeded()
        }
    }
    
    private func updateLogStartEndDateErrors() {
        if selectedLogStartDate != nil && (logStartDateLabel.errorMessage == Constant.Error.LogError.logStartDateMissing || logStartDatePicker.errorMessage == Constant.Error.LogError.logStartDateMissing) {
            logStartDateLabel.errorMessage = nil
            logStartDatePicker.errorMessage = nil
        }
        
        guard let end = selectedLogEndDate, let start = selectedLogStartDate else {
            // if 1 or both missing, then impossible to be conflicting
            if logStartDateLabel.errorMessage == Constant.Error.LogError.logStartTooLate || logStartDatePicker.errorMessage == Constant.Error.LogError.logStartTooLate {
                logStartDateLabel.errorMessage = nil
                logStartDatePicker.errorMessage = nil
            }
            if logEndDateLabel.errorMessage == Constant.Error.LogError.logEndTooEarly || logEndDatePicker.errorMessage == Constant.Error.LogError.logEndTooEarly {
                logEndDateLabel.errorMessage = nil
                logEndDatePicker.errorMessage = nil
            }
            return
        }
        
        // only clear errors if fixed
        guard start <= end else {
            return
        }
        
        if logStartDateLabel.errorMessage == Constant.Error.LogError.logStartTooLate || logStartDatePicker.errorMessage == Constant.Error.LogError.logStartTooLate {
            logStartDateLabel.errorMessage = nil
            logStartDatePicker.errorMessage = nil
        }
        if logEndDateLabel.errorMessage == Constant.Error.LogError.logEndTooEarly || logEndDatePicker.errorMessage == Constant.Error.LogError.logEndTooEarly {
            logEndDateLabel.errorMessage = nil
            logEndDatePicker.errorMessage = nil
        }
    }
    
    private func formatDateRelativeToNow(_ date: Date, addExtraAtForToday: Bool) -> String {
        let extraAt = addExtraAtForToday ? "at " : ""
        if Calendar.user.isDateInToday(date) {
            // If the start date is today, show only time
            // 7:53 AM
            return extraAt + date.houndFormatted(.formatStyle(date: .omitted, time: .shortened), displayTimeZone: UserConfiguration.timeZone)
        }
        else if Calendar.user.isDateInYesterday(date) {
            // If the start date is yesterday, show "Yesterday at 7:53 AM"
            return "Yesterday at " + date.houndFormatted(.formatStyle(date: .omitted, time: .shortened), displayTimeZone: UserConfiguration.timeZone)
        }
        else if Calendar.user.isDateInTomorrow(date) {
            // If the start date is tomorrow, show "Tomorrow at 7:53 AM"
            return "Tomorrow at " + date.houndFormatted(.formatStyle(date: .omitted, time: .shortened), displayTimeZone: UserConfiguration.timeZone)
        }
        else {
            // If start date is not today, show month/day and possibly year
            let yearOfStart = Calendar.user.component(.year, from: date)
            let currentYear = Calendar.user.component(.year, from: Date())
            return date.houndFormatted(.template(yearOfStart == currentYear ? "MMMMdhma" : "MMMMdyyyyhma"), displayTimeZone: UserConfiguration.timeZone)
        }
    }
    
    // MARK: - Drop Down Handling
    
    @objc private func didTapScreen(sender: UITapGestureRecognizer) {
        dropDownManager.hideDropDownIfNotTapped(sender: sender)
        if let senderView = sender.view {
            let point = sender.location(in: senderView)
            if let deepestTouchedView = senderView.hitTest(point, with: nil), !deepestTouchedView.isDescendant(of: logCustomActionNameTextField) && !deepestTouchedView.isDescendant(of: logNumberOfLogUnitsTextField) {
                dismissKeyboard()
            }
        }
    }
    
    /// Determine and show the next required dropdown in the log creation flow
    private func showNextRequiredDropDown(animated: Bool) {
        if selectedDogUUIDs.isEmpty {
            willShowDropDown(LogsAddLogDropDownTypes.parentDog, animated: animated)
        }
        else if selectedLogAction == nil {
            willShowDropDown(LogsAddLogDropDownTypes.logActionType, animated: animated)
        }
        else if selectedLogStartDate == nil && !isShowingLogStartDatePicker {
            willShowDropDown(LogsAddLogDropDownTypes.logStartDate, animated: animated)
        }
    }
    
    func willShowDropDown(_ identifier: any HoundDropDownType, animated: Bool) {
        guard let type = identifier as? LogsAddLogDropDownTypes else { return }
        // If showing start date and only "custom" and "now" are valid, show picker
        if type == .logStartDate && availableLogStartDateOptions.count <= 1 {
            isShowingLogStartDatePicker = true
            return
        }
        // If showing end date and only "custom" is valid, show picker
        if type == .logEndDate && availableLogEndDateOptions.count <= 1 {
            isShowingLogEndDatePicker = true
            return
        }
        
        let numberOfRows: CGFloat = {
            switch type {
            case .parentDog:
                return CGFloat(dogManager.dogs.count)
            case .logActionType:
                return CGFloat(availableLogActions.count)
            case .logUnit:
                guard let selected = selectedLogAction else { return 0.0 }
                return CGFloat(selected.associatedLogUnitTypes.count)
            case .logStartDate:
                return CGFloat(availableLogStartDateOptions.count)
            case .logEndDate:
                return CGFloat(availableLogEndDateOptions.count)
            }
        }()
        
        dropDownManager.show(
            identifier: type,
            numberOfRowsToShow: min(6.5, numberOfRows),
            animated: animated
        )
    }
    
    // MARK: - Drop Down Data Source
    
    func setupCellForDropDown(cell: HoundDropDownTVC, indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let identifier = identifier as? LogsAddLogDropDownTypes else {
            HoundLogger.general.error("LogsAddLogVC.setupCellForDropDown: Unable to identifier \(identifier.rawValue)")
            return
        }
        
        switch identifier {
        case .parentDog:
            let dog = dogManager.dogs[indexPath.row]
            cell.setCustomSelected(selectedDogUUIDs.contains(dog.dogUUID), animated: false)
            cell.label.text = dog.dogName
        case .logActionType:
            let option = availableLogActions[indexPath.row]
            cell.label.text = option.0.convertToReadableName(
                customActionName: option.1,
                includeMatchingEmoji: true
            )
            if option.1 == nil,
               let selected = selectedLogAction,
               selected.logActionTypeId == option.0.logActionTypeId {
                cell.setCustomSelected(true, animated: false)
            }
            else {
                cell.setCustomSelected(false, animated: false)
            }
        case .logUnit:
            guard let selectedAction = selectedLogAction else { return }
            cell.setCustomSelected(false, animated: false)
            let unitTypes = selectedAction.associatedLogUnitTypes
            if indexPath.row < unitTypes.count {
                let unit = unitTypes[indexPath.row]
                cell.label.text = unit.pluralReadableValueNoNumUnits(
                    logNumberOfLogUnits: LogUnitType.convertStringToDouble(
                        logNumberOfLogUnits: logNumberOfLogUnitsTextField.text
                    ) ?? 0.0
                )
                if let selectedUnit = selectedLogUnitType, selectedUnit == unit {
                    cell.setCustomSelected(true, animated: false)
                }
            }
        case .logStartDate:
            cell.setCustomSelected(false, animated: false)
            if let option = availableLogStartDateOptions[safe: indexPath.row] {
                cell.label.text = option.rawValue
                // Do not set “selected” visually, as quick select depends on current time
            }
        case .logEndDate:
            cell.setCustomSelected(false, animated: false)
            if let option = availableLogEndDateOptions[safe: indexPath.row] {
                cell.label.text = option.rawValue
                // Do not set “selected” visually, as quick select depends on current time
            }
        }
    }
    
    func numberOfRows(section: Int, identifier: any HoundDropDownType) -> Int {
        guard let identifier = identifier as? LogsAddLogDropDownTypes else {
            HoundLogger.general.error("LogsAddLogVC.numberOfRows: Unable to identifier \(identifier.rawValue)")
            return 0
        }
        
        switch identifier {
        case LogsAddLogDropDownTypes.parentDog:
            return dogManager.dogs.count
        case LogsAddLogDropDownTypes.logActionType:
            return availableLogActions.count
        case LogsAddLogDropDownTypes.logUnit:
            guard let selected = selectedLogAction else { return 0 }
            return selected.associatedLogUnitTypes.count
        case LogsAddLogDropDownTypes.logStartDate:
            return availableLogStartDateOptions.count
        case LogsAddLogDropDownTypes.logEndDate:
            return availableLogEndDateOptions.count
        }
    }
    
    func numberOfSections(identifier: any HoundDropDownType) -> Int {
        // Each dropdown has a single section
        return 1
    }
    
    func selectItemInDropDown(indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let identifier = identifier as? LogsAddLogDropDownTypes else {
            HoundLogger.general.error("LogsAddLogVC.selectItemInDropDown: Unable to identifier \(identifier.rawValue)")
            return
        }
        guard let dropDown = dropDownManager.dropDown(for: identifier), let cell = dropDown.dropDownTableView?.cellForRow(at: indexPath) as? HoundDropDownTVC else {
            HoundLogger.general.error("LogsAddLogVC.selectItemInDropDown: Unable to find drop down or cell for identifier \(identifier.rawValue)")
            return
        }
        
        switch identifier {
        case LogsAddLogDropDownTypes.parentDog:
            let dog = dogManager.dogs[indexPath.row]
            let beforeCount = selectedDogUUIDs.count
            
            if cell.isCustomSelected {
                // Unselect parent dog
                selectedDogUUIDs.removeAll { $0 == dog.dogUUID }
            }
            else {
                // Select parent dog
                selectedDogUUIDs.append(dog.dogUUID)
            }
            cell.setCustomSelected(!cell.isCustomSelected)
            
            if beforeCount == 0 {
                // After first selection, hide parent dropdown and open log action dropdown
                dropDown.hideDropDown(animated: true)
                showNextRequiredDropDown(animated: true)
            }
            else if selectedDogUUIDs.count == dogManager.dogs.count {
                // If all dogs selected, close dropdown
                dropDown.hideDropDown(animated: true)
            }
        case LogsAddLogDropDownTypes.logActionType:
            let beforeSelection = selectedLogAction
            
            if cell.isCustomSelected {
                // Unselect current log action
                cell.setCustomSelected(false)
                selectedLogAction = nil
                // Do not hide dropdown, need selection for valid log
                return
            }
            
            cell.setCustomSelected(true)
            
            let option = availableLogActions[indexPath.row]
            selectedLogAction = option.0
            if let custom = option.1 {
                logCustomActionNameTextField.text = custom
            }
            else if selectedLogAction?.allowsCustom == true {
                // If custom log action is allowed, begin editing textField
                logCustomActionNameTextField.becomeFirstResponder()
            }
            
            dropDown.hideDropDown(animated: true)
            
            if beforeSelection == nil && !logCustomActionNameTextField.isFirstResponder {
                // First-time selection of log action, so open next dropdown
                showNextRequiredDropDown(animated: true)
            }
        case LogsAddLogDropDownTypes.logUnit:
            if cell.isCustomSelected {
                cell.setCustomSelected(false)
                selectedLogUnitType = nil
            }
            else {
                cell.setCustomSelected(true)
                selectedLogUnitType = selectedLogAction?.associatedLogUnitTypes[indexPath.row]
            }
            
            dropDown.hideDropDown(animated: true)
            
            updateDynamicUIElements()
        case LogsAddLogDropDownTypes.logStartDate:
            // Time quick select cells should never stay visually selected.
            cell.setCustomSelected(true)
            
            let timeIntervalSelected = availableLogStartDateOptions[indexPath.row].valueInSeconds()
            if let interval = timeIntervalSelected {
                // Apply the quick select option
                selectedLogStartDate = Date().addingTimeInterval(interval)
            }
            else {
                isShowingLogStartDatePicker = true
            }
            
            dropDown.hideDropDown(animated: true)
        case LogsAddLogDropDownTypes.logEndDate:
            cell.setCustomSelected(true)
            
            let quickSelectOption = availableLogEndDateOptions[indexPath.row]
            if quickSelectOption == .custom {
                isShowingLogEndDatePicker = true
            }
            else {
                selectedLogEndDate = quickSelectOption.time(startingPoint: selectedLogStartDate ?? Date())
            }
            
            dropDown.hideDropDown(animated: true)
        }
    }
    
    func firstSelectedIndexPath(identifier: any HoundDropDownType) -> IndexPath? {
        guard let identifier = identifier as? LogsAddLogDropDownTypes else { return nil }
        switch identifier {
        case .parentDog:
            if let idx = selectedDogUUIDs
                .compactMap({ uuid in dogManager.dogs.firstIndex(where: { $0.dogUUID == uuid }) })
                .min() {
                return IndexPath(row: idx, section: 0)
            }
        case .logActionType:
            if let action = selectedLogAction,
               let idx = availableLogActions.firstIndex(where: { $0.0.logActionTypeId == action.logActionTypeId && $0.1 == nil }) {
                return IndexPath(row: idx, section: 0)
            }
        case .logUnit:
            if let unit = selectedLogUnitType,
               let idx = selectedLogAction?.associatedLogUnitTypes.firstIndex(of: unit) {
                return IndexPath(row: idx, section: 0)
            }
        case .logStartDate, .logEndDate:
            return nil
        }
        return nil
    }
    
    // MARK: - Add / Update Log Tasks
    
    private func willAddLog(selectedLogAction: LogActionType, selectedLogStartDate: Date) {
        saveLogButton.isLoading = true
        
        // Only retrieve matchingReminders if switch is on.
        let matchingReminders: [(UUID, Reminder)] = dogManager.matchingReminders(
            dogUUIDs: selectedDogUUIDs,
            logActionType: selectedLogAction,
            logCustomActionName: logCustomActionNameTextField.text
        )
        
        var triggerRemindersByDogUUID: [UUID: [Reminder]] = [:]
        let completionTracker = CompletionTracker(
            numberOfTasks: selectedDogUUIDs.count + matchingReminders.count
        ) {
            // Each time a task completes, update the dog manager so everything else updates
            self.delegate?.didUpdateDogManager(
                sender: Sender(origin: self, localized: self),
                dogManager: self.dogManager
            )
        } completedAllTasksCompletionHandler: {
            // create all the triggers silently in the background
            for (dogUUID, reminders) in triggerRemindersByDogUUID {
                guard let dog = self.dogManager.findDog(dogUUID: dogUUID) else {
                    return
                }
                
                // silently try to create trigger reminders
                RemindersRequest.create(
                    errorAlert: .automaticallyAlertForNone,
                    dogUUID: dogUUID,
                    reminders: reminders
                ) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    dog.dogReminders.addReminders(reminders: reminders)
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                }
            }
            
            // When everything completes, close the page
            self.saveLogButton.isLoading = false
            HapticsManager.notification(.success)
            self.dismiss(animated: true) {
                // Request reviews or surveys after dismissal
                ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
            }
        } failedTaskCompletionHandler: {
            // If a problem is encountered, stop the indicator
            self.saveLogButton.isLoading = false
        }
        
        matchingReminders.forEach { dogUUID, matchingReminder in
            matchingReminder.enableIsSkipping(skippedDate: selectedLogStartDate)
            
            RemindersRequest.update(
                errorAlert: .automaticallyAlertOnlyForFailure,
                dogUUID: dogUUID,
                reminders: [matchingReminder]
            ) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    completionTracker.failedTask()
                    return
                }
                completionTracker.completedTask()
            }
        }
        
        for selectedDogUUID in selectedDogUUIDs {
            // Each dog needs its own newLog object with its own unique UUID
            let logToAdd = Log(
                logActionTypeId: selectedLogAction.logActionTypeId,
                logCustomActionName: logCustomActionNameTextField.text,
                logStartDate: selectedLogStartDate,
                logEndDate: selectedLogEndDate,
                logNote: logNoteTextView.text,
                logUnitTypeId: selectedLogUnitType?.logUnitTypeId,
                logNumberOfUnits: LogUnitType.convertStringToDouble(
                    logNumberOfLogUnits: logNumberOfLogUnitsTextField.text
                ),
                logCreatedByReminderUUID: nil
            )
            
            LogsRequest.create(
                errorAlert: .automaticallyAlertOnlyForFailure,
                dogUUID: selectedDogUUID,
                log: logToAdd
            ) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    completionTracker.failedTask()
                    return
                }
                
                // Request was successful, so add the new custom action name locally
                LocalConfiguration.addLogCustomAction(
                    logActionType: logToAdd.logActionType,
                    logCustomActionName: logToAdd.logCustomActionName
                )
                
                let reminders = self.dogManager.findDog(dogUUID: selectedDogUUID)?
                    .dogLogs.addLog(log: logToAdd, invokeDogTriggers: true)
                if let reminders = reminders, !reminders.isEmpty {
                    if triggerRemindersByDogUUID[selectedDogUUID] != nil {
                        triggerRemindersByDogUUID[selectedDogUUID]! += reminders // swiftlint:disable:this force_unwrapping
                    }
                    else {
                        triggerRemindersByDogUUID[selectedDogUUID] = reminders
                    }
                }
                
                completionTracker.completedTask()
            }
        }
    }
    
    private func willUpdateLog(
        dogUUIDToUpdate: UUID,
        logToUpdate: Log,
        selectedLogAction: LogActionType,
        selectedLogStartDate: Date
    ) {
        logToUpdate.setLogDate(
            logStartDate: selectedLogStartDate,
            logEndDate: selectedLogEndDate
        )
        logToUpdate.logActionTypeId = selectedLogAction.logActionTypeId
        logToUpdate.logCustomActionName = selectedLogAction.allowsCustom
        ? (logCustomActionNameTextField.text ?? "")
        : ""
        logToUpdate.setLogUnit(
            logUnitTypeId: selectedLogUnitType?.logUnitTypeId,
            logNumberOfLogUnits: LogUnitType.convertStringToDouble(
                logNumberOfLogUnits: logNumberOfLogUnitsTextField.text
            )
        )
        logToUpdate.logNote = logNoteTextView.text ?? ""
        
        saveLogButton.isLoading = true
        
        LogsRequest.update(
            errorAlert: .automaticallyAlertOnlyForFailure,
            dogUUID: dogUUIDToUpdate,
            log: logToUpdate
        ) { responseStatus, _ in
            self.saveLogButton.isLoading = false
            guard responseStatus != .failureResponse else {
                return
            }
            
            // Request was successful, so store the custom action name locally
            LocalConfiguration.addLogCustomAction(
                logActionType: logToUpdate.logActionType,
                logCustomActionName: logToUpdate.logCustomActionName
            )
            
            self.dogManager.findDog(dogUUID: dogUUIDToUpdate)?
                .dogLogs.addLog(log: logToUpdate, invokeDogTriggers: false)
            self.delegate?.didUpdateDogManager(
                sender: Sender(origin: self, localized: self),
                dogManager: self.dogManager
            )
            
            HapticsManager.notification(.success)
            self.dismiss(animated: true) {
                // Request reviews or surveys after dismissal
                ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
            }
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(saveLogButton)
        view.addSubview(backButton)
        
        containerView.addSubview(editPageHeaderView)
        containerView.addSubview(stackView)
        
        let didTapScreenGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapScreen(sender:))
        )
        didTapScreenGesture.delegate = self
        didTapScreenGesture.cancelsTouchesInView = false
        view.addGestureRecognizer(didTapScreenGesture)
    }
    
    private func remakeFamilyMemberConstraints() {
        familyMemberLabel.snp.remakeConstraints { make in
            if !familyMemberLabel.isHidden && !familyMemberStack.isHidden {
                make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
            }
        }
    }
    private func remakeCustomActionNameConstraints() {
        logCustomActionNameTextField.snp.remakeConstraints { make in
            if !logCustomActionNameTextField.isHidden && !logCustomActionNameStack.isHidden {
                make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
            }
        }
    }
    private func remakeStartDateConstraints() {
        logStartDateLabel.snp.remakeConstraints { make in
            if !logStartDateLabel.isHidden && !logStartDateStack.isHidden {
                make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
            }
        }
        logStartDatePicker.snp.remakeConstraints { make in
            if !logStartDatePicker.isHidden && !logStartDateStack.isHidden {
                make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.datePickerHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.datePickerMaxHeight)
            }
        }
    }
    private func remakeEndDateConstraints() {
        logEndDateLabel.snp.remakeConstraints { make in
            if !logEndDateLabel.isHidden && !logEndDateStack.isHidden {
                make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
            }
        }
        
        logEndDatePicker.snp.remakeConstraints { make in
            if !logEndDatePicker.isHidden && !logEndDateStack.isHidden {
                make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.datePickerHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.datePickerMaxHeight)
            }
        }
    }
    private func remakeLogUnitConstraints() {
        logNumberOfLogUnitsTextField.snp.remakeConstraints { make in
            make.width.equalTo(logUnitLabel.snp.width).multipliedBy(1.0 / 3.0)
            if !logNumberOfLogUnitsTextField.isHidden && !logUnitStack.isHidden {
                make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
            }
        }
        logUnitLabel.snp.remakeConstraints { make in
            if !logUnitLabel.isHidden && !logUnitStack.isHidden {
                make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
            }
        }
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        editPageHeaderView.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.top)
            make.leading.equalTo(containerView.snp.leading)
            make.trailing.equalTo(containerView.snp.trailing)
        }
        
        stackView.snp.makeConstraints { make in
            make.top.equalTo(editPageHeaderView.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.bottom.equalTo(containerView.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset * 2.0)
            make.leading.equalTo(containerView.snp.leading).offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalTo(containerView.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        remakeFamilyMemberConstraints()
        
        parentDogLabel.snp.makeConstraints { make in
            make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        
        logActionLabel.snp.makeConstraints { make in
            make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        
        remakeCustomActionNameConstraints()
        
        remakeStartDateConstraints()
        
        remakeEndDateConstraints()
        
        remakeLogUnitConstraints()
        
        logNoteTextView.snp.makeConstraints { make in
            make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Input.textViewHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textViewMaxHeight)
        }
        
        saveLogButton.snp.makeConstraints { make in
            make.bottom.equalTo(view.safeAreaLayoutGuide.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset)
            make.trailing.equalTo(view.safeAreaLayoutGuide.snp.trailing).inset(Constant.Constraint.Spacing.absoluteCircleHoriInset)
            make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Button.largeCircleHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.largeCircleMaxHeight)
            make.width.equalTo(saveLogButton.snp.height)
        }
        
        backButton.snp.makeConstraints { make in
            make.bottom.equalTo(view.safeAreaLayoutGuide.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset)
            make.leading.equalTo(view.safeAreaLayoutGuide.snp.leading).offset(Constant.Constraint.Spacing.absoluteCircleHoriInset)
            make.height.equalTo(view.snp.width).multipliedBy(Constant.Constraint.Button.largeCircleHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.largeCircleMaxHeight)
            make.width.equalTo(backButton.snp.height)
        }
        
    }
    
}
//
//  AppDelegate.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import os.log
import UIKit
import UserNotifications

@UIApplicationMain

final class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate {

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        HoundLogger.lifecycle.notice("Application Did Finish Launching with Options")
        
        // MUST come first, as other things might rely on user defaults
        PersistenceManager.loadUserDefaults()
        
        // Get InAppPurchaseManager to pre-load products
        InAppPurchaseManager.initialize()
        // Trigger the initialization of NetworkManager and start monitoring
        _ = NetworkManager.shared
        // Monitor changes to the system time zone
        _ = TimeZoneMonitor.shared

        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this function to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }
    
    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        HoundLogger.lifecycle.notice("Application Did Discard Scene Sessions")
        // DO NOT CALL IMPORTANT LIFECYCLE OPERATIONS FROM HERE, IF ASSOCIATED SCENE OPERATION EXISTS (e.g. sceneDidEnterBackground), USE THAT INSTEAD. These function are inconsistent as should be only used as backups, as scene drive lifecycle takes precedence
        PersistenceManager.didEnterBackground(isTerminating: true)
    }

    func applicationWillEnterForeground(_ application: UIApplication) {
        HoundLogger.lifecycle.notice("Application Will Enter Foreground")
        // DO NOT CALL IMPORTANT LIFECYCLE OPERATIONS FROM HERE, IF ASSOCIATED SCENE OPERATION EXISTS (e.g. sceneDidEnterBackground), USE THAT INSTEAD. These function are inconsistent as should be only used as backups, as scene drive lifecycle takes precedence
    }

    func applicationDidEnterBackground(_ application: UIApplication) {
        HoundLogger.lifecycle.notice("Application Did Enter Background")
        // DO NOT CALL IMPORTANT LIFECYCLE OPERATIONS FROM HERE, IF ASSOCIATED SCENE OPERATION EXISTS (e.g. sceneDidEnterBackground), USE THAT INSTEAD. These function are inconsistent as should be only used as backups, as scene drive lifecycle takes precedence
    }

    func applicationWillTerminate(_ application: UIApplication) {
        HoundLogger.lifecycle.notice("Application Will Terminate")
        // DO NOT CALL IMPORTANT LIFECYCLE OPERATIONS FROM HERE, IF ASSOCIATED SCENE OPERATION EXISTS (e.g. sceneDidEnterBackground), USE THAT INSTEAD. These function are inconsistent as should be only used as backups, as scene drive lifecycle takes precedence
        PersistenceManager.didEnterBackground(isTerminating: true)
    }

    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        let tokenParts = deviceToken.map { data in String(format: "%02.2hhx", data) }
        let token = tokenParts.joined()
        
        HoundLogger.general.notice("AppDelegate.didRegisterForRemoteNotificationsWithDeviceToken: Registered for remote notifications for token: \(token)")

        // If the new deviceToken is different from the saved deviceToken (i.e. there is a new token or there was no token saved), then we should attempt to update the server
        guard token != UserInformation.userNotificationToken else { return }
        
        guard UserInformation.userId != nil && UserInformation.userIdentifier != nil else {
            HoundLogger.general.error("AppDelegate.didRegisterForRemoteNotificationsWithDeviceToken: Unable to send token to server")
            return
        }

        let body: JSONRequestBody = [Constant.Key.userNotificationToken.rawValue: .string(token)]
        UserRequest.update(
            errorAlert: .automaticallyAlertForNone,
            body: body
        ) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                return
            }
            
            UserInformation.userNotificationToken = token
        }
    }

    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        HoundLogger.general.error("didFailToRegisterForRemoteNotificationsWithError: Failed to register for remote notifications with error: \(error.localizedDescription)")
    }

    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable: Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
        // look for the aps body
        guard let aps = userInfo["aps"] as? [String: Any] else {
            completionHandler(.noData)
            return
        }
        
        guard let category = aps["category"] as? String else {
            completionHandler(.noData)
            return
        }
        
        if category.contains("NOTIFICATION_CATEGORY_USER_KICKED") {
            // user was kicked from their family so we should back them into the server sync meny
            PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncVC.self, completionHandler: nil)
            completionHandler(.newData)
            return
        }
        else if category.contains("NOTIFICATION_CATEGORY_FAMILY") {
            // family was updated so we should refresh the family
            MainTabBarController.shouldSilentlyRefreshFamily = true
            completionHandler(.newData)
            return
        }
        // Always refresh the dog manager when we recieve a log notification, as that means another user logged something.
        // If we invoke on 'NOTIFICATION_CATEGORY_REMINDER' as well, then everytime a reminder triggers its alarm and a notification comes thru, it will cause a refresh. This will cause a weird interaction as we will be simultaneously showing an alert in app
        else if category.contains("NOTIFICATION_CATEGORY_LOG") {
            MainTabBarController.shouldSilentlyRefreshDogManager = true
            completionHandler(.newData)
            return
        }
        // if the notification is a reminder, then check to see if loud notification can be played
        else if category.contains("NOTIFICATION_CATEGORY_REMINDER") {
            // check to see if we have a reminderLastModified available to us
            if let reminderLastModifiedString = userInfo["reminderLastModified"] as? String, let reminderLastModified = reminderLastModifiedString.formatISO8601IntoDate() {
                
                if let previousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization, previousDogManagerSynchronization.distance(to: reminderLastModified) > 0 {
                    // If the reminder was modified after the last time we synced our whole dogManager, then that means our local reminder is out of date.
                    // This makes our local reminder untrustworthy. The server reminder could have been deleted (and we don't know), the server reminder could have been created (and we don't have it locally), or the server reminder could have had its timing changes (and our locally timing will be inaccurate).
                    // Therefore, we should refresh the dogManager to make sure we are up to date on important features of the reminder's state: create, delete, timing.
                    // Once everything is synced again, the alarm will be shown as expected.

                    // Note: we also individually refresh a reminder before immediately constructing its alertController for its alarm. This ensure, even if the user has notifications turned off (meaning this piece of code right here won't be executed), that the reminder they are being show is up to date.
                    MainTabBarController.shouldSilentlyRefreshDogManager = true
                }
                else if LocalConfiguration.previousDogManagerSynchronization == nil {
                    MainTabBarController.shouldSilentlyRefreshDogManager = true
                }
            }

            AudioManager.playLoudNotification()

            completionHandler(.newData)
            return
        }

        completionHandler(.noData)
        return
    }
    
    func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask {
        return [.portrait]
    }

}
//
//  SceneDelegate.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    
    var window: UIWindow?
    
    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        HoundLogger.lifecycle.notice("Scene Will Connect To Session")
        // Use this function to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        
        // If UserConfiguration.interfaceStyle is updated, it will send a didUpdateUserInterfaceStyle notification, which we then recieve to overrideUserInterfaceStyle every view in our window with the new value
        NotificationCenter.default.addObserver(self, selector: #selector(didUpdateUserInterfaceStyle), name: .didUpdateUserInterfaceStyle, object: nil)
        
        // set initial interface style
        window?.overrideUserInterfaceStyle = UserConfiguration.interfaceStyle
        
        guard let windowScene = scene as? UIWindowScene else { return }
        
        let window = UIWindow(windowScene: windowScene)
        let vc = ServerSyncVC()
        window.rootViewController = vc
        window.makeKeyAndVisible()
        self.window = window
    }
    
    @objc private func didUpdateUserInterfaceStyle() {
        window?.overrideUserInterfaceStyle = UserConfiguration.interfaceStyle
    }
    
    func sceneDidDisconnect(_ scene: UIScene) {
        HoundLogger.lifecycle.notice("Scene Did Disconnect")
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not neccessarily discarded (see `application:didDiscardSceneSessions` instead).
    }
    
    func sceneDidBecomeActive(_ scene: UIScene) {
        HoundLogger.lifecycle.notice("Scene Did Become Active")
        
        PersistenceManager.didBecomeActive()
        // Called when the scene has moved from an inactive state to an active state.
        // Use this function to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }
    
    func sceneWillResignActive(_ scene: UIScene) {
        HoundLogger.lifecycle.notice("Scene Will Resign Active")
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }
    
    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this function to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.
        HoundLogger.lifecycle.notice("Scene Did Enter Background")
        PersistenceManager.didEnterBackground(isTerminating: false)
    }
    
    func sceneWillEnterForeground(_ scene: UIScene) {
        HoundLogger.lifecycle.notice("Scene Will Enter Foreground")
        PersistenceManager.willEnterForeground()
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self, name: .didUpdateUserInterfaceStyle, object: nil)
    }
}
//
//  MainTabBar.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class MainTabBar: UITabBar {

    // MARK: - Properties

    private var shapeLayer: CAShapeLayer?
    private let radii: Double = Constant.Visual.Layer.imageCoveringViewCornerRadius

    // MARK: - Main

    override func draw(_ rect: CGRect) {
        addShape()
    }

    override func layoutSubviews() {
        super.layoutSubviews()
        self.isTranslucent = true
        self.layer.cornerRadius = Constant.Visual.Layer.imageCoveringViewCornerRadius
        self.layer.cornerCurve = .continuous
    }
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        
        // UI has changed its appearance to dark/light mode
        if #available(iOS 13.0, *), traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            // same as addShape
            shapeLayer?.strokeColor = UIColor.systemGray4.cgColor
            shapeLayer?.fillColor = UIColor.systemBackground.cgColor
            shapeLayer?.shadowColor = UIColor.systemGray4.cgColor
        }
    }

    // MARK: - Functions

    private func addShape() {
        let shapeLayer = CAShapeLayer()

        shapeLayer.path = {
            UIBezierPath(
                roundedRect: bounds,
                byRoundingCorners: [.topLeft, .topRight],
                cornerRadii: CGSize(width: radii, height: 0.0)
            ).cgPath
        }()
        // same as traitCollectionDidChange
        shapeLayer.strokeColor = UIColor.systemGray4.cgColor
        shapeLayer.fillColor = UIColor.systemBackground.cgColor
        shapeLayer.shadowColor = UIColor.systemGray4.cgColor
        shapeLayer.lineWidth = 1
        shapeLayer.shadowOffset = CGSize(width: 0, height: -2)
        shapeLayer.shadowOpacity = 0.1
        shapeLayer.shadowRadius = 8
        shapeLayer.shadowPath = UIBezierPath(roundedRect: bounds, cornerRadius: radii).cgPath

        if let oldShapeLayer = self.shapeLayer {
            layer.replaceSublayer(oldShapeLayer, with: shapeLayer)
        }
        else {
            layer.insertSublayer(shapeLayer, at: 0)
        }

        self.shapeLayer = shapeLayer
    }

}
//
//  MainTabBarController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/1/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED 6/24/25
final class MainTabBarController: HoundTabBarController,
                                  ReminderTimingManagerDelegate,
                                  RemindersIntroductionVCDelegate,
                                  ReminderAlarmManagerDelegate,
                                  LogsVCDelegate,
                                  DogsVCDelegate,
                                  SettingsPagesTableVCDelegate,
                                  OfflineModeManagerDelegate,
                                  UITabBarControllerDelegate {
    
    // MARK: LogsVCDelegate && DogsVCDelegate
    
    func didUpdateDogManager(sender: Sender, dogManager: DogManager) {
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    // MARK: - ReminderAlarmManagerDelegate
    
    func didAddLog(sender: Sender, dogUUID: UUID, log: Log, invokeDogTriggers: Bool) {
        let triggerReminders = dogManager.findDog(dogUUID: dogUUID)?.dogLogs.addLog(log: log, invokeDogTriggers: invokeDogTriggers)
        setDogManager(sender: sender, dogManager: dogManager)
        
        guard let triggerReminders = triggerReminders, !triggerReminders.isEmpty else {
            return
        }
        
        // silently try to create trigger reminders
        RemindersRequest.create(errorAlert: .automaticallyAlertForNone, dogUUID: dogUUID, reminders: triggerReminders) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                return
            }
            self.dogManager.findDog(dogUUID: dogUUID)?.dogReminders.addReminders(reminders: triggerReminders)
            self.setDogManager(sender: sender, dogManager: self.dogManager)
        }
    }
    
    func didRemoveReminder(sender: Sender, dogUUID: UUID, reminderUUID: UUID) {
        let dogReminders = dogManager.findDog(dogUUID: dogUUID)?.dogReminders
        dogReminders?.removeReminder(reminderUUID: reminderUUID)
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    // MARK: - ReminderAlarmManagerDelegate && ReminderTimingManagerDelegate
    
    func didAddReminder(sender: Sender, dogUUID: UUID, reminder: Reminder) {
        dogManager.findDog(dogUUID: dogUUID)?.dogReminders.addReminder(reminder: reminder)
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    // MARK: - Dog Manager
    
    private var dogManager: DogManager = DogManager.globalDogManager ?? DogManager()
    
    /// Sets dog manager; when the value changes, propagate timers and child VCs
    func setDogManager(sender: Sender, dogManager: DogManager) {
        self.dogManager = dogManager
        DogManager.globalDogManager = dogManager
        
        // If not coming from ServerSyncVC, initialize timers
        if (sender.localized is ServerSyncVC) == false {
            ReminderTimingManager.initializeReminderTimers(dogManager: dogManager)
        }
        // Propagate to DogsVC if sender isn't DogsVC
        if (sender.localized is DogsVC) == false {
            dogsViewController.setDogManager(
                sender: Sender(origin: sender, localized: self),
                dogManager: dogManager
            )
        }
        // Propagate to LogsVC if sender isn't LogsVC
        if (sender.localized is LogsVC) == false {
            logsViewController.setDogManager(
                sender: Sender(origin: sender, localized: self),
                dogManager: dogManager
            )
        }
    }
    
    // MARK: - UITabBarControllerDelegate
    
    func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -> Bool {
        if let index = tabBarController.viewControllers?.firstIndex(of: viewController),
           index != tabBarController.selectedIndex {
            // Manually set selectedIndex, disables built-in animation
            tabBarController.selectedIndex = index
            return false
        }
        return true
    }
    
    // MARK: - Properties
    
    enum MainTabBarControllerIndexes: Int {
        case logs = 0
        case reminders = 1
        case settings = 2
    }
    
    private static var mainTabBarController: MainTabBarController?
    
    private let logsViewController = LogsVC()
    private let dogsViewController = DogsVC()
    private let settingsPagesTableViewController = SettingsPagesTableVC(style: .grouped)
    
    var tabBarUpperLineView: UIView?
    
    /// Returns true if this controller is currently in the view hierarchy
    static var isInViewHierarchy: Bool {
        return MainTabBarController.mainTabBarController?.viewIfLoaded?.window != nil
    }
    
    /// Toggled when a 'reminder' or 'log' notification arrives, indicating a refresh is needed
    static var shouldSilentlyRefreshDogManager: Bool = false {
        didSet {
            guard shouldSilentlyRefreshDogManager == true else { return }
            guard let mainTBC = MainTabBarController.mainTabBarController,
                  mainTBC.viewIfLoaded?.window != nil else {
                // Not visible; refresh when it appears
                return
            }
            DogsRequest.get(
                errorAlert: .automaticallyAlertForNone,
                dogManager: mainTBC.dogManager
            ) { newDM, _, _ in
                MainTabBarController.shouldSilentlyRefreshDogManager = false
                guard let newDM = newDM else { return }
                mainTBC.setDogManager(
                    sender: Sender(origin: self, localized: self),
                    dogManager: newDM
                )
            }
        }
    }
    
    /// Toggled when a 'family' notification arrives, indicating a family‐level refresh
    static var shouldSilentlyRefreshFamily: Bool = false {
        didSet {
            guard shouldSilentlyRefreshFamily == true else { return }
            guard MainTabBarController.mainTabBarController?.viewIfLoaded?.window != nil else {
                return
            }
            FamilyRequest.get(errorAlert: .automaticallyAlertForNone) { _, _ in
                MainTabBarController.shouldSilentlyRefreshFamily = false
            }
        }
    }
    
    // MARK: - Main
    
    convenience init() {
        self.init(nibName: nil, bundle: nil)
    }
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        delegate = self
        tabBar.isTranslucent = true
        navigationController?.navigationBar.isTranslucent = true
        
        HoundLogger.lifecycle.notice("Version: \(AppVersion.current)")
        
        logsViewController.setup(delegate: self)
        logsViewController.setDogManager(sender: Sender(origin: self, localized: self), dogManager: dogManager)
        
        dogsViewController.setup(delegate: self)
        dogsViewController.setDogManager(sender: Sender(origin: self, localized: self), dogManager: dogManager)
        
        settingsPagesTableViewController.setup(delegate: self)
        
        MainTabBarController.mainTabBarController = self
        ReminderTimingManager.delegate = self
        ReminderAlarmManager.delegate = self
        OfflineModeManager.shared.delegate = self
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        if MainTabBarController.shouldSilentlyRefreshDogManager {
            DogsRequest.get(
                errorAlert: .automaticallyAlertForNone,
                dogManager: self.dogManager
            ) { newDM, _, _ in
                MainTabBarController.shouldSilentlyRefreshDogManager = false
                guard let newDM = newDM else { return }
                self.setDogManager(
                    sender: Sender(origin: self, localized: self),
                    dogManager: newDM
                )
            }
        }
        
        if MainTabBarController.shouldSilentlyRefreshFamily {
            FamilyRequest.get(errorAlert: .automaticallyAlertForNone) { _, _ in
                MainTabBarController.shouldSilentlyRefreshFamily = false
            }
        }
    }
    
    private var didSetupCustomSubviews: Bool = false
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        if UserInformation.isUserFamilyHead {
            InAppPurchaseManager.showPriceConsentIfNeeded()
        }
        
        ShowBonusInformationManager.showReleaseNotesBannerIfNeeded()
        
        // Synchronize notifications and timers on each appearance
        NotificationPermissionsManager.synchronizeNotificationAuthorization()
        ReminderTimingManager.initializeReminderTimers(dogManager: dogManager)
        
        guard didSetupCustomSubviews == false else { return }
        didSetupCustomSubviews = true
        
        // Slight delay so tab item frames are valid before drawing underline
        DispatchQueue.main.asyncAfter(deadline: .now()) {
            self.addTabBarUpperLine(index: self.selectedIndex)
        }
    }
    
    // MARK: - Functions
    
    override func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
        // selectedIndex is still the “old” index at this moment; compute new index manually
        guard let newIndex = tabBar.items?.firstIndex(of: item) else { return }
        addTabBarUpperLine(index: newIndex)
        
        switch newIndex {
        case MainTabBarControllerIndexes.logs.rawValue:
            logsViewController.logsTableViewController.scrollToTop(animated: true)
        case MainTabBarControllerIndexes.reminders.rawValue:
            dogsViewController.scrollDogsTableViewControllerToTop()
            
            if LocalConfiguration.localHasCompletedRemindersIntroductionViewController == false {
                if dogManager.hasCreatedReminder == false {
                    let introVC = RemindersIntroductionVC()
                    introVC.setup(delegate: self, dogManager: dogManager)
                    PresentationManager.enqueueViewController(introVC)
                }
                else {
                    // Not eligible; request notifications directly
                    NotificationPermissionsManager.requestNotificationAuthorization(
                        shouldAdviseUserBeforeRequestingNotifications: true,
                        completionHandler: nil
                    )
                    LocalConfiguration.localHasCompletedRemindersIntroductionViewController = true
                }
            }
        default:
            break
        }
    }
    
    private func addTabBarUpperLine(index: Int) {
        // Underline the selected tab item by accessing its underlying view
        guard let tabView = tabBar.items?[index].value(forKey: "view") as? UIView else { return }
        tabBarUpperLineView?.removeFromSuperview()
        
        let inset = tabView.frame.width * 0.15
        let lineFrame = CGRect(
            x: tabView.frame.minX + inset,
            y: tabView.frame.minY + 0.1,
            width: tabView.frame.width - (inset * 2),
            height: 2.0
        )
        let line = UIView(frame: lineFrame)
        line.backgroundColor = UIColor.systemBlue
        tabBar.addSubview(line)
        tabBarUpperLineView = line
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        if let mainTabBar = self.value(forKey: "tabBar") as? UITabBar,
           !(mainTabBar is MainTabBar) {
            let customTabBar = MainTabBar()
            self.setValue(customTabBar, forKey: "tabBar")
        }
        
        view.backgroundColor = UIColor.secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        let logsNavController = {
            let navController = UINavigationController(rootViewController: logsViewController)
            navController.navigationBar.barTintColor = UIColor.systemBackground
            navController.navigationBar.titleTextAttributes = [
                NSAttributedString.Key.font: UIFont.boldSystemFont(ofSize: 20),
                NSAttributedString.Key.foregroundColor: UIColor.systemBlue
            ]
            navController.navigationBar.isHidden = true
            navController.tabBarItem = UITabBarItem(
                title: "Logs",
                image: UIImage(systemName: "list.bullet.rectangle"),
                tag: MainTabBarControllerIndexes.logs.rawValue
            )
            
            return navController
        }()
        
        let dogsNavController = {
            let navController = UINavigationController(rootViewController: dogsViewController)
            navController.navigationBar.barTintColor = UIColor.systemBackground
            navController.navigationBar.titleTextAttributes = [
                NSAttributedString.Key.font: UIFont.boldSystemFont(ofSize: 20),
                NSAttributedString.Key.foregroundColor: UIColor.systemBlue
            ]
            navController.navigationBar.isHidden = true
            navController.tabBarItem = UITabBarItem(
                title: "Dogs",
                image: UIImage(named: "tabBarBlackPaw"),
                tag: MainTabBarControllerIndexes.reminders.rawValue
            )
            
            return navController
        }()
        
        let settingsNavController = {
            let navController = UINavigationController(rootViewController: settingsPagesTableViewController)
            navController.navigationBar.barTintColor = UIColor.systemBackground
            navController.navigationBar.titleTextAttributes = [
                NSAttributedString.Key.font: UIFont.boldSystemFont(ofSize: 20),
                NSAttributedString.Key.foregroundColor: UIColor.systemBlue
            ]
            navController.navigationBar.isHidden = true
            navController.tabBarItem = UITabBarItem(
                title: "Settings",
                image: UIImage(systemName: "gearshape"),
                tag: MainTabBarControllerIndexes.settings.rawValue
            )
            
            return navController
        }()
        
        self.viewControllers = [logsNavController, dogsNavController, settingsNavController]
    }
    
    override func setupConstraints() {
        super.setupConstraints()
    }
}
//
//  DogsAddDogTriggerView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/10/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddDogTriggersViewDelegate: AnyObject {
    func shouldOpenAddTriggerVC(trigger: Trigger?)
    func didUpdateTriggerCount()
}

final class DogsAddDogTriggersView: HoundView, UITableViewDataSource, UITableViewDelegate {
    
    // MARK: - Elements

    private lazy var tableView: HoundTableView = {
        let tableView = HoundTableView()
        tableView.dataSource = self
        tableView.delegate = self
        
        tableView.register(DogsAddDogTriggerTVC.self, forCellReuseIdentifier: DogsAddDogTriggerTVC.reuseIdentifier)
        
        tableView.isScrollEnabled = false
        
        tableView.shouldAutomaticallyAdjustHeight = true
        tableView.emptyStateEnabled = true
        tableView.emptyStateMessage = "No automations yet..."
        
        return tableView
    }()

    private lazy var addTriggerButton: HoundButton = {
        let button = HoundButton()
        
        button.setTitle("Add Automation", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.thinLabelBorder)
        
        button.addTarget(self, action: #selector(didTouchUpInsideAddTrigger), for: .touchUpInside)
        
        return button
    }()
    
    @objc func didTouchUpInsideAddTrigger() {
        guard dogTriggers.dogTriggers.count < Constant.Class.Dog.maximumNumberOfTriggers else {
            PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.noAddMoreTriggersTitle, subtitle: Constant.Visual.BannerText.noAddMoreTriggersSubtitle, style: .warning)
            return
        }
        
        delegate?.shouldOpenAddTriggerVC(trigger: nil)
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddDogTriggersViewDelegate?
    /// dogTriggers is either a copy of dogToUpdate's triggers or a DogTriggerManager initialized to a default array of triggers. This is purposeful so that either, if you dont have a dogToUpdate, you can still create triggers, and if you do have a dogToUpdate, you don't directly update the dogToUpdate until save is pressed
    private(set) var dogTriggers: DogTriggerManager = DogTriggerManager(dogTriggers: Constant.Class.Trigger.defaultTriggers)
    private(set) var initialTriggers: DogTriggerManager = DogTriggerManager(dogTriggers: Constant.Class.Trigger.defaultTriggers)
    
    var didUpdateInitialValues: Bool {
        // if current triggers has more triggers than initial triggers, the loop below won't catch it, as the loop below just looks to see if each initial trigger is still present in current triggers.
        if initialTriggers.dogTriggers.count != dogTriggers.dogTriggers.count {
            return true
        }
        // make sure each initial trigger has a corresponding current trigger, otherwise current triggers have been updated
        for initialTrigger in initialTriggers.dogTriggers {
            let currentTrigger = dogTriggers.dogTriggers.first(where: { $0.triggerUUID == initialTrigger.triggerUUID })
            
            guard let currentTrigger = currentTrigger else {
                // no corresponding trigger
                return true
            }
            
            // if any of the corresponding triggers are different, then return true to indicate that a trigger has been updated
            if !initialTrigger.isSame(as: currentTrigger) {
                return true
            }
        }
        
        return false
    }
    
    // MARK: - Setup
    
    func setup(delegate: DogsAddDogTriggersViewDelegate, dogTriggers: DogTriggerManager?) {
        self.delegate = delegate
        
        self.dogTriggers = (dogTriggers?.copy() as? DogTriggerManager) ?? self.dogTriggers
        initialTriggers = (dogTriggers?.copy() as? DogTriggerManager) ?? initialTriggers
        
        tableView.reloadData()
    }
    
    // MARK: - Functions
    
    func didAddTrigger(trigger: Trigger) {
        dogTriggers.addTrigger(trigger: trigger)
        delegate?.didUpdateTriggerCount()
        // not in view so no animation
        self.tableView.reloadData()
    }
    
    func didUpdateTrigger(trigger: Trigger) {
        dogTriggers.addTrigger(trigger: trigger)
        delegate?.didUpdateTriggerCount()
        // not in view so no animation
        self.tableView.reloadData()
    }
    
    func didRemoveTrigger(triggerUUID: UUID) {
        dogTriggers.removeTrigger(triggerUUID: triggerUUID)
        delegate?.didUpdateTriggerCount()
        // not in view so no animation
        self.tableView.reloadData()
    }
    
    // MARK: - Table View Data Source
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return dogTriggers.dogTriggers.count
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
        // Only add spacing if NOT the last section
        let lastSection = dogTriggers.dogTriggers.count - 1
        return section == lastSection ? 0 : Constant.Constraint.Spacing.contentTallIntraVert
    }
    
    func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {
        // Only return a view if not the last section
        let lastSection = InAppPurchaseManager.subscriptionProducts.count - 1
        if section == lastSection {
            return nil
        }
        
        let footer = HoundHeaderFooterView()
        return footer
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: DogsAddDogTriggerTVC.reuseIdentifier, for: indexPath)
        
        if let castedCell = cell as? DogsAddDogTriggerTVC {
            castedCell.setup(trigger: dogTriggers.dogTriggers[indexPath.section])
            castedCell.containerView.roundCorners(setCorners: .all)
        }
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let trigger = dogTriggers.dogTriggers[indexPath.section]
        
        delegate?.shouldOpenAddTriggerVC(trigger: trigger)
    }
    
    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
        guard editingStyle == .delete && dogTriggers.dogTriggers.isEmpty == false else { return }
        
        let trigger = dogTriggers.dogTriggers[indexPath.section]
        
        let removeTriggerConfirmation = UIAlertController(title: "Are you sure you want to delete this trigger?", message: nil, preferredStyle: .alert)
        
        let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
            self.dogTriggers.removeTrigger(triggerUUID: trigger.triggerUUID)
            self.delegate?.didUpdateTriggerCount()
            
            self.tableView.deleteSections([indexPath.section], with: .fade)
            UIView.animate(withDuration: Constant.Visual.Animation.moveMultipleElements) {
                self.setNeedsLayout()
                self.layoutIfNeeded()
            }
            
        }
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        removeTriggerConfirmation.addAction(removeAlertAction)
        removeTriggerConfirmation.addAction(cancelAlertAction)
        PresentationManager.enqueueAlert(removeTriggerConfirmation)
    }
    
    func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        return dogTriggers.dogTriggers.isEmpty == false
    }

    // MARK: - Setup Elements

    override func addSubViews() {
        super.addSubViews()
        addSubview(tableView)
        addSubview(addTriggerButton)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: topAnchor),
            tableView.leadingAnchor.constraint(equalTo: leadingAnchor),
            tableView.trailingAnchor.constraint(equalTo: trailingAnchor)
        ])

        NSLayoutConstraint.activate([
            addTriggerButton.topAnchor.constraint(equalTo: tableView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            addTriggerButton.bottomAnchor.constraint(equalTo: bottomAnchor),
            addTriggerButton.leadingAnchor.constraint(equalTo: leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            addTriggerButton.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            addTriggerButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: self),
            addTriggerButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }
}
//
//  DogsAddDogTriggerTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/10/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

final class DogsAddDogTriggerTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    let containerView: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.systemBackground
        view.applyStyle(.thinGrayBorder)
        return view
    }()
    
    private let logReactionsLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        return label
    }()
    
    private let reminderResultLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.secondaryRegularLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        return label
    }()
    
    private lazy var labelStack: HoundStackView = {
        let stack = HoundStackView(huggingPriority: 290, compressionResistancePriority: 290)
        stack.addArrangedSubview(logReactionsLabel)
        stack.addArrangedSubview(reminderResultLabel)
        stack.axis = .vertical
        stack.distribution = .equalSpacing
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        stack.alignment = .leading
        return stack
    }()
    
    private let chevronImageView: HoundImageView = {
        let imageView = HoundImageView(huggingPriority: 300, compressionResistancePriority: 300)
        
        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = UIColor.systemGray4
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "DogsAddDogTriggerTVC"
    
    // MARK: - Setup
    
    func setup(trigger: Trigger) {
        logReactionsLabel.attributedText = {
            let logs = trigger.triggerLogReactions.map { $0.readableName(includeMatchingEmoji: true) }
            let logNames = logs.joined(separator: ", ", endingSeparator: " or ")
            
            // Build the appropriate phrase depending on trigger conditions.
            let text: String
            if trigger.triggerManualCondition && trigger.triggerAlarmCreatedCondition {
                text = "Whenever a \(logNames) log is added"
            }
            else if trigger.triggerManualCondition {
                text = "Whenever someone adds a \(logNames) log"
            }
            else if trigger.triggerAlarmCreatedCondition {
                text = "Whenever an alarm adds a \(logNames) log"
            }
            else {
                text = "Whenever a \(logNames) log is added"
            }
            
            // Find ranges for emphasis styling (log names)
            let attributed = NSMutableAttributedString(string: text, attributes: [.font: Constant.Visual.Font.primaryRegularLabel])
            
            // Find and emphasize log names within the text
            if let range = attributed.string.range(of: logNames) {
                let nsRange = NSRange(range, in: attributed.string)
                attributed.addAttributes([.font: Constant.Visual.Font.emphasizedPrimaryRegularLabel], range: nsRange)
            }
            return attributed
        }()
        
        reminderResultLabel.attributedText = {
            let message: NSMutableAttributedString = NSMutableAttributedString(
                string: "Create ",
                attributes: [.font: Constant.Visual.Font.secondaryRegularLabel])
            message.append(
                NSAttributedString(
                    string: trigger.triggerReminderResult.readableName,
                    attributes: [.font: Constant.Visual.Font.emphasizedSecondaryRegularLabel]
                )
            )
            message.append(
                NSAttributedString(
                    string: " for \(trigger.readableTime())",
                    attributes: [.font: Constant.Visual.Font.secondaryRegularLabel]
                )
            )
            return message
        }()
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        
        containerView.addSubview(labelStack)
        containerView.addSubview(chevronImageView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        containerView.snp.makeConstraints { make in
            make.top.equalTo(contentView.snp.top)
            // Use .high priority to avoid breaking during table view height estimation
            make.bottom.equalTo(contentView.snp.bottom).priority(.high)
            make.leading.equalTo(contentView.snp.leading).offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalTo(contentView.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        labelStack.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset)
            make.leading.equalTo(containerView.snp.leading).offset(Constant.Constraint.Spacing.contentIntraHori)
            make.bottom.equalTo(containerView.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset)
        }
        
        chevronImageView.snp.makeConstraints { make in
            make.leading.equalTo(labelStack.snp.trailing).offset(Constant.Constraint.Spacing.contentIntraHori)
            make.trailing.equalTo(containerView.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.centerY.equalTo(containerView.snp.centerY)
            make.height.equalTo(contentView.snp.width).multipliedBy(Constant.Constraint.Button.chevronHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.chevronMaxHeight)
            make.width.equalTo(chevronImageView.snp.height).multipliedBy(Constant.Constraint.Button.chevronAspectRatio)
        }
    }
}
//
//  DogsAddDogReminderTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/20/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

protocol DogsAddDogReminderTVCDelegate: AnyObject {
    /// The reminder switch to toggle the enable status was flipped. The reminder was updated and the server was NOT queried.
    func didUpdateReminderIsEnabled(sender: Sender, reminderUUID: UUID, reminderIsEnabled: Bool)
}

final class DogsAddDogReminderTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    let containerView: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.systemBackground
        view.applyStyle(.thinGrayBorder)
        return view
    }()
    
    private let triggerResultIndicatorImageView: HoundImageView = {
        let imageView = HoundImageView()
        imageView.image = UIImage(systemName: "sparkles")
        imageView.tintColor = UIColor.systemBlue
        return imageView
    }()
    
    private let reminderActionLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedPrimaryRegularLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        return label
    }()
    
    private let intervalLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.secondaryRegularLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        return label
    }()
    
    private lazy var labelStack: HoundStackView = {
        let stack = HoundStackView(huggingPriority: 290, compressionResistancePriority: 290)
        stack.addArrangedSubview(reminderActionLabel)
        stack.addArrangedSubview(intervalLabel)
        stack.axis = .vertical
        stack.distribution = .equalSpacing
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        stack.alignment = .leading
        return stack
    }()
    
    private lazy var reminderIsEnabledSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch()
        uiSwitch.isOn = true
        uiSwitch.addTarget(self, action: #selector(didToggleReminderIsEnabled), for: .valueChanged)
        return uiSwitch
    }()
    
    private let chevronImageView: HoundImageView = {
        let imageView = HoundImageView()
        
        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = UIColor.systemGray4
        
        return imageView
    }()
    
    private let noNotificationIndicator: HoundImageView = {
        let imageView = HoundImageView()
        
        imageView.image = UIImage(systemName: "bell.slash")
        imageView.tintColor = UIColor.systemGray4
        
        return imageView
    }()
    
    private let differentTimeZoneIndicator: HoundImageView = {
        let imageView = HoundImageView()
        
        imageView.image = UIImage(systemName: "globe")
        imageView.tintColor = UIColor.systemGray4
        
        return imageView
    }()
    
    private lazy var chevronSwitchStack: HoundStackView = {
        let stack = HoundStackView(huggingPriority: 300, compressionResistancePriority: 300)
        
        let imageStack = HoundStackView()
        imageStack.addArrangedSubview(noNotificationIndicator)
        imageStack.addArrangedSubview(differentTimeZoneIndicator)
        imageStack.axis = .vertical
        imageStack.alignment = .trailing
        imageStack.spacing = Constant.Constraint.Spacing.contentIntraVert
        
        stack.addArrangedSubview(imageStack)
        stack.addArrangedSubview(reminderIsEnabledSwitch)
        stack.addArrangedSubview(chevronImageView)
        stack.axis = .horizontal
        stack.distribution = .fill
        stack.alignment = .center
        stack.spacing = Constant.Constraint.Spacing.absoluteHoriInset
        return stack
    }()
    
    private lazy var finalStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(triggerResultIndicatorImageView)
        stack.addArrangedSubview(labelStack)
        stack.addArrangedSubview(chevronSwitchStack)
        stack.axis = .horizontal
        stack.distribution = .fill
        stack.alignment = .center
        stack.spacing = Constant.Constraint.Spacing.contentIntraHori
        return stack
    }()
    
    @objc private func didToggleReminderIsEnabled(_ sender: Any) {
        guard let reminder = reminder else { return }
        
        reminder.reminderIsEnabled = reminderIsEnabledSwitch.isOn
        updateIndicators()
        
        delegate?.didUpdateReminderIsEnabled(sender: Sender(origin: self, localized: self), reminderUUID: reminder.reminderUUID, reminderIsEnabled: reminderIsEnabledSwitch.isOn)
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "DogsAddDogReminderTVC"
    
    private var reminder: Reminder?
    
    private weak var delegate: DogsAddDogReminderTVCDelegate?
    
    // MARK: - Setup
    
    func setup(delegate: DogsAddDogReminderTVCDelegate, reminder: Reminder) {
        self.delegate = delegate
        reminderIsEnabledSwitch.isOn = reminder.reminderIsEnabled
        self.reminder = reminder
        
        reminderActionLabel.text = reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName, includeMatchingEmoji: true)
        
        intervalLabel.text = reminder.readableRecurrance()
        
        triggerResultIndicatorImageView.isHidden = !reminder.reminderIsTriggerResult
        chevronImageView.isHidden = reminder.reminderIsTriggerResult
        reminderIsEnabledSwitch.isHidden = reminder.reminderIsTriggerResult
        
        updateIndicators()
    }
    
    // MARK: - Functions
    
    private func updateIndicators() {
        guard let reminder = reminder else { return }
        let userIsRecipient = reminder.reminderRecipientUserIds.contains { $0 == UserInformation.userId ?? Constant.Visual.Text.unknownUserId }
        let hasRecipients = !reminder.reminderRecipientUserIds.isEmpty
        
        let shouldShowBell =
        reminder.reminderIsEnabled && (
            !userIsRecipient ||
            (hasRecipients && !UserConfiguration.isNotificationEnabled) ||
            (hasRecipients && !UserConfiguration.isReminderNotificationEnabled)
        )
        if noNotificationIndicator.isHidden != !shouldShowBell {
            noNotificationIndicator.isHidden = !shouldShowBell
            remakeNoNotificationIndicatorConstraints()
        }
        
        let shouldShowDiffTZ = reminder.reminderIsEnabled && reminder.reminderTimeZone != UserConfiguration.timeZone
        if differentTimeZoneIndicator.isHidden != !shouldShowDiffTZ {
            differentTimeZoneIndicator.isHidden = !shouldShowDiffTZ
            remakeDifferentTimeZoneIndicatorConstraints()
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        
        containerView.addSubview(finalStack)
    }
    
    private func remakeNoNotificationIndicatorConstraints() {
        noNotificationIndicator.snp.remakeConstraints { make in
            // the entire ui becomes unresponsive if we dont do these 0 constraints
            if noNotificationIndicator.isHidden {
                make.height.equalTo(0)
                make.width.equalTo(0)
            }
            else {
                make.height.equalTo(contentView.snp.width).multipliedBy(Constant.Constraint.Button.chevronHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Button.chevronMaxHeight)
                make.width.equalTo(noNotificationIndicator.snp.height)
            }
        }
    }
    
    private func remakeDifferentTimeZoneIndicatorConstraints() {
        differentTimeZoneIndicator.snp.remakeConstraints { make in
            // the entire ui becomes unresponsive if we dont do these 0 constraints
            if differentTimeZoneIndicator.isHidden {
                make.height.equalTo(0)
                make.width.equalTo(0)
            }
            else {
                make.height.equalTo(contentView.snp.width).multipliedBy(Constant.Constraint.Button.chevronHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Button.chevronMaxHeight)
                make.width.equalTo(differentTimeZoneIndicator.snp.height)
            }
        }
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        containerView.snp.makeConstraints { make in
            make.top.equalTo(contentView.snp.top)
            // Use .high priority to avoid breaking during table view height estimation
            make.bottom.equalTo(contentView.snp.bottom).priority(.high)
            make.leading.equalTo(contentView.snp.leading).offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalTo(contentView.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        finalStack.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset)
            make.bottom.equalTo(containerView.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset)
            make.leading.equalTo(containerView.snp.leading).offset(Constant.Constraint.Spacing.contentIntraHori)
            make.trailing.equalTo(containerView.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        triggerResultIndicatorImageView.snp.makeConstraints { make in
            make.height.equalTo(contentView.snp.width).multipliedBy(Constant.Constraint.Button.circleHeightMultiplier / 1.5).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.circleMaxHeight / 1.5)
            make.width.equalTo(triggerResultIndicatorImageView.snp.height)
        }
        
        chevronImageView.snp.makeConstraints { make in
            make.height.equalTo(contentView.snp.width).multipliedBy(Constant.Constraint.Button.chevronHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.chevronMaxHeight)
            make.width.equalTo(chevronImageView.snp.height).multipliedBy(Constant.Constraint.Button.chevronAspectRatio)
        }
        
        remakeNoNotificationIndicatorConstraints()
        remakeDifferentTimeZoneIndicatorConstraints()
    }
    
}
//
//  DogsAddDogVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/19/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddDogVCDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
}

final class DogsAddDogVC: HoundScrollViewController, UITextFieldDelegate, UIImagePickerControllerDelegate, UINavigationControllerDelegate, DogsAddReminderVCDelegate, DogsAddTriggerVCDelegate, DogsAddDogRemindersViewDelegate, DogsAddDogTriggersViewDelegate {
    
    // MARK: - UIImagePickerControllerDelegate
    
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
        
        if let dogIcon = DogIconManager.processDogIcon(info: info) {
            self.dogIconButton.setTitle(nil, for: .normal)
            self.dogIconButton.setImage(dogIcon, for: .normal)
        }
        
        picker.dismiss(animated: true)
    }
    
    // MARK: - UITextFieldDelegate
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        if !(dogNameTextField.text ?? "").isEmpty {
            dogNameTextField.errorMessage = nil
        }
        self.dismissKeyboard()
        return false
    }
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        if !string.isEmpty {
            dogNameTextField.errorMessage = nil
        }
        // attempt to read the range they are trying to change
        guard let currentText = textField.text, let stringRange = Range(range, in: currentText) else {
            return true
        }
        
        // add their new text to the existing text
        let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
        
        // make sure the result is under dogNameCharacterLimit
        return updatedText.count <= Constant.Class.Dog.dogNameCharacterLimit
    }
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
    // MARK: - DogsAddDogRemindersViewDelegate
    
    func shouldOpenAddReminderVC(reminder: Reminder?) {
        let vc = DogsAddReminderVC()
        /// DogsAddDogVC takes care of all server communication when, and if, the user decides to save their changes to the dog. Therefore, we don't provide a reminderToUpdateDogUUID to dogsAddReminderViewController, as otherwise it would contact and update the server.
        vc.setup(delegate: self, reminderToUpdateDogUUID: nil, reminderToUpdate: reminder)
        PresentationManager.enqueueViewController(vc)
    }
    
    // MARK: - DogsAddDogTriggersViewDelegate
    
    func shouldOpenAddTriggerVC(trigger: Trigger?) {
        let vc = DogsAddTriggerVC()
        /// DogsAddDogVC takes care of all server communication when, and if, the user decides to save their changes to the dog. Therefore, we don't provide a reminderToUpdateDogUUID to dogsAddReminderViewController, as otherwise it would contact and update the server.
        vc.setupWithoutServerPersistence(delegate: self, dog: dogToUpdate, triggerToUpdate: trigger)
        PresentationManager.enqueueViewController(vc)
    }
    
    // MARK: - DogsAddReminderVCDelegate
    
    func didAddReminder(sender: Sender, dogUUID: UUID?, reminder: Reminder) {
        self.remindersView.didAddReminder(reminder: reminder)
    }
    
    func didUpdateReminder(sender: Sender, dogUUID: UUID?, reminder: Reminder) {
        self.remindersView.didUpdateReminder(reminder: reminder)
    }
    
    func didRemoveReminder(sender: Sender, dogUUID: UUID?, reminderUUID: UUID) {
        self.remindersView.didRemoveReminder(reminderUUID: reminderUUID)
    }
    
    func didUpdateReminderCount() {
        updateSegmentedControlTitles()
    }
    
    // MARK: - DogsAddTriggerVCDelegate
    
    func didAddTrigger(sender: Sender, dogUUID: UUID?, trigger: Trigger) {
        self.triggersView.didAddTrigger(trigger: trigger)
    }
    
    func didUpdateTrigger(sender: Sender, dogUUID: UUID?, trigger: Trigger) {
        self.triggersView.didUpdateTrigger(trigger: trigger)
    }
    
    func didRemoveTrigger(sender: Sender, dogUUID: UUID?, triggerUUID: UUID) {
        self.triggersView.didRemoveTrigger(triggerUUID: triggerUUID)
    }
    
    func didUpdateTriggerCount() {
        updateSegmentedControlTitles()
    }
    
    // MARK: - Elements
    
    private lazy var editPageHeaderView: HoundEditPageHeaderView = {
        let view = HoundEditPageHeaderView(huggingPriority: 330, compressionResistancePriority: 330)
        
        view.trailingButton.setImage(UIImage(systemName: "trash.circle"), for: .normal)
        view.trailingButton.addTarget(self, action: #selector(didTouchUpInsideRemoveDog), for: .touchUpInside)
        
        return view
    }()
    
    private lazy var dogNameTextField: HoundTextField = {
        let textField = HoundTextField(huggingPriority: 290, compressionResistancePriority: 290)
        textField.delegate = self
        
        textField.placeholder = "Enter your dog's name..."
        textField.shouldInsetText = true
        textField.backgroundColor = UIColor.systemBackground
        
        textField.applyStyle(.thinGrayBorder)
        
        return textField
    }()
    
    private lazy var dogIconButton: HoundButton = {
        let button = HoundButton(huggingPriority: 290, compressionResistancePriority: 290)
        
        button.setTitle("Choose", for: .normal)
        button.setTitleColor(.placeholderText, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.emphasizedPrimaryRegularLabel
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.thinGrayBorder)
        
        button.addTarget(self, action: #selector(didTouchUpInsideDogIcon), for: .touchUpInside)
        
        return button
    }()
    
    private enum SegmentedControlSection: Int, CaseIterable {
        case reminders
        case triggers
        
        var title: String {
            switch self {
            case .reminders: return "Reminders"
            case .triggers: return "Automations"
            }
        }
        
        static func index(of section: SegmentedControlSection) -> Int { section.rawValue }
    }
    
    private lazy var segmentedControl: HoundSegmentedControl = {
        let segmentedControl = HoundSegmentedControl()
        segmentedControl.selectedSegmentTintColor = UIColor.systemBlue
        SegmentedControlSection.allCases.enumerated().forEach { index, section in
            segmentedControl.insertSegment(withTitle: section.title, at: index, animated: false)
        }
        let attributes: [NSAttributedString.Key: Any] = [
            .font: Constant.Visual.Font.emphasizedPrimaryRegularLabel,
            .foregroundColor: UIColor.systemBackground
        ]
        segmentedControl.setTitleTextAttributes(attributes, for: .normal)
        segmentedControl.backgroundColor = UIColor.systemGray4
        
        segmentedControl.selectedSegmentIndex = SegmentedControlSection.reminders.rawValue
        segmentedControl.apportionsSegmentWidthsByContent = false
        
        segmentedControl.addTarget(self, action: #selector(didUpdateSegment), for: .valueChanged)
        return segmentedControl
    }()
    
    private lazy var remindersView: DogsAddDogRemindersView = {
        let view = DogsAddDogRemindersView()
        view.isHidden = segmentedControl.selectedSegmentIndex != SegmentedControlSection.reminders.rawValue
        return view
    }()
    
    private lazy var triggersView: DogsAddDogTriggersView = {
        let view = DogsAddDogTriggersView()
        view.isHidden = segmentedControl.selectedSegmentIndex != SegmentedControlSection.triggers.rawValue
        return view
    }()
    
    private lazy var tableViewsStack: HoundStackView = {
        let stack = HoundStackView(arrangedSubviews: [remindersView, triggersView])
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    
    private lazy var saveDogButton: HoundButton = {
        let button = HoundButton(huggingPriority: 280, compressionResistancePriority: 280)
        
        button.tintColor = UIColor.systemBlue
        button.setImage(UIImage(systemName: "checkmark.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.addTarget(self, action: #selector(didTouchUpInsideSaveDog), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var backButton: HoundButton = {
        let button = HoundButton(huggingPriority: 260, compressionResistancePriority: 260)
        
        button.tintColor = UIColor.systemGray2
        button.setImage(UIImage(systemName: "arrow.backward.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.addTarget(self, action: #selector(didTouchUpInsideDismissPage), for: .touchUpInside)
        
        return button
    }()
    
    @objc private func didTouchUpInsideDogIcon(_ sender: Any) {
        PresentationManager.enqueueActionSheet(DogIconManager.openCameraOrGalleryForDogIconActionSheet, sourceView: dogIconButton)
    }
    
    @objc private func didTouchUpInsideRemoveDog(_ sender: Any) {
        guard let dogToUpdate = dogToUpdate else { return }
        
        let removeDogConfirmation = UIAlertController(title: "Are you sure you want to delete \(dogNameTextField.text ?? dogToUpdate.dogName)?", message: nil, preferredStyle: .alert)
        
        let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
            DogsRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogToUpdate.dogUUID) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }
                
                self.dogManager?.removeDog(dogUUID: dogToUpdate.dogUUID)
                
                if let dogManager = self.dogManager {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: dogManager)
                }
                
                HapticsManager.notification(.warning)
                self.dismiss(animated: true)
            }
            
        }
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        removeDogConfirmation.addAction(removeAlertAction)
        removeDogConfirmation.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(removeDogConfirmation)
    }
    
    @objc private func didUpdateSegment(_ sender: HoundSegmentedControl) {
        remindersView.isHidden = sender.selectedSegmentIndex != SegmentedControlSection.reminders.rawValue
        triggersView.isHidden = sender.selectedSegmentIndex != SegmentedControlSection.triggers.rawValue
    }
    
    // When the add button is tapped, runs a series of checks. Makes sure the name and description of the dog is valid, and if so then passes information up chain of view controllers to DogsVC.
    @objc private func didTouchUpInsideSaveDog(_ sender: Any) {
        let dog = dogToUpdate ?? Dog()
        guard dog.changeDogName(dogName: dogNameTextField.text) else {
            HapticsManager.notification(.error)
            dogNameTextField.errorMessage = Constant.Error.DogError.dogNameMissing
            return
        }
        
        dog.dogIcon = dogIconButton.imageView?.image
        
        saveDogButton.isLoading = true
        
        let initialReminders = remindersView.initialReminders.dogReminders
        let initialTriggers = triggersView.initialTriggers.dogTriggers
        
        let currentReminders = remindersView.dogReminders.dogReminders
        let currentTriggers = triggersView.dogTriggers.dogTriggers
        
        let createdReminders = currentReminders.filter({ $0.reminderId == nil})
        let createdTriggers = currentTriggers.filter({ $0.triggerId == nil})
        
        createdReminders.forEach { reminder in
            reminder.resetForNextAlarm()
        }
        
        let updatedReminders = currentReminders.filter { currentReminder in
            // The reminder needs to have already been created on the Hound server
            guard currentReminder.reminderId != nil else {
                return false
            }
            
            // Reminders that were updated were in the initialReminders array (maybe or maybe not have reminderId, depends if were in offline mode)
            guard let initialReminder = initialReminders.first(where: { $0.reminderUUID == currentReminder.reminderUUID }) else {
                return false
            }
            
            // If current reminder is different that its corresponding initial reminder, then its been updated
            return !currentReminder.isSame(as: initialReminder)
        }
        let updatedTriggers = currentTriggers.filter { currentTrigger in
            guard currentTrigger.triggerId != nil else {
                return false
            }
            guard let initialTrigger = initialTriggers.first(where: { $0.triggerUUID == currentTrigger.triggerUUID }) else {
                return false
            }
            return !currentTrigger.isSame(as: initialTrigger)
        }
        
        updatedReminders.forEach { updatedReminder in
            // updated reminder could have had its timing updating, so resetForNextAlarm to clear skippedDate, snoozing, etc.
            updatedReminder.resetForNextAlarm()
        }
        
        // looks for reminders that were present in initialReminders but not in currentReminders
        let deletedReminders = initialReminders.filter({ initialReminder in
            // The reminder needs to have already been created on the Hound server
            guard initialReminder.reminderId != nil else {
                return false
            }
            
            // Only include reminders that no longer exist in currentReminders
            return currentReminders.contains(where: { $0.reminderUUID == initialReminder.reminderUUID }) == false
        })
        let deletedTriggers = initialTriggers.filter({ initialTrigger in
            guard initialTrigger.triggerId != nil else {
                return false
            }
            return currentTriggers.contains(where: { $0.triggerUUID == initialTrigger.triggerUUID}) == false
        })
        
        guard dogToUpdate != nil else {
            // not updating, therefore the dog is being created new and the reminders are too
            DogsRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dog: dog) { responseStatusDogCreate, _ in
                guard responseStatusDogCreate != .failureResponse else {
                    self.saveDogButton.isLoading = false
                    return
                }
                
                self.dogManager?.addDog(dog: dog)
                
                var numTasks = 0
                if createdReminders.count >= 1 {
                    numTasks += 1
                }
                if createdTriggers.count >= 1 {
                    numTasks += 1
                }
                
                guard numTasks > 0 else {
                    self.saveDogButton.isLoading = false
                    if let dogManager = self.dogManager {
                        self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: dogManager)
                    }
                    HapticsManager.notification(.success)
                    self.dismiss(animated: true)
                    return
                }
                
                let completionTracker = CompletionTracker(numberOfTasks: numTasks) {
                    // do nothing when an individual task completes
                } completedAllTasksCompletionHandler: {
                    self.saveDogButton.isLoading = false
                    if let dogManager = self.dogManager {
                        self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: dogManager)
                    }
                    HapticsManager.notification(.success)
                    self.dismiss(animated: true)
                } failedTaskCompletionHandler: {
                    self.saveDogButton.isLoading = false
                }

                if createdReminders.count >= 1 {
                    RemindersRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, reminders: createdReminders) { responseStatusReminderCreate, _ in
                        guard responseStatusReminderCreate != .failureResponse else {
                            return
                        }
                        dog.dogReminders.addReminders(reminders: createdReminders)
                        completionTracker.completedTask()
                    }
                }
                if createdTriggers.count >= 1 {
                    TriggersRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, dogTriggers: createdTriggers) { responseStatusTriggerCreate, _ in
                        guard responseStatusTriggerCreate != .failureResponse else {
                            return
                        }
                        dog.dogTriggers.addTriggers(dogTriggers: createdTriggers)
                        completionTracker.completedTask()
                    }
                }
            }
            return
        }
        
        // dog + created reminders + updated reminders + deleted reminders
        let numberOfTasks = {
            // first task is dog update
            var numberOfTasks = 1
            if createdReminders.count >= 1 {
                numberOfTasks += 1
            }
            if updatedReminders.count >= 1 {
                numberOfTasks += 1
            }
            if deletedReminders.count >= 1 {
                numberOfTasks += 1
            }
            if createdTriggers.count >= 1 {
                numberOfTasks += 1
            }
            if updatedTriggers.count >= 1 {
                numberOfTasks += 1
            }
            if deletedTriggers.count >= 1 {
                numberOfTasks += 1
            }
            return numberOfTasks
        }()
        
        let completionTracker = CompletionTracker(numberOfTasks: numberOfTasks) {
            // everytime a task completes, update the dog manager so everything else updates
            if let dogManager = self.dogManager {
                self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: dogManager)
            }
        } completedAllTasksCompletionHandler: {
            // when everything completes, close the page
            self.saveDogButton.isLoading = false
            HapticsManager.notification(.success)
            self.dismiss(animated: true)
        } failedTaskCompletionHandler: {
            // if a problem is encountered, then just stop the indicator
            self.saveDogButton.isLoading = false
        }
        
        // first query to update the dog itself (independent of any reminders)
        DogsRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dog: dog) { responseStatusDogUpdate, _ in
            guard responseStatusDogUpdate != .failureResponse else {
                completionTracker.failedTask()
                return
            }
            
            // Updated dog
            self.dogManager?.addDog(dog: dog)
            completionTracker.completedTask()
            
            if createdReminders.count >= 1 {
                RemindersRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, reminders: createdReminders) { responseStatusReminderCreate, _ in
                    guard responseStatusReminderCreate != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    dog.dogReminders.addReminders(reminders: createdReminders)
                    completionTracker.completedTask()
                }
            }
            if createdTriggers.count >= 1 {
                TriggersRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, dogTriggers: createdTriggers) { responseStatusTriggerCreate, _ in
                    guard responseStatusTriggerCreate != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    dog.dogTriggers.addTriggers(dogTriggers: createdTriggers)
                    completionTracker.completedTask()
                }
            }
            
            if updatedReminders.count >= 1 {
                RemindersRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, reminders: updatedReminders) { responseStatusReminderUpdate, _ in
                    guard responseStatusReminderUpdate != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    dog.dogReminders.addReminders(reminders: updatedReminders)
                    completionTracker.completedTask()
                }
            }
            if updatedTriggers.count >= 1 {
                TriggersRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, dogTriggers: updatedTriggers) { responseStatusTriggerUpdate, _ in
                    guard responseStatusTriggerUpdate != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    dog.dogTriggers.addTriggers(dogTriggers: updatedTriggers)
                    completionTracker.completedTask()
                }
            }
            
            if deletedReminders.count >= 1 {
                RemindersRequest.delete(
                    errorAlert: .automaticallyAlertOnlyForFailure,
                    dogUUID: dog.dogUUID,
                    reminderUUIDs: deletedReminders.map({ reminder in
                        return reminder.reminderUUID
                    })
                ) { responseStatusReminderDelete, _ in
                    guard responseStatusReminderDelete != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    for deletedReminder in deletedReminders {
                        dog.dogReminders.removeReminder(reminderUUID: deletedReminder.reminderUUID)
                    }
                    completionTracker.completedTask()
                }
            }
            if deletedTriggers.count >= 1 {
                TriggersRequest.delete(
                    errorAlert: .automaticallyAlertOnlyForFailure,
                    dogUUID: dog.dogUUID,
                    triggerUUIDs: deletedTriggers.map({ trigger in
                        return trigger.triggerUUID
                    })
                ) { responseStatusTriggerDelete, _ in
                    guard responseStatusTriggerDelete != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    for deletedTrigger in deletedTriggers {
                        dog.dogTriggers.removeTrigger(triggerUUID: deletedTrigger.triggerUUID)
                    }
                    completionTracker.completedTask()
                }
            }
            
        }
    }
    
    @objc private func didTouchUpInsideDismissPage(_ sender: Any) {
        // If the user changed any values on the page, then ask them to confirm to discarding those changes
        guard didUpdateInitialValues == true else {
            self.dismiss(animated: true)
            return
        }
        
        let unsavedInformationConfirmation = UIAlertController(title: "Are you sure you want to exit?", message: nil, preferredStyle: .alert)
        
        let exitAlertAction = UIAlertAction(title: "Yes, I don't want to save changes", style: .default) { _ in
            self.dismiss(animated: true)
        }
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        unsavedInformationConfirmation.addAction(exitAlertAction)
        unsavedInformationConfirmation.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(unsavedInformationConfirmation)
    }
    
    // MARK: - Properties
    
    private var didSetupCustomSubviews: Bool = false
    
    private weak var delegate: DogsAddDogVCDelegate?
    
    private var dogManager: DogManager?
    private var dogToUpdate: Dog?
    
    private var initialDogName: String?
    private var initialDogIcon: UIImage?
    
    var didUpdateInitialValues: Bool {
        if dogNameTextField.text != initialDogName {
            return true
        }
        if let image = dogIconButton.imageView?.image, image != initialDogIcon {
            return true
        }
        
        if remindersView.didUpdateInitialValues {
            return true
        }
        if triggersView.didUpdateInitialValues {
            return true
        }
        
        return false
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        self.view.dismissKeyboardOnTap(delegate: self)
        
        DogIconManager.didSelectDogIconController.delegate = self
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        
        let saveButtonTop = saveDogButton.convert(saveDogButton.bounds, to: view).minY
        let backButtonTop = backButton.convert(backButton.bounds, to: view).minY
        let buttonTop = min(saveButtonTop, backButtonTop)
        
        let distanceFromBottom = view.bounds.height - buttonTop
        
        let minInset = distanceFromBottom + Constant.Constraint.Spacing.absoluteVertInset
        
        scrollView.contentInset.bottom = max(scrollView.contentInset.bottom, minInset)
    }
    
    // MARK: - Setup
    
    func setup(delegate: DogsAddDogVCDelegate, dogManager: DogManager?, dogToUpdate: Dog?) {
        self.delegate = delegate
        self.dogManager = dogManager
        self.dogToUpdate = dogToUpdate
        
        editPageHeaderView.setTitle(dogToUpdate == nil ? "Create Dog" : "Edit Dog")
        editPageHeaderView.isTrailingButtonEnabled = dogToUpdate != nil
        
        dogNameTextField.text = dogToUpdate?.dogName
        initialDogName = dogToUpdate?.dogName
        
        if let dogIcon = dogToUpdate?.dogIcon {
            dogIconButton.setTitle(nil, for: .normal)
            dogIconButton.setImage(dogIcon, for: .normal)
        }
        initialDogIcon = dogToUpdate?.dogIcon
        
        remindersView.setup(delegate: self, dogReminders: dogToUpdate?.dogReminders)
        triggersView.setup(delegate: self, dogTriggers: dogToUpdate?.dogTriggers)
        
        updateSegmentedControlTitles()
    }
    
    // MARK: - Functions
    
    private func updateSegmentedControlTitles() {
        segmentedControl.setTitle("Reminders (\(remindersView.dogReminders.dogReminders.count))", forSegmentAt: SegmentedControlSection.reminders.rawValue)
        segmentedControl.setTitle("Automations (\(triggersView.dogTriggers.dogTriggers.count))", forSegmentAt: SegmentedControlSection.triggers.rawValue)
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(saveDogButton)
        view.addSubview(backButton)
        
        containerView.addSubview(editPageHeaderView)
        containerView.addSubview(dogIconButton)
        containerView.addSubview(dogNameTextField)
        containerView.addSubview(segmentedControl)
        containerView.addSubview(tableViewsStack)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // editPageHeaderView
        NSLayoutConstraint.activate([
            editPageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            editPageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            editPageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // dogIconButton
        NSLayoutConstraint.activate([
            dogIconButton.topAnchor.constraint(equalTo: editPageHeaderView.bottomAnchor),
            dogIconButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteCircleHoriInset),
            dogIconButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier, relativeToWidthOf: view),
            dogIconButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight),
            dogIconButton.createSquareAspectRatio()
        ])
        
        // dogNameTextField
        NSLayoutConstraint.activate([
            dogNameTextField.leadingAnchor.constraint(equalTo: dogIconButton.trailingAnchor, constant: Constant.Constraint.Spacing.absoluteCircleHoriInset),
            dogNameTextField.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            dogNameTextField.centerYAnchor.constraint(equalTo: dogIconButton.centerYAnchor),
            dogNameTextField.createHeightMultiplier(Constant.Constraint.Input.textFieldHeightMultiplier, relativeToWidthOf: view),
            dogNameTextField.createMaxHeight(Constant.Constraint.Input.textFieldMaxHeight)
        ])
        
        // segmentedControl
        NSLayoutConstraint.activate([
            segmentedControl.topAnchor.constraint(equalTo: dogIconButton.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            segmentedControl.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset / 2.0),
            segmentedControl.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset / 2.0),
            segmentedControl.createHeightMultiplier(Constant.Constraint.Input.segmentedHeightMultiplier, relativeToWidthOf: view),
            segmentedControl.createMaxHeight(Constant.Constraint.Input.segmentedMaxHeight)
        ])
        
        // tableViewsStack
        NSLayoutConstraint.activate([
            tableViewsStack.topAnchor.constraint(equalTo: segmentedControl.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            tableViewsStack.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            tableViewsStack.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            tableViewsStack.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // saveLogButton
        NSLayoutConstraint.activate([
            saveDogButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            saveDogButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteCircleHoriInset),
            saveDogButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier, relativeToWidthOf: view),
            saveDogButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight),
            saveDogButton.createSquareAspectRatio()
        ])
        
        // backButton
        NSLayoutConstraint.activate([
            backButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            backButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteCircleHoriInset),
            backButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier, relativeToWidthOf: view),
            backButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight),
            backButton.createSquareAspectRatio()
        ])
    }
    
}
//
//  DogsAddDogRemindersView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/10/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddDogRemindersViewDelegate: AnyObject {
    func shouldOpenAddReminderVC(reminder: Reminder?)
    func didUpdateReminderCount()
}

final class DogsAddDogRemindersView: HoundView, UITableViewDataSource, UITableViewDelegate, DogsAddDogReminderTVCDelegate {
    
    // MARK: - DogsAddDogReminderTVCDelegate
    
    func didUpdateReminderIsEnabled(sender: Sender, reminderUUID: UUID, reminderIsEnabled: Bool) {
        dogReminders.findReminder(reminderUUID: reminderUUID)?.reminderIsEnabled = reminderIsEnabled
    }
    
    // MARK: - Elements

    private lazy var tableView: HoundTableView = {
        let tableView = HoundTableView()
        tableView.dataSource = self
        tableView.delegate = self
        
        tableView.register(DogsAddDogReminderTVC.self, forCellReuseIdentifier: DogsAddDogReminderTVC.reuseIdentifier)
        
        tableView.isScrollEnabled = false
        
        tableView.shouldAutomaticallyAdjustHeight = true
        tableView.emptyStateEnabled = true
        tableView.emptyStateMessage = "No reminders yet..."
        
        return tableView
    }()

    private lazy var addReminderButton: HoundButton = {
        let button = HoundButton()
        
        button.setTitle("Add Reminder", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = Constant.Visual.Font.wideButton
        
        button.backgroundColor = UIColor.systemBackground
        
        button.applyStyle(.thinLabelBorder)
        
        button.addTarget(self, action: #selector(didTouchUpInsideAddReminder), for: .touchUpInside)
        
        return button
    }()
    
    @objc func didTouchUpInsideAddReminder() {
        let numNonTriggerReminders = dogReminders.dogReminders.count(where: { $0.reminderIsTriggerResult == false })
        
        guard numNonTriggerReminders < Constant.Class.Dog.maximumNumberOfReminders else {
            PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.noAddMoreRemindersTitle, subtitle: Constant.Visual.BannerText.noAddMoreRemindersSubtitle, style: .warning)
            return
        }
        
        delegate?.shouldOpenAddReminderVC(reminder: nil)
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddDogRemindersViewDelegate?
    /// dogReminders is either a copy of dogToUpdate's reminders or a DogReminderManager initialized to a default array of reminders. This is purposeful so that either, if you dont have a dogToUpdate, you can still create reminders, and if you do have a dogToUpdate, you don't directly update the dogToUpdate until save is pressed
    private(set) var dogReminders: DogReminderManager = DogReminderManager(reminders: Constant.Class.Reminder.defaultReminders)
    private(set) var initialReminders: DogReminderManager = DogReminderManager(reminders: Constant.Class.Reminder.defaultReminders)
    
    var didUpdateInitialValues: Bool {
        // if current reminders has more reminders than initial reminders, the loop below won't catch it, as the loop below just looks to see if each initial reminder is still present in current reminders.
        if initialReminders.dogReminders.count != dogReminders.dogReminders.count {
            return true
        }
        // make sure each initial reminder has a corresponding current reminder, otherwise current reminders have been updated
        for initialReminder in initialReminders.dogReminders {
            let currentReminder = dogReminders.dogReminders.first(where: { $0.reminderUUID == initialReminder.reminderUUID })
            
            guard let currentReminder = currentReminder else {
                // no corresponding reminder
                return true
            }
            
            // if any of the corresponding reminders are different, then return true to indicate that a reminder has been updated
            if !initialReminder.isSame(as: currentReminder) {
                return true
            }
        }
        
        return false
    }
    
    // MARK: - Setup
    
    func setup(delegate: DogsAddDogRemindersViewDelegate, dogReminders: DogReminderManager?) {
        self.delegate = delegate
        
        self.dogReminders = (dogReminders?.copy() as? DogReminderManager) ?? self.dogReminders
        initialReminders = (dogReminders?.copy() as? DogReminderManager) ?? initialReminders
        
        tableView.reloadData()
    }
    
    // MARK: - Functions
    
    func didAddReminder(reminder: Reminder) {
        dogReminders.addReminder(reminder: reminder)
        delegate?.didUpdateReminderCount()
        // not in view so no animation
        self.tableView.reloadData()
    }
    
    func didUpdateReminder(reminder: Reminder) {
        dogReminders.addReminder(reminder: reminder)
        delegate?.didUpdateReminderCount()
        // not in view so no animation
        self.tableView.reloadData()
    }
    
    func didRemoveReminder(reminderUUID: UUID) {
        dogReminders.removeReminder(reminderUUID: reminderUUID)
        delegate?.didUpdateReminderCount()
        // not in view so no animation
        self.tableView.reloadData()
    }
    
    // MARK: - Table View Data Source
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return dogReminders.dogReminders.count
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
        // Only add spacing if NOT the last section
        let lastSection = dogReminders.dogReminders.count - 1
        return section == lastSection ? 0 : Constant.Constraint.Spacing.contentTallIntraVert
    }
    
    func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {
        // Only return a view if not the last section
        let lastSection = InAppPurchaseManager.subscriptionProducts.count - 1
        if section == lastSection {
            return nil
        }
        
        let footer = HoundHeaderFooterView()
        return footer
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: DogsAddDogReminderTVC.reuseIdentifier, for: indexPath)
        
        if let castedCell = cell as? DogsAddDogReminderTVC {
            castedCell.setup(delegate: self, reminder: dogReminders.dogReminders[indexPath.section])
            castedCell.containerView.roundCorners(setCorners: .all)
        }
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let reminder = dogReminders.dogReminders[indexPath.section]
        
        guard reminder.reminderIsTriggerResult == false else {
            PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.noEditTriggerResultRemindersTitle, subtitle: Constant.Visual.BannerText.noEditTriggerResultRemindersSubtitle, style: .warning)
            return
        }
        
        delegate?.shouldOpenAddReminderVC(reminder: reminder)
    }
    
    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
        guard editingStyle == .delete && dogReminders.dogReminders.isEmpty == false else { return }
        
        let reminder = dogReminders.dogReminders[indexPath.section]
        
        let removeReminderConfirmation = UIAlertController(title: "Are you sure you want to delete \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))?", message: nil, preferredStyle: .alert)
        
        let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
            self.dogReminders.removeReminder(reminderUUID: reminder.reminderUUID)
            self.delegate?.didUpdateReminderCount()
            
            self.tableView.deleteSections([indexPath.section], with: .fade)
            UIView.animate(withDuration: Constant.Visual.Animation.moveMultipleElements) {
                self.setNeedsLayout()
                self.layoutIfNeeded()
            }
            
        }
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        removeReminderConfirmation.addAction(removeAlertAction)
        removeReminderConfirmation.addAction(cancelAlertAction)
        PresentationManager.enqueueAlert(removeReminderConfirmation)
    }
    
    func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        return dogReminders.dogReminders.isEmpty == false
    }

    // MARK: - Setup Elements

    override func addSubViews() {
        super.addSubViews()
        addSubview(tableView)
        addSubview(addReminderButton)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: topAnchor),
            tableView.leadingAnchor.constraint(equalTo: leadingAnchor),
            tableView.trailingAnchor.constraint(equalTo: trailingAnchor)
        ])

        NSLayoutConstraint.activate([
            addReminderButton.topAnchor.constraint(equalTo: tableView.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            addReminderButton.bottomAnchor.constraint(equalTo: bottomAnchor),
            addReminderButton.leadingAnchor.constraint(equalTo: leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            addReminderButton.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            addReminderButton.createHeightMultiplier(Constant.Constraint.Button.wideHeightMultiplier, relativeToWidthOf: self),
            addReminderButton.createMaxHeight(Constant.Constraint.Button.wideMaxHeight)
        ])
    }
}
//
//  SecondViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsVCDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
}

final class DogsVC: HoundViewController, DogsAddDogVCDelegate, DogsTableVCDelegate, DogsAddReminderVCDelegate, DogsAddTriggerVCDelegate {
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        true
    }
    
    // MARK: - Dual Delegate Implementation
    
    func didUpdateDogManager(sender: Sender, dogManager: DogManager) {
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    // MARK: - DogsAddReminderVCDelegate
    
    func didAddReminder(sender: Sender, dogUUID: UUID?, reminder: Reminder) {
        // dogUUID must be defined, as we are either adding a reminder to some existing dog or creating a reminder for an existing dog. Only DogsAddDogVC can use dogsAddReminderViewController without a dogUUID
        guard let dogUUID = dogUUID else { return }
        
        // Since our reminder was already created by the server, we don't need to worry about placeholderIds. Simply add the reminder and DogReminderManager handles it
        dogManager.findDog(dogUUID: dogUUID)?.dogReminders.addReminder(reminder: reminder)
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    func didUpdateReminder(sender: Sender, dogUUID: UUID?, reminder: Reminder) {
        // dogUUID must be defined, as we are either adding a reminder to some existing dog or creating a reminder for an existing dog. Only DogsAddDogVC can use dogsAddReminderViewController without a dogUUID
        guard let dogUUID = dogUUID else { return }
        
        // Since our reminder was already created by the server, we don't need to worry about placeholderIds. Simply add the reminder and DogReminderManager handles it
        dogManager.findDog(dogUUID: dogUUID)?.dogReminders.addReminder(reminder: reminder)
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    func didRemoveReminder(sender: Sender, dogUUID: UUID?, reminderUUID: UUID) {
        // dogUUID must be defined, as we are either adding a reminder to some existing dog or creating a reminder for an existing dog. Only DogsAddDogVC can use dogsAddReminderViewController without a dogUUID
        guard let dogUUID = dogUUID else { return }
        
        dogManager.findDog(dogUUID: dogUUID)?.dogReminders.removeReminder(reminderUUID: reminderUUID)
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    // MARK: - DogsAddTriggerVCDelegate
    
    func didAddTrigger(sender: Sender, dogUUID: UUID?, trigger: Trigger) {
        // dogUUID must be defined, as we are either adding a trigger to some existing dog or creating a trigger for an existing dog. Only DogsAddDogVC can use dogsAddTriggerViewController without a dogUUID
        guard let dogUUID = dogUUID else { return }
        
        // Since our reminder was already created by the server, we don't need to worry about placeholderIds. Simply add the reminder and DogReminderManager handles it
        dogManager.findDog(dogUUID: dogUUID)?.dogTriggers.addTrigger(trigger: trigger)
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    func didUpdateTrigger(sender: Sender, dogUUID: UUID?, trigger: Trigger) {
        // dogUUID must be defined, as we are either adding a trigger to some existing dog or creating a trigger for an existing dog. Only DogsAddDogVC can use dogsAddTriggerViewController without a dogUUID
        guard let dogUUID = dogUUID else { return }
        
        // Since our reminder was already created by the server, we don't need to worry about placeholderIds. Simply add the reminder and DogReminderManager handles it
        dogManager.findDog(dogUUID: dogUUID)?.dogTriggers.addTrigger(trigger: trigger)
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    func didRemoveTrigger(sender: Sender, dogUUID: UUID?, triggerUUID: UUID) {
        // dogUUID must be defined, as we are either adding a trigger to some existing dog or creating a trigger for an existing dog. Only DogsAddDogVC can use dogsAddTriggerViewController without a dogUUID
        guard let dogUUID = dogUUID else { return }
        
        dogManager.findDog(dogUUID: dogUUID)?.dogTriggers.removeTrigger(triggerUUID: triggerUUID)
        setDogManager(sender: sender, dogManager: dogManager)
    }
    
    // MARK: - DogsTableVCDelegate
    
    /// If a dog in DogsTableVC or Add Dog were tapped, invokes this function. Opens up the same page but changes between creating new and editing existing mode.
    func shouldOpenDogMenu(dogUUID: UUID?) {
        guard let dogUUID = dogUUID, let dog = dogManager.findDog(dogUUID: dogUUID) else {
            let vc = DogsAddDogVC()
            vc.setup(delegate: self, dogManager: dogManager, dogToUpdate: nil)
            dogsAddDogViewController = vc
            PresentationManager.enqueueViewController(vc)
            return
        }
        
        PresentationManager.beginFetchingInformationIndicator()
        
        DogsRequest.get(errorAlert: .automaticallyAlertOnlyForFailure, dog: dog) { newDog, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                guard responseStatus != .failureResponse else {
                    return
                }
                
                guard let newDog = newDog else {
                    // If the response was successful but no dog was returned, that means the dog was deleted. Therefore, update the dogManager to indicate as such.
                    self.dogManager.removeDog(dogUUID: dogUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    return
                }
                
                let vc = DogsAddDogVC()
                vc.setup(delegate: self, dogManager: self.dogManager, dogToUpdate: newDog)
                self.dogsAddDogViewController = vc
                PresentationManager.enqueueViewController(vc)
            }
        }
    }
    
    /// If a reminder in DogsTableVC or Add Reminder were tapped, invokes this function. Opens up the same page but changes between creating new and editing existing mode.
    func shouldOpenReminderMenu(dogUUID: UUID, reminder: Reminder?) {
        guard let reminder = reminder else {
            // creating new
            // no need to query as nothing in server since creating
            let vc = DogsAddReminderVC()
            vc.setup(delegate: self, reminderToUpdateDogUUID: dogUUID, reminderToUpdate: nil)
            self.dogsAddReminderViewController = vc
            PresentationManager.enqueueViewController(vc)
            return
        }
        
        // updating
        PresentationManager.beginFetchingInformationIndicator()
        // query for existing
        RemindersRequest.get(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminder: reminder) { responseReminder, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                guard responseStatus != .failureResponse else {
                    return
                }
                guard let responseReminder = responseReminder else {
                    // If the response was successful but no reminder was returned, that means the reminder was deleted. Therefore, update the dogManager to indicate as such.
                    let dogReminders = self.dogManager.findDog(dogUUID: dogUUID)?.dogReminders
                    dogReminders?.removeReminder(reminderUUID: reminder.reminderUUID)
                    
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    return
                }
                
                let vc = DogsAddReminderVC()
                vc.setup(delegate: self, reminderToUpdateDogUUID: dogUUID, reminderToUpdate: responseReminder)
                self.dogsAddReminderViewController = vc
                PresentationManager.enqueueViewController(vc)
            }
        }
    }
    
    /// If a trigger in DogsTableVC or Add Trigger were tapped, invokes this function. Opens up the same page but changes between creating new and editing existing mode.
    func shouldOpenTriggerMenu(dog: Dog, trigger: Trigger?) {
        guard let trigger = trigger else {
            // creating new
            // no need to query as nothing in server since creating
            let vc = DogsAddTriggerVC()
            vc.setupWithServerPersistence(delegate: self, dog: dog, triggerToUpdate: nil)
            self.dogsAddTriggerViewController = vc
            PresentationManager.enqueueViewController(vc)
            return
        }
        
        // updating
        PresentationManager.beginFetchingInformationIndicator()
        // query for existing
        TriggersRequest.get(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, trigger: trigger) { responseTrigger, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                guard responseStatus != .failureResponse else {
                    return
                }
                guard let responseTrigger = responseTrigger else {
                    // If the response was successful but no trigger was returned, that means the trigger was deleted. Therefore, update the dogManager to indicate as such.
                    let dogTriggers = self.dogManager.findDog(dogUUID: dog.dogUUID)?.dogTriggers
                    dogTriggers?.removeTrigger(triggerUUID: trigger.triggerUUID)
                    
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    return
                }
                
                let vc = DogsAddTriggerVC()
                vc.setupWithServerPersistence(delegate: self, dog: dog, triggerToUpdate: responseTrigger)
                self.dogsAddTriggerViewController = vc
                PresentationManager.enqueueViewController(vc)
            }
        }
    }
    
    func shouldUpdateAlphaForButtons(alpha: Double) {
        createNewMenuButton.alpha = alpha
        createNewMenuButton.isHidden = alpha == 0
    }
    
    // MARK: - Elements
    
    private lazy var dogsTableViewController: DogsTableVC = {
        let tableView = DogsTableVC(style: .grouped)
        
        tableView.setup(delegate: self)
        
        return tableView
    }()
    
    private let noDogsRecordedLabel: HoundLabel = {
        let label = HoundLabel()
        label.isHidden = true
        label.text = "No dogs created yet!\n\nTry creating one..."
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.secondaryHeaderLabel
        label.textColor = UIColor.systemBlue
        return label
    }()
    
    private lazy var screenDimmer: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.black
        view.isUserInteractionEnabled = false
        view.alpha = 0
        
        let gesture = UITapGestureRecognizer(target: self, action: #selector(closeCreateNewMenu))
        gesture.delegate = self
        gesture.cancelsTouchesInView = false
        view.addGestureRecognizer(gesture)
        
        return view
    }()
    
    private lazy var createNewMenuButton: HoundButton = {
        let button = HoundButton(huggingPriority: 260, compressionResistancePriority: 260)
        
        button.tintColor = UIColor.systemBlue
        button.setImage(UIImage(systemName: "plus.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = UIColor.secondarySystemBackground
        
        button.addTarget(self, action: #selector(didSelectCreateNew), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var createNewDogLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Create New Dog"
        label.font = Constant.Visual.Font.emphasizedPrimaryRegularLabel
        label.textColor = UIColor.systemBackground
        label.isUserInteractionEnabled = true
        
        label.backgroundLabelColor = UIColor.systemBlue
        
        let gesture = UITapGestureRecognizer(target: self, action: #selector(didSelectCreateDog))
        gesture.delegate = self
        gesture.cancelsTouchesInView = false
        label.addGestureRecognizer(gesture)
        
        return label
    }()
    private lazy var createNewDogButton: HoundButton = {
        let button = HoundButton()
        
        button.setImage(UIImage(systemName: "plus.circle"), for: .normal)
        button.tintColor = UIColor.systemBlue
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.addTarget(self, action: #selector(didSelectCreateDog), for: .touchUpInside)
        
        return button
    }()
    private lazy var createNewDogStack: HoundStackView = {
        let substack = HoundStackView(arrangedSubviews: [createNewDogLabel, createNewDogButton])
        substack.axis = .horizontal
        substack.distribution = .fill
        substack.alignment = .center
        substack.spacing = Constant.Constraint.Spacing.contentIntraHori
        return substack
    }()
    
    private lazy var createNewReminderLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Create New Reminder"
        label.font = Constant.Visual.Font.emphasizedPrimaryRegularLabel
        label.textColor = UIColor.systemBackground
        label.isUserInteractionEnabled = true
        
        label.backgroundLabelColor = UIColor.systemBlue
        
        let gesture = UITapGestureRecognizer(target: self, action: #selector(didSelectCreateReminder))
        gesture.delegate = self
        gesture.cancelsTouchesInView = false
        label.addGestureRecognizer(gesture)
        
        return label
    }()
    private lazy var createNewReminderButton: HoundButton = {
        let button = HoundButton()
        
        button.setImage(UIImage(systemName: "plus.circle"), for: .normal)
        button.tintColor = UIColor.systemBlue
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.addTarget(self, action: #selector(didSelectCreateReminder), for: .touchUpInside)
        
        return button
    }()
    private lazy var createNewReminderStack: HoundStackView = {
        let substack = HoundStackView(arrangedSubviews: [createNewReminderLabel, createNewReminderButton])
        substack.axis = .horizontal
        substack.distribution = .fill
        substack.alignment = .center
        substack.spacing = Constant.Constraint.Spacing.contentIntraHori
        return substack
    }()
    
    private lazy var createNewTriggerLabel: HoundLabel = {
        let label = HoundLabel()
        label.text = "Create New Automation"
        label.font = Constant.Visual.Font.emphasizedPrimaryRegularLabel
        label.textColor = UIColor.systemBackground
        label.isUserInteractionEnabled = true
        
        label.backgroundLabelColor = UIColor.systemBlue
        
        let gesture = UITapGestureRecognizer(target: self, action: #selector(didSelectCreateTrigger))
        gesture.delegate = self
        gesture.cancelsTouchesInView = false
        label.addGestureRecognizer(gesture)
        
        return label
    }()
    private lazy var createNewTriggerButton: HoundButton = {
        let button = HoundButton()
        
        button.setImage(UIImage(systemName: "plus.circle"), for: .normal)
        button.tintColor = UIColor.systemBlue
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.addTarget(self, action: #selector(didSelectCreateTrigger), for: .touchUpInside)
        
        return button
    }()
    private lazy var createNewTriggerStack: HoundStackView = {
        let substack = HoundStackView(arrangedSubviews: [createNewTriggerLabel, createNewTriggerButton])
        substack.axis = .horizontal
        substack.distribution = .fill
        substack.alignment = .center
        substack.spacing = Constant.Constraint.Spacing.contentIntraHori
        return substack
    }()
    
    private var createNewStackVisibleConstraint: NSLayoutConstraint!
    private var createNewStackOffScreenConstraint: NSLayoutConstraint!
    private lazy var createNewLabelsAndButtonsStackView: HoundStackView = {
        let stack = HoundStackView(arrangedSubviews: [createNewDogStack, createNewReminderStack, createNewTriggerStack])
        stack.axis = .vertical
        stack.distribution = .equalSpacing
        stack.alignment = .trailing
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    
    @objc private func didSelectCreateNew() {
        guard !dogManager.dogs.isEmpty else {
            self.shouldOpenDogMenu(dogUUID: nil)
            return
        }
        
        createNewMenuIsOpen.toggle()
    }
    
    @objc private func didSelectCreateDog() {
        closeCreateNewMenu()
        self.shouldOpenDogMenu(dogUUID: nil)
    }
    
    @objc private func didSelectCreateReminder() {
        closeCreateNewMenu()
        presentDogSelection(action: .reminder)
    }
    
    @objc private func didSelectCreateTrigger() {
        closeCreateNewMenu()
        presentDogSelection(action: .trigger)
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsVCDelegate?
    
    private(set) var dogsAddDogViewController: DogsAddDogVC?
    
    private(set) var dogsAddReminderViewController: DogsAddReminderVC?
    private(set) var dogsAddTriggerViewController: DogsAddTriggerVC?
    
    private var createNewMenuIsOpen: Bool = false {
        didSet {
            if createNewMenuIsOpen {
                screenDimmer.isUserInteractionEnabled = true
                openCreateNewMenu()
            }
            else {
                screenDimmer.isUserInteractionEnabled = false
                closeCreateNewMenu()
            }
        }
    }
    // MARK: - Dog Manager
    
    private(set) var dogManager = DogManager()
    
    func setDogManager(sender: Sender, dogManager: DogManager) {
        self.dogManager = dogManager
        
        // possible senders
        // DogsTableVC
        // DogsAddDogVC
        // MainTabBarController
        
        if !(sender.localized is DogsTableVC) {
            dogsTableViewController.setDogManager(sender: Sender(origin: sender, localized: self), dogManager: dogManager)
        }
        
        if (sender.localized is MainTabBarController) == true {
            // main tab bar view controller could have performed a dog manager refresh, meaning the open modification page is invalid
//            dogsAddDogViewController?.dismiss(animated: false)
//            dogsAddReminderViewController?.dismiss(animated: false)
//            dogsAddTriggerViewController?.dismiss(animated: false)
        }
        if !(sender.localized is MainTabBarController) {
            delegate?.didUpdateDogManager(sender: Sender(origin: sender, localized: self), dogManager: dogManager)
        }
        
        noDogsRecordedLabel.isHidden = !dogManager.dogs.isEmpty
        createNewReminderStack.isHidden = dogManager.dogs.isEmpty
        createNewTriggerStack.isHidden = dogManager.dogs.isEmpty
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        closeCreateNewMenu()
    }
    
    // MARK: - Setup
    
    func setup(delegate: DogsVCDelegate) {
        self.delegate = delegate
    }
    
    // MARK: - Functions
    
    func scrollDogsTableViewControllerToTop() {
        guard let y = dogsTableViewController.referenceContentOffsetY else { return }
        dogsTableViewController.tableView?.setContentOffset(CGPoint(x: 0, y: y), animated: true)
    }
    
    private enum CreateAction {
        case reminder
        case trigger
    }
    
    private func presentDogSelection(action: CreateAction) {
        guard dogManager.dogs.isEmpty == false else {
            return
        }
        
        let openForDog: (Dog) -> Void = { dog in
            if action == .reminder {
                let numNonTriggerReminders = dog.dogReminders.dogReminders.count(where: { $0.reminderIsTriggerResult == false })
                
                guard numNonTriggerReminders < Constant.Class.Dog.maximumNumberOfReminders else {
                    PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.noAddMoreRemindersTitle, subtitle: Constant.Visual.BannerText.noAddMoreRemindersSubtitle, style: .warning)
                    return
                }
                
                self.shouldOpenReminderMenu(dogUUID: dog.dogUUID, reminder: nil)
            }
            else {
                let numTriggers = dog.dogTriggers.dogTriggers.count
                
                guard numTriggers < Constant.Class.Dog.maximumNumberOfTriggers else {
                    PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.noAddMoreTriggersTitle, subtitle: Constant.Visual.BannerText.noAddMoreTriggersSubtitle, style: .warning)
                    return
                }
                
                self.shouldOpenTriggerMenu(dog: dog, trigger: nil)
            }
        }
        
        if dogManager.dogs.count == 1, let dog = dogManager.dogs.first {
            openForDog(dog)
            return
        }
        
        let alert = UIAlertController(title: action == .reminder ? "Add Reminder" : "Add Automation", message: nil, preferredStyle: .alert)
        for dog in dogManager.dogs {
            alert.addAction(UIAlertAction(title: dog.dogName, style: .default) { _ in
                openForDog(dog)
            })
        }
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil))
        PresentationManager.enqueueAlert(alert)
    }
    
    private func openCreateNewMenu() {
        UIView.animate(withDuration: Constant.Visual.Animation.showMultipleElements) {
            self.createNewMenuButton.transform = CGAffineTransform(rotationAngle: -.pi / 4)
            self.createNewMenuButton.tintColor = UIColor.systemRed
            
            self.screenDimmer.alpha = 0.5
            self.tabBarController?.tabBar.alpha = 0.25
            
            self.createNewStackOffScreenConstraint.isActive = false
            self.createNewStackVisibleConstraint.isActive = true
            
            self.view.layoutIfNeeded()
        }
    }
    
    @objc private func closeCreateNewMenu() {
        UIView.animate(withDuration: Constant.Visual.Animation.hideMultipleElements) {
            self.createNewMenuButton.transform = .identity
            self.createNewMenuButton.tintColor = UIColor.systemBlue
            
            self.screenDimmer.alpha = 0
            self.tabBarController?.tabBar.alpha = 1
            
            self.createNewStackVisibleConstraint.isActive = false
            self.createNewStackOffScreenConstraint.isActive = true
            
            self.view.layoutIfNeeded()
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = UIColor.secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        embedChild(dogsTableViewController)
        
        view.addSubview(noDogsRecordedLabel)
        view.addSubview(screenDimmer)
        
        // need to be after screenDimmer so they arent obscured.
        view.addSubview(createNewLabelsAndButtonsStackView)
        view.addSubview(createNewMenuButton)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // createNewButtons
        for button in [createNewDogButton, createNewReminderButton, createNewTriggerButton] {
            NSLayoutConstraint.activate([
                button.createSquareAspectRatio(),
                button.createHeightMultiplier(Constant.Constraint.Button.circleHeightMultiplier, relativeToWidthOf: view),
                button.createMaxHeight(Constant.Constraint.Button.circleMaxHeight)
            ])
        }
        
        // createNewLabelsAndButtonsStackView
        createNewStackVisibleConstraint = createNewLabelsAndButtonsStackView.trailingAnchor.constraint(equalTo: createNewMenuButton.trailingAnchor)
        createNewStackOffScreenConstraint = createNewLabelsAndButtonsStackView.leadingAnchor.constraint(equalTo: view.trailingAnchor)
        createNewStackVisibleConstraint.isActive = false
        createNewStackOffScreenConstraint.isActive = true
        NSLayoutConstraint.activate([
            createNewLabelsAndButtonsStackView.bottomAnchor.constraint(equalTo: createNewMenuButton.topAnchor, constant: -Constant.Constraint.Spacing.contentIntraVert)
        ])
        
        // logsTableViewController.view
        NSLayoutConstraint.activate([
            dogsTableViewController.view.topAnchor.constraint(equalTo: view.topAnchor),
            dogsTableViewController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            dogsTableViewController.view.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            dogsTableViewController.view.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        ])
        
        // createNewMenuButton
        NSLayoutConstraint.activate([
            createNewMenuButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            createNewMenuButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteCircleHoriInset),
            createNewMenuButton.createSquareAspectRatio(),
            createNewMenuButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier, relativeToWidthOf: view),
            createNewMenuButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight)
        ])
        
        // screenDimmer
        NSLayoutConstraint.activate([
            screenDimmer.topAnchor.constraint(equalTo: view.topAnchor),
            screenDimmer.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            screenDimmer.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            screenDimmer.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        ])
        
        // noLogsRecordedLabel
        NSLayoutConstraint.activate([
            noDogsRecordedLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            noDogsRecordedLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            noDogsRecordedLabel.centerYAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerYAnchor)
        ])
    }
    
}
//
//  DogsTableVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/1/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsTableVCDelegate: AnyObject {
    func shouldOpenDogMenu(dogUUID: UUID?)
    func shouldOpenReminderMenu(dogUUID: UUID, reminder: Reminder?)
    func shouldOpenTriggerMenu(dog: Dog, trigger: Trigger?)
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
    func shouldUpdateAlphaForButtons(alpha: Double)
}

final class DogsTableVC: HoundTableViewController {
    
    // MARK: - UIScrollViewDelegate
    
    override func scrollViewDidScroll(_ scrollView: UIScrollView) {
        guard let referenceContentOffsetY = referenceContentOffsetY else { return }
        
        // Sometimes the default contentOffset.y isn't 0.0, in testing it was -47.0, so we want to adjust that value to 0.0
        let adjustedContentOffsetY = scrollView.contentOffset.y - referenceContentOffsetY
        // When scrollView.contentOffset.y reaches the value of alphaConstant, the UI element's alpha is set to 0 and is hidden.
        let alphaConstant: Double = 100.0
        let alpha: Double = max(1.0 - (adjustedContentOffsetY / alphaConstant), 0.0)
        delegate?.shouldUpdateAlphaForButtons(alpha: alpha)
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsTableVCDelegate?
    
    private var loopTimer: Timer?
    
    // MARK: - Dog Manager
    
    private(set) var dogManager: DogManager = DogManager()
    
    func setDogManager(sender: Sender, dogManager: DogManager) {
        self.dogManager = dogManager
        
        // possible senders
        // DogsAddDogReminderTVC
        // DogTVC
        // DogsVC
        if !(sender.localized is DogsVC) {
            delegate?.didUpdateDogManager(sender: Sender(origin: sender, localized: self), dogManager: dogManager)
        }
        if !(sender.localized is DogsReminderTVC) && !(sender.origin is DogsTableVC) {
            // source could be anything and could not be in view so no animation
            self.tableView.reloadData()
        }
        if sender.localized is DogsReminderTVC {
            self.reloadVisibleCellsNextAlarmLabels()
        }
        
        // start up loop timer, normally done in view will appear but sometimes view has appeared and doesn't need a loop but then it can get a dogManager update which requires a loop. This happens due to reminder added in DogsIntroduction page.
        if viewIsBeingViewed == true && loopTimer == nil {
            loopTimer = Timer(fireAt: Date(), interval: 1.0, target: self, selector: #selector(self.reloadVisibleCellsNextAlarmLabels), userInfo: nil, repeats: true)
            
            if let loopTimer = loopTimer {
                RunLoop.main.add(loopTimer, forMode: .common)
            }
        }
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.tableView.register(DogTVC.self, forCellReuseIdentifier: DogTVC.reuseIdentifier)
        self.tableView.register(DogsReminderTVC.self, forCellReuseIdentifier: DogsReminderTVC.reuseIdentifier)
        self.tableView.contentInset.top = Constant.Constraint.Spacing.absoluteVertInset
        self.tableView.contentInset.bottom = Constant.Constraint.Spacing.absoluteVertInset
        self.tableView.allowsSelection = !dogManager.dogs.isEmpty
        
        self.tableView.refreshControl = UIRefreshControl()
        self.tableView.refreshControl?.addTarget(self, action: #selector(refreshTableData), for: .valueChanged)
    }
    
    private var viewIsBeingViewed: Bool = false
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        viewIsBeingViewed = true
        
        // not in view so no animation
        self.tableView.reloadData()
        
        loopTimer = Timer(fireAt: Date(), interval: 1.0, target: self, selector: #selector(self.reloadVisibleCellsNextAlarmLabels), userInfo: nil, repeats: true)
        
        if let loopTimer = loopTimer {
            RunLoop.main.add(loopTimer, forMode: .common)
        }
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        viewIsBeingViewed = false
        
        loopTimer?.invalidate()
        loopTimer = nil
    }
    
    // MARK: - Setup
    
    func setup(delegate: DogsTableVCDelegate) {
        self.delegate = delegate
    }
    
    // MARK: - Functions
    
    @objc private func reloadVisibleCellsNextAlarmLabels() {
        guard tableView.visibleCells.isEmpty == false else {
            loopTimer?.invalidate()
            loopTimer = nil
            return
        }
        
        for cell in tableView.visibleCells {
            (cell as? DogsReminderTVC)?.reloadNextAlarmLabel()
        }
    }
    
    /// Makes a query to the server to retrieve new information then refreshed the tableView
    @objc private func refreshTableData() {
        PresentationManager.beginFetchingInformationIndicator()
        DogsRequest.get(errorAlert: .automaticallyAlertOnlyForFailure, dogManager: dogManager) { newDogManager, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                // end refresh first otherwise there will be a weird visual issue
                self.tableView.refreshControl?.endRefreshing()
                
                guard responseStatus != .failureResponse, let newDogManager = newDogManager else {
                    return
                }
                
                if responseStatus == .successResponse {
                    PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.successRefreshRemindersTitle, subtitle: Constant.Visual.BannerText.successRefreshRemindersSubtitle, style: .success)
                }
                else {
                    if OfflineModeManager.shared.hasDisplayedOfflineModeBanner == true {
                        // If OfflineModeManager has displayed its banner that indicates its turning on, then we are safe to display this banner. Otherwise, we would run the risk of both of these banners displaying if its the first time enterin offline mode.
                        PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.infoRefreshOnHoldTitle, subtitle: Constant.Visual.BannerText.infoRefreshOnHoldSubtitle, style: .info)
                    }
                }
                
                self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: newDogManager)
                // manually reload table as the self sender doesn't do that
                // whole page is changing so no animation
                self.tableView.reloadData()
            }
        }
    }
    
    private func willShowDogActionSheet(cell: DogTVC, indexPath: IndexPath) {
        guard let dog = cell.dog, let dogName = cell.dog?.dogName, let dogUUID = cell.dog?.dogUUID, let section = self.dogManager.dogs.firstIndex(where: { dog in
            dog.dogUUID == dogUUID
        }) else { return }
        
        let alertController = UIAlertController(title: "You Selected: \(dogName)", message: nil, preferredStyle: .actionSheet)
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        let addReminderAlertAction = UIAlertAction(title: "Add Reminder", style: .default) { _ in
            self.delegate?.shouldOpenReminderMenu(dogUUID: dogUUID, reminder: nil)
        }
        let addTriggerAlertAction = UIAlertAction(title: "Add Automation", style: .default) { _ in
            self.delegate?.shouldOpenTriggerMenu(dog: dog, trigger: nil)
        }
        
        let editAlertAction = UIAlertAction(
            title: "Edit Dog",
            style: .default,
            handler: { (_: UIAlertAction!)  in
                self.delegate?.shouldOpenDogMenu(dogUUID: dogUUID)
            })
        
        let removeAlertAction = UIAlertAction(title: "Delete Dog", style: .destructive) { _ in
            
            // REMOVE CONFIRMATION
            let removeDogConfirmation = UIAlertController(title: "Are you sure you want to delete \(dogName)?", message: nil, preferredStyle: .alert)
            
            let confirmRemoveDogAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
                DogsRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    self.dogManager.removeDog(dogUUID: dogUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    self.tableView.deleteSections([section], with: .automatic)
                    
                }
            }
            
            let confirmCancelRemoveDogAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            
            removeDogConfirmation.addAction(confirmRemoveDogAlertAction)
            removeDogConfirmation.addAction(confirmCancelRemoveDogAlertAction)
            
            PresentationManager.enqueueAlert(removeDogConfirmation)
        }
        
        alertController.addAction(addReminderAlertAction)
        alertController.addAction(addTriggerAlertAction)
        
        alertController.addAction(editAlertAction)
        
        alertController.addAction(removeAlertAction)
        
        alertController.addAction(cancelAlertAction)
        
        PresentationManager.enqueueActionSheet(alertController, sourceView: cell)
    }
    
    /// Called when a reminder is tapped by the user, display an action sheet of possible modifcations to the alarm/reminder.
    private func willShowReminderActionSheet(cell: DogsReminderTVC, indexPath: IndexPath) {
        guard let dogUUID = cell.dogUUID, let dog = dogManager.findDog(dogUUID: dogUUID) else { return }
        
        guard let reminder = cell.reminder else { return }
        
        var alertControllerTitle = "You Selected: \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName)) for \(dog.dogName)"
        if reminder.reminderIsTriggerResult {
            alertControllerTitle += "\n\nReminders created by automations cannot be edited"
        }
        let selectedReminderAlertController = UIAlertController(title: alertControllerTitle, message: nil, preferredStyle: .actionSheet)
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        let editAlertAction = UIAlertAction(title: "Edit Reminder", style: .default) { _ in
            self.delegate?.shouldOpenReminderMenu(dogUUID: dogUUID, reminder: reminder)
        }
        
        // REMOVE BUTTON
        let removeAlertAction = UIAlertAction(title: "Delete Reminder", style: .destructive) { _ in
            
            // REMOVE CONFIRMATION
            let removeReminderConfirmation = UIAlertController(title: "Are you sure you want to delete \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))?", message: nil, preferredStyle: .alert)
            
            let removeReminderConfirmationRemove = UIAlertAction(title: "Delete", style: .destructive) { _ in
                RemindersRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, reminderUUIDs: [reminder.reminderUUID]) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    
                    let numReminders = self.dogManager.dogs[indexPath.section].dogReminders.dogReminders.count
                    if numReminders > 1 && indexPath.row == numReminders {
                        // there is a reminder above its its the new bottom, so it needs its corners rounded
                        let aboveReminderCell = self.tableView.cellForRow(at: IndexPath(row: indexPath.row - 1, section: indexPath.section)) as? DogsReminderTVC
                        UIView.animate(withDuration: Constant.Visual.Animation.showOrHideSingleElement) {
                            aboveReminderCell?.containerView.roundCorners(setCorners: .bottom)
                        }
                    }
                    dog.dogReminders.removeReminder(reminderUUID: reminder.reminderUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    self.tableView.deleteRows(at: [indexPath], with: .automatic)
                }
                
            }
            
            let removeReminderConfirmationCancel = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            
            removeReminderConfirmation.addAction(removeReminderConfirmationRemove)
            removeReminderConfirmation.addAction(removeReminderConfirmationCancel)
            
            PresentationManager.enqueueAlert(removeReminderConfirmation)
            
        }
        
        let skipOnceAlertAction = UIAlertAction(
            title: "Skip Once",
            style: .default,
            handler: { _ in
                self.userSkippedReminderOnce(dogUUID: dog.dogUUID, reminder: reminder)
                PresentationManager.enqueueBanner(title: "Skipped \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName)) Once", subtitle: nil, style: .success)
            })
        
        // DETERMINES IF ITS A LOG BUTTON OR UNDO LOG BUTTON
        let shouldUndoLogOrUnskip: Bool = {
            guard reminder.reminderIsEnabled == true && reminder.snoozeComponents.executionInterval == nil else {
                return false
            }
            
            return (reminder.reminderType == .weekly && reminder.weeklyComponents.isSkipping) || (reminder.reminderType == .monthly && reminder.monthlyComponents.isSkipping)
        }()
        
        let shouldShowSkipOnceAction: Bool = {
            guard shouldUndoLogOrUnskip == false else {
                return false
            }
            
            guard reminder.reminderIsEnabled == true && reminder.snoozeComponents.executionInterval == nil && reminder.reminderType != .oneTime else {
                return false
            }
            
            return true
        }()
        
        // STORES LOG BUTTON(S)
        var alertActionsForLog: [UIAlertAction] = []
        
        // ADD LOG BUTTONS (MULTIPLE IF POTTY OR OTHER SPECIAL CASE)
        if shouldUndoLogOrUnskip == true {
            let logToUndo = findLogFromSkippedReminder(dog: dog, reminder: reminder)
            
            let logAlertAction = UIAlertAction(
                title:
                    (logToUndo != nil
                     ? "Undo Log "
                     : "Undo Skip ")
                + "for \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))",
                style: .default,
                handler: { (_: UIAlertAction!)  in
                    self.userSelectedUnskipReminder(dog: dog, reminder: reminder)
                    
                    let bannerTitle = (logToUndo != nil
                                       ? "Undid "
                                       : "Unskipped ")
                    + (reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))
                    PresentationManager.enqueueBanner(title: bannerTitle, subtitle: nil, style: .success)
                    
                })
            alertActionsForLog.append(logAlertAction)
        }
        else {
            // Cant convert a reminderActionType of potty directly to logActionType, as it has serveral possible outcomes. Otherwise, logActionType and reminderActionType 1:1
            let logActionTypes: [LogActionType] = reminder.reminderActionType.associatedLogActionTypes
            
            for logActionType in logActionTypes {
                let fullReadableName = logActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName, includeMatchingEmoji: true)
                let logAlertAction = UIAlertAction(
                    title: "Log \(fullReadableName)",
                    style: .default,
                    handler: { _ in
                        self.userPreemptivelyLoggedReminder(dogUUID: dog.dogUUID, reminder: reminder, logActionType: logActionType)
                        PresentationManager.enqueueBanner(title: "Logged \(fullReadableName)", subtitle: nil, style: .success)
                    })
                alertActionsForLog.append(logAlertAction)
            }
        }
        
        for logAlertAction in alertActionsForLog {
            selectedReminderAlertController.addAction(logAlertAction)
        }
        
        if shouldShowSkipOnceAction == true {
            selectedReminderAlertController.addAction(skipOnceAlertAction)
        }
        
        if reminder.reminderIsTriggerResult == false {
            selectedReminderAlertController.addAction(editAlertAction)
        }
        
        selectedReminderAlertController.addAction(removeAlertAction)
        
        selectedReminderAlertController.addAction(cancelAlertAction)
        
        PresentationManager.enqueueActionSheet(selectedReminderAlertController, sourceView: cell)
        
    }
    
    /// The user went to log/skip a reminder on the reminders page. Must updating skipping data and add a log.
    private func userPreemptivelyLoggedReminder(dogUUID: UUID, reminder: Reminder, logActionType: LogActionType) {
        let log = Log(logActionTypeId: logActionType.logActionTypeId, logCustomActionName: reminder.reminderCustomActionName, logStartDate: Date(), logCreatedByReminderUUID: nil)
        
        // special case. Once a oneTime reminder executes/ is skipped, it must be delete. Therefore there are special server queries.
        if reminder.reminderType == .oneTime {
            // make request to add log, then (if successful) make request to delete reminder
            
            // delete the reminder on the server
            RemindersRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminderUUIDs: [reminder.reminderUUID]) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }
                
                if let dogSection = self.dogManager.dogs.firstIndex(where: { $0.dogUUID == dogUUID }),
                   let reminderIndex = self.dogManager.dogs[dogSection].dogReminders.dogReminders.firstIndex(where: { $0.reminderUUID == reminder.reminderUUID }) {
                    let indexPath = IndexPath(row: reminderIndex + 1, section: dogSection)
                    
                    let numReminders = self.dogManager.dogs[indexPath.section].dogReminders.dogReminders.count
                    if numReminders > 1 && indexPath.row == numReminders {
                        // there is a reminder above its its the new bottom, so it needs its corners rounded
                        let aboveReminderCell = self.tableView.cellForRow(at: IndexPath(row: indexPath.row - 1, section: indexPath.section)) as? DogsReminderTVC
                        UIView.animate(withDuration: Constant.Visual.Animation.showOrHideSingleElement) {
                            aboveReminderCell?.containerView.roundCorners(setCorners: .bottom)
                        }
                    }
                    self.dogManager.dogs[dogSection].dogReminders.removeReminder(reminderUUID: reminder.reminderUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    
                    self.tableView.deleteRows(at: [indexPath], with: .automatic)
                    //                    UIView.animate(withDuration: Constant.Visual.Animation.moveMultipleElements) {
                    //                        self.view.setNeedsLayout()
                    //                        self.view.layoutIfNeeded()
                    //                    }
                }
                else {
                    self.dogManager.findDog(dogUUID: dogUUID)?.dogReminders.removeReminder(reminderUUID: reminder.reminderUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    self.tableView.reloadData()
                }
                
                LogsRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, log: log) { responseStatusLogCreate, _ in
                    guard responseStatusLogCreate != .failureResponse else {
                        return
                    }
                    
                    let triggerReminders = self.dogManager.findDog(dogUUID: dogUUID)?.dogLogs.addLog(log: log, invokeDogTriggers: true)
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    
                    guard let triggerReminders = triggerReminders, !triggerReminders.isEmpty else {
                        return
                    }
                    
                    // silently try to create trigger reminders
                    RemindersRequest.create(errorAlert: .automaticallyAlertForNone, dogUUID: dogUUID, reminders: triggerReminders) { responseStatus, _ in
                        guard responseStatus != .failureResponse else {
                            return
                        }
                        self.dogManager.findDog(dogUUID: dogUUID)?.dogReminders.addReminders(reminders: triggerReminders)
                        self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    }
                }
            }
        }
        // Nest all the other cases inside this else statement as otherwise .oneTime alarms would make request with the above code then again down here.
        else {
            reminder.enableIsSkipping(skippedDate: Date())
            
            // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
            RemindersRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminders: [reminder]) { responseStatusReminderUpdate, _ in
                guard responseStatusReminderUpdate != .failureResponse else {
                    return
                }
                
                self.dogManager.findDog(dogUUID: dogUUID)?.dogReminders.addReminder(reminder: reminder)
                self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                
                LogsRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, log: log) { responseStatusLogCreate, _ in
                    guard responseStatusLogCreate != .failureResponse else {
                        return
                    }
                    
                    let triggerReminders = self.dogManager.findDog(dogUUID: dogUUID)?.dogLogs.addLog(log: log, invokeDogTriggers: true)
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    
                    guard let triggerReminders = triggerReminders, !triggerReminders.isEmpty else {
                        return
                    }
                    
                    // silently try to create trigger reminders
                    RemindersRequest.create(errorAlert: .automaticallyAlertForNone, dogUUID: dogUUID, reminders: triggerReminders) { responseStatus, _ in
                        guard responseStatus != .failureResponse else {
                            return
                        }
                        self.dogManager.findDog(dogUUID: dogUUID)?.dogReminders.addReminders(reminders: triggerReminders)
                        self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    }
                }
            }
        }
    }
    
    /// The user went to log/skip a reminder on the reminders page. Must updating skipping data and add a log.
    private func userSkippedReminderOnce(dogUUID: UUID, reminder: Reminder) {
        guard reminder.reminderType != .oneTime else { return }
        
        reminder.enableIsSkipping(skippedDate: Date())
        
        // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
        RemindersRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminders: [reminder]) { responseStatusReminderUpdate, _ in
            guard responseStatusReminderUpdate != .failureResponse else {
                return
            }
            
            self.dogManager.findDog(dogUUID: dogUUID)?.dogReminders.addReminder(reminder: reminder)
            self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
        }
    }
    
    /// If a reminder was skipped, it could have either been a preemptive log (meaning there was a log created) or it was skipped without a log. Thus, locate the log if it exists.
    private func findLogFromSkippedReminder(dog: Dog, reminder: Reminder) -> Log? {
        // this is the time that the reminder's next alarm was skipped. at this same moment, a log was added. If this log is still there, with it's date unmodified by the user, then we remove it.
        let dateOfLogToRemove: Date? = {
            if reminder.reminderType == .weekly {
                return reminder.weeklyComponents.skippedDate
            }
            else if reminder.reminderType == .monthly {
                return reminder.monthlyComponents.skippedDate
            }
            
            return nil
        }()
        
        guard let dateOfLogToRemove = dateOfLogToRemove else {
            return nil
        }
        
        // find log that is incredibly close the time where the reminder was skipped, once found, then we delete it.
        let logToRemove = dog.dogLogs.dogLogs.first(where: { log in
            return abs(dateOfLogToRemove.distance(to: log.logStartDate)) < 0.001
        })
        
        return logToRemove
    }
    
    /// The user went to unlog/unskip a reminder on the reminders page. Must update skipping information. Note: only weekly/monthly reminders can be skipped therefore only they can be unskipped.
    private func userSelectedUnskipReminder(dog: Dog, reminder: Reminder) {
        // we can only unskip a weekly/monthly reminder that is currently isSkipping == true
        guard (reminder.reminderType == .weekly && reminder.weeklyComponents.isSkipping == true) || (reminder.reminderType == .monthly && reminder.monthlyComponents.isSkipping == true) else { return }
        
        reminder.disableIsSkipping()
        
        // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
        RemindersRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, reminders: [reminder]) { responseStatusReminderUpdate, _ in
            guard responseStatusReminderUpdate != .failureResponse else {
                return
            }
            
            self.dogManager.findDog(dogUUID: dog.dogUUID)?.dogReminders.addReminder(reminder: reminder)
            self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
            
            // find log that is incredibly close the time where the reminder was skipped, once found, then we delete it.
            guard let logToRemove = self.findLogFromSkippedReminder(dog: dog, reminder: reminder) else {
                return
            }
            
            // log to remove from unlog event. Attempt to delete the log server side
            LogsRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, logUUID: logToRemove.logUUID) { responseStatusLogDelete, _ in
                guard responseStatusLogDelete != .failureResponse else {
                    return
                }
                
                self.dogManager.findDog(dogUUID: dog.dogUUID)?.dogLogs.removeLog(logUUID: logToRemove.logUUID)
                self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
            }
            
        }
    }
    
    override func didUpdateUserTimeZone() {
        self.tableView.reloadData()
    }
    
    // MARK: - Table View Data Source
    
    override func numberOfSections(in tableView: UITableView) -> Int {
        dogManager.dogs.count
    }
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        guard dogManager.dogs.isEmpty == false else {
            return 0
        }
        
        return dogManager.dogs[section].dogReminders.dogReminders.count + 1
    }
    
    override func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return Constant.Constraint.Spacing.contentTallIntraVert
    }
    
    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let footer = HoundHeaderFooterView()
        return footer
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard dogManager.dogs.isEmpty == false else {
            return HoundTableViewCell()
        }
        
        let cell = indexPath.row == 0
        ? tableView.dequeueReusableCell(withIdentifier: DogTVC.reuseIdentifier, for: indexPath)
        : tableView.dequeueReusableCell(withIdentifier: DogsReminderTVC.reuseIdentifier, for: indexPath)
        
        if let castedCell = cell as? DogTVC {
            castedCell.setup(dog: dogManager.dogs[indexPath.section])
            castedCell.containerView.roundCorners(setCorners: .all)
            
            if dogManager.dogs[indexPath.section].dogReminders.dogReminders.isEmpty {
                // if there is a reminder cell below this cell, we want to the white background of the reminder cell to "continuously" flow from the reminder cell to under this cell. the only way we can make that happen, is having a white background layer below out blue table view cell (which appears if there is a cell below this)
                castedCell.containerExtraBackgroundView.isHidden = true
            }
            else {
                castedCell.containerExtraBackgroundView.isHidden = false
            }
        }
        else if let castedCell = cell as? DogsReminderTVC {
            castedCell.setup(dogUUID: dogManager.dogs[indexPath.section].dogUUID, reminder: dogManager.dogs[indexPath.section].dogReminders.dogReminders[indexPath.row - 1])
            
            // This cell is a bottom cell
            if indexPath.row == dogManager.dogs[indexPath.section].dogReminders.dogReminders.count {
                castedCell.containerView.roundCorners(setCorners: .bottom)
            }
            else {
                castedCell.containerView.roundCorners(setCorners: .none)
            }
        }
        
        return cell
    }
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        
        tableView.deselectRow(at: indexPath, animated: true)
        
        guard dogManager.dogs.isEmpty == false else { return }
        
        if indexPath.row == 0, let dogsDogDisplayTableViewCell = tableView.cellForRow(at: indexPath) as? DogTVC {
            willShowDogActionSheet(cell: dogsDogDisplayTableViewCell, indexPath: indexPath)
        }
        else if indexPath.row > 0, let dogsReminderDisplayTableViewCell = tableView.cellForRow(at: indexPath) as? DogsReminderTVC {
            willShowReminderActionSheet(cell: dogsReminderDisplayTableViewCell, indexPath: indexPath)
        }
        
    }
    
    override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
        
        guard editingStyle == .delete && dogManager.dogs.isEmpty == false else { return }
        var removeConfirmation: UIAlertController?
        
        // delete dog
        if indexPath.row == 0, let dogCell = tableView.cellForRow(at: indexPath) as?  DogTVC, let dog = dogCell.dog {
            // cell in question
            
            removeConfirmation = UIAlertController(title: "Are you sure you want to delete \(dog.dogName)?", message: nil, preferredStyle: .alert)
            
            let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
                DogsRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    
                    self.dogManager.removeDog(dogUUID: dog.dogUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    self.tableView.deleteSections([indexPath.section], with: .automatic)
                    UIView.animate(withDuration: Constant.Visual.Animation.moveMultipleElements) {
                        self.view.setNeedsLayout()
                        self.view.layoutIfNeeded()
                    }
                    
                }
                
            }
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            removeConfirmation?.addAction(removeAlertAction)
            removeConfirmation?.addAction(cancelAlertAction)
        }
        // delete reminder
        if indexPath.row > 0, let reminderCell = tableView.cellForRow(at: indexPath) as? DogsReminderTVC, let dogUUID = reminderCell.dogUUID, let dog: Dog = dogManager.findDog(dogUUID: dogUUID), let reminder = reminderCell.reminder {
            removeConfirmation = UIAlertController(title: "Are you sure you want to delete \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))?", message: nil, preferredStyle: .alert)
            
            let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
                RemindersRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminderUUIDs: [reminder.reminderUUID]) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    
                    let numReminders = self.dogManager.dogs[indexPath.section].dogReminders.dogReminders.count
                    if numReminders > 1 && indexPath.row == numReminders {
                        // there is a reminder above its its the new bottom, so it needs its corners rounded
                        let aboveReminderCell = tableView.cellForRow(at: IndexPath(row: indexPath.row - 1, section: indexPath.section)) as? DogsReminderTVC
                        UIView.animate(withDuration: Constant.Visual.Animation.showOrHideSingleElement) {
                            aboveReminderCell?.containerView.roundCorners(setCorners: .bottom)
                        }
                    }
                    dog.dogReminders.removeReminder(reminderUUID: reminder.reminderUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), dogManager: self.dogManager)
                    self.tableView.deleteRows(at: [indexPath], with: .automatic)
                }
                
            }
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            removeConfirmation?.addAction(removeAlertAction)
            removeConfirmation?.addAction(cancelAlertAction)
        }
        
        if let removeConfirmation = removeConfirmation {
            PresentationManager.enqueueAlert(removeConfirmation)
        }
    }
    
    override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        dogManager.dogs.count >= 1
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        tableView.backgroundColor = UIColor.secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
    }
    
    override func setupConstraints() {
        super.setupConstraints()
    }
    
}
//
//  DogsMainScreenTableViewCellReminder.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/2/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

final class DogsReminderTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    let containerView: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.systemBackground
        return view
    }()
    
    private let reminderActionIconLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.textAlignment = .center
        // same as LogTVC
        label.font = UIFont.systemFont(ofSize: 42.5, weight: .medium)
        return label
    }()
    private let triggerResultIndicatorImageView: HoundImageView = {
        let imageView = HoundImageView()
        imageView.image = UIImage(systemName: "sparkles")
        imageView.tintColor = UIColor.systemBlue
        return imageView
    }()
    
    private let reminderActionTextLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryHeaderLabel
        return label
    }()
    
    private let intervalLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.secondaryRegularLabel
        return label
    }()
    
    private let nextAlarmLabel: HoundLabel = {
        let label = HoundLabel()
        label.backgroundColor = UIColor.secondarySystemBackground
        // font set in attributed text closure
        label.shouldInsetText = true
        
        label.shouldRoundCorners = true
        label.staticCornerRadius = nil
        return label
    }()
    
    private lazy var nestedLabelStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(reminderActionTextLabel)
        stack.addArrangedSubview(intervalLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
    private lazy var labelStack: HoundStackView = {
        let stack = HoundStackView(huggingPriority: 280, compressionResistancePriority: 280)
        stack.addArrangedSubview(nestedLabelStack)
        stack.addArrangedSubview(nextAlarmLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()

    private let chevronImageView: HoundImageView = {
        let imageView = HoundImageView(huggingPriority: 300, compressionResistancePriority: 300)
       
        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = UIColor.systemGray4
        
        return imageView
    }()
    
    private let notificationBellImageView: HoundImageView = {
        let imageView = HoundImageView()
        
        imageView.image = UIImage(systemName: "bell.slash")
        imageView.tintColor = UIColor.systemGray4
        
        return imageView
    }()
    
    private let timeZoneIndicatorImageView: HoundImageView = {
            let imageView = HoundImageView()

            imageView.image = UIImage(systemName: "globe")
            imageView.tintColor = UIColor.systemGray4

            return imageView
        }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "DogsReminderTVC"
    
    var dogUUID: UUID?
    var reminder: Reminder?
    
    private let reminderEnabledElementAlpha: CGFloat = 1.0
    private let reminderDisabledElementAlpha: CGFloat = 0.4
    
    // MARK: - Setup
    
    func setup(dogUUID: UUID, reminder: Reminder) {
        self.dogUUID = dogUUID
        self.reminder = reminder
        
        reminderActionIconLabel.text = reminder.reminderActionType.emoji
        reminderActionIconLabel.alpha = reminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
        reminderActionIconLabel.isHidden = reminder.reminderIsTriggerResult
        
        triggerResultIndicatorImageView.alpha = reminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
        triggerResultIndicatorImageView.isHidden = !reminder.reminderIsTriggerResult
        
        reminderActionTextLabel.text = reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName)
        reminderActionTextLabel.alpha = reminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
        
        intervalLabel.text = reminder.readableRecurrance()
        intervalLabel.alpha = reminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
        
        chevronImageView.alpha = (reminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha) * 0.75
        notificationBellImageView.alpha = reminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
        
        let reminderEnabled = reminder.reminderIsEnabled
        let userIsRecipient = reminder.reminderRecipientUserIds.contains { $0 == UserInformation.userId ?? Constant.Visual.Text.unknownUserId }
        let hasRecipients = !reminder.reminderRecipientUserIds.isEmpty
        
        let shouldShowBell =
        reminderEnabled && (
            !userIsRecipient ||
            (hasRecipients && !UserConfiguration.isNotificationEnabled) ||
            (hasRecipients && !UserConfiguration.isReminderNotificationEnabled)
        )
        
        notificationBellImageView.isHidden = !shouldShowBell
        timeZoneIndicatorImageView.isHidden = !reminder.reminderIsEnabled || UserConfiguration.timeZone == reminder.reminderTimeZone
        
        reloadNextAlarmLabel()
    }
    
    // MARK: - Function
    
    func reloadNextAlarmLabel() {
        guard let reminder = reminder else { return }
        
        guard reminder.reminderIsEnabled == true, let executionDate = reminder.reminderExecutionDate else {
            nextAlarmLabel.isHidden = true
            return
        }
        
        nextAlarmLabel.isHidden = false
        
        guard Date().distance(to: executionDate) > 0 else {
            nextAlarmLabel.attributedText = NSAttributedString(string: "No More Time Left", attributes: [.font: Constant.Visual.Font.emphasizedSecondaryRegularLabel])
            return
        }
        
        nextAlarmLabel.attributedText = {
            let message = NSMutableAttributedString(
                string: reminder.snoozeComponents.executionInterval != nil ? "Snoozing: " : "Remind In: ",
                attributes: [.font: Constant.Visual.Font.emphasizedSecondaryRegularLabel]
            )
            
            message.append(NSAttributedString(string: Date().distance(to: executionDate).readable(capitalizeWords: false, abbreviationLevel: .short, maxComponents: 2, enforceSequentialComponents: true), attributes: [.font: Constant.Visual.Font.secondaryRegularLabel]))
            
            return message
        }()
    }
    
    // MARK: - Setup Elements

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(reminderActionIconLabel)
        containerView.addSubview(triggerResultIndicatorImageView)
        containerView.addSubview(labelStack)
        containerView.addSubview(chevronImageView)
        containerView.addSubview(notificationBellImageView)
        containerView.addSubview(timeZoneIndicatorImageView)
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        containerView.snp.makeConstraints { make in
            make.top.equalTo(contentView.snp.top)
            // Use .high priority to avoid breaking during table view height estimation
            make.bottom.equalTo(contentView.snp.bottom).priority(.high)
            make.leading.equalTo(contentView.snp.leading).offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalTo(contentView.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        reminderActionIconLabel.snp.makeConstraints { make in
            make.top.equalTo(labelStack.snp.top).inset(Constant.Constraint.Spacing.contentTightIntraHori)
            make.leading.equalTo(containerView.snp.leading).offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.height.equalTo(reminderActionIconLabel.snp.width)
        }
        
        triggerResultIndicatorImageView.snp.makeConstraints { make in
            make.top.equalTo(reminderActionIconLabel.snp.top).offset(Constant.Constraint.Spacing.contentTightIntraHori)
            make.bottom.equalTo(reminderActionIconLabel.snp.bottom).inset(Constant.Constraint.Spacing.contentTightIntraHori)
            make.leading.equalTo(reminderActionIconLabel.snp.leading).offset(Constant.Constraint.Spacing.contentTightIntraHori)
            make.trailing.equalTo(reminderActionIconLabel.snp.trailing).inset(Constant.Constraint.Spacing.contentTightIntraHori)
        }
        
        labelStack.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset)
            make.bottom.equalTo(containerView.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset)
            make.leading.equalTo(reminderActionIconLabel.snp.trailing).offset(Constant.Constraint.Spacing.contentIntraHori)
        }
        
        chevronImageView.snp.makeConstraints { make in
            make.leading.equalTo(labelStack.snp.trailing).offset(Constant.Constraint.Spacing.contentIntraHori)
            make.trailing.equalTo(containerView.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.centerY.equalTo(containerView.snp.centerY)
            make.height.equalTo(contentView.snp.width).multipliedBy(Constant.Constraint.Button.chevronHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.chevronMaxHeight)
            make.width.equalTo(chevronImageView.snp.height).multipliedBy(Constant.Constraint.Button.chevronAspectRatio)
        }
        
        notificationBellImageView.snp.makeConstraints { make in
            make.centerX.equalTo(chevronImageView.snp.centerX)
            make.centerY.equalTo(reminderActionTextLabel.snp.centerY)
            make.height.equalTo(chevronImageView.snp.height)
            make.width.equalTo(notificationBellImageView.snp.height)
        }
        
        timeZoneIndicatorImageView.snp.makeConstraints { make in
            make.centerX.equalTo(chevronImageView.snp.centerX)
            make.centerY.equalTo(nextAlarmLabel.snp.centerY)
            make.height.equalTo(chevronImageView.snp.height)
            make.width.equalTo(timeZoneIndicatorImageView.snp.height)
        }
    }

}
//
//  DogsMainScreenTableViewCellDogDescription.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/11/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

final class DogTVC: HoundTableViewCell {
    
    // MARK: - Elements
    
    let containerExtraBackgroundView: HoundView = {
        // When the cell/containerView is rounded and there is a reminder below it, we dont want a weird lapse in color
        let view = HoundView()
        view.backgroundColor = UIColor.systemBackground
        view.isHidden = true
        return view
    }()
    
    let containerView: HoundView = {
        let view = HoundView()
        view.backgroundColor = UIColor.systemBlue
        return view
    }()
    
    private let houndPaw: HoundPawImageView = {
        let imageView = HoundPawImageView(huggingPriority: 290, compressionResistancePriority: 290)
        
        imageView.shouldRoundCorners = true
        imageView.staticCornerRadius = nil
        
        return imageView
    }()
    
    private let dogNameLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 295, compressionResistancePriority: 295)
        label.font = Constant.Visual.Font.megaHeaderLabel
        label.textColor = UIColor.systemBackground
        return label
    }()
    
    private let chevronImageView: HoundImageView = {
        let imageView = HoundImageView(huggingPriority: 300, compressionResistancePriority: 300)
        
        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = UIColor.systemBackground
        
        return imageView
    }()
    
    private let dogTriggersLabel: HoundLabel = {
        let label = HoundLabel()
        label.backgroundColor = UIColor.systemBackground
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = UIColor.label
        
        label.shouldInsetText = true
        label.shouldRoundCorners = true
        label.staticCornerRadius = nil
        return label
    }()
    
    private lazy var labelStack: HoundStackView = {
        let stack = HoundStackView(huggingPriority: 294, compressionResistancePriority: 294)
        stack.addArrangedSubview(dogNameLabel)
        stack.addArrangedSubview(dogTriggersLabel)
        stack.axis = .vertical
        stack.distribution = .fillProportionally
        stack.alignment = .fill
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }()
        
    // MARK: - Properties
    
    static let reuseIdentifier = "DogTVC"
    
    var dog: Dog?
    
    // MARK: - Setup
    
    func setup(dog: Dog) {
        self.dog = dog
        
        houndPaw.shouldRoundCorners = dog.dogIcon != nil
        
        dogNameLabel.text = dog.dogName
        if dog.dogTriggers.dogTriggers.isEmpty {
            dogTriggersLabel.text = "No automations ✨"
        }
        else {
            dogTriggersLabel.text = "\(dog.dogTriggers.dogTriggers.count) automation\(dog.dogTriggers.dogTriggers.count > 1 ? "s" : "") ✨"
        }
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerExtraBackgroundView)
        contentView.addSubview(containerView)
        containerView.addSubview(houndPaw)
        containerView.addSubview(chevronImageView)
        containerView.addSubview(labelStack)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        containerView.snp.makeConstraints { make in
            // Use .high priority to avoid breaking during table view height estimation
            make.verticalEdges.equalTo(contentView.snp.verticalEdges).priority(.high)
            make.horizontalEdges.equalTo(contentView.snp.horizontalEdges).inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        containerExtraBackgroundView.snp.makeConstraints { make in
            make.edges.equalTo(containerView.snp.edges)
        }
        
        houndPaw.snp.makeConstraints { make in
            make.height.equalTo(dogNameLabel.snp.height).offset(Constant.Constraint.Spacing.contentTightIntraHori * 2.0)
            make.centerY.equalTo(dogNameLabel.snp.centerY)
            make.leading.equalTo(containerView.snp.leading).offset(Constant.Constraint.Spacing.contentIntraHori)
            make.width.equalTo(houndPaw.snp.height)
        }
        
        dogNameLabel.snp.makeConstraints { make in
            make.height.equalTo(contentView.snp.width).multipliedBy(Constant.Constraint.Text.megaHeaderLabelHeightMultipler).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Text.megaHeaderLabelMaxHeight)
        }
        
        labelStack.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset * 2.0)
            make.bottom.equalTo(containerView.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset)
            make.leading.equalTo(houndPaw.snp.trailing).offset(Constant.Constraint.Spacing.contentIntraHori)
        }
        
        chevronImageView.snp.makeConstraints { make in
            make.leading.equalTo(labelStack.snp.trailing).offset(Constant.Constraint.Spacing.contentIntraHori)
            make.trailing.equalTo(containerView.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.centerY.equalTo(containerView.snp.centerY)
            make.height.equalTo(contentView.snp.width).multipliedBy(Constant.Constraint.Button.chevronHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.chevronMaxHeight)
            make.width.equalTo(chevronImageView.snp.height).multipliedBy(Constant.Constraint.Button.chevronAspectRatio)
        }
    }
    
}
//
//  DogsAddReminderMonthlyVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/13/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

protocol DogsAddReminderMonthlyViewDelegate: AnyObject {
    func willDismissKeyboard()
    func didUpdateDescriptionLabel()
}

final class DogsAddReminderMonthlyView: HoundView {
    
    // MARK: - Elements
    
    private lazy var timeOfDayDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker(huggingPriority: 260, compressionResistancePriority: 260)
        datePicker.datePickerMode = .dateAndTime
        datePicker.preferredDatePickerStyle = .wheels
        datePicker.minuteInterval = Constant.Development.minuteInterval
        
        datePicker.addTarget(self, action: #selector(didUpdateTimeOfDay), for: .valueChanged)
        
        datePicker.date = Date.roundDate(targetDate: Date(), roundingInterval: Double(60 * datePicker.minuteInterval), roundingMethod: .up)
        
        return datePicker
    }()
    
    private let rollUnderDisclaimerLabel: HoundLabel = {
        let label = HoundLabel()
        label.textColor = UIColor.secondaryLabel
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.isHidden = true
        return label
    }()
    
    private lazy var stack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(timeOfDayDatePicker)
        stack.addArrangedSubview(rollUnderDisclaimerLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    
    @objc private func didUpdateTimeOfDay(_ sender: Any) {
        updateDescriptionLabel()
        delegate?.willDismissKeyboard()
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddReminderMonthlyViewDelegate?
    private(set) var currentTimeZone: TimeZone = UserConfiguration.timeZone
    
    // timeOfDayDatePicker.date
    private var currentTimeOfDay: Date {
        timeOfDayDatePicker.date
    }
    
    /// Monthly component represented by the current UI state.
    var currentComponent: MonthlyComponents {
        let calendar = Calendar.fromZone(currentTimeZone)
        let comps = calendar.dateComponents(in: currentTimeZone, from: currentTimeOfDay)
        let day = comps.day ?? Constant.Class.ReminderComponent.defaultZonedDay
        let hour = comps.hour ?? Constant.Class.ReminderComponent.defaultZonedHour
        let minute = comps.minute ?? Constant.Class.ReminderComponent.defaultZonedMinute
        return MonthlyComponents(zonedDay: day, zonedHour: hour, zonedMinute: minute)
    }
    
    var descriptionLabelText: String {
        let comps = Calendar.fromZone(currentTimeZone).dateComponents([.day], from: timeOfDayDatePicker.date)
        let day = comps.day ?? 1
        
        let timeString = timeOfDayDatePicker.date.houndFormatted(
            .formatStyle(date: .omitted, time: .shortened),
            displayTimeZone: currentTimeZone
        )
        
        return "Reminder will sound on the \(day)\(day.daySuffix()) of each month at \(timeString)"
    }
    
    private var disclaimerLabelText: String? {
        let comps = Calendar.fromZone(currentTimeZone).dateComponents([.day], from: timeOfDayDatePicker.date)
        let day = comps.day ?? 1
        
        return day > 28 ? "If a month has less than \(day) days, the reminder will occur on the last day of that month." : nil
    }
    
    // MARK: - Setup
    
    func setup(
        delegate: DogsAddReminderMonthlyViewDelegate,
        components: MonthlyComponents?,
        timeZone: TimeZone
    ) {
        self.delegate = delegate
        currentTimeZone = timeZone
        timeOfDayDatePicker.timeZone = timeZone
        
        if let components = components {
            let calendar = Calendar.fromZone(currentTimeZone)
            var comps = calendar.dateComponents([.year, .month], from: Date())
            comps.day = components.zonedDay
            comps.hour = components.zonedHour
            comps.minute = components.zonedMinute
            comps.second = 0
            comps.timeZone = timeZone
            timeOfDayDatePicker.date = calendar.date(from: comps) ?? timeOfDayDatePicker.date
        }
        updateDescriptionLabel()
    }
    
    // MARK: - Time Zone
    
    func updateDisplayedTimeZone(_ newTimeZone: TimeZone) {
        guard newTimeZone != currentTimeZone else { return }
        
        let calendar = Calendar.fromZone(currentTimeZone)
        let oldComps = calendar.dateComponents([.year, .month, .day, .hour, .minute], from: timeOfDayDatePicker.date)
        let day = oldComps.day ?? 1
        let hour = oldComps.hour ?? 0
        let minute = oldComps.minute ?? 0
        
        let converted = currentTimeZone.convert(
            day: day,
            hour: hour,
            minute: minute,
            to: newTimeZone,
            referenceDate: timeOfDayDatePicker.date
        )
        
        var newComps = DateComponents()
        newComps.year = oldComps.year
        newComps.month = oldComps.month
        newComps.day = converted.day
        newComps.hour = converted.hour
        newComps.minute = converted.minute
        newComps.second = 0
        newComps.timeZone = newTimeZone
        
        if let newDate = calendar.date(from: newComps) {
            timeOfDayDatePicker.timeZone = newTimeZone
            timeOfDayDatePicker.date = newDate
        }
        
        currentTimeZone = newTimeZone
        updateDescriptionLabel()
    }
    
    // MARK: - Functions
    
    private func updateDescriptionLabel() {
        delegate?.didUpdateDescriptionLabel()
        
        rollUnderDisclaimerLabel.text = disclaimerLabelText
        rollUnderDisclaimerLabel.isHidden = disclaimerLabelText == nil
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(stack)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        stack.snp.makeConstraints { make in
            make.edges.equalTo(self.snp.edges)
        }
        
        timeOfDayDatePicker.snp.makeConstraints { make in
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.megaDatePickerHeightMultiplier)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.megaDatePickerMaxHeight)
        }
    }
    
}
//
//  DogsAddReminderVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/26/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddReminderVCDelegate: AnyObject {
    /// If a dogUUID is provided, then the reminder is added, updated, or deleted on the Hound server,
    /// and both a dogUUID and reminder is returned. If a dogUUID is not returned, the reminder has only
    /// been added, updated, or deleted locally.
    func didAddReminder(sender: Sender, dogUUID: UUID?, reminder: Reminder)
    func didUpdateReminder(sender: Sender, dogUUID: UUID?, reminder: Reminder)
    func didRemoveReminder(sender: Sender, dogUUID: UUID?, reminderUUID: UUID)
}

final class DogsAddReminderVC: HoundScrollViewController {
    
    // MARK: - Elements
    
    private lazy var editPageHeaderView: HoundEditPageHeaderView = {
        let view = HoundEditPageHeaderView(huggingPriority: 330, compressionResistancePriority: 330)
        
        view.leadingButton.setImage(UIImage(systemName: "doc.circle"), for: .normal)
        view.leadingButton.addTarget(self, action: #selector(didTouchUpInsideDuplicateReminder), for: .touchUpInside)
        
        view.trailingButton.setImage(UIImage(systemName: "trash.circle"), for: .normal)
        view.trailingButton.addTarget(self, action: #selector(didTouchUpInsideRemoveReminder), for: .touchUpInside)
        
        return view
    }()
    
    private let dogsAddReminderManagerView: DogsAddReminderManagerView = {
        let vc = DogsAddReminderManagerView(huggingPriority: 320, compressionResistancePriority: 320)
        return vc
    }()
    
    private lazy var saveReminderButton: HoundButton = {
        let button = HoundButton(huggingPriority: 350, compressionResistancePriority: 350)
        
        button.tintColor = UIColor.systemBlue
        button.setImage(UIImage(systemName: "checkmark.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.addTarget(self, action: #selector(didTouchUpInsideSaveReminder), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var backButton: HoundButton = {
        let button = HoundButton(huggingPriority: 340, compressionResistancePriority: 340)
        
        button.tintColor = UIColor.systemGray2
        button.setImage(UIImage(systemName: "arrow.backward.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.addTarget(self, action: #selector(didTouchUpInsideBack), for: .touchUpInside)
        
        return button
    }()
    
    @objc private func didTapScreen(sender: UITapGestureRecognizer) {
        dogsAddReminderManagerView.didTapScreen(sender: sender)
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddReminderVCDelegate?
    
    private var reminderToUpdate: Reminder?
    private var reminderToUpdateDogUUID: UUID?
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        
        let saveButtonTop = saveReminderButton.convert(saveReminderButton.bounds, to: view).minY
        let backButtonTop = backButton.convert(backButton.bounds, to: view).minY
        let buttonTop = min(saveButtonTop, backButtonTop)
        
        let distanceFromBottom = view.bounds.height - buttonTop
        
        let minInset = distanceFromBottom + Constant.Constraint.Spacing.absoluteVertInset
        
        scrollView.contentInset.bottom = max(scrollView.contentInset.bottom, minInset)
    }
    
    // MARK: - Setup
    
    func setup(
        delegate: DogsAddReminderVCDelegate,
        reminderToUpdateDogUUID: UUID?,
        reminderToUpdate: Reminder?
    ) {
        self.delegate = delegate
        self.reminderToUpdateDogUUID = reminderToUpdateDogUUID
        self.reminderToUpdate = reminderToUpdate
        
        editPageHeaderView.setTitle(reminderToUpdate == nil ? "Create Reminder" : "Edit Reminder")
        editPageHeaderView.isLeadingButtonEnabled = reminderToUpdate != nil
        editPageHeaderView.isTrailingButtonEnabled = reminderToUpdate != nil
        
        dogsAddReminderManagerView.setup(reminderToUpdate: reminderToUpdate)
    }
    
    // MARK: - Functions
    
    @objc private func didTouchUpInsideSaveReminder(_ sender: Any) {
        guard let reminder = dogsAddReminderManagerView.constructReminder(showErrorIfFailed: true) else { return }
        
        // Persist custom action name locally
        LocalConfiguration.addReminderCustomAction(
            reminderActionType: reminder.reminderActionType,
            reminderCustomActionName: reminder.reminderCustomActionName
        )
        
        // If there's no dogUUID, notify delegate locally and dismiss
        guard let reminderToUpdateDogUUID = reminderToUpdateDogUUID else {
            if reminderToUpdate == nil {
                delegate?.didAddReminder(
                    sender: Sender(origin: self, localized: self),
                    dogUUID: nil,
                    reminder: reminder
                )
            }
            else {
                delegate?.didUpdateReminder(
                    sender: Sender(origin: self, localized: self),
                    dogUUID: nil,
                    reminder: reminder
                )
            }
            HapticsManager.notification(.success)
            self.dismiss(animated: true)
            return
        }
        
        // Otherwise, call API to create/update on server
        view.isUserInteractionEnabled = false
        saveReminderButton.isLoading = true
        
        let completionHandler: (ResponseStatus, HoundError?) -> Void = { [weak self] responseStatus, _ in
            guard let self = self else { return }
            view.isUserInteractionEnabled = true
            self.saveReminderButton.isLoading = false
            guard responseStatus != .failureResponse else { return }
            
            if self.reminderToUpdate != nil {
                self.delegate?.didUpdateReminder(
                    sender: Sender(origin: self, localized: self),
                    dogUUID: reminderToUpdateDogUUID,
                    reminder: reminder
                )
            }
            else {
                self.delegate?.didAddReminder(
                    sender: Sender(origin: self, localized: self),
                    dogUUID: reminderToUpdateDogUUID,
                    reminder: reminder
                )
            }
            HapticsManager.notification(.success)
            self.dismiss(animated: true)
        }
        
        if reminderToUpdate != nil {
            RemindersRequest.update(
                errorAlert: .automaticallyAlertOnlyForFailure,
                dogUUID: reminderToUpdateDogUUID,
                reminders: [reminder],
                completionHandler: completionHandler
            )
        }
        else {
            RemindersRequest.create(
                errorAlert: .automaticallyAlertOnlyForFailure,
                dogUUID: reminderToUpdateDogUUID,
                reminders: [reminder],
                completionHandler: completionHandler
            )
        }
    }
    
    @objc private func didTouchUpInsideDuplicateReminder(_ sender: Any) {
        guard let duplicateReminder = dogsAddReminderManagerView.constructReminder(showErrorIfFailed: true)?.duplicate() else { return }
        
        // If no dogUUID, notify delegate locally
        guard let reminderToUpdateDogUUID = reminderToUpdateDogUUID else {
            delegate?.didAddReminder(
                sender: Sender(origin: self, localized: self),
                dogUUID: nil,
                reminder: duplicateReminder
            )
            HapticsManager.notification(.success)
            self.dismiss(animated: true)
            return
        }
        
        // Otherwise, call API to create/update on server
        view.isUserInteractionEnabled = false
        saveReminderButton.isLoading = true
        
        RemindersRequest.create(
            errorAlert: .automaticallyAlertOnlyForFailure,
            dogUUID: reminderToUpdateDogUUID,
            reminders: [duplicateReminder]
        ) { [weak self] responseStatus, _ in
            guard let self = self else { return }
            view.isUserInteractionEnabled = true
            self.saveReminderButton.isLoading = false
            guard responseStatus != .failureResponse else { return }
            
            self.delegate?.didAddReminder(
                sender: Sender(origin: self, localized: self),
                dogUUID: reminderToUpdateDogUUID,
                reminder: duplicateReminder
            )
            HapticsManager.notification(.success)
            self.dismiss(animated: true)
        }
    }
    
    @objc private func didTouchUpInsideRemoveReminder(_ sender: Any) {
        guard let reminderToUpdate = reminderToUpdate else { return }
        guard let reminderToUpdateDogUUID = reminderToUpdateDogUUID else {
            delegate?.didRemoveReminder(
                sender: Sender(origin: self, localized: self),
                dogUUID: nil,
                reminderUUID: reminderToUpdate.reminderUUID
            )
            HapticsManager.notification(.warning)
            self.dismiss(animated: true)
            return
        }
        
        let actionName = dogsAddReminderManagerView
            .selectedReminderAction?
            .convertToReadableName(customActionName: reminderToUpdate.reminderCustomActionName)
        ?? reminderToUpdate.reminderActionType.convertToReadableName(customActionName: reminderToUpdate.reminderCustomActionName)
        
        let alert = UIAlertController(
            title: "Are you sure you want to delete \(actionName)?",
            message: nil,
            preferredStyle: .alert
        )
        
        let deleteAction = UIAlertAction(title: "Delete", style: .destructive) { [weak self] _ in
            guard let self = self else { return }
            view.isUserInteractionEnabled = false
            
            RemindersRequest.delete(
                errorAlert: .automaticallyAlertOnlyForFailure,
                dogUUID: reminderToUpdateDogUUID,
                reminderUUIDs: [reminderToUpdate.reminderUUID]
            ) { responseStatus, _ in
                self.view.isUserInteractionEnabled = true
                guard responseStatus != .failureResponse else { return }
                
                self.delegate?.didRemoveReminder(
                    sender: Sender(origin: self, localized: self),
                    dogUUID: reminderToUpdateDogUUID,
                    reminderUUID: reminderToUpdate.reminderUUID
                )
                HapticsManager.notification(.warning)
                self.dismiss(animated: true)
            }
        }
        
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        alert.addAction(deleteAction)
        alert.addAction(cancelAction)
        PresentationManager.enqueueAlert(alert)
    }
    
    @objc private func didTouchUpInsideBack(_ sender: Any) {
        guard dogsAddReminderManagerView.didUpdateInitialValues else {
            self.dismiss(animated: true)
            return
        }
        
        let alert = UIAlertController(
            title: "Are you sure you want to exit?",
            message: nil,
            preferredStyle: .alert
        )
        let exitAction = UIAlertAction(title: "Yes, I don't want to save changes", style: .default) { [weak self] _ in
            self?.dismiss(animated: true)
        }
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        alert.addAction(exitAction)
        alert.addAction(cancelAction)
        PresentationManager.enqueueAlert(alert)
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(saveReminderButton)
        view.addSubview(backButton)
        
        containerView.addSubview(editPageHeaderView)
        containerView.addSubview(dogsAddReminderManagerView)
        
        let didTapScreenGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapScreen(sender:))
        )
        didTapScreenGesture.delegate = self
        didTapScreenGesture.cancelsTouchesInView = false
        view.addGestureRecognizer(didTapScreenGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // editPageHeaderView
        NSLayoutConstraint.activate([
            editPageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            editPageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            editPageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // dogsAddReminderManagerView
        NSLayoutConstraint.activate([
            dogsAddReminderManagerView.topAnchor.constraint(equalTo: editPageHeaderView.bottomAnchor),
            dogsAddReminderManagerView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor),
            dogsAddReminderManagerView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            dogsAddReminderManagerView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        
        // saveLogButton
        NSLayoutConstraint.activate([
            saveReminderButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            saveReminderButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteCircleHoriInset),
            saveReminderButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier, relativeToWidthOf: view),
            saveReminderButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight),
            saveReminderButton.createSquareAspectRatio()
        ])
        
        // backButton
        NSLayoutConstraint.activate([
            backButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            backButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteCircleHoriInset),
            backButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier, relativeToWidthOf: view),
            backButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight),
            backButton.createSquareAspectRatio()
        ])
    }
    
}
//
//  DogsAddReminderCountdownVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/28/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddReminderCountdownViewDelegate: AnyObject {
    func willDismissKeyboard()
    func didUpdateDescriptionLabel()
}

final class DogsAddReminderCountdownView: HoundView {
    
    // MARK: - Elements
    
    private lazy var countdownDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker(huggingPriority: 240, compressionResistancePriority: 240)
        datePicker.datePickerMode = .countDownTimer
        datePicker.minuteInterval = Constant.Development.minuteInterval
        datePicker.countDownDuration = Constant.Class.ReminderComponent.defaultCountdownExecutionInterval
        
        datePicker.addTarget(self, action: #selector(didUpdateCountdown), for: .editingChanged)
        datePicker.addTarget(self, action: #selector(didUpdateCountdown), for: .valueChanged)
        
        return datePicker
    }()
    
    @objc private func didUpdateCountdown(_ sender: Any) {
        delegate?.willDismissKeyboard()
        delegate?.didUpdateDescriptionLabel()
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddReminderCountdownViewDelegate?
    
    var currentComponent: CountdownComponents {
        CountdownComponents(executionInterval: countdownDatePicker.countDownDuration)
    }
    
    var descriptionLabelText: String {
        return "Reminder will sound every \(countdownDatePicker.countDownDuration.readable(capitalizeWords: false, abbreviationLevel: .long)) then automatically restart"
    }
    
    // MARK: - Setup
    
    func setup(delegate: DogsAddReminderCountdownViewDelegate,
               components: CountdownComponents?) {
        self.delegate = delegate
        
        countdownDatePicker.countDownDuration = components?.executionInterval ??
        countdownDatePicker.countDownDuration
        delegate.didUpdateDescriptionLabel()
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(countdownDatePicker)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
    
        // countdownDatePicker
        NSLayoutConstraint.activate([
            countdownDatePicker.topAnchor.constraint(equalTo: topAnchor),
            countdownDatePicker.leadingAnchor.constraint(equalTo: leadingAnchor),
            countdownDatePicker.trailingAnchor.constraint(equalTo: trailingAnchor),
            countdownDatePicker.bottomAnchor.constraint(equalTo: bottomAnchor),
            countdownDatePicker.createHeightMultiplier(Constant.Constraint.Input.megaDatePickerHeightMultiplier, relativeToWidthOf: self),
            countdownDatePicker.createMaxHeight(Constant.Constraint.Input.megaDatePickerMaxHeight)
        ])
    }
    
}
//
//  DogsAddReminderManagerView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/28/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

enum DogsAddReminderDropDownTypes: String, HoundDropDownType {
    case reminderAction = "DropDownReminderAction"
    case reminderRecipients = "DropDownReminderRecipients"
    case reminderType = "DropDownReminderType"
    case reminderTimeZone = "DropDownReminderTimeZone"
}

final class DogsAddReminderManagerView: HoundView,
                                        UITextFieldDelegate,
                                        UIGestureRecognizerDelegate,
                                        DogsAddReminderCountdownViewDelegate,
                                        DogsAddReminderWeeklyViewDelegate,
                                        HoundDropDownDataSource,
                                        HoundDropDownManagerDelegate,
                                        DogsAddReminderMonthlyViewDelegate,
                                        DogsAddReminderOneTimeViewDelegate {
    
    // MARK: - DogsAddReminderCountdownViewDelegate, DogsAddReminderWeeklyViewDelegate, DogsAddReminderMonthlyViewDelegate, DogsAddReminderOneTimeViewDelegate
    
    func willDismissKeyboard() {
        dismissKeyboard()
    }
    
    func didUpdateDescriptionLabel() {
        updateReminderTypeDescriptionLabel()
    }
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        true
    }
    
    // MARK: - UITextFieldDelegate
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        dismissKeyboard()
        return false
    }
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        
        // attempt to read the range they are trying to change
        guard let currentText = textField.text, let stringRange = Range(range, in: currentText) else {
            return true
        }
        
        // add their new text to the existing text
        let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
        
        // make sure the result is under reminderCustomActionNameCharacterLimit
        return updatedText.count <= Constant.Class.Reminder.reminderCustomActionNameCharacterLimit
    }
    
    // MARK: - Elements
    
    private let reminderActionHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "Remind About"
        return label
    }()
    private lazy var reminderActionLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a reminder type..."
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: DogsAddReminderDropDownTypes.reminderAction,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .reminderAction, label: label, autoscroll: .firstOpen)
        
        return label
    }()
    private lazy var reminderIsEnabledSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 300, compressionResistancePriority: 300)
        uiSwitch.isOn = Constant.Class.Reminder.defaultReminderIsEnabled
        uiSwitch.addTarget(self, action: #selector(didToggleIsReminderEnabled), for: .valueChanged)
        return uiSwitch
    }()
    private lazy var reminderCustomActionNameTextField: HoundTextField = {
        let textField = HoundTextField()
        textField.delegate = self
        
        textField.applyStyle(.thinGrayBorder)
        textField.placeholder = "Add a custom name... (optional)"
        textField.shouldInsetText = true
        
        return textField
    }()
    private lazy var nestedReminderLabelStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(reminderActionLabel)
        
        // reminderIsEnabledSwitch needs an extra Constant.Constraint.Spacing.absoluteHoriInset before the end of the stack
        let extraPaddingAfterSwitch = HoundView()
        let paddedSwitchStack = HoundStackView(arrangedSubviews: [reminderIsEnabledSwitch, extraPaddingAfterSwitch])
        extraPaddingAfterSwitch.snp.makeConstraints { make in
            make.width.equalTo(Constant.Constraint.Spacing.absoluteHoriInset)
            make.height.equalTo(reminderIsEnabledSwitch.snp.height)
        }
        stack.addArrangedSubview(paddedSwitchStack)
        
        stack.axis = .horizontal
        stack.spacing = Constant.Constraint.Spacing.absoluteHoriInset
        stack.alignment = .center
        stack.distribution = .fill
        return stack
    }()
    private lazy var reminderActionStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(reminderActionHeaderLabel)
        
        let nestedStack = HoundStackView()
        nestedStack.addArrangedSubview(nestedReminderLabelStack)
        nestedStack.addArrangedSubview(reminderCustomActionNameTextField)
        nestedStack.axis = .vertical
        nestedStack.spacing = Constant.Constraint.Spacing.contentIntraVert
        
        stack.addArrangedSubview(nestedStack)
        
        return stack
    }()
    
    private let reminderRecipientsHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "Notify These People"
        return label
    }()
    private lazy var reminderRecipientsLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 295, compressionResistancePriority: 295)
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select family members... (optional)"
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: DogsAddReminderDropDownTypes.reminderRecipients,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .reminderRecipients, label: label, autoscroll: .firstOpen)
        return label
    }()
    private let notificationsDisabledLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        
        return label
    }()
    private lazy var nestedRecipientsLabelStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(reminderRecipientsLabel)
        stack.addArrangedSubview(notificationsDisabledLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    private lazy var reminderRecipientsStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(reminderRecipientsHeaderLabel)
        stack.addArrangedSubview(nestedRecipientsLabelStack)
        return stack
    }()
    
    private let reminderTypeHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "How Often"
        return label
    }()
    private lazy var reminderTypeLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: DogsAddReminderDropDownTypes.reminderType,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .reminderType, label: label, direction: .down, autoscroll: .firstOpen)
        return label
    }()
    private let reminderTypeDescriptionLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        return label
    }()
    private lazy var nestedReminderTypeStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(reminderTypeLabel)
        stack.addArrangedSubview(reminderTypeDescriptionLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    private lazy var reminderTypeStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(reminderTypeHeaderLabel)
        stack.addArrangedSubview(nestedReminderTypeStack)
        return stack
    }()
    
    private let timeZoneHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "Time Zone"
        return label
    }()
    private lazy var timeZoneLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a time zone..."
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: DogsAddReminderDropDownTypes.reminderTimeZone,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .reminderTimeZone, label: label, direction: .up, autoscroll: .firstOpen)
        return label
    }()
    private let timeZoneDisclaimerLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        return label
    }()
    private lazy var nestedTimeZoneStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(timeZoneLabel)
        stack.addArrangedSubview(timeZoneDisclaimerLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    private lazy var timeZoneStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(timeZoneHeaderLabel)
        stack.addArrangedSubview(nestedTimeZoneStack)
        return stack
    }()
    
    private let onceView = DogsAddReminderOneTimeView()
    private let countdownView = DogsAddReminderCountdownView()
    private let weeklyView = DogsAddReminderWeeklyView()
    private let monthlyView = DogsAddReminderMonthlyView()
    
    private lazy var reminderViewsStack: HoundStackView = {
        let stack = HoundStackView(arrangedSubviews: [onceView, countdownView, weeklyView, monthlyView])
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    
    private lazy var dropDownManager = HoundDropDownManager<DogsAddReminderDropDownTypes>(
        rootView: self,
        dataSource: self,
        delegate: self
    )
    
    @objc private func didToggleIsReminderEnabled(_ sender: HoundSwitch) {
        updateRecipientsLabel()
        updateDisclaimerLabel()
        if !reminderIsEnabledSwitch.isOn {
            let dropDown = dropDownManager.dropDown(for: .reminderRecipients)
            dropDown?.hideDropDown(animated: true)
        }
    }
    
    // MARK: - Properties
    
    private var reminderToUpdate: Reminder?
    private var initialReminder: Reminder?
    
    /// Options for the reminder action drop down consisting of base types and their previous custom names
    private var availableReminderActions: [(ReminderActionType, String?)] {
        var options: [(ReminderActionType, String?)] = []
        for type in GlobalTypes.shared.reminderActionTypes {
            options.append((type, nil))
            let matching = LocalConfiguration.localPreviousReminderCustomActionNames.filter { $0.reminderActionTypeId == type.reminderActionTypeId }
            for prev in matching {
                options.append((type, prev.reminderCustomActionName))
            }
        }
        return options
    }
    private var availableFamilyMembers: [FamilyMember] {
        FamilyInformation.familyMembers
    }
    private var availableReminderTypes: [ReminderType] {
        return ReminderType.allCases
    }
    private var availableTimeZones = Array(TimeZone.houndTimeZones.reversed())
    private(set) var selectedReminderAction: ReminderActionType? {
        didSet {
            reminderActionLabel.text = selectedReminderAction?.convertToReadableName(customActionName: nil, includeMatchingEmoji: true)
            
            let customActionNameIsHidden = selectedReminderAction?.allowsCustom != true
            if reminderCustomActionNameTextField.isHidden != customActionNameIsHidden {
                UIView.animate(withDuration: Constant.Visual.Animation.showOrHideSingleElement) {
                    self.reminderCustomActionNameTextField.isHidden = customActionNameIsHidden
                    self.remakeCustomActionNameConstraints()
                }
            }
        }
    }
    var selectedReminderActionIndexPath: IndexPath? {
        guard let selectedReminderAction = selectedReminderAction else { return nil }
        let mapped = availableReminderActions.enumerated().map { index, element -> (ReminderActionType, String?, Int) in
            return (element.0, element.1, index)
        }
        
        let matchingTypes = mapped.filter { type, _, _ in
            return type.reminderActionTypeId == selectedReminderAction.reminderActionTypeId
        }
        
        guard let first = matchingTypes.first else {
            return nil
        }
        
        // if we only find 1 match for a given reminder type, then there are no PreviousReminderCustomNames or in the mix, so the one availableReminderActions of type selectedReminderAction is our selected guy
        guard matchingTypes.count > 1 && (reminderCustomActionNameTextField.text?.hasText() ?? false) else {
            // first.2 is just the index of selectedReminderAction in availableReminderActions
            return IndexPath(row: first.2, section: 0)
        }
        
        // we have multiple of the same reminder type, so try to match based upon custom name
        let typesWithCustomNames = matchingTypes.filter { _, customName, _ in
            return customName?.hasText() ?? false
        }
        let typesWithoutCustomNames = matchingTypes.filter { _, customName, _ in
            return (customName?.hasText() ?? false) == false
        }
        
        for typesWithCustomName in typesWithCustomNames where reminderCustomActionNameTextField.text == typesWithCustomName.1 {
            // matched reminder type and custom name
            return IndexPath(row: typesWithCustomName.2, section: 0)
        }
        
        // no match, revert to just custom name only
        if let noName = typesWithoutCustomNames.first {
            return IndexPath(row: noName.2, section: 0)
        }
        return nil
    }
    private var selectedRecipientUserIds: Set<String> = []
    private var selectedReminderType: ReminderType = Constant.Class.Reminder.defaultReminderType {
        didSet {
            reminderTypeLabel.text = selectedReminderType.readable
            
            onceView.isHidden = selectedReminderType != ReminderType.oneTime
            countdownView.isHidden = selectedReminderType != ReminderType.countdown
            weeklyView.isHidden = selectedReminderType != ReminderType.weekly
            monthlyView.isHidden = selectedReminderType != ReminderType.monthly
            
            // hide if not any of the views that use TZ
            let timeZoneIsHidden = selectedReminderType != ReminderType.oneTime && selectedReminderType != ReminderType.weekly && selectedReminderType != ReminderType.monthly
            if timeZoneStack.isHidden != timeZoneIsHidden {
                timeZoneStack.isHidden = timeZoneIsHidden
                remakeTimeZoneConstraints()
            }
            
            updateReminderTypeDescriptionLabel()
        }
    }
    private var selectedTimeZone: TimeZone? {
        didSet {
            timeZoneLabel.text = selectedTimeZone?.displayName()
            
            if let selectedTimeZone = selectedTimeZone, selectedTimeZone.identifier != UserConfiguration.timeZone.identifier {
                let timeDiff = selectedTimeZone.secondsFromGMT() - UserConfiguration.timeZone.secondsFromGMT()
                var text = "Your device's time zone is \(UserConfiguration.timeZone.displayName())"
                if timeDiff != 0 {
                    text += " which is \(timeDiff.readable(abbreviationLevel: .short, maxComponents: 3, enforceSequentialComponents: true)) \(timeDiff >= 0 ? "behind" : "ahead")."
                }
                timeZoneDisclaimerLabel.text = text
            }
            else {
                timeZoneDisclaimerLabel.text = nil
            }
            timeZoneDisclaimerLabel.isHidden = timeZoneDisclaimerLabel.text == nil
        }
    }
    
    func constructReminder(showErrorIfFailed: Bool) -> Reminder? {
        guard let selectedReminderAction = selectedReminderAction else {
            if showErrorIfFailed {
                HapticsManager.notification(.error)
                reminderActionLabel.errorMessage = Constant.Error.ReminderError.reminderActionMissing
            }
            return nil
        }
        
        guard let reminder: Reminder = reminderToUpdate != nil ? reminderToUpdate?.copy() as? Reminder : Reminder() else {
            return nil
        }
        
        reminder.reminderActionTypeId = selectedReminderAction.reminderActionTypeId
        
        if selectedReminderAction.allowsCustom {
            // if the trimmedReminderCustomActionName is not "", meaning it has text, then we save it. Otherwise, the trimmedReminderCustomActionName is "" or nil so we save its value as nil
            reminder.reminderCustomActionName = reminderCustomActionNameTextField.text?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        }
        reminder.reminderIsEnabled = reminderIsEnabledSwitch.isOn
        reminder.reminderRecipientUserIds = Array(selectedRecipientUserIds)
        
        switch selectedReminderType {
        case .oneTime, .weekly, .monthly:
            guard let selectedTimeZone = selectedTimeZone else {
                   if showErrorIfFailed {
                       HapticsManager.notification(.error)
                       timeZoneLabel.errorMessage = Constant.Error.ReminderError.reminderTimeZoneMissing
                   }
                   return nil
               }
            
            reminder.reminderTimeZone = selectedTimeZone
        case .countdown:
            break
        }
        
        switch selectedReminderType {
        case .oneTime:
            reminder.changeReminderType(.oneTime)
            reminder.oneTimeComponents.oneTimeDate = onceView.currentComponent.oneTimeDate
        case .countdown:
            reminder.changeReminderType(.countdown)
            reminder.countdownComponents.executionInterval = countdownView.currentComponent.executionInterval
        case .weekly:
            reminder.changeReminderType(.weekly)
            guard let component = weeklyView.currentComponent else {
                if showErrorIfFailed {
                    HapticsManager.notification(.error)
                    weeklyView.weekdayStack.errorMessage = Constant.Error.WeeklyComponentsError.weekdaysInvalid
                }
                return nil
            }
            reminder.weeklyComponents.zonedHour = component.zonedHour
            reminder.weeklyComponents.zonedMinute = component.zonedMinute
            _ = reminder.weeklyComponents.setZonedWeekdays(component.zonedWeekdays)
        case .monthly:
            reminder.changeReminderType(.monthly)
            let component = monthlyView.currentComponent
            reminder.monthlyComponents.apply(from: component)
        }
        
        // Check if we are updating a reminder
        guard let reminderToUpdate = reminderToUpdate else {
            // Not updating an existing reminder, therefore created a reminder and prepare it for use
            reminder.resetForNextAlarm()
            return reminder
        }
        
        // Updating an existing reminder
        
        // Checks for differences in time of day, execution interval, weekdays, or time of month. If one is detected then we reset the reminder's whole timing to default
        // If you were 5 minutes in to a 1 hour countdown but then change it to 30 minutes, you would want to be 0 minutes into the new timer and not 5 minutes in like previously.
        switch reminder.reminderType {
        case .oneTime:
            if !reminder.oneTimeComponents.isSame(as: reminderToUpdate.oneTimeComponents) {
                reminder.resetForNextAlarm()
            }
        case .countdown:
            if !reminder.countdownComponents.isSame(as: reminderToUpdate.countdownComponents) {
                reminder.resetForNextAlarm()
            }
        case .weekly:
            if !reminder.weeklyComponents.isSame(as: reminderToUpdate.weeklyComponents) {
                reminder.resetForNextAlarm()
            }
        case .monthly:
            if !reminder.monthlyComponents.isSame(as: reminderToUpdate.monthlyComponents) {
                reminder.resetForNextAlarm()
            }
        }
        
        return reminder
    }
    
    var didUpdateInitialValues: Bool {
        guard let initialReminder = initialReminder else {
            // creating new reminder right now, so return true
            return true
        }
        
        guard let newReminder = constructReminder(showErrorIfFailed: false) else {
            // new reminder has invalid settings so show warning abt exiting
            // we have an initialReminder, so user HAS to be editing, and if newReminder couldn't be saved then user input an invalid setting
            return false
        }
        
        return !initialReminder.isSame(as: newReminder)
    }
    
    // MARK: - Setup
    
    func setup(reminderToUpdate: Reminder?) {
        self.reminderToUpdate = reminderToUpdate
        initialReminder = reminderToUpdate?.copy() as? Reminder
        
        // reminderActionLabel
        selectedReminderAction = reminderToUpdate?.reminderActionType
        
        // reminderCustomActionNameTextField
        reminderCustomActionNameTextField.text = reminderToUpdate?.reminderCustomActionName
        
        // reminderIsEnabledSwitch
        reminderIsEnabledSwitch.isOn = reminderToUpdate?.reminderIsEnabled ?? reminderIsEnabledSwitch.isOn
        selectedRecipientUserIds = Set(reminderToUpdate?.reminderRecipientUserIds ?? FamilyInformation.familyMembers.map { $0.userId })
        updateRecipientsLabel()
        updateDisclaimerLabel()
        
        // reminderTypeLabel
        selectedReminderType = reminderToUpdate?.reminderType ?? Constant.Class.Reminder.defaultReminderType
        
        let timeZone = reminderToUpdate?.reminderTimeZone ?? UserConfiguration.timeZone
        selectedTimeZone = timeZone
        
        // onceView
        if reminderToUpdate?.reminderType == .oneTime {
            let date = Date().distance(to: reminderToUpdate?.oneTimeComponents.oneTimeDate ?? Date()) > 0 ?
            reminderToUpdate?.oneTimeComponents.oneTimeDate : nil
            onceView.setup(
                delegate: self,
                components: date != nil ? OneTimeComponents(oneTimeDate: date) : nil,
                timeZone: timeZone
            )
        }
        else {
            onceView.setup(delegate: self, components: nil, timeZone: timeZone)
        }
        
        // countdownView
        if reminderToUpdate?.reminderType == .countdown {
            countdownView.setup(
                delegate: self,
                components: reminderToUpdate?.countdownComponents
            )
        }
        else {
            countdownView.setup(delegate: self, components: nil)
        }
        
        // weeklyView
        if reminderToUpdate?.reminderType == .weekly {
            weeklyView.setup(
                delegate: self,
                components: reminderToUpdate?.weeklyComponents,
                timeZone: timeZone
            )
        }
        else {
            weeklyView.setup(delegate: self, components: nil, timeZone: timeZone)
        }
        
        // monthlyView
        if reminderToUpdate?.reminderType == .monthly {
            monthlyView.setup(
                delegate: self,
                components: reminderToUpdate?.monthlyComponents,
                timeZone: timeZone
            )
        }
        else {
            monthlyView.setup(delegate: self, components: nil, timeZone: timeZone)
        }
    }
    
    // MARK: - Functions
    
    @objc override func dismissKeyboard() {
        super.dismissKeyboard()
        endEditing(true)
    }
    
    private func updateRecipientsLabel() {
        reminderRecipientsLabel.isEnabled = reminderIsEnabledSwitch.isOn
        if selectedRecipientUserIds.isEmpty {
            reminderRecipientsLabel.text = nil
        }
        else if selectedRecipientUserIds.count == 1, let userId = selectedRecipientUserIds.first, userId == UserInformation.userId {
            reminderRecipientsLabel.text = "Me"
        }
        else if selectedRecipientUserIds.count == 1, let userId = selectedRecipientUserIds.first {
            reminderRecipientsLabel.text = FamilyInformation.findFamilyMember(userId: userId)?.displayFullName ?? Constant.Visual.Text.unknownName
        }
        else if  selectedRecipientUserIds.count == FamilyInformation.familyMembers.count {
            reminderRecipientsLabel.text = "Everyone"
        }
        else {
            reminderRecipientsLabel.text = "Multiple"
        }
    }
    private func updateDisclaimerLabel() {
        let reminderEnabled = reminderIsEnabledSwitch.isOn
        let userIsRecipient = selectedRecipientUserIds.contains(UserInformation.userId ?? Constant.Visual.Text.unknownUserId)
        let hasRecipients = !selectedRecipientUserIds.isEmpty
        let shouldShowDisclaimer =
            !reminderEnabled ||
            !userIsRecipient ||
            (hasRecipients && !UserConfiguration.isNotificationEnabled) ||
            (hasRecipients && !UserConfiguration.isReminderNotificationEnabled)
        
        notificationsDisabledLabel.isHidden = !shouldShowDisclaimer
        
        notificationsDisabledLabel.attributedText = {
            let message = NSMutableAttributedString()
            if !reminderEnabled {
                message.append(NSAttributedString(
                    string: "Your reminder is currently ",
                    attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
                ))
                message.append(NSAttributedString(
                    string: "off",
                    attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel]
                ))
                message.append(NSAttributedString(
                    string: ", so no alarms will sound.",
                    attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
                ))
            }
            else if !userIsRecipient {
                message.append(NSAttributedString(
                    string: "You're ",
                    attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
                ))
                message.append(NSAttributedString(
                    string: "not",
                    attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel]
                ))
                message.append(NSAttributedString(
                    string: " a recipient for this reminder, so you won't be notified.",
                    attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
                ))
            }
            else if !UserConfiguration.isNotificationEnabled {
                message.append(NSAttributedString(
                    string: "Your notifications are ",
                    attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
                ))
                message.append(NSAttributedString(
                    string: "disabled",
                    attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel]
                ))
                message.append(NSAttributedString(
                    string: ", so you won't receive any push notifications (you can change this in Hound's settings).",
                    attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
                ))
            }
            else if !UserConfiguration.isReminderNotificationEnabled {
                message.append(NSAttributedString(
                    string: "Your reminder notifications are ",
                    attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
                ))
                message.append(NSAttributedString(
                    string: "disabled",
                    attributes: [.font: Constant.Visual.Font.emphasizedSecondaryColorDescLabel]
                ))
                message.append(NSAttributedString(
                    string: ", so you won’t get push notifications for reminders (you can change this in Hound's settings).",
                    attributes: [.font: Constant.Visual.Font.secondaryColorDescLabel]
                ))
            }
            return message
        }()
    }
    private func updateReminderTypeDescriptionLabel() {
        switch selectedReminderType {
        case .oneTime:
            reminderTypeDescriptionLabel.text = onceView.descriptionLabelText
        case .countdown:
            reminderTypeDescriptionLabel.text = countdownView.descriptionLabelText
        case .weekly:
            reminderTypeDescriptionLabel.text = nil
        case .monthly:
            reminderTypeDescriptionLabel.text = monthlyView.descriptionLabelText
        }
        reminderTypeDescriptionLabel.isHidden = reminderTypeDescriptionLabel.text == nil
    }
    
    // MARK: - Drop Down Handling
    
    @objc func didTapScreen(sender: UITapGestureRecognizer) {
        dropDownManager.hideDropDownIfNotTapped(sender: sender)
        if let senderView = sender.view {
            let point = sender.location(in: senderView)
            if let deepestTouchedView = senderView.hitTest(point, with: nil), !deepestTouchedView.isDescendant(of: reminderCustomActionNameTextField) {
                dismissKeyboard()
            }
        }
    }
    
    /// Determine and show the next required dropdown in the log creation flow
    private func showNextRequiredDropDown(animated: Bool) {
        if selectedReminderAction == nil {
            willShowDropDown(DogsAddReminderDropDownTypes.reminderAction, animated: animated)
        }
    }
    
    func willShowDropDown(_ identifier: any HoundDropDownType, animated: Bool) {
        guard let type = identifier as? DogsAddReminderDropDownTypes else { return }
        
        let numberOfRows: CGFloat = {
            switch type {
            case .reminderAction:
                return CGFloat(availableReminderActions.count)
            case .reminderRecipients:
                return CGFloat(availableFamilyMembers.count)
            case .reminderType:
                return CGFloat(availableReminderTypes.count)
            case .reminderTimeZone:
                return CGFloat(availableTimeZones.count)
            }
        }()
        
        dropDownManager.show(
            identifier: type,
            numberOfRowsToShow: min(6.5, numberOfRows),
            animated: animated
        )
    }
    
    // MARK: - Drop Down Data Source
    
    func setupCellForDropDown(cell: HoundDropDownTVC, indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let identifier = identifier as? DogsAddReminderDropDownTypes else { return }
        
        switch identifier {
        case .reminderAction:
            let option = availableReminderActions[indexPath.row]
            if let selectedReminderActionIndexPath = selectedReminderActionIndexPath {
                cell.setCustomSelected(selectedReminderActionIndexPath == indexPath, animated: false)
            }
            else {
                cell.setCustomSelected(false, animated: false)
            }
            cell.label.text = option.0.convertToReadableName(customActionName: option.1, includeMatchingEmoji: true)
        case .reminderRecipients:
            let member = availableFamilyMembers[indexPath.row]
            cell.setCustomSelected(selectedRecipientUserIds.contains(member.userId), animated: false)
            cell.label.text = member.displayFullName ?? Constant.Visual.Text.unknownName
        case .reminderType:
            let type = availableReminderTypes[indexPath.row]
            cell.setCustomSelected(selectedReminderType == type, animated: false)
            cell.label.text = type.readable
        case .reminderTimeZone:
            let tz = availableTimeZones[indexPath.row]
            cell.setCustomSelected(selectedTimeZone?.identifier == tz.identifier, animated: false)
            cell.label.text = tz.displayName(currentTimeZone: UserConfiguration.timeZone)
        }
    }
    
    func numberOfRows(section: Int, identifier: any HoundDropDownType) -> Int {
        guard let identifier = identifier as? DogsAddReminderDropDownTypes else {
            return 0
        }
        
        switch identifier {
        case DogsAddReminderDropDownTypes.reminderAction:
            return availableReminderActions.count
        case DogsAddReminderDropDownTypes.reminderRecipients:
            return availableFamilyMembers.count
        case DogsAddReminderDropDownTypes.reminderType:
            return availableReminderTypes.count
        case DogsAddReminderDropDownTypes.reminderTimeZone:
            return availableTimeZones.count
        }
    }
    
    func numberOfSections(identifier: any HoundDropDownType) -> Int {
        return 1
    }
    
    func selectItemInDropDown(indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let identifier = identifier as? DogsAddReminderDropDownTypes else { return }
        guard let dropDown = dropDownManager.dropDown(for: identifier), let cell = dropDown.dropDownTableView?.cellForRow(at: indexPath) as? HoundDropDownTVC else { return }
  
        switch identifier {
        case .reminderAction:
            guard !cell.isCustomSelected else {
                cell.setCustomSelected(false)
                selectedReminderAction = nil
                return
            }
            
            if let previouslySelectedReminderActionIndexPath = selectedReminderActionIndexPath {
                let previousSelectedCell = dropDown.dropDownTableView?.cellForRow(at: previouslySelectedReminderActionIndexPath) as? HoundDropDownTVC
                previousSelectedCell?.setCustomSelected(false)
            }
            
            cell.setCustomSelected(true)
            
            let option = availableReminderActions[indexPath.row]
            selectedReminderAction = option.0
            reminderCustomActionNameTextField.text = option.1
            
            reminderActionLabel.errorMessage = nil
            
            dropDown.hideDropDown(animated: true)
            
            showNextRequiredDropDown(animated: true)
        case .reminderRecipients:
            let member = availableFamilyMembers[indexPath.row]
            
            if cell.isCustomSelected {
                selectedRecipientUserIds.remove(member.userId)
            }
            else {
                selectedRecipientUserIds.insert(member.userId)
            }
            cell.setCustomSelected(!cell.isCustomSelected)
            
            // If no one selected, close
            // If all ppl selected, close dropdown
            if selectedRecipientUserIds.isEmpty || selectedRecipientUserIds.count == availableFamilyMembers.count {
                dropDown.hideDropDown(animated: true)
            }
            
            // recipient label text changes and disclaimer label maybe appears/disappears
            updateRecipientsLabel()
            updateDisclaimerLabel()
        case .reminderType:
            let type = availableReminderTypes[indexPath.row]
            
            // prevent deselectiong of reminder type. we shuld always have one selected
            guard type != selectedReminderType else {
                return
            }
            
            cell.setCustomSelected(true)
            selectedReminderType = type
            dropDown.hideDropDown(animated: true)
        case .reminderTimeZone:
            guard !cell.isCustomSelected else {
                cell.setCustomSelected(false)
                selectedTimeZone = nil
                return
            }
            
            if let selectedTimeZone = selectedTimeZone,
               let previouslySelectedIndexPath = availableTimeZones.firstIndex(of: selectedTimeZone),
               let previousSelectedCell = dropDown.dropDownTableView?.cellForRow(at: IndexPath(row: previouslySelectedIndexPath, section: 0)) as? HoundDropDownTVC {
                previousSelectedCell.setCustomSelected(false)
            }
            
            cell.setCustomSelected(true)
            
            let timeZone = availableTimeZones[indexPath.row]
            selectedTimeZone = timeZone
            
            timeZoneLabel.errorMessage = nil
            
            onceView.updateDisplayedTimeZone(timeZone)
            // nothing for countdown view
            weeklyView.updateDisplayedTimeZone(timeZone)
            monthlyView.updateDisplayedTimeZone(timeZone)
            
            dropDown.hideDropDown(animated: true)
        }
    }
    
    func firstSelectedIndexPath(identifier: any HoundDropDownType) -> IndexPath? {
            guard let identifier = identifier as? DogsAddReminderDropDownTypes else { return nil }
            switch identifier {
            case .reminderAction:
                return selectedReminderActionIndexPath
            case .reminderRecipients:
                if let idx = selectedRecipientUserIds
                    .compactMap({ userId in availableFamilyMembers.firstIndex(where: { $0.userId == userId }) })
                    .min() {
                    return IndexPath(row: idx, section: 0)
                }
            case .reminderType:
                if let idx = availableReminderTypes.firstIndex(of: selectedReminderType) {
                    return IndexPath(row: idx, section: 0)
                }
            case .reminderTimeZone:
                if let selectedTZ = selectedTimeZone,
                   let idx = availableTimeZones.firstIndex(where: { tz in
                       return tz.identifier == selectedTZ.identifier
                   }) {
                    return IndexPath(row: idx, section: 0)
                }
            }
            return nil
        }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(reminderActionStack)
        addSubview(reminderRecipientsStack)
        addSubview(reminderTypeStack)
        addSubview(reminderViewsStack)
        addSubview(timeZoneStack)
        
        let didTapScreenGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapScreen(sender:))
        )
        didTapScreenGesture.delegate = self
        didTapScreenGesture.cancelsTouchesInView = false
        addGestureRecognizer(didTapScreenGesture)
    }
    
    private func remakeCustomActionNameConstraints() {
        reminderCustomActionNameTextField.snp.makeConstraints { make in
            if !reminderCustomActionNameTextField.isHidden {
                make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
            }
        }
    }
    
    private func remakeTimeZoneConstraints() {
        let shouldHideTimeZone = timeZoneLabel.isHidden || timeZoneStack.isHidden
        
        // they might conflict in the process of updating
        reminderViewsStack.snp.removeConstraints()
        timeZoneStack.snp.removeConstraints()
        timeZoneLabel.snp.removeConstraints()
        
        reminderViewsStack.snp.remakeConstraints { make in
            make.top.equalTo(reminderTypeStack.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.leading.equalToSuperview().offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset)
            if shouldHideTimeZone {
                make.bottom.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteVertInset)
            }
        }
        
        timeZoneStack.snp.remakeConstraints { make in
            if !shouldHideTimeZone {
                make.top.equalTo(reminderViewsStack.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
                make.bottom.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteVertInset)
                make.leading.equalToSuperview().offset(Constant.Constraint.Spacing.absoluteHoriInset)
                make.trailing.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset)
            }
        }
        
        timeZoneLabel.snp.remakeConstraints { make in
            if !shouldHideTimeZone {
                make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
            }
        }
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        reminderActionStack.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.leading.equalToSuperview().offset(Constant.Constraint.Spacing.absoluteHoriInset)
            // add extra inset for the switch inside
            make.trailing.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        }
        reminderActionLabel.snp.makeConstraints { make in
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        remakeCustomActionNameConstraints()
        
        reminderRecipientsStack.snp.makeConstraints { make in
            make.top.equalTo(reminderActionStack.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.leading.equalToSuperview().offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        reminderRecipientsLabel.snp.makeConstraints { make in
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        
        reminderTypeStack.snp.makeConstraints { make in
            make.top.equalTo(reminderRecipientsStack.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.leading.equalToSuperview().offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        reminderTypeLabel.snp.makeConstraints { make in
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        
        remakeTimeZoneConstraints()
    }
    
}
//
//  DogsAddReminderWeeklyVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/28/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddReminderWeeklyViewDelegate: AnyObject {
    func willDismissKeyboard()
}

final class DogsAddReminderWeeklyView: HoundView {
    
    // MARK: - Elements
    
    lazy var weekdayStack: HoundStackView = {
        let stack = HoundStackView()
        weekdayButtons.forEach { button in
            stack.addArrangedSubview(button)
        }
        stack.axis = .horizontal
        stack.alignment = .center
        stack.distribution = .equalSpacing
        return stack
    }()
    
    private lazy var sundayButton: HoundButton = {
        let button = HoundButton()
        button.setImage(UIImage(systemName: "s.circle.fill"), for: .normal)
        applyWeekdayButtonStyle(button)
        return button
    }()
    
    private lazy var mondayButton: HoundButton = {
        let button = HoundButton()
        button.setImage(UIImage(systemName: "m.circle.fill"), for: .normal)
        applyWeekdayButtonStyle(button)
        return button
    }()
    
    private lazy var tuesdayButton: HoundButton = {
        let button = HoundButton()
        button.setImage(UIImage(systemName: "t.circle.fill"), for: .normal)
        applyWeekdayButtonStyle(button)
        return button
    }()
    
    private lazy var wednesdayButton: HoundButton = {
        let button = HoundButton()
        button.setImage(UIImage(systemName: "w.circle.fill"), for: .normal)
        applyWeekdayButtonStyle(button)
        return button
    }()
    
    private lazy var thursdayButton: HoundButton = {
        let button = HoundButton()
        button.setImage(UIImage(systemName: "t.circle.fill"), for: .normal)
        applyWeekdayButtonStyle(button)
        return button
    }()
    
    private lazy var fridayButton: HoundButton = {
        let button = HoundButton()
        button.setImage(UIImage(systemName: "f.circle.fill"), for: .normal)
        applyWeekdayButtonStyle(button)
        return button
    }()
    
    private lazy var saturdayButton: HoundButton = {
        let button = HoundButton()
        button.setImage(UIImage(systemName: "s.circle.fill"), for: .normal)
        applyWeekdayButtonStyle(button)
        return button
    }()
    
    private lazy var timeOfDayDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker(huggingPriority: 240, compressionResistancePriority: 240)
        datePicker.datePickerMode = .time
        datePicker.minuteInterval = Constant.Development.minuteInterval
        datePicker.preferredDatePickerStyle = .wheels
        
        datePicker.date = Date.roundDate(targetDate: Date(), roundingInterval: Double(60 * datePicker.minuteInterval), roundingMethod: .up)
        
        datePicker.addTarget(self, action: #selector(didUpdateTimeOfDay), for: .valueChanged)
        
        return datePicker
    }()
    
    @objc private func didToggleWeekdayButton(_ sender: Any) {
        delegate?.willDismissKeyboard()
        
        guard let senderButton = sender as? HoundButton else { return }
        
        senderButton.isUserInteractionEnabled = false
        UIView.animate(withDuration: Constant.Visual.Animation.selectSingleElement) {
            if senderButton.tag == Constant.Visual.ViewTag.weekdayEnabled {
                self.disableWeekdayButton(senderButton)
            }
            else {
                self.enabledWeekdayButton(senderButton)
            }
        } completion: { _ in
            senderButton.isUserInteractionEnabled = true
        }
        
        if !currentWeekdays.isEmpty {
            weekdayStack.errorMessage = nil
        }
    }
    
    @objc private func didUpdateTimeOfDay(_ sender: Any) {
        delegate?.willDismissKeyboard()
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddReminderWeeklyViewDelegate?
    
    private(set) var currentTimeZone: TimeZone = .current
    
    private var weekdayButtons: [HoundButton] {
        return [sundayButton, mondayButton, tuesdayButton, wednesdayButton, thursdayButton, fridayButton, saturdayButton]
    }
    
    private var currentWeekdays: [Weekday] {
        var days: [Weekday] = []
        
        weekdayButtons.forEach { button in
            guard button.tag == Constant.Visual.ViewTag.weekdayEnabled else {
                return
            }
            
            days.append(valueForWeekdayButton(button))
        }
        
        return days
    }
    
    /// The weekly component represented by the current UI state.
    var currentComponent: WeeklyComponents? {
        guard !currentWeekdays.isEmpty else { return nil }
        let calendar = Calendar.fromZone(currentTimeZone)
        let comps = calendar.dateComponents([.hour, .minute], from: timeOfDayDatePicker.date)
        let hour = comps.hour ?? Constant.Class.ReminderComponent.defaultZonedHour
        let minute = comps.minute ?? Constant.Class.ReminderComponent.defaultZonedMinute
        
        let component = WeeklyComponents(zonedHour: hour, zonedMinute: minute)
        _ = component.setZonedWeekdays(currentWeekdays)
        return component
    }
    
    // MARK: - Setup
    
    func setup(
        delegate: DogsAddReminderWeeklyViewDelegate,
        components: WeeklyComponents?,
        timeZone: TimeZone
    ) {
        self.delegate = delegate
        currentTimeZone = timeZone
        timeOfDayDatePicker.timeZone = timeZone
        
        if let components = components {
            let calendar = Calendar.fromZone(currentTimeZone)
            var dateComponents = calendar.dateComponents([.year, .month, .day], from: Date())
            dateComponents.hour = components.zonedHour
            dateComponents.minute = components.zonedMinute
            dateComponents.second = 0
            dateComponents.timeZone = timeZone
            timeOfDayDatePicker.date = calendar.date(from: dateComponents) ?? timeOfDayDatePicker.date
            
            weekdayButtons.forEach { button in
                let value = valueForWeekdayButton(button)
                if components.zonedWeekdays.contains(value) {
                    enabledWeekdayButton(button)
                }
                else {
                    disableWeekdayButton(button)
                }
            }
            
        }
        else {
            weekdayButtons.forEach { enabledWeekdayButton($0) }
        }
    }
    
    func updateDisplayedTimeZone(_ newTimeZone: TimeZone) {
        guard newTimeZone != currentTimeZone else { return }
        
        let calendar = Calendar.fromZone(currentTimeZone)
        let oldComps = calendar.dateComponents([.year, .month, .day, .hour, .minute], from: timeOfDayDatePicker.date)
        let day = oldComps.day ?? 1
        let hour = oldComps.hour ?? 0
        let minute = oldComps.minute ?? 0
        
        let converted = currentTimeZone.convert(
            day: day,
            hour: hour,
            minute: minute,
            to: newTimeZone,
            referenceDate: timeOfDayDatePicker.date
        )
        
        var newComps = DateComponents()
        newComps.year = oldComps.year
        newComps.month = oldComps.month
        newComps.day = converted.day
        newComps.hour = converted.hour
        newComps.minute = converted.minute
        newComps.second = 0
        newComps.timeZone = newTimeZone
        
        if let newDate = calendar.date(from: newComps) {
            timeOfDayDatePicker.timeZone = newTimeZone
            timeOfDayDatePicker.date = newDate
        }
        
        let newWeekdays = currentTimeZone.convert(
            weekdays: currentWeekdays,
            hour: hour,
            minute: minute,
            to: newTimeZone,
            referenceDate: timeOfDayDatePicker.date
        )
        weekdayButtons.forEach { button in
            let value = valueForWeekdayButton(button)
            if newWeekdays.contains(value) {
                enabledWeekdayButton(button)
            }
            else {
                disableWeekdayButton(button)
            }
        }
        
        currentTimeZone = newTimeZone
    }
    
    // MARK: - Functions
    
    private func applyWeekdayButtonStyle(_ button: HoundButton) {
        button.backgroundCircleTintColor = UIColor.systemBackground
        disableWeekdayButton(button)
        button.addTarget(self, action: #selector(didToggleWeekdayButton), for: .touchUpInside)
    }
    private func enabledWeekdayButton(_ button: HoundButton) {
        button.tag = Constant.Visual.ViewTag.weekdayEnabled
        button.tintColor = UIColor.systemBlue
    }
    private func disableWeekdayButton(_ button: HoundButton) {
        button.tag = Constant.Visual.ViewTag.weekdayDisabled
        button.tintColor = UIColor.systemGray4
    }
    private func valueForWeekdayButton(_ button: HoundButton) -> Weekday {
        switch button {
        case sundayButton: return .sunday
        case mondayButton: return .monday
        case tuesdayButton: return .tuesday
        case wednesdayButton: return .wednesday
        case thursdayButton: return .thursday
        case fridayButton: return .friday
        case saturdayButton: return .saturday
        default: fatalError("DogsAddReminderWeeklyView.valueForWeekdayButton: Unrecognized weekday button")
        }
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(weekdayStack)
        addSubview(timeOfDayDatePicker)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // weekdayStack
        NSLayoutConstraint.activate([
            weekdayStack.topAnchor.constraint(equalTo: topAnchor),
            weekdayStack.leadingAnchor.constraint(equalTo: leadingAnchor),
            weekdayStack.trailingAnchor.constraint(equalTo: trailingAnchor)
        ])
        
        // weekdayButtons
        weekdayButtons.forEach { button in
            NSLayoutConstraint.activate([
                button.createSquareAspectRatio(),
                button.createHeightMultiplier(Constant.Constraint.Button.circleHeightMultiplier, relativeToWidthOf: self),
                button.createMaxHeight(Constant.Constraint.Button.circleMaxHeight)
            ])
        }
        
        // timeOfDayDatePicker
        NSLayoutConstraint.activate([
            timeOfDayDatePicker.topAnchor.constraint(equalTo: weekdayStack.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            timeOfDayDatePicker.bottomAnchor.constraint(equalTo: bottomAnchor),
            timeOfDayDatePicker.leadingAnchor.constraint(equalTo: leadingAnchor),
            timeOfDayDatePicker.trailingAnchor.constraint(equalTo: trailingAnchor),
            timeOfDayDatePicker.createHeightMultiplier(Constant.Constraint.Input.megaDatePickerHeightMultiplier, relativeToWidthOf: self),
            timeOfDayDatePicker.createMaxHeight(Constant.Constraint.Input.megaDatePickerMaxHeight)
        ])
    }
    
}
//
//  DogsAddReminderOneTimeVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/30/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddReminderOneTimeViewDelegate: AnyObject {
    func willDismissKeyboard()
    func didUpdateDescriptionLabel()
}

final class DogsAddReminderOneTimeView: HoundView {
    
    // MARK: - Elements
    
    private lazy var oneTimeDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker(huggingPriority: 240, compressionResistancePriority: 260)
        datePicker.datePickerMode = .dateAndTime
        datePicker.preferredDatePickerStyle = .wheels
        datePicker.minuteInterval = Constant.Development.minuteInterval
        
        datePicker.date = Date.roundDate(targetDate: Date(), roundingInterval: Double(60 * datePicker.minuteInterval), roundingMethod: .up)
        
        // they can't choose a one time alarm that isn't in the future, otherwise there is no point
        datePicker.minimumDate = Date.roundDate(targetDate: Date(), roundingInterval: Double(60 * datePicker.minuteInterval), roundingMethod: .up)
        
        datePicker.addTarget(self, action: #selector(didUpdateOneTimeDatePicker), for: .valueChanged)
        
        return datePicker
    }()
    
    @objc private func didUpdateOneTimeDatePicker(_ sender: Any) {
        delegate?.didUpdateDescriptionLabel()
        delegate?.willDismissKeyboard()
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddReminderOneTimeViewDelegate?
    private(set) var currentTimeZone: TimeZone = .current
    
    private var oneTimeDate: Date {
        oneTimeDatePicker.date
    }
    
    /// One-time component represented by the current UI state.
    var currentComponent: OneTimeComponents {
        OneTimeComponents(oneTimeDate: oneTimeDate)
    }
    
    var descriptionLabelText: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        formatter.timeStyle = .short
        formatter.timeZone = currentTimeZone
        let dateString = formatter.string(from: oneTimeDatePicker.date)
        return "Reminder will sound once on \(dateString) then automatically delete"
    }
    
    // MARK: - Setup
    
    func setup(
        delegate: DogsAddReminderOneTimeViewDelegate,
        components: OneTimeComponents?,
        timeZone: TimeZone
    ) {
        self.delegate = delegate
        currentTimeZone = timeZone
        oneTimeDatePicker.timeZone = timeZone
        if let date = components?.oneTimeDate {
            oneTimeDatePicker.date = date
        }
        delegate.didUpdateDescriptionLabel()
    }
    
    // MARK: - Time Zone
    
    func updateDisplayedTimeZone(_ newTimeZone: TimeZone) {
        guard newTimeZone != currentTimeZone else { return }
        
        currentTimeZone = newTimeZone
        oneTimeDatePicker.timeZone = newTimeZone
        delegate?.didUpdateDescriptionLabel()
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(oneTimeDatePicker)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // oneTimeDatePicker
        NSLayoutConstraint.activate([
            oneTimeDatePicker.topAnchor.constraint(equalTo: topAnchor),
            oneTimeDatePicker.leadingAnchor.constraint(equalTo: leadingAnchor),
            oneTimeDatePicker.trailingAnchor.constraint(equalTo: trailingAnchor),
            oneTimeDatePicker.bottomAnchor.constraint(equalTo: bottomAnchor),
            oneTimeDatePicker.createHeightMultiplier(Constant.Constraint.Input.megaDatePickerHeightMultiplier, relativeToWidthOf: self),
            oneTimeDatePicker.createMaxHeight(Constant.Constraint.Input.megaDatePickerMaxHeight)
        ])
    }
    
}
//
//  DogsAddTriggerVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/8/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddTriggerVCDelegate: AnyObject {
    func didAddTrigger(sender: Sender, dogUUID: UUID?, trigger: Trigger)
    func didUpdateTrigger(sender: Sender, dogUUID: UUID?, trigger: Trigger)
    func didRemoveTrigger(sender: Sender, dogUUID: UUID?, triggerUUID: UUID)
}

final class DogsAddTriggerVC: HoundScrollViewController {
    
    // MARK: - Elements
    
    private lazy var editPageHeaderView: HoundEditPageHeaderView = {
        let view = HoundEditPageHeaderView(huggingPriority: 330, compressionResistancePriority: 330)
        view.leadingButton.setImage(UIImage(systemName: "doc.circle"), for: .normal)
        view.leadingButton.addTarget(self, action: #selector(didTouchUpInsideDuplicateTrigger), for: .touchUpInside)
        
        view.trailingButton.setImage(UIImage(systemName: "trash.circle"), for: .normal)
        view.trailingButton.addTarget(self, action: #selector(didTouchUpInsideRemoveTrigger), for: .touchUpInside)
        
        return view
    }()
    
    private let managerView: DogsAddTriggerManagerView = {
        let view = DogsAddTriggerManagerView(huggingPriority: 320, compressionResistancePriority: 320)
        return view
    }()
    
    private lazy var saveButton: HoundButton = {
        let button = HoundButton(huggingPriority: 350, compressionResistancePriority: 350)
        button.tintColor = UIColor.systemBlue
        button.setImage(UIImage(systemName: "checkmark.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBackground
        button.addTarget(self, action: #selector(didTouchUpInsideSaveTrigger), for: .touchUpInside)
        return button
    }()
    
    private lazy var backButton: HoundButton = {
        let button = HoundButton(huggingPriority: 340, compressionResistancePriority: 340)
        button.tintColor = UIColor.systemGray2
        button.setImage(UIImage(systemName: "arrow.backward.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBackground
        button.addTarget(self, action: #selector(didTouchUpInsideBack), for: .touchUpInside)
        return button
    }()
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddTriggerVCDelegate?
    /// This variable is not solely based upon the existance of self.dog. If it is true, then dog MUST be provided. However, dog can be provided and this can be false (e.g. DogsAddDogVC it editing a dog and opens this menu to add/edit a trigger. It doesn't want server persistence, but it does have a dog set).
    private var shouldPersistChangesToServer: Bool = false
    private var dog: Dog?
    private var triggerToUpdate: Trigger?
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        
        let saveButtonTop = saveButton.convert(saveButton.bounds, to: view).minY
        let backButtonTop = backButton.convert(backButton.bounds, to: view).minY
        let buttonTop = min(saveButtonTop, backButtonTop)
        
        let distanceFromBottom = view.bounds.height - buttonTop
        
        let minInset = distanceFromBottom + Constant.Constraint.Spacing.absoluteVertInset
        
        scrollView.contentInset.bottom = max(scrollView.contentInset.bottom, minInset)
    }
    
    // MARK: - Setup
    
    /// Changes made by this view controller will not be persisted to the server, and will only be used locally. Dog is optional
    func setupWithoutServerPersistence(delegate: DogsAddTriggerVCDelegate, dog: Dog?, triggerToUpdate: Trigger?) {
        shouldPersistChangesToServer = false
        commonSetup(delegate: delegate, dog: dog, triggerToUpdate: triggerToUpdate)
    }
    
    /// Changes made by this view controller will be persisted to the server. Dog is required
    func setupWithServerPersistence(delegate: DogsAddTriggerVCDelegate, dog: Dog, triggerToUpdate: Trigger?) {
        shouldPersistChangesToServer = true
        commonSetup(delegate: delegate, dog: dog, triggerToUpdate: triggerToUpdate)
    }
    
    private func commonSetup(delegate: DogsAddTriggerVCDelegate, dog: Dog?, triggerToUpdate: Trigger?) {
        self.delegate = delegate
        self.dog = dog
        self.triggerToUpdate = triggerToUpdate
        
        editPageHeaderView.setTitle(triggerToUpdate == nil ? "Create Automation" : "Edit Automation")
        editPageHeaderView.isLeadingButtonEnabled = triggerToUpdate != nil
        editPageHeaderView.isTrailingButtonEnabled = triggerToUpdate != nil
        managerView.setup(dog: dog, triggerToUpdate: triggerToUpdate)
    }
    
    // MARK: - Functions
    
    @objc private func didTouchUpInsideSaveTrigger(_ sender: Any) {
        guard let trigger = managerView.constructTrigger(showErrorIfFailed: true) else { return }
        
        if shouldPersistChangesToServer && dog == nil {
            HoundLogger.general.error("DogsAddTriggerVC.didTouchUpInsideSaveTrigger: Dog must be set when persisting changes to server.")
        }
        
        guard shouldPersistChangesToServer, let dog = dog else {
            if triggerToUpdate == nil {
                delegate?.didAddTrigger(sender: Sender(origin: self, localized: self), dogUUID: nil, trigger: trigger)
            }
            else {
                delegate?.didUpdateTrigger(sender: Sender(origin: self, localized: self), dogUUID: nil, trigger: trigger)
            }
            HapticsManager.notification(.success)
            self.dismiss(animated: true)
            return
        }
        
        // Otherwise, call API to create/update on server
        view.isUserInteractionEnabled = false
        saveButton.isLoading = true
        
        let completion: (ResponseStatus, HoundError?) -> Void = { [weak self] status, _ in
            guard let self = self else { return }
            
            self.view.isUserInteractionEnabled = true
            self.saveButton.isLoading = false
            
            guard status != .failureResponse else { return }
            
            if self.triggerToUpdate != nil {
                self.delegate?.didUpdateTrigger(sender: Sender(origin: self, localized: self), dogUUID: dog.dogUUID, trigger: trigger)
            }
            else {
                self.delegate?.didAddTrigger(sender: Sender(origin: self, localized: self), dogUUID: dog.dogUUID, trigger: trigger)
            }
            
            HapticsManager.notification(.success)
            self.dismiss(animated: true)
        }
        
        if triggerToUpdate != nil {
            TriggersRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, dogTriggers: [trigger], completionHandler: completion)
        }
        else {
            TriggersRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, dogTriggers: [trigger], completionHandler: completion)
        }
    }
    
    @objc private func didTouchUpInsideDuplicateTrigger(_ sender: Any) {
        guard let duplicateTrigger = managerView.constructTrigger(showErrorIfFailed: true)?.copy() as? Trigger else { return }
        
        if shouldPersistChangesToServer && dog == nil {
            HoundLogger.general.error("DogsAddTriggerVC.didTouchUpInsideDuplicateTrigger: Dog must be set when persisting changes to server.")
        }
        
        guard shouldPersistChangesToServer, let dog = dog else {
            delegate?.didAddTrigger(sender: Sender(origin: self, localized: self), dogUUID: nil, trigger: duplicateTrigger)
            HapticsManager.notification(.success)
            self.dismiss(animated: true)
            return
        }
        
        // Otherwise, call API to create/update on server
        view.isUserInteractionEnabled = false
        saveButton.isLoading = true
        
        TriggersRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, dogTriggers: [duplicateTrigger]) { [weak self] status, _ in
            guard let self = self else { return }
            self.view.isUserInteractionEnabled = true
            self.saveButton.isLoading = false
            
            guard status != .failureResponse else { return }
            self.delegate?.didAddTrigger(sender: Sender(origin: self, localized: self), dogUUID: dog.dogUUID, trigger: duplicateTrigger)
            HapticsManager.notification(.success)
            self.dismiss(animated: true)
        }
    }
    
    @objc private func didTouchUpInsideRemoveTrigger(_ sender: Any) {
        guard let triggerToUpdate = triggerToUpdate else { return }
        
        if shouldPersistChangesToServer && dog == nil {
            HoundLogger.general.error("DogsAddTriggerVC.didTouchUpInsideRemoveTrigger: Dog must be set when persisting changes to server.")
        }
        
        guard shouldPersistChangesToServer, let dog = dog else {
            delegate?.didRemoveTrigger(sender: Sender(origin: self, localized: self), dogUUID: nil, triggerUUID: triggerToUpdate.triggerUUID)
            HapticsManager.notification(.warning)
            self.dismiss(animated: true)
            return
        }
        
        let alert = UIAlertController(title: "Are you sure you want to delete this trigger?", message: nil, preferredStyle: .alert)
        let deleteAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
            self.view.isUserInteractionEnabled = false
            TriggersRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dog.dogUUID, triggerUUIDs: [triggerToUpdate.triggerUUID]) { status, _ in
                self.view.isUserInteractionEnabled = true
                guard status != .failureResponse else { return }
                self.delegate?.didRemoveTrigger(sender: Sender(origin: self, localized: self), dogUUID: dog.dogUUID, triggerUUID: triggerToUpdate.triggerUUID)
                HapticsManager.notification(.warning)
                self.dismiss(animated: true)
            }
        }
        alert.addAction(deleteAction)
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil))
        PresentationManager.enqueueAlert(alert)
    }
    
    @objc private func didTouchUpInsideBack(_ sender: Any) {
        guard managerView.didUpdateInitialValues else {
            self.dismiss(animated: true)
            return
        }
        let alert = UIAlertController(title: "Are you sure you want to exit?", message: nil, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "Yes, I don't want to save changes", style: .default) { _ in
            self.dismiss(animated: true)
        })
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil))
        PresentationManager.enqueueAlert(alert)
    }
    
    @objc private func didTapScreen(sender: UITapGestureRecognizer) {
        managerView.didTapScreen(sender: sender)
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(saveButton)
        view.addSubview(backButton)
        containerView.addSubview(editPageHeaderView)
        containerView.addSubview(managerView)
        
        let didTapScreenGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapScreen(sender:))
        )
        didTapScreenGesture.delegate = self
        didTapScreenGesture.cancelsTouchesInView = false
        view.addGestureRecognizer(didTapScreenGesture)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        NSLayoutConstraint.activate([
            editPageHeaderView.topAnchor.constraint(equalTo: containerView.topAnchor),
            editPageHeaderView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            editPageHeaderView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        NSLayoutConstraint.activate([
            managerView.topAnchor.constraint(equalTo: editPageHeaderView.bottomAnchor),
            managerView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor),
            managerView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            managerView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        ])
        NSLayoutConstraint.activate([
            saveButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            saveButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteCircleHoriInset),
            saveButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier, relativeToWidthOf: view),
            saveButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight),
            saveButton.createSquareAspectRatio()
        ])
        NSLayoutConstraint.activate([
            backButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset),
            backButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteCircleHoriInset),
            backButton.createHeightMultiplier(Constant.Constraint.Button.largeCircleHeightMultiplier, relativeToWidthOf: view),
            backButton.createMaxHeight(Constant.Constraint.Button.largeCircleMaxHeight),
            backButton.createSquareAspectRatio()
        ])
    }
}
//
//  DogsAddTriggerManagerView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/8/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//
import SnapKit
import UIKit
    enum DogsAddTriggerDropDownTypes: String, HoundDropDownType {
    case logReactions = "DropDownLogReactions"
    case reminderResult = "DropDownReminderResult"
    case triggerType = "DropDownTriggerType"
}
final class DogsAddTriggerManagerView: HoundView,
                                       UIGestureRecognizerDelegate,
                                       DogsAddTriggerTimeDelayViewDelegate,
                                       DogsAddTriggerFixedTimeViewDelegate,
                                       HoundDropDownDataSource,
                                       HoundDropDownManagerDelegate {
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
    // MARK: - Delegate Methods
    
    func willDismissKeyboard() {
        dismissKeyboard()
    }

    func didUpdateDescriptionLabel() {
        updateTriggerTypeDescriptionLabel()
    }
    
    // MARK: - Elements
    
    private let logReactionsHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "When This Log is Added"
        return label
    }()
    private lazy var logReactionsLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select one or more types..."
        label.shouldInsetText = true
        label.adjustsFontSizeToFitWidth = false
        
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: DogsAddTriggerDropDownTypes.logReactions,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .logReactions, label: label, autoscroll: .firstOpen)
        return label
    }()
    private lazy var logReactionStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(logReactionsHeaderLabel)
        stack.addArrangedSubview(logReactionsLabel)
        return stack
    }()
    
    private let conditionsHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "If This Log Was..."
        return label
    }()
    private let manuallyCreatedLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 250, compressionResistancePriority: 250)
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.textColor = .label
        label.text = "Added Manually"
        return label
    }()
    private let createdByAlarmLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 250, compressionResistancePriority: 250)
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.textColor = .label
        label.text = "Added by Alarm"
        return label
    }()
    private lazy var manuallyCreatedSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.addTarget(self, action: #selector(didToggleSwitch(_:)), for: .valueChanged)
        return uiSwitch
    }()
    private lazy var createdByAlarmSwitch: HoundSwitch = {
        let uiSwitch = HoundSwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.addTarget(self, action: #selector(didToggleSwitch(_:)), for: .valueChanged)
        return uiSwitch
    }()
    private lazy var nestedConditionsStack: HoundStackView = {
        let manuallyCreatedStack = HoundStackView()
        manuallyCreatedStack.addArrangedSubview(manuallyCreatedLabel)
        manuallyCreatedStack.addArrangedSubview(manuallyCreatedSwitch)
        manuallyCreatedStack.axis = .horizontal
        manuallyCreatedStack.alignment = .center
        manuallyCreatedStack.spacing = Constant.Constraint.Spacing.contentIntraHori
        
        let createdByAlarmStack = HoundStackView()
        createdByAlarmStack.addArrangedSubview(createdByAlarmLabel)
        createdByAlarmStack.addArrangedSubview(createdByAlarmSwitch)
        createdByAlarmStack.axis = .horizontal
        createdByAlarmStack.alignment = .center
        createdByAlarmStack.spacing = Constant.Constraint.Spacing.contentIntraHori
        
        let nestedStack = HoundStackView()
        nestedStack.addArrangedSubview(manuallyCreatedStack)
        nestedStack.addArrangedSubview(createdByAlarmStack)
        nestedStack.axis = .vertical
        nestedStack.spacing = Constant.Constraint.Spacing.contentTallIntraVert
        
        nestedStack.errorMessageChangesBorder = false
        
        return nestedStack
    }()
    private lazy var conditionsStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(conditionsHeaderLabel)
        stack.addArrangedSubview(nestedConditionsStack)
        
        return stack
    }()
    
    private let reminderResultHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "Then Create This Reminder"
        return label
    }()
    private lazy var reminderResultLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a reminder type..."
        label.shouldInsetText = true
        label.adjustsFontSizeToFitWidth = false
        
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: DogsAddTriggerDropDownTypes.reminderResult,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .reminderResult, label: label, autoscroll: .firstOpen)
        return label
    }()
    private lazy var reminderCustomActionNameTextField: HoundTextField = {
        let textField = HoundTextField()
        textField.delegate = self
        textField.applyStyle(.thinGrayBorder)
        textField.placeholder = "Add a custom name... (optional)"
        textField.shouldInsetText = true
        return textField
    }()
    private lazy var reminderResultStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(reminderResultHeaderLabel)
        
        let nestedStack = HoundStackView()
        nestedStack.addArrangedSubview(reminderResultLabel)
        nestedStack.addArrangedSubview(reminderCustomActionNameTextField)
        nestedStack.axis = .vertical
        nestedStack.spacing = Constant.Constraint.Spacing.contentIntraVert
        
        stack.addArrangedSubview(nestedStack)
        
        return stack
    }()

    private let triggerTypeHeaderLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.emphasizedSecondaryRegularLabel
        label.textColor = .label
        label.text = "When Should the Reminder Be Sent?"
        return label
    }()
    private lazy var triggerTypeLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.applyStyle(.thinGrayBorder)
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(
            dropDownManager.showHideDropDownGesture(
                identifier: DogsAddTriggerDropDownTypes.triggerType,
                delegate: self
            )
        )
        dropDownManager.register(identifier: .triggerType, label: label, autoscroll: .firstOpen)
        return label
    }()
    private let triggerTypeDescriptionLabel: HoundLabel = {
        let label = HoundLabel()
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        label.numberOfLines = 0
        return label
    }()
    private lazy var nestedTriggerTypeStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(triggerTypeLabel)
        stack.addArrangedSubview(triggerTypeDescriptionLabel)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    private lazy var triggerTypeStack: HoundStackView = {
        let stack = HoundStackView.inputFieldStack(triggerTypeHeaderLabel)
        stack.addArrangedSubview(nestedTriggerTypeStack)
        return stack
    }()
    
     private lazy var timeDelayView: DogsAddTriggerTimeDelayView = {
        let view = DogsAddTriggerTimeDelayView()
        view.isHidden = selectedTriggerType != .timeDelay
        
        let timeDelayTap = UITapGestureRecognizer(target: self, action: #selector(didInteractWithTimeDelayView))
        timeDelayTap.delegate = self
        timeDelayTap.cancelsTouchesInView = false
        view.addGestureRecognizer(timeDelayTap)
        view.isUserInteractionEnabled = true
        
        return view
    }()
    
    private lazy var fixedTimeView: DogsAddTriggerFixedTimeView = {
        let view = DogsAddTriggerFixedTimeView()
        view.isHidden = selectedTriggerType != .fixedTime
        
        let fixedTimeTap = UITapGestureRecognizer(target: self, action: #selector(didInteractWithFixedTimeView))
        fixedTimeTap.delegate = self
        fixedTimeTap.cancelsTouchesInView = false
        view.addGestureRecognizer(fixedTimeTap)
        view.isUserInteractionEnabled = true
        
        return view
    }()
    
    private lazy var triggerViewsStack: HoundStackView = {
        let stack = HoundStackView(arrangedSubviews: [timeDelayView, fixedTimeView])
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    
    private lazy var dropDownManager = HoundDropDownManager<DogsAddTriggerDropDownTypes>(
        rootView: self,
        dataSource: self,
        delegate: self
    )
    
    @objc private func didToggleSwitch(_ sender: Any) {
        if sender as? HoundSwitch == manuallyCreatedSwitch || sender as? HoundSwitch == createdByAlarmSwitch {
            if manuallyCreatedSwitch.isOn || createdByAlarmSwitch.isOn {
                nestedConditionsStack.errorMessage = nil
            }
        }
    }
    
    @objc private func didInteractWithTimeDelayView() {
        timeDelayView.errorMessage = nil
    }
    
    @objc private func didInteractWithFixedTimeView() {
        fixedTimeView.errorMessage = nil
    }
    
    // MARK: - Properties
    
    private var dog: Dog?
    private var initialTrigger: Trigger?
    private var triggerToUpdate: Trigger?
    
    private var availableLogReactions: [TriggerLogReaction] = []
    private var selectedLogReactions: [TriggerLogReaction] = []
    
    private var availableReminderResults: [TriggerReminderResult] = []
    private var selectedReminderResult: TriggerReminderResult?
    private let availableTriggerTypes: [TriggerType] = TriggerType.allCases
    private var selectedTriggerType: TriggerType = Constant.Class.Trigger.defaultTriggerType {
        didSet {
            triggerTypeLabel.text = selectedTriggerType.readable
            timeDelayView.isHidden = selectedTriggerType != .timeDelay
            fixedTimeView.isHidden = selectedTriggerType != .fixedTime
            updateTriggerTypeDescriptionLabel()
        }
    }
    
    var didUpdateInitialValues: Bool {
        guard let initialTrigger = initialTrigger else {
            // creating new trigger right now, so return true
            return true
        }
        
        guard let newTrigger = constructTrigger(showErrorIfFailed: false) else {
            // new trigger has invalid settings so show warning abt exiting
            // we have an initialTrigger, so user HAS to be editing, and if newTrigger couldn't be saved then user input an invalid setting
            return false
        }
        
        return !initialTrigger.isSame(as: newTrigger)
    }
    
    // MARK: - Function
    
    // Construct trigger based on current selections
    func constructTrigger(showErrorIfFailed: Bool) -> Trigger? {
        let trigger: Trigger = triggerToUpdate?.copy() as? Trigger ?? Trigger()
        
        guard trigger.setTriggerLogReactions(selectedLogReactions) else {
            if showErrorIfFailed {
                HapticsManager.notification(.error)
                logReactionsLabel.errorMessage = Constant.Error.TriggerError.logReactionMissing
            }
            return nil
        }
        
        guard manuallyCreatedSwitch.isOn || createdByAlarmSwitch.isOn else {
            if showErrorIfFailed {
                HapticsManager.notification(.error)
                nestedConditionsStack.errorMessage = Constant.Error.TriggerError.conditionsInvalid
            }
            return nil
        }
        trigger.triggerManualCondition = manuallyCreatedSwitch.isOn
        trigger.triggerAlarmCreatedCondition = createdByAlarmSwitch.isOn
        
        guard let selectedReminderResult = selectedReminderResult else {
            if showErrorIfFailed {
                HapticsManager.notification(.error)
                reminderResultLabel.errorMessage = Constant.Error.TriggerError.reminderResultMissing
            }
            
            return nil
        }
        
        let reminderActionType = ReminderActionType.find(reminderActionTypeId: selectedReminderResult.reminderActionTypeId)
        let customName = reminderActionType.allowsCustom ? (reminderCustomActionNameTextField.text?.trimmingCharacters(in: .whitespacesAndNewlines) ?? "") : ""
        trigger.triggerReminderResult = TriggerReminderResult(reminderActionTypeId: selectedReminderResult.reminderActionTypeId, reminderCustomActionName: customName)
        
        if selectedTriggerType == .timeDelay {
            trigger.triggerType = .timeDelay
            let component = timeDelayView.currentComponent
            if !trigger.timeDelayComponents.changeTriggerTimeDelay(component.triggerTimeDelay) {
                            if showErrorIfFailed {
                                HapticsManager.notification(.error)
                                timeDelayView.errorMessage = Constant.Error.TriggerError.timeDelayInvalid
                            }
                            return nil
                        }
        }
        else {
            trigger.triggerType = .fixedTime
            let component = fixedTimeView.currentComponent
            if !trigger.fixedTimeComponents.changeFixedTimeHour(component.triggerFixedTimeHour) ||
                !trigger.fixedTimeComponents.changeFixedTimeMinute(component.triggerFixedTimeMinute) ||
                !trigger.fixedTimeComponents.changeTriggerFixedTimeTypeAmount(component.triggerFixedTimeTypeAmount) {
                if showErrorIfFailed {
                    HapticsManager.notification(.error)
                    fixedTimeView.errorMessage = Constant.Error.TriggerError.fixedTimeTypeAmountInvalid
                }
                return nil
            }
        }
        return trigger
    }
    
    private func updateDynamicUIElements() {
        logReactionsLabel.text = selectedLogReactions.map({ $0.readableName(includeMatchingEmoji: true) }).joined(separator: ", ")
        reminderResultLabel.text = selectedReminderResult?.readableName
        reminderCustomActionNameTextField.text = selectedReminderResult?.reminderCustomActionName
        updateTriggerTypeDescriptionLabel()
        
        let customActionNameIsHidden = !(selectedReminderResult.map { ReminderActionType.find(reminderActionTypeId: $0.reminderActionTypeId).allowsCustom } ?? false)
        if reminderCustomActionNameTextField.isHidden != customActionNameIsHidden {
            reminderCustomActionNameTextField.isHidden = customActionNameIsHidden
            remakeCustomActionNameConstraints()
        }
        
        UIView.animate(withDuration: Constant.Visual.Animation.showOrHideSingleElement) {
            self.setNeedsLayout()
            self.layoutIfNeeded()
        }
    }

    private func updateTriggerTypeDescriptionLabel() {
        switch selectedTriggerType {
        case .timeDelay:
            triggerTypeDescriptionLabel.text = timeDelayView.descriptionLabelText
        case .fixedTime:
            triggerTypeDescriptionLabel.text = fixedTimeView.descriptionLabelText
        }
    }
    
    @objc override func dismissKeyboard() {
        super.dismissKeyboard()
        endEditing(true)
    }
    
    // MARK: - Setup
    
    func setup(dog: Dog?, triggerToUpdate: Trigger?) {
        self.dog = dog
        self.triggerToUpdate = triggerToUpdate
        initialTrigger = triggerToUpdate?.copy() as? Trigger
        
        availableLogReactions = []
        let logs = dog?.dogLogs.dogLogs ?? []
        for type in GlobalTypes.shared.logActionTypes {
            availableLogReactions.append(
                TriggerLogReaction(logActionTypeId: type.logActionTypeId)
            )
            var seen = Set<String>()
            for log in logs where log.logActionTypeId == type.logActionTypeId {
                let name = log.logCustomActionName.trimmingCharacters(in: .whitespacesAndNewlines)
                guard type.allowsCustom, !name.isEmpty else { continue }
                if seen.insert(name).inserted {
                    availableLogReactions.append(
                        TriggerLogReaction(logActionTypeId: type.logActionTypeId, logCustomActionName: name)
                    )
                }
                if seen.count >= PreviousLogCustomActionName.maxStored { break }
            }
            
        }
        
        manuallyCreatedSwitch.isOn = triggerToUpdate?.triggerManualCondition ?? Constant.Class.Trigger.defaultTriggerManualCondition
        createdByAlarmSwitch.isOn = triggerToUpdate?.triggerAlarmCreatedCondition ?? Constant.Class.Trigger.defaultTriggerAlarmCreatedCondition
        
        // Build available reminder results
        availableReminderResults = []
        let reminders = dog?.dogReminders.dogReminders ?? []
        for type in GlobalTypes.shared.reminderActionTypes {
            availableReminderResults.append(
                TriggerReminderResult(reminderActionTypeId: type.reminderActionTypeId)
            )
            var seen = Set<String>()
            for reminder in reminders where reminder.reminderActionTypeId == type.reminderActionTypeId {
                let name = reminder.reminderCustomActionName.trimmingCharacters(in: .whitespacesAndNewlines)
                guard type.allowsCustom, !name.isEmpty else { continue }
                if seen.insert(name).inserted {
                    availableReminderResults.append(
                        TriggerReminderResult(reminderActionTypeId: type.reminderActionTypeId, reminderCustomActionName: name)
                    )
                }
                if seen.count >= PreviousReminderCustomActionName.maxStored { break }
            }
        }
        
        if let trigger = triggerToUpdate {
            selectedLogReactions = trigger.triggerLogReactions
            selectedReminderResult = trigger.triggerReminderResult
            selectedTriggerType = trigger.triggerType
        }
        else {
            selectedTriggerType = Constant.Class.Trigger.defaultTriggerType
        }
        
        if triggerToUpdate?.triggerType == .timeDelay {
            timeDelayView.setup(delegate: self, components: triggerToUpdate?.timeDelayComponents)
        }
        else {
            timeDelayView.setup(delegate: self, components: nil)
        }
        
        if triggerToUpdate?.triggerType == .fixedTime {
            fixedTimeView.setup(delegate: self, components: triggerToUpdate?.fixedTimeComponents)
        }
        else {
            fixedTimeView.setup(delegate: self, components: nil)
        }
        
        updateDynamicUIElements()
    }
    
    // MARK: - Drop Down Handling
    
    @objc func didTapScreen(sender: UITapGestureRecognizer) {
        dropDownManager.hideDropDownIfNotTapped(sender: sender)
        if let senderView = sender.view {
            let point = sender.location(in: senderView)
            if let deepestTouchedView = senderView.hitTest(point, with: nil), !deepestTouchedView.isDescendant(of: reminderCustomActionNameTextField) {
                dismissKeyboard()
            }
        }
    }
    /// Determine and show the next required dropdown in the log creation flow
    private func showNextRequiredDropDown(animated: Bool) {
        if selectedLogReactions.isEmpty && selectedReminderResult == nil {
            willShowDropDown(DogsAddTriggerDropDownTypes.logReactions, animated: animated)
        }
        else if selectedReminderResult == nil {
            willShowDropDown(DogsAddTriggerDropDownTypes.reminderResult, animated: animated)
        }
    }
    
    func willShowDropDown(_ identifier: any HoundDropDownType, animated: Bool) {
        guard let type = identifier as? DogsAddTriggerDropDownTypes else { return }
        
        let numberOfRows: CGFloat = {
            switch type {
            case .logReactions:
                return CGFloat(availableLogReactions.count)
            case .reminderResult:
                return CGFloat(availableReminderResults.count)
            case .triggerType:
                return CGFloat(availableTriggerTypes.count)
            }
        }()
        
        dropDownManager.show(
            identifier: type,
            numberOfRowsToShow: min(6.5, numberOfRows),
            animated: animated
        )
    }
    
    // MARK: - DropDown Data Source
    
    func setupCellForDropDown(cell: HoundDropDownTVC, indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let type = identifier as? DogsAddTriggerDropDownTypes else { return }
        
        switch type {
        case .logReactions:
            let item = availableLogReactions[indexPath.row]
            cell.label.text = item.readableName(includeMatchingEmoji: true)
            let selected = selectedLogReactions.contains(item)
            cell.setCustomSelected(selected, animated: false)
        case .reminderResult:
            let item = availableReminderResults[indexPath.row]
            cell.label.text = item.readableName
            let selected = selectedReminderResult?.isSame(as: item) ?? false
            cell.setCustomSelected(selected, animated: false)
        case .triggerType:
            let type = availableTriggerTypes[indexPath.row]
            cell.label.text = type.readable
            cell.setCustomSelected(selectedTriggerType == type, animated: false)
        }
    }
    
    func numberOfRows(section: Int, identifier: any HoundDropDownType) -> Int {
        guard let type = identifier as? DogsAddTriggerDropDownTypes else { return 0 }
        switch type {
        case .logReactions:
            return availableLogReactions.count
        case .reminderResult:
            return availableReminderResults.count
        case .triggerType:
            return availableTriggerTypes.count
        }
    }
    
    func numberOfSections(identifier: any HoundDropDownType) -> Int {
        // Each dropdown has a single section
        return 1
    }
    
    func selectItemInDropDown(indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let type = identifier as? DogsAddTriggerDropDownTypes else { return }
        guard let dropDown = dropDownManager.dropDown(for: type) else { return }
        guard let cell = dropDown.dropDownTableView?.cellForRow(at: indexPath) as? HoundDropDownTVC else { return }
        
        switch type {
        case .logReactions:
            let beforeSelectNumberOfLogReactions = selectedLogReactions.count
            let reaction = availableLogReactions[indexPath.row]
            
            let indexOfReaction = { (target: TriggerLogReaction) -> Int? in
                return self.selectedLogReactions.firstIndex { $0 === target }
            }
            
            if let index = indexOfReaction(reaction) {
                // Deselecting reaction
                cell.setCustomSelected(false)
                selectedLogReactions.remove(at: index)
                
                if reaction.logCustomActionName.hasText() {
                    // Deselect parent if needed
                    if let parentIndex = self.availableLogReactions.firstIndex(where: { $0.logActionTypeId == reaction.logActionTypeId && !$0.logCustomActionName.hasText() }),
                       let selectedParentIndex = indexOfReaction(self.availableLogReactions[parentIndex]) {
                        selectedLogReactions.remove(at: selectedParentIndex)
                        if let parentCell = dropDown.dropDownTableView?.cellForRow(at: IndexPath(row: parentIndex, section: 0)) as? HoundDropDownTVC {
                            parentCell.setCustomSelected(false)
                        }
                    }
                }
                else {
                    // Deselect all children when deselecting parent
                    for (idx, item) in self.availableLogReactions.enumerated() where item.logActionTypeId == reaction.logActionTypeId && item.logCustomActionName.hasText() {
                        if let selectedIdx = indexOfReaction(item) {
                            selectedLogReactions.remove(at: selectedIdx)
                        }
                        if let childCell = dropDown.dropDownTableView?.cellForRow(at: IndexPath(row: idx, section: 0)) as? HoundDropDownTVC {
                            childCell.setCustomSelected(false)
                        }
                    }
                }
            }
            else {
                // Selecting reaction
                cell.setCustomSelected(true)
                selectedLogReactions.append(reaction)
                logReactionsLabel.errorMessage = nil
                
                if reaction.logCustomActionName.hasText() == false {
                    // Selecting parent selects all children
                    for (idx, item) in self.availableLogReactions.enumerated() where item.logActionTypeId == reaction.logActionTypeId && item.logCustomActionName.hasText() {
                        if indexOfReaction(item) == nil {
                            selectedLogReactions.append(item)
                        }
                        if let childCell = dropDown.dropDownTableView?.cellForRow(at: IndexPath(row: idx, section: 0)) as? HoundDropDownTVC {
                            childCell.setCustomSelected(true)
                        }
                    }
                }
            }
            
            updateDynamicUIElements()
            
            if beforeSelectNumberOfLogReactions == 0 || selectedLogReactions.count == availableLogReactions.count {
                // selected their first log action
                // selected every log reaction
                dropDown.hideDropDown(animated: true)
                showNextRequiredDropDown(animated: true)
            }
        case .reminderResult:
            let beforeSelection = selectedReminderResult
            
            guard cell.isCustomSelected == false else {
                cell.setCustomSelected(false)
                selectedReminderResult = nil
                updateDynamicUIElements()
                return
            }
            
            if let previousSelected = availableReminderResults.firstIndex(where: { reminderResult in
                return reminderResult.reminderActionTypeId == selectedReminderResult?.reminderActionTypeId
                && ((selectedReminderResult?.reminderCustomActionName.hasText() ?? false)
                    ? reminderResult.reminderCustomActionName == selectedReminderResult?.reminderCustomActionName
                    : true)
            }) {
                let previouslySelectedIndexPath = IndexPath(row: previousSelected, section: 0)
                let previousSelectedCell = dropDown.dropDownTableView?.cellForRow(at: previouslySelectedIndexPath) as? HoundDropDownTVC
                previousSelectedCell?.setCustomSelected(false)
            }
            
            cell.setCustomSelected(true)
            reminderResultLabel.errorMessage = nil
            selectedReminderResult = availableReminderResults[indexPath.row]
            
            if let selectedReminderResult = selectedReminderResult, ReminderActionType.find(reminderActionTypeId: selectedReminderResult.reminderActionTypeId).allowsCustom {
                // If custom action is allowed, begin editing textField
                reminderCustomActionNameTextField.text = selectedReminderResult.reminderCustomActionName
            }
            
            updateDynamicUIElements()
            
            dropDown.hideDropDown(animated: true)
            if beforeSelection == nil && !reminderCustomActionNameTextField.isFirstResponder {
                // First-time selection of reminder result, so open next dropdown
                showNextRequiredDropDown(animated: true)
            }
        case .triggerType:
            let type = availableTriggerTypes[indexPath.row]
            
            // prevent deselectiong of trigger type. we shuld always have one selected
            guard type != selectedTriggerType else {
                return
            }
            
            cell.setCustomSelected(true)
            selectedTriggerType = type
            dropDown.hideDropDown(animated: true)
        }
    }
    
    func firstSelectedIndexPath(identifier: any HoundDropDownType) -> IndexPath? {
            guard let type = identifier as? DogsAddTriggerDropDownTypes else { return nil }
            switch type {
            case .logReactions:
                if let idx = selectedLogReactions
                    .compactMap({ reaction in availableLogReactions.firstIndex(where: { $0.isSame(as: reaction)}) })
                    .min() {
                    return IndexPath(row: idx, section: 0)
                }
            case .reminderResult:
                if let result = selectedReminderResult,
                   let idx = availableReminderResults.firstIndex(where: { $0.isSame(as: result) }) {
                    return IndexPath(row: idx, section: 0)
                }
            case .triggerType:
                if let idx = TriggerType.allCases.firstIndex(of: selectedTriggerType) {
                    return IndexPath(row: idx, section: 0)
                }
            }
            return nil
        }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(logReactionStack)
        addSubview(conditionsStack)
        addSubview(reminderResultStack)
        addSubview(triggerTypeStack)
        addSubview(triggerViewsStack)
        
        let didTapScreenGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapScreen(sender:))
        )
        didTapScreenGesture.delegate = self
        didTapScreenGesture.cancelsTouchesInView = false
        addGestureRecognizer(didTapScreenGesture)
    }
    
    private func remakeCustomActionNameConstraints() {
        reminderCustomActionNameTextField.snp.remakeConstraints { make in
            if !reminderCustomActionNameTextField.isHidden {
                make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
                make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
            }
        }
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        logReactionStack.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.leading.equalToSuperview().offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        logReactionsLabel.snp.makeConstraints { make in
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        
        conditionsStack.snp.makeConstraints { make in
            make.top.equalTo(logReactionStack.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.leading.equalToSuperview().offset(Constant.Constraint.Spacing.absoluteHoriInset)
            // add extra inset for the switches inside
            make.trailing.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset * 2.0)
        }
        
        reminderResultStack.snp.makeConstraints { make in
            make.top.equalTo(conditionsStack.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.leading.equalToSuperview().offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        reminderResultLabel.snp.makeConstraints { make in
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        remakeCustomActionNameConstraints()

        triggerTypeStack.snp.makeConstraints { make in
            make.top.equalTo(reminderResultStack.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.leading.equalToSuperview().offset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.trailing.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        triggerTypeLabel.snp.makeConstraints { make in
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        
        triggerViewsStack.snp.makeConstraints { make in
            make.top.equalTo(triggerTypeStack.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
            make.bottom.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteVertInset)
            make.leading.equalToSuperview()
            make.trailing.equalToSuperview()
        }
    }
}

extension DogsAddTriggerManagerView: UITextFieldDelegate {
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        dismissKeyboard(); return false
    }
}
//
//  DogsAddTriggerTimeDelayView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/8/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddTriggerTimeDelayViewDelegate: AnyObject {
    func willDismissKeyboard()
    func didUpdateDescriptionLabel()
}

final class DogsAddTriggerTimeDelayView: HoundView {
    
    // MARK: - Elements
    
    private lazy var countdownDatePicker: HoundDatePicker = {
        let datePicker = HoundDatePicker(huggingPriority: 240, compressionResistancePriority: 240)
        datePicker.datePickerMode = .countDownTimer
        datePicker.minuteInterval = Constant.Development.minuteInterval
        datePicker.countDownDuration = Constant.Class.Trigger.defaultTriggerTimeDelay
        datePicker.addTarget(self, action: #selector(didUpdateCountdown), for: .valueChanged)
        return datePicker
    }()
    
    @objc private func didUpdateCountdown(_ sender: Any) {
        self.errorMessage = nil
        delegate?.willDismissKeyboard()
        delegate?.didUpdateDescriptionLabel()
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddTriggerTimeDelayViewDelegate?
    
    var currentComponent: TriggerTimeDelayComponents {
        TriggerTimeDelayComponents(triggerTimeDelay: countdownDatePicker.countDownDuration)
    }
    
    // MARK: - Setup
    
    func setup(
        delegate: DogsAddTriggerTimeDelayViewDelegate,
        components: TriggerTimeDelayComponents?
    ) {
        self.delegate = delegate
        if let delay = components?.triggerTimeDelay {
            countdownDatePicker.countDownDuration = delay
        }
        
        delegate.didUpdateDescriptionLabel()
    }
    
    // MARK: - Functions
    
    var descriptionLabelText: String {
            "Reminder will be sent \(countdownDatePicker.countDownDuration.readable(capitalizeWords: false, abbreviationLevel: .long)) after the log is added"
        }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(countdownDatePicker)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        NSLayoutConstraint.activate([
            countdownDatePicker.topAnchor.constraint(equalTo: topAnchor),
            countdownDatePicker.leadingAnchor.constraint(equalTo: leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            countdownDatePicker.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            countdownDatePicker.bottomAnchor.constraint(equalTo: bottomAnchor),
            countdownDatePicker.createHeightMultiplier(Constant.Constraint.Input.megaDatePickerHeightMultiplier, relativeToWidthOf: self),
            countdownDatePicker.createMaxHeight(Constant.Constraint.Input.megaDatePickerMaxHeight)
        ])
    }
}
//
//  DogsAddTriggerFixedTimeView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/8/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

protocol DogsAddTriggerFixedTimeViewDelegate: AnyObject {
    func willDismissKeyboard()
    func didUpdateDescriptionLabel()
}

enum DogsAddTriggerFixedTimeDropDownTypes: String, HoundDropDownType {
    case dayOffset = "DropDownDayOffset"
}

final class DogsAddTriggerFixedTimeView: HoundView, HoundDropDownDataSource, HoundDropDownManagerDelegate, UIGestureRecognizerDelegate {
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        true
    }
    
    // MARK: - Elements
    
    private lazy var dayOffsetLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 260, compressionResistancePriority: 260)
        label.applyStyle(.thinGrayBorder)
        label.placeholder = "Select a day offset..."
        label.shouldInsetText = true
        label.isUserInteractionEnabled = true
        label.addGestureRecognizer(dropDownManager.showHideDropDownGesture(identifier: .dayOffset, delegate: self))
        dropDownManager.register(identifier: .dayOffset, label: label, autoscroll: .firstOpen)
        return label
    }()
    
    private lazy var timeOfDayPicker: HoundDatePicker = {
        let datePicker = HoundDatePicker(huggingPriority: 250, compressionResistancePriority: 250)
        datePicker.datePickerMode = .time
        datePicker.minuteInterval = Constant.Development.minuteInterval
        datePicker.preferredDatePickerStyle = .wheels
        datePicker.timeZone = UserConfiguration.timeZone
        datePicker.date = Date.roundDate(
            targetDate: Date(),
            roundingInterval: Double(60 * datePicker.minuteInterval),
            roundingMethod: .up
        )
        datePicker.addTarget(self, action: #selector(didUpdateTimeOfDay), for: .valueChanged)
        return datePicker
    }()
    
    private let timeZoneDisclaimerLabel: HoundLabel = {
        let label = HoundLabel()
        label.textAlignment = .center
        label.textColor = UIColor.secondaryLabel
        label.font = Constant.Visual.Font.secondaryColorDescLabel
        label.text = "If your family is spread across time zones, the reminder’s time will be based off whichever device handles this automation first."
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.isHidden = FamilyInformation.familyMembers.count <= 1
        return label
    }()
    
    private lazy var disclaimerStack: HoundStackView = {
        let stack = HoundStackView()
        stack.addArrangedSubview(timeOfDayPicker)
        stack.addArrangedSubview(timeZoneDisclaimerLabel)
        stack.axis = .vertical
        stack.distribution = .equalSpacing
        stack.spacing = Constant.Constraint.Spacing.contentIntraVert
        return stack
    }()
    
    @objc private func didUpdateTimeOfDay(_ sender: Any) {
        self.errorMessage = nil
        delegate?.didUpdateDescriptionLabel()
        delegate?.willDismissKeyboard()
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddTriggerFixedTimeViewDelegate?
    
    private lazy var dropDownManager = HoundDropDownManager<DogsAddTriggerFixedTimeDropDownTypes>(rootView: self, dataSource: self, delegate: self)
    private var selectedDayOffset: Int = 0 {
        didSet {
            self.errorMessage = nil
        }
    }
    private let availableDayOffsets = [0, 1, 2, 3, 4, 5, 6, 7]
    
    var currentComponent: TriggerFixedTimeComponents {
        let comps = Calendar.user.dateComponents([.hour, .minute], from: timeOfDayPicker.date)
        let hour = comps.hour ?? Constant.Class.Trigger.defaultTriggerFixedTimeHour
        let minute = comps.minute ?? Constant.Class.Trigger.defaultTriggerFixedTimeMinute
        return TriggerFixedTimeComponents(
            triggerFixedTimeType: .day,
            triggerFixedTimeTypeAmount: selectedDayOffset,
            triggerFixedTimeHour: hour,
            triggerFixedTimeMinute: minute
        )
    }
    
    // MARK: - Setup
    
    func setup(
        delegate: DogsAddTriggerFixedTimeViewDelegate,
        components: TriggerFixedTimeComponents?
    ) {
        self.delegate = delegate
        
        let index = components?.triggerFixedTimeTypeAmount ?? selectedDayOffset
        selectedDayOffset = index
        dayOffsetLabel.text = textForOffset(index)
        
        if let components = components {
            var comps = DateComponents()
            comps.year = 2000
            comps.month = 1
            comps.day = 1
            comps.hour = components.triggerFixedTimeHour
            comps.minute = components.triggerFixedTimeMinute
            comps.second = 0
            comps.timeZone = UserConfiguration.timeZone
            timeOfDayPicker.date = Calendar.user.date(from: comps) ?? timeOfDayPicker.date
        }
        
        delegate.didUpdateDescriptionLabel()
    }
    
    // MARK: - Functions
    
    var descriptionLabelText: String {
        var text = "Reminder be sent "
        
        switch selectedDayOffset {
        case 0: text += "on the same day as the log "
        case 1: text += "the day after the log "
        default: text += "\(selectedDayOffset) days after the log "
        }
        
        let comps = Calendar.user.dateComponents([.hour, .minute], from: timeOfDayPicker.date)
        let hour = comps.hour ?? Constant.Class.Trigger.defaultTriggerFixedTimeHour
        let minute = comps.minute ?? Constant.Class.Trigger.defaultTriggerFixedTimeMinute
        text += "at \(String.convert(hour: hour, minute: minute))"
        
        return text
    }
    
    private func textForOffset(_ offset: Int) -> String {
        switch offset {
        case 0: return "Same Day"
        case 1: return "Next Day"
        default: return "After \(offset) Days"
        }
    }
    
    // MARK: - Drop Down Handling
    
    @objc private func didTapScreen(sender: UITapGestureRecognizer) {
        dropDownManager.hideDropDownIfNotTapped(sender: sender)
        dismissKeyboard()
    }
    
    // MARK: - DropDown Data Source
    
    func willShowDropDown(_ identifier: any HoundDropDownType, animated: Bool) {
        guard let type = identifier as? DogsAddTriggerFixedTimeDropDownTypes else { return }
        
        let numberOfRows: CGFloat = {
            switch type {
            case .dayOffset: return CGFloat(availableDayOffsets.count)
            }
        }()
        
        dropDownManager.show(identifier: type, numberOfRowsToShow: min(6.5, numberOfRows), animated: animated)
    }
    
    func setupCellForDropDown(cell: HoundDropDownTVC, indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let type = identifier as? DogsAddTriggerFixedTimeDropDownTypes else { return }
        cell.label.text = textForOffset(availableDayOffsets[indexPath.row])
        
        switch type {
        case .dayOffset:
            cell.setCustomSelected(availableDayOffsets[indexPath.row] == selectedDayOffset, animated: false)
        }
    }
    
    func numberOfRows(section: Int, identifier: any HoundDropDownType) -> Int {
        guard let type = identifier as? DogsAddTriggerFixedTimeDropDownTypes else { return 0 }
        switch type {
        case .dayOffset:
            return availableDayOffsets.count
        }
    }
    
    func numberOfSections(identifier: any HoundDropDownType) -> Int {
        // Each dropdown has a single section
        return 1
    }
    
    func selectItemInDropDown(indexPath: IndexPath, identifier: any HoundDropDownType) {
        guard let type = identifier as? DogsAddTriggerFixedTimeDropDownTypes else { return }
        guard let dropDown = dropDownManager.dropDown(for: type), let cell = dropDown.dropDownTableView?.cellForRow(at: indexPath) as? HoundDropDownTVC else {
            return
        }
        switch type {
        case .dayOffset:
            let previousIndexPath = IndexPath(row: selectedDayOffset, section: 0)
            if previousIndexPath != indexPath {
                let previousCell = dropDown.dropDownTableView?.cellForRow(at: previousIndexPath) as? HoundDropDownTVC
                previousCell?.setCustomSelected(false)
            }
            
            cell.setCustomSelected(true)
            selectedDayOffset = availableDayOffsets[indexPath.row]
            dayOffsetLabel.text = textForOffset(availableDayOffsets[indexPath.row])
            
            dropDown.hideDropDown(animated: true)
            delegate?.willDismissKeyboard()
            
            delegate?.didUpdateDescriptionLabel()
        }
    }
    
    func firstSelectedIndexPath(identifier: any HoundDropDownType) -> IndexPath? {
            guard let type = identifier as? DogsAddTriggerFixedTimeDropDownTypes else { return nil }
            switch type {
            case .dayOffset:
                if let idx = availableDayOffsets.firstIndex(of: selectedDayOffset) {
                    return IndexPath(row: idx, section: 0)
                }
            }
            return nil
        }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(dayOffsetLabel)
        addSubview(disclaimerStack)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        dayOffsetLabel.snp.makeConstraints { make in
            make.top.equalToSuperview()
            make.horizontalEdges.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset)
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.textFieldHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.textFieldMaxHeight)
        }
        
        disclaimerStack.snp.makeConstraints { make in
            make.top.equalTo(dayOffsetLabel.snp.bottom).offset(Constant.Constraint.Spacing.contentIntraVert)
            make.bottom.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteVertInset)
            make.horizontalEdges.equalToSuperview().inset(Constant.Constraint.Spacing.absoluteHoriInset)
        }
        
        timeOfDayPicker.snp.makeConstraints { make in
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Input.megaDatePickerHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Input.megaDatePickerMaxHeight)
        }
        
    }
}
//
//  HoundPawButton.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/4/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class HoundPawImageView: HoundImageView {

    // MARK: - Main

    override init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(huggingPriority: huggingPriority, compressionResistancePriority: compressionResistancePriority)
        updatePawImage()
    }

    override init() {
        super.init()
        updatePawImage()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        updatePawImage()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    // MARK: - Override Functions

    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            updatePawImage()
        }
    }

    // MARK: - Functions

    private func updatePawImage() {
        self.image = UITraitCollection.current.userInterfaceStyle == .dark
        ? UIImage.init(named: "blackPaw") ?? UIImage()
        : UIImage.init(named: "whitePaw") ?? UIImage()
    }
}
//
//  HoundScrollViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/30/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

class HoundScrollViewController: HoundViewController {
    
    // MARK: - Elements
    
    let scrollView: HoundScrollView = {
        let scrollView = HoundScrollView()
        scrollView.onlyScrollIfBigger()
        // Disable automatic adjustments so contentInset.top can be manually
        // managed without the system adding an additional safe area inset.
        scrollView.contentInsetAdjustmentBehavior = .never
        return scrollView
    }()
    
    let containerView: HoundView = HoundView()
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        addSubViews()
        setupConstraints()
    }
    
    override func viewSafeAreaInsetsDidChange() {
        super.viewSafeAreaInsetsDidChange()
        // Set the top content inset so the scroll view's content initially starts just below the safe area (e.g., under the notch or status bar).
        scrollView.contentInset.top = view.safeAreaInsets.top
        scrollView.contentInset.bottom = view.safeAreaInsets.bottom
        // Reset the content offset so the top of the contelont is aligned exactly with the safe area top when the view first appears.
        // This avoids the scroll view appearing already scrolled down due to system adjustments when the inset is changed.
        scrollView.contentOffset.y = -view.safeAreaInsets.top
    }
    
    // MARK: - Functions
    
    func scrollDescendantViewToVisibleIfNeeded(_ targetView: UIView, verticalPadding: CGFloat = Constant.Constraint.Spacing.absoluteVertInset) {
        // Convert the target view's frame to the scrollView's coordinate system
        let targetRect = containerView.convert(targetView.frame, from: targetView.superview)
        let paddedRect = targetRect.insetBy(dx: 0, dy: -verticalPadding)
        
        let visibleRect = CGRect(origin: scrollView.contentOffset, size: scrollView.bounds.size)
        
        if !visibleRect.contains(paddedRect) {
            scrollView.scrollRectToVisible(paddedRect, animated: true)
        }
    }
    
    // MARK: - Setup
    
    override func addSubViews() {
        view.addSubview(scrollView)
        scrollView.addSubview(containerView)
    }
    
    override func setupConstraints() {
        scrollView.snp.makeConstraints { make in
            make.edges.equalTo(view.snp.edges)
        }
        
        containerView.snp.makeConstraints { make in
            make.top.equalTo(scrollView.contentLayoutGuide.snp.top)
            make.bottom.equalTo(scrollView.contentLayoutGuide.snp.bottom)
            make.horizontalEdges.equalTo(scrollView.contentLayoutGuide.snp.horizontalEdges)
            make.width.equalTo(scrollView.frameLayoutGuide.snp.width)
        }
    }
}
//
//  HoundStackView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/2/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundStackView: UIStackView, HoundUIProtocol, HoundDynamicCorners {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - Properties
    
    var staticCornerRadius: CGFloat? = Constant.Visual.Layer.defaultCornerRadius
    var shouldRoundCorners: Bool = false {
        didSet {
            updateCornerRounding()
        }
    }
    
    var borderWidth: Double {
        get {
            Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }
    
    // MARK: - Override Properties
    
    override var bounds: CGRect {
        didSet {
            updateCornerRounding()
        }
    }
    
    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }
    
    init(arrangedSubviews: [UIView]) {
        super.init(frame: .zero)
        arrangedSubviews.forEach { view in
            self.addArrangedSubview(view)
        }
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        applyDefaultSetup()
    }
    
    required init(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.alignment = .fill
        self.distribution = .fill
        self.translatesAutoresizingMaskIntoConstraints = false
        
        HoundSizeDebugView.install(on: self)
        
        updateCornerRounding()
    }
    
    static func inputFieldStack(_ header: UIView) -> HoundStackView {
        let stack = HoundStackView()
        stack.addArrangedSubview(header)
        stack.axis = .vertical
        stack.spacing = Constant.Constraint.Spacing.contentTightIntraVert
        return stack
    }
}
//
//  HoundDynamicCorners.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol HoundDynamicCorners: AnyObject {
    var shouldRoundCorners: Bool { get }
    var staticCornerRadius: CGFloat? { get }
}

extension HoundDynamicCorners where Self: UIView {
    func updateCornerRounding() {
        if shouldRoundCorners {
            self.layer.masksToBounds = true
            self.layer.cornerRadius = shouldRoundCorners ? (staticCornerRadius ?? (self.bounds.height / 2.0)) : 0.0
            self.layer.cornerCurve = .continuous
        }
    }
}
//
//  HoundDynamicBorder.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol HoundDynamicBorder: AnyObject {
    var borderColor: UIColor? { get }
}

extension HoundDynamicBorder where Self: UIView {
    func updateDynamicBorderColor(using previousTraitCollection: UITraitCollection?) {
        guard #available(iOS 13.0, *),
              traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection),
              let color = borderColor else { return }
        layer.borderColor = color.cgColor
    }
}
//
//  GenerlViewStyle.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/3/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

struct HoundBorderStyle {
    var borderColor: UIColor
    var borderWidth: Double
    var shouldRoundCorners: Bool
    
    static let thinLabelBorder = HoundBorderStyle(
        borderColor: UIColor.label,
        borderWidth: 2,
        shouldRoundCorners: true
    )

    static let labelBorder = HoundBorderStyle(
        borderColor: UIColor.label,
        borderWidth: 2,
        shouldRoundCorners: true
    )

    static let thinGrayBorder = HoundBorderStyle(
        borderColor: UIColor.systemGray2,
        borderWidth: 0.5,
        shouldRoundCorners: true
    )
    
    static let greenSelectionBorder = HoundBorderStyle(
        borderColor: UIColor.systemGreen,
        borderWidth: 4,
        shouldRoundCorners: true
    )
    
    static let redBorder = HoundBorderStyle(
        borderColor: UIColor.systemRed,
        borderWidth: 2,
        shouldRoundCorners: true
    )
}

protocol HoundBorderStylable: AnyObject {
    var borderColor: UIColor? { get set }
    var borderWidth: Double { get set }
    var shouldRoundCorners: Bool { get set }
}

extension HoundBorderStylable where Self: UIView {
    func applyStyle(_ style: HoundBorderStyle) {
        self.borderColor = style.borderColor
        self.borderWidth = style.borderWidth
        self.shouldRoundCorners = style.shouldRoundCorners
    }
}

extension HoundButton: HoundBorderStylable {}
extension HoundLabel: HoundBorderStylable {}
extension HoundTextView: HoundBorderStylable {}
extension HoundTextField: HoundBorderStylable {}
extension HoundView: HoundBorderStylable {}
extension HoundTableView: HoundBorderStylable {}
extension HoundStackView: HoundBorderStylable {}
//
//  HoundSwitch.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/13/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class HoundSwitch: UISwitch, HoundUIProtocol {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.contentHorizontalAlignment = .center
        self.contentVerticalAlignment = .center
        self.translatesAutoresizingMaskIntoConstraints = false
        self.onTintColor = UIColor.systemBlue
        
        HoundSizeDebugView.install(on: self)
        
        self.addTarget(self, action: #selector(handleValueChanged), for: .valueChanged)
    }
    
    @objc private func handleValueChanged() {
        // UISwitch fires .valueChanged for BOTH user interaction and programmatic changes (e.g., mySwitch.setOn(true, animated: true) or mySwitch.isOn = true).
        // DIFFERENT THAN HOW UISEGMENTEDCONTROL WORKS
        if self.isTracking {
            HapticsManager.selectionChanged()
        }
    }

}
//
//  DropDownParentDogTableViewCell.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/2/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

class HoundDropDownTVC: HoundTableViewCell {

    // MARK: - Elements

    let label: HoundLabel = {
        let label = HoundLabel()
        // if change this then change estimatedHeight too
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        return label
    }()

    private var leading: NSLayoutConstraint!
    private var trailing: NSLayoutConstraint!

    // MARK: - Properties
    
    static let singleLineHeight = (Constant.Constraint.Spacing.absoluteVertInset * 1.125) + Constant.Visual.Font.primaryRegularLabel.lineHeight + (Constant.Constraint.Spacing.absoluteVertInset * 1.125)
    static let reuseIdentifier = "HoundDropDownTVC"

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    private(set) var isCustomSelected: Bool = false

    // MARK: - Functions

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    func setCustomSelected(_ selected: Bool, animated: Bool = true) {
        // DO NOT INVOKE DEFAULT IMPLEMENTATION OF super.setSelected(selected, animated: animated)
        guard selected != isCustomSelected else { return }

        isCustomSelected = selected
        
        guard animated else {
            UIView.performWithoutAnimation {
                self.contentView.backgroundColor = selected ? UIColor.systemBlue : UIColor.systemBackground
                self.label.textColor = selected ? UIColor.white : UIColor.label
            }
            return
        }
        
        UIView.animate(withDuration: Constant.Visual.Animation.selectSingleElement) {
            self.contentView.backgroundColor = selected ? UIColor.systemBlue : UIColor.systemBackground
            self.label.textColor = selected ? UIColor.white : UIColor.label
        }

    }

    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(label)
    }

    override func setupConstraints() {
        super.setupConstraints()
        label.snp.makeConstraints { make in
            make.top.equalTo(contentView.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset * 1.125)
            // Use .high priority to avoid breaking during table view height estimation
            make.bottom.equalTo(contentView.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset * 1.125).priority(.high)
            make.horizontalEdges.equalTo(contentView.snp.horizontalEdges).inset(Constant.Constraint.Spacing.contentIntraHori)
        }
    }
}
//
//  HoundDropDown.swift
//  HoundDropDown
//
//  Created by ems on 02/05/19.
//  Copyright © 2019 Majesco. All rights reserved.
//

import UIKit

enum HoundDropDownDirection {
    case down
    case up
}

enum HoundDropDownAutoscroll {
    /// Never autoscroll to a selected item
    case never
    /// Autoscroll only the first time the dropdown is opened
    case firstOpen
    /// Autoscroll every time the dropdown is opened
    case always
}

protocol HoundDropDownDataSource {
    func setupCellForDropDown(cell: HoundDropDownTVC, indexPath: IndexPath, identifier: any HoundDropDownType)
    /// Returns number of rows in a given section of the dropDownMenu
    func numberOfRows(section: Int, identifier: any HoundDropDownType) -> Int
    /// Returns number section in the dropDownMenu
    func numberOfSections(identifier: any HoundDropDownType) -> Int
    
    /// Called when an item is selected in the dropdown menu
    func selectItemInDropDown(indexPath: IndexPath, identifier: any HoundDropDownType)
    
    /// Returns index path of the first selected item if it exists
    func firstSelectedIndexPath(identifier: any HoundDropDownType) -> IndexPath?
}

final class HoundDropDown<T: HoundDropDownType>: HoundView, UITableViewDelegate, UITableViewDataSource {
    typealias Identifier = T
    
    // MARK: - UITableViewDelegate & UITableViewDataSource
    func numberOfSections(in tableView: UITableView) -> Int {
        guard let identifier = identifier else {
            return 0
        }
        
        return (dropDownDataSource?.numberOfSections(identifier: identifier) ?? 0)
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        guard let identifier = identifier else {
            return 0
        }
        
        return (dropDownDataSource?.numberOfRows(section: section, identifier: identifier) ?? 0)
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let identifier = identifier else {
            return HoundDropDownTVC()
        }
        
        let cell: HoundDropDownTVC = (dropDownTableView?.dequeueReusableCell(withIdentifier: HoundDropDownTVC.reuseIdentifier) as? HoundDropDownTVC ?? HoundDropDownTVC())
        
        dropDownDataSource?.setupCellForDropDown(cell: cell, indexPath: indexPath, identifier: identifier)
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        guard let identifier = identifier else {
            return
        }
        
        HapticsManager.selectionChanged()
        
        dropDownDataSource?.selectItemInDropDown(indexPath: indexPath, identifier: identifier)
    }
    
    // Converts `indexPath` into the index path expected by the data source when the dropdown is displayed in `.up` direction.
//    private func translatedIndexPath(_ indexPath: IndexPath) -> IndexPath {
//        guard direction == .up, let identifier = identifier else { return indexPath }
//        let totalRows = dropDownDataSource?.numberOfRows(section: indexPath.section, identifier: identifier) ?? 0
//        let newRow = max(totalRows - 1 - indexPath.row, 0)
//        return IndexPath(row: newRow, section: indexPath.section)
//    }
    
    // MARK: - Properties
    
    /// The DropDownIdentifier is to differentiate if you are using multiple Xibs
    private var identifier: Identifier?
    // Table View
    private(set) var dropDownTableView: HoundTableView?
    private var dropDownViewWidth: CGFloat = 0
    private var dropDownViewOffset: CGFloat = 0
    private var dropDownDataSource: HoundDropDownDataSource?
    private var direction: HoundDropDownDirection = .down
    private var autoscrollBehavior: HoundDropDownAutoscroll = .never
    private var didAutoScroll: Bool = false
    
    // Other Variables
    private var viewPositionReference: CGRect?
    private(set) var isDown: Bool = false
    
    // MARK: - DropDown Methods
    
    /// Make Table View Programatically
    func setupDropDown(
        identifier: Identifier,
        dataSource: HoundDropDownDataSource,
        viewPositionReference: CGRect,
        offset: CGFloat = Constant.Constraint.Spacing.contentTightIntraVert,
        direction: HoundDropDownDirection = .down,
        autoscrollBehavior: HoundDropDownAutoscroll = .never
    ) {
        self.identifier = identifier
        self.dropDownDataSource = dataSource
        self.viewPositionReference = viewPositionReference
        self.dropDownViewWidth = viewPositionReference.width
        self.dropDownViewOffset = offset
        self.direction = direction
        self.autoscrollBehavior = autoscrollBehavior
        self.didAutoScroll = false
        
        // The shadow on self so it can expand as much as it wants, border on dropDownTableView so it and the subviews can be masked / clipped.
        self.shadowColor = UIColor.label
        self.shadowOffset = CGSize(width: 0, height: direction == .down ? 2.5 : -2.5)
        self.shadowRadius = 5.0
        self.shadowOpacity = 0.5
        
        let originY: CGFloat
        if direction == .down {
            originY = viewPositionReference.maxY + offset
        }
        else {
            originY = viewPositionReference.minY - offset
        }
        self.frame = CGRect(x: viewPositionReference.minX, y: originY, width: 0, height: 0)
        
        let dropDownTableView = HoundTableView(frame: CGRect(x: 0, y: 0, width: 0, height: 0))
        self.dropDownTableView = dropDownTableView
        
        dropDownTableView.estimatedRowHeight = HoundDropDownTVC.singleLineHeight
        dropDownTableView.register(HoundDropDownTVC.self, forCellReuseIdentifier: HoundDropDownTVC.reuseIdentifier)
        
        // The shadow on self so it can expand as much as it wants, border on dropDownTableView so it and the subviews can be masked / clipped.
        dropDownTableView.applyStyle(.thinGrayBorder)
        
        dropDownTableView.delegate = self
        dropDownTableView.dataSource = self
        
        self.addSubview(dropDownTableView)
    }
    
    /// Update the reference frame used to position the dropdown
    func updateReferenceFrame(_ referenceFrame: CGRect) {
        self.viewPositionReference = referenceFrame
        self.dropDownViewWidth = referenceFrame.width
    }
    
    /// Shows Drop Down Menu, hides it if already present. The height of the dropdown shown will be equal to the rowHeight of the individual dropdown cells multiplied by the numberOfRowsToShow
    func showDropDown(numberOfRowsToShow numberOfRows: CGFloat, animated: Bool, direction: HoundDropDownDirection? = nil) {
        guard let identifier = identifier else {
            return
        }
        
        guard isDown == false else {
            self.hideDropDown(animated: animated)
            return
        }
        
        guard let dropDownTableView = dropDownTableView, let viewPositionReference = viewPositionReference else { return }
        
        self.direction = direction ?? self.direction
        
        let heightSpecifiedForNumberOfRows = numberOfRows * dropDownTableView.estimatedRowHeight
        let heightNeededToDisplayAllRows: CGFloat = {
            var heightNeeded: CGFloat = 0.0
            let numberOfSections = dropDownDataSource?.numberOfSections(identifier: identifier) ?? 0
            
            for i in 0..<numberOfSections {
                let numberOfRows = dropDownDataSource?.numberOfRows(section: i, identifier: identifier) ?? 0
                heightNeeded += CGFloat(numberOfRows) * dropDownTableView.estimatedRowHeight
            }
            
            return heightNeeded
        }()
        
        self.dropDownTableView?.isScrollEnabled = heightNeededToDisplayAllRows > heightSpecifiedForNumberOfRows
        
        self.dropDownTableView?.reloadData()
        self.dropDownTableView?.layoutIfNeeded()
        
        isDown = true
        let anchorY: CGFloat
        if direction == .down {
            anchorY = viewPositionReference.maxY + dropDownViewOffset
        }
        else {
            anchorY = viewPositionReference.minY - dropDownViewOffset
        }
        
        self.frame = CGRect(x: viewPositionReference.minX, y: anchorY, width: dropDownViewWidth, height: 0)
        dropDownTableView.frame = CGRect(x: 0, y: 0, width: dropDownViewWidth, height: 0)
        
        let shadowPad = max((self.shadowRadius ?? 0.0) + abs(self.shadowOffset?.height ?? 0.0), 0.0)
        
        let availableSpace: CGFloat
        if direction == .down {
            availableSpace = max((self.superview?.frame.height ?? 0.0) - anchorY - shadowPad, 0.0)
        }
        else {
            availableSpace = max(anchorY - shadowPad, 0.0)
        }
        
        // First, we don't want to make the drop down larger than the space needed to display all of its content. So we limit its size to the theoretical maximum space it would need to display all of its content
        // Second, we don't want the drop down larger than the available space in the superview. So we cap its size at the available vertical space.
        let height = min(min(heightSpecifiedForNumberOfRows, heightNeededToDisplayAllRows), availableSpace)
        
        let maxOffset = max(dropDownTableView.contentSize.height - height, 0)
        
        if autoscrollBehavior == .always || (autoscrollBehavior == .firstOpen && !didAutoScroll) {
            if let indexPath = dropDownDataSource?.firstSelectedIndexPath(identifier: identifier),
               indexPath.section < dropDownTableView.numberOfSections,
               indexPath.row < dropDownTableView.numberOfRows(inSection: indexPath.section) {
                let rect = dropDownTableView.rectForRow(at: indexPath)
                var offset = rect.midY - (height / 2.0)
                offset = max(min(offset, maxOffset), 0)
                dropDownTableView.setContentOffset(CGPoint(x: 0, y: offset), animated: false)
                didAutoScroll = true
            }
        }
        
        if self.direction == .up && !didAutoScroll {
            let bottomOffset = maxOffset
            dropDownTableView.setContentOffset(CGPoint(x: 0, y: bottomOffset), animated: false)
        }
        
        UIView.animate(withDuration: animated ? 0.7 : 0.0, delay: 0, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.05, options: .curveLinear, animations: {
            if self.direction == .down {
                self.frame.size = CGSize(width: self.dropDownViewWidth, height: height)
            }
            else {
                self.frame = CGRect(x: self.frame.minX, y: viewPositionReference.minY - self.dropDownViewOffset - height, width: self.dropDownViewWidth, height: height)
            }
            
            dropDownTableView.frame.size = CGSize(width: self.dropDownViewWidth, height: height)
        })
        
    }
    
    /// Hides DropDownMenu
    func hideDropDown(animated: Bool) {
        guard isDown else { return }
        
        isDown = false
        
        let originY: CGFloat
        if let viewPositionReference = viewPositionReference {
            if direction == .down {
                originY = viewPositionReference.maxY + dropDownViewOffset
            }
            else {
                originY = viewPositionReference.minY - dropDownViewOffset
            }
        }
        else {
            originY = frame.minY
        }
        
        UIView.animate(withDuration: animated ? 0.5 : 0, delay: 0, usingSpringWithDamping: 0.8, initialSpringVelocity: 0.3, options: .curveLinear, animations: {
            if self.direction == .up {
                self.frame.origin.y = originY
            }
            self.frame.size = CGSize(width: self.dropDownViewWidth, height: 0)
            self.dropDownTableView?.frame.size = CGSize(width: self.dropDownViewWidth, height: 0)
        })
    }
}
//
//  HoundDropDownManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/23/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol HoundDropDownManagerDelegate: AnyObject {
    func willShowDropDown(_ identifier: any HoundDropDownType, animated: Bool)
}

/// Manages multiple `HoundDropDown` instances so callers don't repeat setup code.
/// Each dropdown is referenced by a unique string identifier.
final class HoundDropDownManager<T: HoundDropDownType> {
    typealias Identifier = T
    
    /// Internal representation of a registered drop down
    private struct Entry {
        weak var label: HoundLabel?
        var dropDown: HoundDropDown<T>?
        var direction: HoundDropDownDirection
        var autoscroll: HoundDropDownAutoscroll
    }
    
    // MARK: - Properties
    
    private unowned let rootView: UIView
    private let dataSource: HoundDropDownDataSource
    private unowned let delegate: HoundDropDownManagerDelegate
    private let offset: CGFloat
    
    // Preserve the registration order so drop downs are stacked correctly
    private var order: [Identifier] = []
    private var entries: [Identifier: Entry] = [:]
    
    // MARK: - Main
    
    init(rootView: UIView, dataSource: HoundDropDownDataSource, delegate: HoundDropDownManagerDelegate, offset: CGFloat = Constant.Constraint.Spacing.contentTightIntraVert) {
        self.rootView = rootView
        self.dataSource = dataSource
        self.delegate = delegate
        self.offset = offset
    }
    
    // MARK: - Functions
    
    /// Register a label that will trigger/show a dropdown with the identifier.
    func register(
        identifier: Identifier,
        label: HoundLabel,
        direction: HoundDropDownDirection = .down,
        autoscroll: HoundDropDownAutoscroll = .never
    ) {
        if entries[identifier] == nil {
            order.append(identifier)
        }
        entries[identifier] = Entry(
            label: label,
            dropDown: entries[identifier]?.dropDown,
            direction: direction,
            autoscroll: autoscroll
        )
    }
    
    /// Returns the managed dropdown for identifier if it exists
    func dropDown(for identifier: Identifier) -> HoundDropDown<T>? {
        return entries[identifier]?.dropDown
    }
    
    func label(for identifier: Identifier) -> HoundLabel? {
        return entries[identifier]?.label
    }
    
    /// Show the drop down corresponding to `identifier`.
    /// If a drop down hasn't been created yet one will be lazily instantiated.
    func show(identifier: Identifier, numberOfRowsToShow numberOfRows: CGFloat, animated: Bool) {
        guard let label = entries[identifier]?.label else { return }
        var entry = entries[identifier] ?? Entry(label: label, dropDown: nil, direction: .down, autoscroll: .never)
        
        let referenceFrame = label.superview?.convert(label.frame, to: rootView) ?? label.frame
        
        if entry.dropDown == nil {
            let drop = HoundDropDown<T>()
            drop.setupDropDown(
                identifier: identifier,
                dataSource: dataSource,
                viewPositionReference: referenceFrame,
                offset: offset,
                direction: entry.direction,
                autoscrollBehavior: entry.autoscroll,
            )
            entry.dropDown = drop
            entries[identifier] = entry
        }
        else {
            entry.dropDown?.updateReferenceFrame(referenceFrame)
        }
        
        reorderDropDowns()
        entry.dropDown?.showDropDown(numberOfRowsToShow: numberOfRows, animated: animated, direction: entry.direction)
    }
    
    /// Hide the dropdown for identifier if it is currently showing
    func hide(identifier: Identifier, animated: Bool) {
        entries[identifier]?.dropDown?.hideDropDown(animated: animated)
    }
    
    /// Remove and re-add drop downs so they appear stacked using registration order
    private func reorderDropDowns() {
        let dropDowns = order.compactMap { entries[$0]?.dropDown }
        dropDowns.forEach { $0.removeFromSuperview() }
        for dropDown in dropDowns.reversed() { rootView.addSubview(dropDown) }
    }
    
    func showHideDropDownGesture(identifier: Identifier, delegate: UIGestureRecognizerDelegate) -> UITapGestureRecognizer {
        let gesture = UITapGestureRecognizer(
            target: self,
            action: #selector(HoundDropDownManager.didTapLabel(sender:))
        )
        gesture.name = identifier.rawValue
        gesture.self.delegate = delegate
        gesture.cancelsTouchesInView = false
        return gesture
    }
    
    @objc private func didTapLabel(sender: UITapGestureRecognizer) {
        guard let name = sender.name, let identifier = Identifier(rawValue: name) else {
            HoundLogger.general.warning("HoundDropDownManager.tappedDropDownLabel: No drop down found for identifier \(String(describing: sender.name))")
            return
        }
        
        guard let dropDown = dropDown(for: identifier) else {
            delegate.willShowDropDown(identifier, animated: true)
            return
        }
        
        if !dropDown.isDown {
            delegate.willShowDropDown(identifier, animated: true)
        }
        else {
            dropDown.hideDropDown(animated: true)
        }
    }
    
    @discardableResult
    func hideDropDownIfNotTapped(sender: UITapGestureRecognizer) -> [HoundDropDown<T>] {
        guard let senderView = sender.view else { return [] }
        
        let point = sender.location(in: senderView)
        guard let touched = senderView.hitTest(point, with: nil) else { return [] }
        
        var dropDownsHidden: [HoundDropDown<T>] = []
        for (_, entry) in entries {
            guard let dd = entry.dropDown, let label = entry.label else { continue }
            
            if !touched.isDescendant(of: label) && !touched.isDescendant(of: dd) {
                dd.hideDropDown(animated: true)
                dropDownsHidden.append(dd)
            }
        }
        return dropDownsHidden
    }
}
//
//  HoundDropDownType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/23/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

protocol HoundDropDownType: RawRepresentable, Hashable, CaseIterable where RawValue == String {}
//
//  HoundTabBarController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundTabBarController: UITabBarController, HoundUIProtocol, HoundUIKitProtocol {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - HoundUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            HoundLogger.general.warning("SomeHoundView.setupGeneratedViews: Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            HoundLogger.general.warning("SomeHoundView.addSubViews: Attempting to re-invoke addSubViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            HoundLogger.general.warning("SomeHoundView.setupConstraints: Attempting to re-invoke setupConstraints for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Properties

    /// If true, upon viewIsAppearing and viewDidDisappear, the viewController will add or remove itself from the presentation manager's global presenter stack
    var eligibleForGlobalPresenter: Bool = false {
        didSet {
            if eligibleForGlobalPresenter == false {
                PresentationManager.removeGlobalPresenterFromStack(self)
            }
        }
    }
    
    // MARK: - Main
    
    override func loadView() {
        super.loadView()
        setupGeneratedViews()
    }

    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.addGlobalPresenterToStack(self)
        }
    }

    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.removeGlobalPresenterFromStack(self)
        }
    }
}
//
//  HoundLeftAlignedCollectionViewFlowLayout.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundLeftAlignedCollectionViewFlowLayout: UICollectionViewFlowLayout {
    override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {
        let attributes = super.layoutAttributesForElements(in: rect)
        var leftMargin = sectionInset.left
        var maxY: CGFloat = -1.0
        attributes?.forEach { layoutAttribute in
            if layoutAttribute.representedElementCategory == .cell {
                if layoutAttribute.frame.origin.y >= maxY {
                    leftMargin = sectionInset.left
                }
                layoutAttribute.frame.origin.x = leftMargin
                leftMargin += layoutAttribute.frame.width + minimumInteritemSpacing
                maxY = max(layoutAttribute.frame.maxY, maxY)
            }
        }
        return attributes
    }
}
//
//  HoundTableHeaderFooterView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/20/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundTableHeaderFooterView: HoundHeaderFooterView {
    
    // MARK: - Views
    
    private let headerLabel: HoundLabel = {
        let label = HoundLabel()
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.emphasizedSecondaryHeaderLabel
        return label
    }()
    
    // MARK: - Setup
    
    func setTitle(_ title: String) {
        headerLabel.text = title
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: Constant.Constraint.Spacing.absoluteVertInset),
            // Use .high priority to avoid breaking during table view height estimation
            headerLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset).withPriority(.defaultHigh),
            headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            headerLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
    }
}
//
//  HoundPageSheetHeaderView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/25/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

final class HoundPageSheetHeaderView: HoundView {
    
    // MARK: - Elements
    
    lazy var pageHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 500, compressionResistancePriority: 500)
        label.text = "Default Page Header"
        label.font = Constant.Visual.Font.primaryHeaderLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.textAlignment = useLeftTextAlignment ? .left : .center
        return label
    }()
    
    let backButton: HoundButton = {
        let button = HoundButton(huggingPriority: 490, compressionResistancePriority: 490)
        
        button.tintColor = UIColor.label
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.backgroundCircleTintColor = UIColor.systemBackground
        
        button.shouldRoundCorners = true
        button.shouldDismissParentViewController = true
        return button
    }()
    
    lazy var pageDescriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 480, compressionResistancePriority: 480)
        label.text = "Default Page Description"
        label.font = Constant.Visual.Font.tertiaryHeaderLabel
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.textAlignment = useLeftTextAlignment ? .left : .center
        label.isHidden = !isDescriptionEnabled
        return label
    }()
    
    // MARK: - Properties
    
    var useLeftTextAlignment: Bool = true {
        didSet {
            pageHeaderLabel.textAlignment = useLeftTextAlignment ? .left : .center
            pageDescriptionLabel.textAlignment = useLeftTextAlignment ? .left : .center
            remakeHeaderAndDescriptionConstraints()
        }
    }
    
    var isDescriptionEnabled: Bool = false {
        didSet {
            pageDescriptionLabel.isHidden = !isDescriptionEnabled
            remakeHeaderAndDescriptionConstraints()
        }
    }
    
    // MARK: - Functions
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        self.addSubview(backButton)
        self.addSubview(pageHeaderLabel)
        self.addSubview(pageDescriptionLabel)
    }
    
    private func remakeHeaderAndDescriptionConstraints() {
        // in the process of remaking header constraints when description is still active (not remade yet), may run into issues, so remove description first
        pageDescriptionLabel.snp.removeConstraints()
        
        pageHeaderLabel.snp.remakeConstraints { make in
            make.top.equalTo(self.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset)
            if useLeftTextAlignment {
                make.leading.equalTo(self.snp.leading).offset(Constant.Constraint.Spacing.absoluteHoriInset)
            }
            else {
                make.centerX.equalTo(self.snp.centerX)
            }
            
            if pageDescriptionLabel.isHidden {
                make.bottom.equalTo(self.snp.bottom)
            }
        }
        
        pageDescriptionLabel.snp.remakeConstraints { make in
            if !pageDescriptionLabel.isHidden {
                make.top.equalTo(pageHeaderLabel.snp.bottom).offset(Constant.Constraint.Spacing.contentTallIntraVert)
                make.bottom.equalTo(self.snp.bottom)
                make.horizontalEdges.equalTo(self.snp.horizontalEdges).inset(Constant.Constraint.Spacing.absoluteHoriInset)
            }
        }
    }
    override func setupConstraints() {
        super.setupConstraints()
        
        backButton.snp.makeConstraints { make in
            make.top.equalTo(self.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset)
            // the header should be at least as tall as the back btn
            make.bottom.lessThanOrEqualTo(self.snp.bottom)
            make.leading.equalTo(pageHeaderLabel.snp.trailing).offset(Constant.Constraint.Spacing.contentTightIntraHori)
            make.trailing.equalTo(self.snp.trailing).inset(Constant.Constraint.Spacing.absoluteCircleHoriInset)
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Button.circleHeightMultiplier)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.circleMaxHeight)
            make.width.equalTo(backButton.snp.height)
        }
        
        remakeHeaderAndDescriptionConstraints()
        
    }

}
//
//  HoundHeaderFooterView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/25/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundHeaderFooterView: UITableViewHeaderFooterView, HoundUIProtocol, HoundUIKitProtocol {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - HoundUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            HoundLogger.general.warning("SomeHoundView.setupGeneratedViews: Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            HoundLogger.general.warning("SomeHoundView.addSubViews: Attempting to re-invoke addSubViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            HoundLogger.general.warning("SomeHoundView.setupConstraints: Attempting to re-invoke setupConstraints for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Main
    
    override init(reuseIdentifier: String?) {
        super.init(reuseIdentifier: reuseIdentifier)
        applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func awakeFromNib() {
        super.awakeFromNib()
        fatalError("XIB is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        setupGeneratedViews()
    }
    
}
//
//  HoundEditPageHeaderView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

final class HoundEditPageHeaderView: HoundView {
    
    // MARK: - Elements
    
    private let titleLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 500, compressionResistancePriority: 500)
        label.textAlignment = .center
        label.text = "Default Edit Page Header"
        label.font = Constant.Visual.Font.primaryHeaderLabel
        label.textColor = UIColor.systemBlue
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        return label
    }()
    
    let leadingButton: HoundButton = {
        let button = HoundButton(huggingPriority: 490, compressionResistancePriority: 490)
        button.tintColor = UIColor.systemBlue
        button.isHidden = true
        return button
    }()
    
    let trailingButton: HoundButton = {
        let button = HoundButton(huggingPriority: 490, compressionResistancePriority: 490)
        button.tintColor = UIColor.systemBlue
        button.isHidden = true
        return button
    }()
    
    // MARK: - Properties
    
    /// Controls if the leading button should be visible.
    var isLeadingButtonEnabled: Bool {
        get { !leadingButton.isHidden }
        set {
            leadingButton.isHidden = !newValue
            updateTitleLabelConstraints()
        }
    }
    
    /// Controls if the trailing button should be visible.
    var isTrailingButtonEnabled: Bool {
        get { !trailingButton.isHidden }
        set {
            trailingButton.isHidden = !newValue
            updateTitleLabelConstraints()
        }
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(titleLabel)
        addSubview(leadingButton)
        addSubview(trailingButton)
    }
    
    private func updateTitleLabelConstraints() {
        titleLabel.snp.remakeConstraints { make in
            make.bottom.equalTo(self.snp.bottom).inset(Constant.Constraint.Spacing.absoluteVertInset)
            
            if leadingButton.isHidden && trailingButton.isHidden {
                make.top.equalTo(self.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset)
                make.leading.equalTo(self.snp.leading).offset(Constant.Constraint.Spacing.absoluteHoriInset)
                make.trailing.equalTo(self.snp.trailing).inset(Constant.Constraint.Spacing.absoluteHoriInset)
            }
            else {
                make.top.greaterThanOrEqualTo(self.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset)
                if !leadingButton.isHidden {
                    make.centerY.equalTo(leadingButton.snp.centerY)
                }
                else {
                    make.centerY.equalTo(trailingButton.snp.centerY)
                }
                make.leading.equalTo(leadingButton.snp.trailing).offset(Constant.Constraint.Spacing.contentIntraHori)
                // this number just has to be negative. if i do .offset(Constant.Constraint.Spacing.contentIntraHori), it doesnt work at all lol
                make.trailing.equalTo(trailingButton.snp.leading).inset(-Constant.Constraint.Spacing.contentIntraHori)
            }
        }
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        leadingButton.snp.makeConstraints { make in
            make.top.equalTo(self.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset)
            make.leading.equalTo(self.snp.leading).offset(Constant.Constraint.Spacing.absoluteCircleHoriInset)
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Button.circleHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.circleMaxHeight)
            make.width.equalTo(leadingButton.snp.height)
        }
        
        trailingButton.snp.makeConstraints { make in
            make.top.equalTo(self.snp.top).offset(Constant.Constraint.Spacing.absoluteVertInset)
            make.trailing.equalTo(self.snp.trailing).inset(Constant.Constraint.Spacing.absoluteCircleHoriInset)
            make.height.equalTo(self.snp.width).multipliedBy(Constant.Constraint.Button.circleHeightMultiplier).priority(.high)
            make.height.lessThanOrEqualTo(Constant.Constraint.Button.circleMaxHeight)
            make.width.equalTo(trailingButton.snp.height)
        }
        
        updateTitleLabelConstraints()
    }
    
    // MARK: - Functions
    
    /// Sets the header title text.
    func setTitle(_ title: String) {
        titleLabel.text = title
    }
}
//
//  HoundButton.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/19/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundButton: UIButton, HoundUIProtocol, HoundDynamicBorder, HoundDynamicCorners {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - Properties
    
    var staticCornerRadius: CGFloat?
    /// If true, self.layer.cornerRadius = self.bounds.height / 2 is applied upon bounds change. Otherwise, self.layer.cornerRadius = 0 is applied upon bounds change.
    var shouldRoundCorners: Bool = false {
        didSet {
            updateCornerRounding()
        }
    }
    
    /// If true, upon .touchUpInside the button will dismiss the closest parent UIViewController.
    var shouldDismissParentViewController: Bool = false {
        didSet {
            if shouldDismissParentViewController {
                self.addTarget(self, action: #selector(dismissParentViewController), for: .touchUpInside)
            }
            else {
                self.removeTarget(self, action: #selector(dismissParentViewController), for: .touchUpInside)
            }
        }
    }
    @objc private func dismissParentViewController() {
        self.closestParentViewController?.dismiss(animated: true)
    }
    
    var borderWidth: Double {
        get { Double(self.layer.borderWidth) }
        set { self.layer.borderWidth = CGFloat(newValue) }
    }
    
    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }
    
    var backgroundCircleTintColor: UIColor? {
        didSet {
            updateBackgroundCircle()
        }
    }
    
    /// Using UIImageView to avoid button recursion/layout issues.
    private var backgroundCircleView: UIImageView?
    
    /// The activity indicator used when the button is in a loading state.
    private var loadingIndicator: UIActivityIndicatorView?
    private var beforeLoadingTintColor: UIColor?
    private var beforeLoadingBackgroundCircleTintColor: UIColor?
    private var beforeLoadingBackgroundColor: UIColor?
    private var beforeLoadingBorderColor: UIColor?
    /// Stores the preloading state of `isUserInteractionEnabled` so that it can be restored when loading ends.
    private var beforeLoadingUserInteractionEnabled: Bool?
    /// If `true` the button hides its title/image and shows a spinning indicator instead.
    var isLoading: Bool = false {
        didSet { updateLoadingState() }
    }
    
    // MARK: - Override Properties
    
    /// Resize corner radius when the bounds change
    override var bounds: CGRect {
        didSet {
            updateCornerRounding()
            self.updateScaleImagePointSize()
            self.updateBackgroundCircle()
        }
    }
    
    override var isEnabled: Bool {
        didSet {
            self.alpha = isEnabled ? 1 : 0.5
        }
    }
    
    override var isHidden: Bool {
        didSet {
            backgroundCircleView?.isHidden = isHidden
        }
    }
    
    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Override Functions
    
    override func setImage(_ image: UIImage?, for state: UIControl.State) {
        super.setImage(image, for: state)
        updateScaleImagePointSize()
    }
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        updateDynamicBorderColor(using: previousTraitCollection)
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentHorizontalAlignment = .center
        self.contentVerticalAlignment = .center
        self.contentMode = .scaleToFill
        self.translatesAutoresizingMaskIntoConstraints = false
        
        HoundSizeDebugView.install(on: self)
        
        updateCornerRounding()
        updateScaleImagePointSize()
    }
    
    /// If there is a current, symbol image, scales its point size to the smallest dimension of bounds
    private func updateScaleImagePointSize() {
        guard let currentImage = currentImage, currentImage.isSymbolImage == true else { return }
        let smallestDimension = bounds.height <= bounds.width ? bounds.height : bounds.width
        super.setImage(currentImage.applyingSymbolConfiguration(UIImage.SymbolConfiguration.init(pointSize: smallestDimension)), for: .normal)
    }
    
    private func updateBackgroundCircle() {
        guard let backgroundCircleTintColor = backgroundCircleTintColor else {
            // Remove background circle if tint is cleared
            backgroundCircleView?.removeFromSuperview()
            backgroundCircleView = nil
            return
        }
        
        // If it doesn't exist, create it and insert below imageView
        if backgroundCircleView == nil {
            let image = UIImageView(image: UIImage(systemName: "circle.fill"))
            image.isUserInteractionEnabled = false
            if let imageView = imageView {
                insertSubview(image, belowSubview: imageView)
            }
            else {
                addSubview(image)
            }
            
            backgroundCircleView = image
        }
        
        // Update color and frame each time
        backgroundCircleView?.tintColor = backgroundCircleTintColor
        
        let multiplier = 1.05
        let width = bounds.width / multiplier
        let height = bounds.height / multiplier
        let adjustedBounds = CGRect(
            x: (bounds.width / 2.0) - (width / 2),
            y: (bounds.height / 2.0) - (height / 2),
            width: width,
            height: height)
        
        backgroundCircleView?.frame = adjustedBounds
    }
    
    private func updateLoadingState() {
        if isLoading {
            guard loadingIndicator == nil else { return }
            UIView.animate(withDuration: Constant.Visual.Animation.selectSingleElement) {
                self.beforeLoadingUserInteractionEnabled = self.isUserInteractionEnabled
                self.isUserInteractionEnabled = false
                self.beforeLoadingTintColor = self.tintColor
                self.tintColor = UIColor.systemGray2
                if self.backgroundCircleTintColor != nil {
                    self.beforeLoadingBackgroundCircleTintColor = self.backgroundCircleTintColor
                    self.backgroundCircleTintColor = UIColor.systemGray2
                }
                if self.backgroundColor != nil {
                    self.beforeLoadingBackgroundColor = self.backgroundColor
                    self.backgroundColor = UIColor.systemGray2
                }
                if self.borderColor != nil {
                    self.beforeLoadingBorderColor = self.borderColor
                    self.borderColor = UIColor.systemGray2
                }

                self.titleLabel?.alpha = 0
                self.imageView?.alpha = 0
                
                let indicator = UIActivityIndicatorView(style: .large)
                indicator.translatesAutoresizingMaskIntoConstraints = false
                indicator.hidesWhenStopped = true
                indicator.startAnimating()
                indicator.color = UIColor.systemBackground
                
                self.addSubview(indicator)
                NSLayoutConstraint.activate([
                    indicator.centerYAnchor.constraint(equalTo: self.centerYAnchor),
                    indicator.centerXAnchor.constraint(equalTo: self.centerXAnchor)
                ])
                self.loadingIndicator = indicator
            }
        }
        else {
            guard let indicator = loadingIndicator else { return }
            UIView.animate(withDuration: Constant.Visual.Animation.selectSingleElement) {
                indicator.stopAnimating()
                indicator.removeFromSuperview()
                self.loadingIndicator = nil
                
                self.titleLabel?.alpha = 1
                self.imageView?.alpha = 1
                
                if let before = self.beforeLoadingUserInteractionEnabled {
                    self.isUserInteractionEnabled = before
                    self.beforeLoadingUserInteractionEnabled = nil
                }
                if let before = self.beforeLoadingTintColor {
                    self.tintColor = before
                    self.beforeLoadingTintColor = nil
                }
                if let before = self.beforeLoadingBackgroundCircleTintColor {
                    self.backgroundCircleTintColor = before
                    self.beforeLoadingBackgroundCircleTintColor = nil
                }
                if let before = self.beforeLoadingBackgroundColor {
                    self.backgroundColor = before
                    self.beforeLoadingBackgroundColor = nil
                }
                if let before = self.beforeLoadingBorderColor {
                    self.borderColor = before
                    self.beforeLoadingBorderColor = nil
                }
            }
        }
    }
    
}
//
//  HoundTableViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundTableViewController: UITableViewController, HoundUIProtocol, HoundUIKitProtocol {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - HoundUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            HoundLogger.general.warning("SomeHoundView.setupGeneratedViews: Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            HoundLogger.general.warning("SomeHoundView.addSubViews: Attempting to re-invoke addSubViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            HoundLogger.general.warning("SomeHoundView.setupConstraints: Attempting to re-invoke setupConstraints for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Properties
    
    /// If true, upon viewIsAppearing and viewDidDisappear, the viewController will add or remove itself from the presentation manager's global presenter stack
    var eligibleForGlobalPresenter: Bool = false {
        didSet {
            if eligibleForGlobalPresenter == false {
                PresentationManager.removeGlobalPresenterFromStack(self)
            }
        }
    }
    
    var referenceContentOffsetY: CGFloat?
    
    private var timeZoneObserver: NSObjectProtocol?
    
    // MARK: - Main
    
    override func loadView() {
        super.loadView()
        applyDefaultSetup()
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        timeZoneObserver = NotificationCenter.default.addObserver(
            forName: .didUpdateUserTimeZone,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.didUpdateUserTimeZone()
        }
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.addGlobalPresenterToStack(self)
        }
        
        if referenceContentOffsetY == nil {
            referenceContentOffsetY = tableView.contentOffset.y
        }
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.removeGlobalPresenterFromStack(self)
        }
    }
    
    deinit {
        if let timeZoneObserver = timeZoneObserver {
            NotificationCenter.default.removeObserver(timeZoneObserver)
        }
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.tableView.contentMode = .scaleToFill
        self.tableView.showsHorizontalScrollIndicator = false
        self.tableView.showsVerticalScrollIndicator = false
        self.tableView.separatorStyle = .none
        self.tableView.translatesAutoresizingMaskIntoConstraints = false
        
        setupGeneratedViews()
    }
    
    func didUpdateUserTimeZone() { }
    
}
//
//  HoundScrollView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundScrollView: UIScrollView, HoundUIProtocol, HoundUIKitProtocol {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - HoundUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            HoundLogger.general.warning("SomeHoundView.setupGeneratedViews: Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            HoundLogger.general.warning("SomeHoundView.addSubViews: Attempting to re-invoke addSubViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            HoundLogger.general.warning("SomeHoundView.setupConstraints: Attempting to re-invoke setupConstraints for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }

    // MARK: - Override Properties

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }

    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.isMultipleTouchEnabled = true
        self.contentMode = .scaleToFill
        self.showsHorizontalScrollIndicator = false
        self.showsVerticalScrollIndicator = false
        self.translatesAutoresizingMaskIntoConstraints = false
        
        HoundSizeDebugView.install(on: self)
        
        setupGeneratedViews()
    }
}
//
//  UIViewBadgeExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/4/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import ObjectiveC
import UIKit

// Associated object keys used to store properties on UIView. Swift extensions
// cannot add stored properties, so we use the Objective-C runtime instead.
private var badgeLabelKey: UInt8 = 0
private var badgeValueKey: UInt8 = 1
private var badgeVisibleKey: UInt8 = 2

private final class HoundBadgeLabel: UILabel {
    override func layoutSubviews() {
        super.layoutSubviews()
        self.layer.cornerRadius = bounds.height / 2
        self.layer.masksToBounds = true
    }
}

/// Allows any UIView to display a small numeric badge in its top-right corner.
/// Set `badgeValue` to show a number or assign `nil` to hide the badge.
extension UIView {
    
    private var badgeLabel: HoundBadgeLabel? {
        // Stored via associated objects since extensions can't add properties.
        get { objc_getAssociatedObject(self, &badgeLabelKey) as? HoundBadgeLabel }
        set { objc_setAssociatedObject(self, &badgeLabelKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
    }
    
    private var storedBadgeValue: Int? {
        // Backing storage for the public badgeValue property.
        get { objc_getAssociatedObject(self, &badgeValueKey) as? Int }
        set { objc_setAssociatedObject(self, &badgeValueKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
    }
    
    private var storedBadgeVisible: Bool {
        get { (objc_getAssociatedObject(self, &badgeVisibleKey) as? Bool) ?? false }
        set { objc_setAssociatedObject(self, &badgeVisibleKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
    }
    
    /// Controls visibility of badge (text or empty)
    var badgeVisible: Bool {
        get { storedBadgeVisible }
        set {
            storedBadgeVisible = newValue
            updateBadgeAppearance()
        }
    }
    
    /// Value to display inside badge. Setting to nil means no text.
    var badgeValue: Int? {
        get { storedBadgeValue }
        set {
            storedBadgeValue = newValue
            updateBadgeAppearance()
        }
    }
    
    private func updateBadgeAppearance() {
        // If badge should ever be shown, ensure label exists
        if badgeVisible {
            createBadgeLabelIfNeeded()
            badgeLabel?.isHidden = false
            if let value = badgeValue {
                badgeLabel?.text = String(value)
            }
            else {
                badgeLabel?.text = nil // Show badge, but no text
            }
        }
        else {
            badgeLabel?.isHidden = true
        }
    }
    
    private func createBadgeLabelIfNeeded() {
        guard badgeLabel == nil else { return }
        
        let label = HoundBadgeLabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.textAlignment = .center
        label.font = Constant.Visual.Font.badgeLabel
        label.minimumScaleFactor = 0.0
        label.adjustsFontSizeToFitWidth = true
        
        label.backgroundColor = UIColor.houndYellow
        
        label.textColor = UIColor.label
        
        addSubview(label)
        
        // Square with side equal to min(0.2 * width, 0.2 * height)
        let ratio: CGFloat = 0.35
        NSLayoutConstraint.activate([
            label.topAnchor.constraint(equalTo: self.topAnchor),
            label.trailingAnchor.constraint(equalTo: self.trailingAnchor),
            label.widthAnchor.constraint(equalTo: self.widthAnchor, multiplier: ratio).withPriority(.defaultHigh),
            label.heightAnchor.constraint(equalTo: self.heightAnchor, multiplier: ratio).withPriority(.defaultHigh),
            label.createSquareAspectRatio()
        ])
        
        badgeLabel = label
    }
}
//
//  UIViewErrorExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/17/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

private var houndErrorLabelKey: UInt8 = 0
private var errorMessageChangesBorderKey: UInt8 = 6

// both
private var originalBorderWidthKey: UInt8 = 1
private var originalBorderColorKey: UInt8 = 2

// hound stylable
private var originalShouldRoundCornersKey: UInt8 = 3

// non hound stylable
private var originalCornerRadiusKey: UInt8 = 4
private var originalCornerCurveKey: UInt8 = 5

extension UIView {

    /// Optional message describing an input error. Setting a non-nil value
    /// outlines the view in red and displays the message below it. Setting to
    /// `nil` removes the error UI.
    var errorMessage: String? {
        get {
            (objc_getAssociatedObject(self, &houndErrorLabelKey) as? HoundLabel)?.text
        }
        set {
            guard let message = newValue, message.isEmpty == false else {
                removeErrorMessage()
                return
            }
            showErrorMessage(message)
        }
    }
    var errorMessageChangesBorder: Bool {
        get {
            (objc_getAssociatedObject(self, &errorMessageChangesBorderKey) as? Bool) ?? true
        }
        set {
            objc_setAssociatedObject(self, &errorMessageChangesBorderKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
    }

    private func showErrorMessage(_ message: String) {
        var label = objc_getAssociatedObject(self, &houndErrorLabelKey) as? HoundLabel
        if label == nil {
            let newLabel = HoundLabel()
            newLabel.font = Constant.Visual.Font.tertiaryRegularLabel
            newLabel.textColor = UIColor.systemRed
            newLabel.numberOfLines = 0
            newLabel.lineBreakMode = .byWordWrapping
            newLabel.adjustsFontSizeToFitWidth = false
            newLabel.translatesAutoresizingMaskIntoConstraints = false
            objc_setAssociatedObject(self, &houndErrorLabelKey, newLabel, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
            label = newLabel

            if let superview = self.superview {
                superview.addSubview(newLabel)
                NSLayoutConstraint.activate([
                    newLabel.topAnchor.constraint(equalTo: self.bottomAnchor),
                    newLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor),
                    newLabel.trailingAnchor.constraint(equalTo: self.trailingAnchor)
                ])
            }
        }

        label?.text = message
        label?.isHidden = false

        if objc_getAssociatedObject(self, &originalBorderWidthKey) == nil {
            objc_setAssociatedObject(self, &originalBorderWidthKey, layer.borderWidth, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
        
        if let styleable = self as? HoundBorderStylable {
            if objc_getAssociatedObject(self, &originalBorderColorKey) == nil {
                objc_setAssociatedObject(self, &originalBorderColorKey, styleable.borderColor, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
            }
            if objc_getAssociatedObject(self, &originalShouldRoundCornersKey) == nil {
                objc_setAssociatedObject(self, &originalShouldRoundCornersKey, styleable.shouldRoundCorners, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
            }
        }
        else {
            if objc_getAssociatedObject(self, &originalBorderColorKey) == nil, let layerBorderColor = layer.borderColor {
                // cannot encode CGColor
                objc_setAssociatedObject(self, &originalBorderColorKey, UIColor(cgColor: layerBorderColor), .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
            }
            if objc_getAssociatedObject(self, &originalCornerRadiusKey) == nil {
                objc_setAssociatedObject(self, &originalCornerRadiusKey, layer.cornerRadius, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
            }
            if objc_getAssociatedObject(self, &originalCornerCurveKey) == nil {
                objc_setAssociatedObject(self, &originalCornerCurveKey, layer.cornerCurve, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
            }
        }
        
        guard errorMessageChangesBorder else {
            return
        }

        if let styleable = self as? (UIView & HoundBorderStylable) {
            styleable.applyStyle(.redBorder)
        }
        else {
            layer.borderColor = HoundBorderStyle.redBorder.borderColor.cgColor
            layer.borderWidth = HoundBorderStyle.redBorder.borderWidth
            layer.cornerRadius = Constant.Visual.Layer.defaultCornerRadius
            layer.cornerCurve = .continuous
        }
    }

    private func removeErrorMessage() {
        if let label = objc_getAssociatedObject(self, &houndErrorLabelKey) as? HoundLabel {
            label.removeFromSuperview()
            objc_setAssociatedObject(self, &houndErrorLabelKey, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
        
        guard errorMessageChangesBorder else {
            return
        }

        // Restore original border
        if let styleable = self as? HoundBorderStylable {
            styleable.borderWidth = objc_getAssociatedObject(self, &originalBorderWidthKey) as? CGFloat ?? styleable.borderWidth
            styleable.borderColor = objc_getAssociatedObject(self, &originalBorderColorKey) as? UIColor
            styleable.shouldRoundCorners = objc_getAssociatedObject(self, &originalShouldRoundCornersKey) as? Bool ?? styleable.shouldRoundCorners
        }
        else {
            layer.borderColor = (objc_getAssociatedObject(self, &originalBorderColorKey) as? UIColor)?.cgColor ?? layer.borderColor
            layer.borderWidth = objc_getAssociatedObject(self, &originalBorderWidthKey) as? CGFloat ?? layer.borderWidth
            layer.cornerRadius = objc_getAssociatedObject(self, &originalCornerRadiusKey) as? CGFloat ?? layer.cornerRadius
            layer.cornerCurve = objc_getAssociatedObject(self, &originalCornerCurveKey) as? CALayerCornerCurve ?? layer.cornerCurve
        }

        // Remove stored original border values
        objc_setAssociatedObject(self, &originalBorderColorKey, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        objc_setAssociatedObject(self, &originalBorderWidthKey, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        objc_setAssociatedObject(self, &originalBorderColorKey, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        objc_setAssociatedObject(self, &originalShouldRoundCornersKey, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        objc_setAssociatedObject(self, &originalCornerRadiusKey, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        objc_setAssociatedObject(self, &originalCornerCurveKey, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
    }
}
//
//  UIApplicationExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/3/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIApplication {
    
    /// Special keyWindow
    static var keyWindow: UIWindow? {
        // Get connected scenes
        return UIApplication.shared.connectedScenes
        // Keep only active scenes, onscreen and visible to the user
            .filter { $0.activationState == .foregroundActive }
        // Keep only the first `UIWindowScene`
            .first(where: { $0 is UIWindowScene })
        // Get its associated windows
            .flatMap({ $0 as? UIWindowScene })?.windows
        // Finally, keep only the key window
            .first(where: \.isKeyWindow)
    }
}
//
//  UIViewControllerExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/30/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIViewController {
    
    @objc func dismissKeyboard() {
        self.view.dismissKeyboard()
    }
    
    /// Performs recursive dismisses without animation until the next presentingViewController is the same class as ofClass, then performs a dismiss with animation to that viewController of equal ofClass and invokes completionHandler once that finishes. If we run out of presentingViewController without finding one of ofClass, then completionHandler is not include
    func dismissToViewController(ofClass: AnyClass, completionHandler: (() -> Void)?) {
        // If we want to dismiss the self, we must make sure its presentedViewController is dismised
        self.presentedViewController?.dismiss(animated: false)
        
        guard self.isKind(of: ofClass) == false else {
            // We already have dismissed to that viewController of ofClass
            completionHandler?()
            return
        }
        
        // With a UITabBarController and UINavigationStack, self.presentingViewController is not a solely reliable way to iterate backwards through the "stack" of presents, segues, modal presentations, etc. Instead, we rely upon the fact that globalPresenter is set by viewIsAppearing, which is invoked after a dismiss is complete
        
        if self.presentingViewController?.isKind(of: ofClass) == true {
            // presentingViewController is ofClass, so perform animations as this is the final dismiss
            self.dismiss(animated: true, completion: completionHandler)
        }
        else if self.isBeingPresented == true || self.presentingViewController != nil {
            // self.presentingViewController before dismiss and PresentationManager.globalPresenter can be the same, or they can be different. viewIsAppearing of views that appear after dismiss can change PresentationManager.globalPresenter.
            // This view controller is being presented, so calling dismiss(animated:completion:) will actually dismiss something.
            self.dismiss(animated: false) {
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ofClass, completionHandler: completionHandler)
            }
        }
        else {
            // This view controller is NOT being presented, so calling dismiss(animated:completion:) won't do anything. Therefore, we ran out of places to dismiss to and didn't reach ofClass.
            completionHandler?()
        }
        
    }
    
    func embedChild(_ child: UIViewController) {
        addChild(child)
        view.addSubview(child.view)
        child.view.translatesAutoresizingMaskIntoConstraints = false
        child.didMove(toParent: self)
    }
    
}
//
//  UIViewExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/20/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIView {
    
    /// Once called, any future taps to the view will call dismissKeyboard.
    func dismissKeyboardOnTap(delegate: UIGestureRecognizerDelegate) {
        let tap: UITapGestureRecognizer = UITapGestureRecognizer(
            target: self,
            action: #selector(self.dismissKeyboard)
        )
        
        tap.self.delegate = delegate
        tap.cancelsTouchesInView = false
        
        self.addGestureRecognizer(tap)
    }
    
    /// Invokes endEditing(true). This method looks at the current view and its subview hierarchy for the text field that is currently the first responder. If it finds one, it asks that text field to resign as first responder. If the force parameter is set to true, the text field is never even asked; it is forced to resign.
    @objc func dismissKeyboard() {
        self.endEditing(true)
    }
    
    enum SetRoundedCorners {
        case none
        case top
        case bottom
        case all
    }
    func roundCorners(setCorners: SetRoundedCorners) {
        switch setCorners {
        case .none:
            self.layer.maskedCorners = []
        case .top:
            self.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]
        case .bottom:
            self.layer.maskedCorners = [.layerMinXMaxYCorner, .layerMaxXMaxYCorner]
        case .all:
            self.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner, .layerMinXMaxYCorner, .layerMaxXMaxYCorner]
        }
        
        self.layer.cornerRadius = Constant.Visual.Layer.defaultCornerRadius
        self.layer.cornerCurve = .continuous
    }
    
    enum AddRoundedCorners {
        case top
        case bottom
        case all
    }
    func roundCorners(addCorners: AddRoundedCorners) {
        switch addCorners {
        case .top:
            self.layer.maskedCorners.insert([.layerMinXMinYCorner, .layerMaxXMinYCorner])
        case .bottom:
            self.layer.maskedCorners.insert([.layerMinXMaxYCorner, .layerMaxXMaxYCorner])
        case .all:
            self.layer.maskedCorners.insert([.layerMinXMinYCorner, .layerMaxXMinYCorner, .layerMinXMaxYCorner, .layerMaxXMaxYCorner])
        }
        
        self.layer.cornerRadius = Constant.Visual.Layer.defaultCornerRadius
        self.layer.cornerCurve = .continuous
    }
    
    var closestParentViewController: UIViewController? {
        var parentResponder: UIResponder? = self
        while parentResponder != nil {
            parentResponder = parentResponder?.next
            if let viewController = parentResponder as? UIViewController {
                return viewController
            }
        }
        return nil
    }
    
    func createAbsHoriInset(_ relativeTo: UIView) -> [NSLayoutConstraint] {
        return [
            self.leadingAnchor.constraint(equalTo: relativeTo.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            self.trailingAnchor.constraint(equalTo: relativeTo.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ]
    }
    func createHeightMultiplier(_ multiplier: CGFloat, relativeToWidthOf: UIView) -> NSLayoutConstraint {
        return self.heightAnchor.constraint(equalTo: relativeToWidthOf.widthAnchor, multiplier: multiplier).withPriority(.defaultHigh)
    }
    func createMaxHeight(_ constant: CGFloat) -> NSLayoutConstraint {
        return self.heightAnchor.constraint(lessThanOrEqualToConstant: constant)
    }
    func createSquareAspectRatio() -> NSLayoutConstraint {
        return createAspectRatio(1.0)
    }
    func createAspectRatio(_ widthToHeightRatio: CGFloat) -> NSLayoutConstraint {
        return self.widthAnchor.constraint(equalTo: self.heightAnchor, multiplier: widthToHeightRatio)
    }
    func checkForOversizedFrame() {
        let maxReasonableSize: CGFloat = 5000
        if bounds.width > maxReasonableSize || bounds.height > maxReasonableSize {
            HoundLogger.general.error(
                """
                WARNING: Oversized frame detected.
                Frame: \(self.bounds.width) x \(self.bounds.height)
                Self: \(String(describing: self))
                Superview: \(String(describing: self.superview))
                Stack: \(Thread.callStackSymbols.joined(separator: "\n"))
                """
            )
        }
    }
}
//
//  UIScrollViewExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/8/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIScrollView {
    func onlyScrollIfBigger() {
        // Only bounce if content is larger
        self.alwaysBounceVertical = false
        // Allow bounce if scrollable
        self.bounces = true
        // Default: scrolling is enabled if needed
        self.isScrollEnabled = true
    }
}
//
//  UIImageExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/30/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIImage {
    func isEqualToImage(image: UIImage) -> Bool {
        let data1 = self.pngData()
        let data2 = image.pngData()
        return data1 == data2
    }
}
//
//  HoundTableViewCell.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundTableViewCell: UITableViewCell, HoundUIProtocol, HoundUIKitProtocol {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - HoundUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            HoundLogger.general.warning("SomeHoundView.setupGeneratedViews: Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            HoundLogger.general.warning("SomeHoundView.addSubViews: Attempting to re-invoke addSubViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            HoundLogger.general.warning("SomeHoundView.setupConstraints: Attempting to re-invoke setupConstraints for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func awakeFromNib() {
        super.awakeFromNib()
        fatalError("XIB is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        selectionStyle = .none
        backgroundColor = UIColor.clear
        contentView.backgroundColor = UIColor.clear
        selectedBackgroundView?.backgroundColor = UIColor.clear
        
        setupGeneratedViews()
    }

}
//
//  HoundTextField.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/30/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class HoundTextField: UITextField, HoundUIProtocol, HoundDynamicBorder, HoundDynamicCorners {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - Properties
    
    var staticCornerRadius: CGFloat? = Constant.Visual.Layer.defaultCornerRadius
    /// If true, self.layer.cornerRadius = Constant.Visual.Layer.defaultCornerRadius. Otherwise, self.layer.cornerRadius = 0.
    var shouldRoundCorners: Bool = false {
        didSet {
            updateCornerRounding()
        }
    }
    
    var borderWidth: Double {
        get {
            Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }
    
    override var bounds: CGRect {
        didSet {
            updateCornerRounding()
        }
    }
    
    override var isEnabled: Bool {
        didSet {
            self.alpha = isEnabled ? 1 : 0.5
        }
    }
    
    /// Insets for all text/placeholder content.
    var textInsets: UIEdgeInsets = .zero {
        didSet { setNeedsDisplay(); invalidateIntrinsicContentSize() }
    }
    
    /// If true, standard insets are applied to text/placeholder; otherwise, no inset.
    var shouldInsetText: Bool = false {
        didSet {
            textInsets = shouldInsetText
            ? UIEdgeInsets(
                top: ConstraintConstant.Spacing.contentTightIntraVert,
                left: ConstraintConstant.Spacing.contentIntraHori,
                bottom: ConstraintConstant.Spacing.contentTightIntraVert,
                right: ConstraintConstant.Spacing.contentIntraHori)
            : .zero
        }
    }
    
    // MARK: - Main
    
    init(
        huggingPriority: Float = UILayoutPriority.defaultLow.rawValue,
        compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue
    ) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        applyDefaultSetup()
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Override Functions
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        updateDynamicBorderColor(using: previousTraitCollection)
    }
    
    override func textRect(forBounds bounds: CGRect) -> CGRect {
        return bounds.inset(by: textInsets)
    }
    
    override func editingRect(forBounds bounds: CGRect) -> CGRect {
        return bounds.inset(by: textInsets)
    }
    
    override func placeholderRect(forBounds bounds: CGRect) -> CGRect {
        return bounds.inset(by: textInsets)
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.contentHorizontalAlignment = .left
        self.contentVerticalAlignment = .center
        self.translatesAutoresizingMaskIntoConstraints = false
        self.textAlignment = .natural
        self.clearsOnBeginEditing = true
        self.font = Constant.Visual.Font.primaryRegularLabel
        
        HoundSizeDebugView.install(on: self)
        
        updateCornerRounding()
    }
    
}
//
//  HoundSizeDebugView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/26/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

private extension UIApplication {
    /// Finds the currently visible (topmost) view controller.
    func topMostViewController() -> UIViewController? {
        guard var top = UIApplication.keyWindow?.rootViewController else { return nil }
        while true {
            if let presented = top.presentedViewController {
                top = presented
            }
            else if let nav = top as? UINavigationController, let v = nav.visibleViewController {
                top = v
            }
            else if let tab = top as? UITabBarController, let v = tab.selectedViewController {
                top = v
            }
            else {
                break
            }
        }
        return top
    }
}

final class HoundSizeDebugView: UIView {
    
    // MARK: - Properties
    
    private weak var targetView: UIView?
    private weak var targetVC: UIViewController?
    private let label = UILabel()
    private var cleanupTimer: Timer?
    
    /// If true, all overlays are permanently disabled and will never reappear.
    private static var permanentlyDisabled = true
    
    // MARK: - Shared state
    
    private static let overlays = NSHashTable<HoundSizeDebugView>.weakObjects()
    private static var highlightsVisible = false
    private static var highlightBoxes: [UIView] = []
    
    // MARK: - Init & teardown
    
    init(measuring view: UIView) {
        super.init(frame: .zero)
        targetView = view
        targetVC = view.closestParentViewController
        setupLabel()
        guard Self.permanentlyDisabled == false else {
            // If overlays were nuked before init, never add self.
            return
        }
        Self.overlays.add(self)
        startCleanupLoop()
    }
    
    required init?(coder: NSCoder) { fatalError("not supported") }
    
    deinit { cleanupTimer?.invalidate() }
    
    private func setupLabel() {
        backgroundColor = UIColor.systemGray
        label.font = .systemFont(ofSize: 8, weight: .medium)
        label.textColor = UIColor.systemBackground
        label.isUserInteractionEnabled = true
        addSubview(label)
        
        // Single tap toggles border overlays
        let tap = UITapGestureRecognizer(target: self, action: #selector(toggleHighlights))
        label.addGestureRecognizer(tap)
        
        // Long press removes ALL overlays and disables debug forever
        let longPress = UILongPressGestureRecognizer(target: self, action: #selector(handleLongPress))
        longPress.minimumPressDuration = 0.7
        label.addGestureRecognizer(longPress)
        
        layer.zPosition = CGFloat(Float.greatestFiniteMagnitude)
    }
    
    // MARK: - Layout
    
    override func layoutSubviews() {
        super.layoutSubviews()
        guard let target = targetView, let host = superview else { return }
        // update label text
        let w = Int(target.bounds.width), h = Int(target.bounds.height)
        label.text = "\(w)×\(h)"
        label.sizeToFit()
        
        // position over target
        let origin = target.convert(CGPoint.zero, to: host)
        let newSize = CGSize(width: label.frame.width + 4,
                             height: label.frame.height + 4)
        frame = CGRect(origin: origin, size: newSize)
        label.frame.origin = CGPoint(x: 2, y: 2)
    }
    
    // MARK: - Highlight toggle
    
    @objc private func toggleHighlights() {
        // If overlays are disabled, don't allow toggling highlights.
        guard Self.permanentlyDisabled == false else { return }
        
        // clear existing
        Self.highlightBoxes.forEach { $0.removeFromSuperview() }
        Self.highlightBoxes.removeAll()
        
        Self.highlightsVisible.toggle()
        guard Self.highlightsVisible else { return }
        
        // draw new highlight boxes
        for overlay in Self.overlays.allObjects {
            guard
                let tgt = overlay.targetView,
                let container = overlay.superview
            else { continue }
            
            let boxFrame = tgt.convert(tgt.bounds, to: container)
            let box = UIView(frame: boxFrame)
            box.layer.borderWidth = HoundBorderStyle.redBorder.borderWidth
            box.layer.borderColor = HoundBorderStyle.redBorder.borderColor.cgColor
            box.layer.zPosition = CGFloat(Float.greatestFiniteMagnitude)
            box.isUserInteractionEnabled = false
            container.addSubview(box)
            Self.highlightBoxes.append(box)
        }
    }
    
    // MARK: - Long press destroyer
    
    /// Handles long-press on any label. Nukes all overlays and permanently disables further debug overlays.
    @objc private func handleLongPress(_ sender: UILongPressGestureRecognizer) {
        guard sender.state == .began else { return }
        
        // Permanently disable overlays for the lifetime of the app
        Self.permanentlyDisabled = true
        
        // Remove all overlays immediately
        for overlay in Self.overlays.allObjects {
            overlay.removeOverlay()
        }
        Self.overlays.removeAllObjects()
        
        // Remove all highlight boxes
        Self.highlightBoxes.forEach { $0.removeFromSuperview() }
        Self.highlightBoxes.removeAll()
        
        // Once nuked, overlays/highlights never reappear (even if install is called again)
    }
    
    // MARK: - Cleanup loop
    
    private func startCleanupLoop() {
        cleanupTimer = Timer.scheduledTimer(withTimeInterval: 0.05, repeats: true) { [weak self] _ in
            guard
                let self = self,
                let tv = self.targetView,
                let vc = self.targetVC
            else {
                self?.removeOverlay()
                return
            }
            
            // 1) removed from hierarchy?
            if tv.superview == nil {
                removeOverlay(); return
            }
            // 2) VC still topmost?
            if UIApplication.shared.topMostViewController() !== vc {
                removeOverlay(); return
            }
            // 3) still around → update
            self.setNeedsLayout()
        }
    }
    
    private func removeOverlay() {
        cleanupTimer?.invalidate()
        removeFromSuperview()
    }
    
    // MARK: - Installer
    
    /// Installs a size debug overlay for the given view, unless overlays are permanently disabled.
    static func install(on view: UIView) {
        guard Constant.Development.isProduction == false else { return }
        guard Self.permanentlyDisabled == false else { return }
        DispatchQueue.main.async {
            let host = findNonClippingAncestor(of: view) ?? view.superview
            guard let container = host else { return }
            
            // avoid dupes
            if container.subviews.contains(where: {
                ($0 as? HoundSizeDebugView)?.targetView === view
            }) { return }
            
            let overlay = HoundSizeDebugView(measuring: view)
            container.addSubview(overlay)
            overlay.setNeedsLayout()
            overlay.layoutIfNeeded()
        }
    }
    
    private static func findNonClippingAncestor(of view: UIView) -> UIView? {
        var c = view.superview
        while let cand = c {
            if !cand.clipsToBounds { return cand }
            c = cand.superview
        }
        return nil
    }
}
//
//  HoundAlarmAlertController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/23/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import UIKit

final class HoundAlarmAlertController: UIAlertController {
    
    // MARK: - Properties

    /// If nil, this HoundAlarmAlertController has not been combined. If non-nil, this HoundAlarmAlertController has been combined into another HoundAlarmAlertController.
    private(set) var absorbedIntoAlarmAlertController: HoundAlarmAlertController?

    /// The dogUUID that the HoundAlarmAlertController is alerting about
    private(set) var dogUUID: UUID?

    /// The reminder(s) that the HoundAlarmAlertController is alerting about
    private(set) var reminders: [Reminder]?

    // MARK: - Main

    /// UIAlertController can't be subclassed. Therefore, we can't override the init functions.
    func setup(dogUUID: UUID, reminder: Reminder) {
        self.dogUUID = dogUUID
        self.reminders = [reminder]
    }

    // MARK: - Functions

    /// If the provided HoundAlarmAlertController contains matching data, incorporates that data into self and removes the data from the provided HoundAlarmAlertController. Returns true if successfully absorbed other view controller.
    func absorb(_ absorbFromAlarmAlertController: HoundAlarmAlertController) -> Bool {
        // We don't want to absorb a HoundAlarmAlertController that has already been HoundAlarmAlertController
        guard absorbFromAlarmAlertController.absorbedIntoAlarmAlertController == nil else {
            return false
        }

        // Check that both HoundAlarmAlertController both are setup with reminders
        guard let selfReminder = reminders?.first, let absorbedReminder = absorbFromAlarmAlertController.reminders?.first else {
            return false
        }
        
        // Check that both HoundAlarmAlertController both reference the same dog
        guard let selfDogUUID = dogUUID, let absorbedDogUUID = absorbFromAlarmAlertController.dogUUID, selfDogUUID == absorbedDogUUID else {
            return false
        }

        // Check that both HoundAlarmAlertController both reference reminders with the same reminderActionType
        guard selfReminder.reminderActionType == absorbedReminder.reminderActionType  else {
            return false
        }

        // If reminderActionType is .custom, check that both HoundAlarmAlertController both reference reminders with the same reminderCustomActionName
        guard selfReminder.reminderActionType.allowsCustom == false || (selfReminder.reminderCustomActionName == absorbedReminder.reminderCustomActionName) else {
            return false
        }

        // Both HoundAlarmAlertController are the same. Add their components together
        self.reminders = (self.reminders ?? []) + (absorbFromAlarmAlertController.reminders ?? [])

        // absorbFromAlarmAlertController should now be dismantled
        absorbFromAlarmAlertController.absorbedIntoAlarmAlertController = self
        absorbFromAlarmAlertController.dogUUID = nil
        absorbFromAlarmAlertController.reminders = nil

        return true
    }
}
import UIKit

final class HoundTableView: UITableView, HoundUIProtocol, HoundDynamicBorder, HoundDynamicCorners {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - Properties

    var shouldAutomaticallyAdjustHeight: Bool = false {
        didSet {
            if shouldAutomaticallyAdjustHeight {
                self.invalidateIntrinsicContentSize()
                self.layoutIfNeeded()
            }
        }
    }

    /// Optional view to display when table is empty. If nil, falls back to a message label.
    private var emptyStateView: UIView?
    var emptyStateEnabled: Bool = false
    /// Message string to show if table is empty and no custom view is set.
    var emptyStateMessage: String = "No content available..."
    var emptyStateMessageColor: UIColor = UIColor.label
    /// Minimum height for the empty state (when using automatic height adjustment).
    var minimumEmptyStateHeight: CGFloat = 60.0

    var staticCornerRadius: CGFloat? = Constant.Visual.Layer.defaultCornerRadius
    var shouldRoundCorners: Bool = false {
        didSet {
            updateCornerRounding()
        }
    }

    var borderWidth: Double {
        get { Double(self.layer.borderWidth) }
        set { self.layer.borderWidth = CGFloat(newValue) }
    }

    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }

    var shadowColor: UIColor? {
        didSet {
            if let shadowColor = shadowColor {
                self.layer.shadowColor = shadowColor.cgColor
            }
        }
    }

    var shadowOffset: CGSize? {
        didSet {
            if let shadowOffset = shadowOffset {
                self.layer.shadowOffset = shadowOffset
            }
        }
    }

    var shadowRadius: CGFloat? {
        didSet {
            if let shadowRadius = shadowRadius {
                self.layer.shadowRadius = shadowRadius
            }
        }
    }

    var shadowOpacity: Float? {
        didSet {
            if let shadowOpacity = shadowOpacity {
                self.layer.shadowOpacity = shadowOpacity
            }
        }
    }

    // MARK: - Override Properties

    override var intrinsicContentSize: CGSize {
        if shouldAutomaticallyAdjustHeight {
            self.layoutIfNeeded()
            let totalRows = numberOfRowsInAllSections()
            if totalRows == 0 && emptyStateEnabled {
                // If empty, ensure there's at least enough space for the empty state
                return CGSize(width: UIView.noIntrinsicMetric, height: minimumEmptyStateHeight)
            }
            else {
                return CGSize(width: UIView.noIntrinsicMetric, height: contentSize.height)
            }
        }
        else {
            return super.intrinsicContentSize
        }
    }

    override var contentSize: CGSize {
        didSet {
            if shouldAutomaticallyAdjustHeight {
                invalidateIntrinsicContentSize()
            }
        }
    }

    override var bounds: CGRect {
        didSet {
            updateCornerRounding()
        }
    }

    override var isUserInteractionEnabled: Bool {
        didSet {
            self.alpha = isUserInteractionEnabled ? 1 : 0.5
        }
    }

    // MARK: - Main
    
    init(style: UITableView.Style, huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero, style: style)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero, style: .plain)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect, style: UITableView.Style) {
        super.init(frame: frame, style: style)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
        updateEmptyStateIfNeeded()
    }

    // MARK: - Override Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.showsHorizontalScrollIndicator = false
        self.showsVerticalScrollIndicator = false
        self.separatorStyle = .none
        self.translatesAutoresizingMaskIntoConstraints = false
        self.sectionHeaderTopPadding = 0
        self.backgroundColor = .systemBackground
        
        HoundSizeDebugView.install(on: self)
        updateCornerRounding()
        updateEmptyStateIfNeeded()
    }

    override func reloadData() {
        super.reloadData()
        if shouldAutomaticallyAdjustHeight {
            self.invalidateIntrinsicContentSize()
        }
        updateEmptyStateIfNeeded()
    }

    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        updateDynamicBorderColor(using: previousTraitCollection)

        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            if let shadowColor = shadowColor {
                self.layer.shadowColor = shadowColor.cgColor
            }
        }
    }

    // MARK: - Empty State Handling

    /// Sets a custom view for the empty state (removes previous).
    func setEmptyStateView(_ view: UIView) {
        emptyStateView?.removeFromSuperview()
        emptyStateView = view
        updateEmptyStateIfNeeded()
    }

    /// Helper: Counts all rows in all sections.
    private func numberOfRowsInAllSections() -> Int {
        let dataSource = self.dataSource
        let sections = dataSource?.numberOfSections?(in: self) ?? 1
        var totalRows = 0
        for section in 0..<sections {
            totalRows += dataSource?.tableView(self, numberOfRowsInSection: section) ?? 0
        }
        return totalRows
    }

    /// Call this after data changes to update the empty state view.
    private func updateEmptyStateIfNeeded() {
        let totalRows = numberOfRowsInAllSections()
        guard emptyStateEnabled && totalRows == 0 else {
            emptyStateView?.removeFromSuperview()
            return
        }
        
        if emptyStateView == nil {
            let label = HoundLabel()
            // this label will get resized like crazy when the table view is resized, but we dont really care so disable the message
            label.debugCheckForOversizedFrame = false
            label.textAlignment = .center
            label.numberOfLines = 0
            label.lineBreakMode = .byWordWrapping
            label.adjustsFontSizeToFitWidth = false
            label.text = emptyStateMessage
            label.textColor = emptyStateMessageColor
            
            setEmptyStateView(label)
        }
        if let emptyView = emptyStateView, emptyView.superview !== self {
            self.addSubview(emptyView)
            NSLayoutConstraint.activate([
                emptyView.centerYAnchor.constraint(equalTo: self.centerYAnchor),
                emptyView.centerXAnchor.constraint(equalTo: self.centerXAnchor)
            ])
        }
    }
}
//
//  HoundSegmentedControl.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundSegmentedControl: UISegmentedControl, HoundUIProtocol, HoundUIKitProtocol {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - HoundUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            HoundLogger.general.warning("SomeHoundView.setupGeneratedViews: Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            HoundLogger.general.warning("SomeHoundView.addSubViews: Attempting to re-invoke addSubViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            HoundLogger.general.warning("SomeHoundView.setupConstraints: Attempting to re-invoke setupConstraints for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }

    // MARK: - Override Properties

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }

    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.contentHorizontalAlignment = .left
        self.contentVerticalAlignment = .top
        self.apportionsSegmentWidthsByContent = true
        self.translatesAutoresizingMaskIntoConstraints = false
        
        HoundSizeDebugView.install(on: self)
        
        self.addTarget(self, action: #selector(handleValueChanged), for: .valueChanged)
        
        setupGeneratedViews()
    }
    
    @objc private func handleValueChanged() {
        // No need to check isTracking (only user interaction triggers .valueChanged)
        // DIFFERENT THAN HOW UISWITCH WORKS
        HapticsManager.selectionChanged()
    }
}
//
//  HoundLabel.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/3/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import SnapKit
import UIKit

final class HoundLabel: UILabel, HoundUIProtocol, HoundDynamicBorder, HoundDynamicCorners {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - Properties
    
    var debugCheckForOversizedFrame: Bool = true
    
    var staticCornerRadius: CGFloat? = Constant.Visual.Layer.defaultCornerRadius
    var shouldRoundCorners: Bool = false {
        didSet {
            updateCornerRounding()
        }
    }
    
    var borderWidth: Double {
        get {
            Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }
    
    override var bounds: CGRect {
        didSet {
            if oldValue != bounds {
                updateCornerRounding()
            }
        }
    }
    
    override var isEnabled: Bool {
        didSet {
            self.isUserInteractionEnabled = isEnabled
            self.alpha = isEnabled ? 1 : 0.5
        }
    }
    
    var textInsets: UIEdgeInsets = .zero {
        didSet { setNeedsDisplay(); invalidateIntrinsicContentSize() }
    }
    
    var customTextInsets: UIEdgeInsets = UIEdgeInsets(
        top: ConstraintConstant.Spacing.contentTightIntraVert,
        left: ConstraintConstant.Spacing.contentIntraHori,
        bottom: ConstraintConstant.Spacing.contentTightIntraVert,
        right: ConstraintConstant.Spacing.contentIntraHori) {
            didSet {
                textInsets = shouldInsetText ? customTextInsets : .zero
                updatePlaceholderLabel()
            }
        }
    var shouldInsetText: Bool = false {
        didSet {
            textInsets = shouldInsetText ? customTextInsets : .zero
            updatePlaceholderLabel()
        }
    }
    
    // MARK: - Placeholder and Background Label
    
    var placeholder: String? {
        didSet {
            placeholderLabel?.text = placeholder
            updatePlaceholderLabel()
        }
    }
    private var placeholderLabel: UILabel?
    
    /// Color of the outlined background label. When set, a duplicate label is
    /// inserted behind this label with an outline matching this color. Set to
    /// `nil` to remove the background label.
    var backgroundLabelColor: UIColor? {
        didSet {
            updateBackgroundLabel()
        }
    }
    private var backgroundLabel: UILabel?
    private let backgroundLabelStrokeWidthScale: CGFloat = 0.8
    
    override func drawText(in rect: CGRect) {
        super.drawText(in: rect.inset(by: textInsets))
    }
    
    override func textRect(forBounds bounds: CGRect, limitedToNumberOfLines numberOfLines: Int) -> CGRect {
        let insetBounds = bounds.inset(by: textInsets)
        let textRect = super.textRect(forBounds: insetBounds, limitedToNumberOfLines: numberOfLines)
        return CGRect(
            x: textRect.origin.x - textInsets.left,
            y: textRect.origin.y - textInsets.top,
            width: textRect.width + textInsets.left + textInsets.right,
            height: textRect.height + textInsets.top + textInsets.bottom
        )
    }
    
    override var intrinsicContentSize: CGSize {
        let size = super.intrinsicContentSize
        return CGSize(width: size.width + textInsets.left + textInsets.right,
                      height: size.height + textInsets.top + textInsets.bottom)
    }
    
    override var text: String? {
        didSet {
            if oldValue != text {
                updatePlaceholderLabel()
                updateBackgroundLabel()
            }
        }
    }
    
    override var attributedText: NSAttributedString? {
        didSet {
            if oldValue != attributedText {
                updatePlaceholderLabel()
                updateBackgroundLabel()
            }
        }
    }
    
    override var numberOfLines: Int {
        didSet {
            if oldValue != numberOfLines {
                placeholderLabel?.numberOfLines = numberOfLines
                backgroundLabel?.numberOfLines = numberOfLines
            }
        }
    }
    
    override var contentMode: UIView.ContentMode {
        didSet {
            if oldValue != contentMode {
                placeholderLabel?.contentMode = contentMode
                backgroundLabel?.contentMode = contentMode
            }
        }
    }
    
    override var textAlignment: NSTextAlignment {
        didSet {
            if oldValue != textAlignment {
                placeholderLabel?.textAlignment = textAlignment
                backgroundLabel?.textAlignment = textAlignment
            }
        }
    }
    
    override var lineBreakMode: NSLineBreakMode {
        didSet {
            if oldValue != lineBreakMode {
                placeholderLabel?.lineBreakMode = lineBreakMode
                backgroundLabel?.lineBreakMode = lineBreakMode
            }
        }
    }
    
    override var baselineAdjustment: UIBaselineAdjustment {
        didSet {
            if oldValue != baselineAdjustment {
                placeholderLabel?.baselineAdjustment = baselineAdjustment
                backgroundLabel?.baselineAdjustment = baselineAdjustment
            }
        }
    }
    
    override var adjustsFontSizeToFitWidth: Bool {
        didSet {
            if oldValue != adjustsFontSizeToFitWidth {
                placeholderLabel?.adjustsFontSizeToFitWidth = adjustsFontSizeToFitWidth
                backgroundLabel?.adjustsFontSizeToFitWidth = adjustsFontSizeToFitWidth
            }
        }
    }
    
    override var minimumScaleFactor: CGFloat {
        didSet {
            if oldValue != minimumScaleFactor {
                placeholderLabel?.minimumScaleFactor = minimumScaleFactor
                backgroundLabel?.minimumScaleFactor = minimumScaleFactor
            }
        }
    }
    
    override var font: UIFont! {
        didSet {
            if oldValue != font {
                placeholderLabel?.font = font
                // need to recalculate the attributed text for the background label
                updateBackgroundLabel()
            }
        }
    }
    
    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        if debugCheckForOversizedFrame {
            checkForOversizedFrame()
        }
    }
    
    override func didMoveToSuperview() {
        super.didMoveToSuperview()
        // Reattach background label to the new superview if needed
        updateBackgroundLabel()
    }
    
    // MARK: - Override Functions
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        updateDynamicBorderColor(using: previousTraitCollection)
        
        // UI has changed its appearance to dark/light mode
        if #available(iOS 13.0, *), traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            updateBackgroundLabel()
        }
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.numberOfLines = 1
        self.contentMode = .left
        self.textAlignment = .natural
        self.lineBreakMode = .byTruncatingTail
        self.baselineAdjustment = .alignBaselines
        self.adjustsFontSizeToFitWidth = true
        self.minimumScaleFactor = 0.825
        self.font = Constant.Visual.Font.primaryRegularLabel
        
        self.translatesAutoresizingMaskIntoConstraints = false
        
        HoundSizeDebugView.install(on: self)
        
        updateCornerRounding()
    }
    
    private func updatePlaceholderLabel() {
        
        let usesPlaceholderLabel = !(placeholder?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ?? true)
        
        guard usesPlaceholderLabel else {
            placeholderLabel?.snp.removeConstraints()
            placeholderLabel?.removeFromSuperview()
            placeholderLabel = nil
            return
        }
        
        if placeholderLabel == nil {
            let label = UILabel()
            label.textColor = .placeholderText
            label.translatesAutoresizingMaskIntoConstraints = false
            label.isUserInteractionEnabled = false
            label.text = placeholder
            placeholderLabel = label
        }
        
        guard let placeholderLabel = placeholderLabel else {
            return
        }
        
        let isEmpty: Bool = (text?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ?? true)
        
        placeholderLabel.isHidden = !isEmpty
        
        placeholderLabel.numberOfLines = numberOfLines
        placeholderLabel.contentMode = contentMode
        placeholderLabel.textAlignment = textAlignment
        placeholderLabel.lineBreakMode = lineBreakMode
        placeholderLabel.baselineAdjustment = baselineAdjustment
        placeholderLabel.adjustsFontSizeToFitWidth = adjustsFontSizeToFitWidth
        placeholderLabel.minimumScaleFactor = minimumScaleFactor
        placeholderLabel.font = font
        
        if placeholderLabel.superview != self {
            placeholderLabel.removeFromSuperview()
            addSubview(placeholderLabel)
        }
        
        placeholderLabel.snp.remakeConstraints { make in
            if shouldInsetText {
                make.edges.equalTo(self.snp.edges).inset(textInsets)
            }
            else {
                make.edges.equalTo(self.snp.edges)
            }
        }
    }
    
    private func updateBackgroundLabel() {
        guard let color = backgroundLabelColor else {
            backgroundLabel?.snp.removeConstraints()
            backgroundLabel?.removeFromSuperview()
            backgroundLabel = nil
            return
        }
        
        if backgroundLabel == nil {
            let label = UILabel()
            label.translatesAutoresizingMaskIntoConstraints = false
            backgroundLabel = label
        }
        
        guard let backgroundLabel = backgroundLabel else {
            return
        }
        
        if backgroundLabel.superview !== superview, let superview = superview {
            backgroundLabel.snp.removeConstraints()
            backgroundLabel.removeFromSuperview()
            superview.insertSubview(backgroundLabel, belowSubview: self)
            backgroundLabel.snp.makeConstraints { make in
                make.edges.equalTo(self.snp.edges).inset(textInsets)
            }
        }
        
        backgroundLabel.numberOfLines = numberOfLines
        backgroundLabel.contentMode = contentMode
        backgroundLabel.textAlignment = textAlignment
        backgroundLabel.lineBreakMode = lineBreakMode
        backgroundLabel.baselineAdjustment = baselineAdjustment
        backgroundLabel.adjustsFontSizeToFitWidth = adjustsFontSizeToFitWidth
        backgroundLabel.minimumScaleFactor = minimumScaleFactor
        backgroundLabel.font = font
        
        backgroundLabel.attributedText = NSAttributedString(string: self.text ?? "", attributes: [
            .strokeColor: color as Any,
            .foregroundColor: color as Any,
            .strokeWidth: self.font.pointSize * self.backgroundLabelStrokeWidthScale
        ])
    }
    
}
//
//  HoundViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundViewController: UIViewController, HoundUIProtocol, HoundUIKitProtocol, UIGestureRecognizerDelegate {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - HoundUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            HoundLogger.general.warning("SomeHoundView.setupGeneratedViews: Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            HoundLogger.general.warning("SomeHoundView.addSubViews: Attempting to re-invoke addSubViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            HoundLogger.general.warning("SomeHoundView.setupConstraints: Attempting to re-invoke setupConstraints for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Properties
    
    /// If true, upon viewIsAppearing and viewDidDisappear, the viewController will add or remove itself from the presentation manager's global presenter stack
    var eligibleForGlobalPresenter: Bool = false {
        didSet {
            if eligibleForGlobalPresenter == false {
                PresentationManager.removeGlobalPresenterFromStack(self)
            }
        }
    }
    
    /// Toggle if the interactive swipe-to-go-back gesture dismisses the view controller.
    /// Defaults to `false` so most views can't be dismissed via a swipe.
    var enableSwipeBackToDismiss: Bool = false {
        didSet { updateSwipeBackGesture() }
    }
    
    private var customSwipeGesture: UIScreenEdgePanGestureRecognizer?
    
    private var timeZoneObserver: NSObjectProtocol?
    
    // MARK: - Main
    
    override func loadView() {
        super.loadView()
        view.backgroundColor = UIColor.systemBackground
        setupGeneratedViews()
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        timeZoneObserver = NotificationCenter.default.addObserver(
            forName: .didUpdateUserTimeZone,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.didUpdateUserTimeZone()
        }
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.addGlobalPresenterToStack(self)
        }
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.removeGlobalPresenterFromStack(self)
        }
    }
    
    deinit {
        if let timeZoneObserver = timeZoneObserver {
            NotificationCenter.default.removeObserver(timeZoneObserver)
        }
    }
    
    // MARK: - Functions
    
    private func updateSwipeBackGesture() {
        guard isViewLoaded else { return }
        
        if let popGesture = navigationController?.interactivePopGestureRecognizer {
            popGesture.isEnabled = enableSwipeBackToDismiss
            customSwipeGesture?.isEnabled = false
        }
        else {
            if customSwipeGesture == nil {
                let gesture = UIScreenEdgePanGestureRecognizer(target: self, action: #selector(didSwipeBack(_:)))
                gesture.edges = .left
                gesture.delegate = self
                view.addGestureRecognizer(gesture)
                customSwipeGesture = gesture
            }
            customSwipeGesture?.isEnabled = enableSwipeBackToDismiss
        }
    }
    
    @objc private func didSwipeBack(_ sender: UIScreenEdgePanGestureRecognizer) {
        guard sender.state == .recognized else { return }
        if let navController = navigationController {
            navController.popViewController(animated: true)
        }
        else {
            dismiss(animated: true)
        }
    }
    
    func didUpdateUserTimeZone() { }
}
//
//  HoundView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/2/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundView: UIView, HoundUIProtocol, HoundUIKitProtocol, HoundDynamicBorder, HoundDynamicCorners {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - HoundUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            HoundLogger.general.warning("SomeHoundView.setupGeneratedViews: Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            HoundLogger.general.warning("SomeHoundView.addSubViews: Attempting to re-invoke addSubViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            HoundLogger.general.warning("SomeHoundView.setupConstraints: Attempting to re-invoke setupConstraints for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Properties

    var staticCornerRadius: CGFloat? = Constant.Visual.Layer.defaultCornerRadius
    /// If true, self.layer.cornerRadius = Constant.Visual.Layer.defaultCornerRadius. Otherwise, self.layer.cornerRadius = 0.
    var shouldRoundCorners: Bool = false {
        didSet {
            updateCornerRounding()
        }
    }

   var borderWidth: Double {
        get {
            Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }

    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }

    var shadowColor: UIColor? {
        didSet {
            if let shadowColor = shadowColor {
                self.layer.shadowColor = shadowColor.cgColor
            }
        }
    }

    var shadowOffset: CGSize? {
        didSet {
            if let shadowOffset = shadowOffset {
                self.layer.shadowOffset = shadowOffset
            }
        }
    }

    var shadowRadius: CGFloat? {
        didSet {
            if let shadowRadius = shadowRadius {
                self.layer.shadowRadius = shadowRadius
            }
        }
    }

    var shadowOpacity: Float? {
        didSet {
            if let shadowOpacity = shadowOpacity {
                self.layer.shadowOpacity = shadowOpacity
            }
        }
    }

    // MARK: - Override Properties

    override var bounds: CGRect {
        didSet {
            updateCornerRounding()
        }
    }

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Override Functions
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        updateDynamicBorderColor(using: previousTraitCollection)

        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            if let shadowColor = shadowColor {
                self.layer.shadowColor = shadowColor.cgColor
            }
        }
    }

    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.translatesAutoresizingMaskIntoConstraints = false
        
        HoundSizeDebugView.install(on: self)
        
        updateCornerRounding()
        
        setupGeneratedViews()
    }
}
//
//  HoundIntroductionView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/24/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

/// Modular introduction view with header, description, and content slot.
/// Designed for reuse across pages.
final class HoundIntroductionView: HoundView {
    
    // MARK: - Elements
    
    let backgroundImageView: HoundImageView = {
        let imageView = HoundImageView(huggingPriority: 300, compressionResistancePriority: 300)
        imageView.image = UIImage(named: "darkGreenForestWithMountainsFamilyWalkingDog")
        return imageView
    }()
    
    let whiteBackgroundView: HoundView = {
        let view = HoundView(huggingPriority: 290, compressionResistancePriority: 290)
        view.backgroundColor = UIColor.systemBackground
        view.layer.cornerRadius = Constant.Visual.Layer.imageCoveringViewCornerRadius
        view.layer.cornerCurve = .continuous
        return view
    }()
    
    let pageHeaderLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = Constant.Visual.Font.primaryHeaderLabel
        return label
    }()
    
    let pageDescriptionLabel: HoundLabel = {
        let label = HoundLabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.adjustsFontSizeToFitWidth = false
        label.font = Constant.Visual.Font.primaryRegularLabel
        label.textColor = UIColor.secondaryLabel
        return label
    }()
    
    let contentView: HoundView = {
        let view = HoundView(huggingPriority: 260, compressionResistancePriority: 260)
        return view
    }()
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        self.backgroundColor = UIColor.systemBackground
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        self.addSubview(backgroundImageView)
        self.addSubview(whiteBackgroundView)
        self.addSubview(pageHeaderLabel)
        self.addSubview(pageDescriptionLabel)
        self.addSubview(contentView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        let overlap: CGFloat = 25.0
        
        // backgroundImageView
        NSLayoutConstraint.activate([
            backgroundImageView.topAnchor.constraint(lessThanOrEqualTo: self.topAnchor),
            backgroundImageView.bottomAnchor.constraint(lessThanOrEqualTo: self.centerYAnchor).withPriority(.defaultHigh),
            backgroundImageView.leadingAnchor.constraint(equalTo: self.leadingAnchor),
            backgroundImageView.trailingAnchor.constraint(equalTo: self.trailingAnchor),
            backgroundImageView.createSquareAspectRatio()
        ])
        
        // whiteBackgroundView
        NSLayoutConstraint.activate([
            whiteBackgroundView.topAnchor.constraint(equalTo: backgroundImageView.bottomAnchor, constant: -overlap),
            whiteBackgroundView.bottomAnchor.constraint(equalTo: self.bottomAnchor),
            whiteBackgroundView.leadingAnchor.constraint(equalTo: self.leadingAnchor),
            whiteBackgroundView.trailingAnchor.constraint(equalTo: self.trailingAnchor)
        ])
        
        // pageHeaderLabel
        NSLayoutConstraint.activate([
            pageHeaderLabel.topAnchor.constraint(equalTo: whiteBackgroundView.topAnchor, constant: overlap),
            pageHeaderLabel.leadingAnchor.constraint(equalTo: whiteBackgroundView.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            pageHeaderLabel.trailingAnchor.constraint(equalTo: whiteBackgroundView.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // pageDescriptionLabel
        NSLayoutConstraint.activate([
            pageDescriptionLabel.topAnchor.constraint(equalTo: pageHeaderLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentIntraVert),
            pageDescriptionLabel.leadingAnchor.constraint(equalTo: self.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            pageDescriptionLabel.trailingAnchor.constraint(equalTo: self.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset)
        ])
        
        // contentView
        NSLayoutConstraint.activate([
            contentView.topAnchor.constraint(equalTo: pageDescriptionLabel.bottomAnchor, constant: Constant.Constraint.Spacing.contentTallIntraVert),
            contentView.leadingAnchor.constraint(equalTo: self.safeAreaLayoutGuide.leadingAnchor, constant: Constant.Constraint.Spacing.absoluteHoriInset),
            contentView.trailingAnchor.constraint(equalTo: self.safeAreaLayoutGuide.trailingAnchor, constant: -Constant.Constraint.Spacing.absoluteHoriInset),
            contentView.bottomAnchor.constraint(equalTo: self.safeAreaLayoutGuide.bottomAnchor, constant: -Constant.Constraint.Spacing.absoluteVertInset)
        ])
    }
}
//
//  HoundDatePicker.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/13/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class HoundDatePicker: UIDatePicker, HoundUIProtocol {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.contentHorizontalAlignment = .center
        self.contentVerticalAlignment = .center
        self.translatesAutoresizingMaskIntoConstraints = false
        self.timeZone = UserConfiguration.timeZone
        
        HoundSizeDebugView.install(on: self)
    }
    
}
//
//  HoundIntrinsicCollectionView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class HoundIntrinsicCollectionView: UICollectionView {
    override var contentSize: CGSize {
        didSet {
            invalidateIntrinsicContentSize()
        }
    }

    override var intrinsicContentSize: CGSize {
        return contentSize
    }

    override func reloadData() {
        super.reloadData()
        layoutIfNeeded()
        invalidateIntrinsicContentSize()
    }
}
//
//  HoundProgressView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/13/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class HoundProgressView: UIProgressView, HoundUIProtocol {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Override Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.translatesAutoresizingMaskIntoConstraints = false
        
        HoundSizeDebugView.install(on: self)
    }

}
//
//  HoundTextView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/30/22.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

/// Custom UITextView supporting a properly inset placeholder label, rounding, and border styling.
final class HoundTextView: UITextView, HoundUIProtocol, HoundDynamicBorder, HoundDynamicCorners {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - Properties
    
    var staticCornerRadius: CGFloat? = Constant.Visual.Layer.defaultCornerRadius
    /// If true, self.layer.cornerRadius = Constant.Visual.Layer.defaultCornerRadius. Otherwise, self.layer.cornerRadius = 0.
    var shouldRoundCorners: Bool = false {
        didSet {
            updateCornerRounding()
        }
    }
    
    var borderWidth: Double {
        get { Double(self.layer.borderWidth) }
        set { self.layer.borderWidth = CGFloat(newValue) }
    }
    
    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }
    
    override var bounds: CGRect {
        didSet {
            updateCornerRounding()
        }
    }
    
    override var isUserInteractionEnabled: Bool {
        didSet {
            self.alpha = isUserInteractionEnabled ? 1 : 0.5
        }
    }
    
    // MARK: - Placeholder Label
    
    var placeholder: String? {
        didSet {
            placeholderLabel?.text = placeholder
            updatePlaceholderLabel()
        }
    }
    private var placeholderLabel: UILabel?
    
    override var text: String? {
        didSet {
            if oldValue != text {
                updatePlaceholderLabel()
            }
        }
    }
    
    override var attributedText: NSAttributedString? {
        didSet {
            if oldValue != attributedText {
                updatePlaceholderLabel()
            }
        }
    }
    
    override var contentMode: UIView.ContentMode {
        didSet {
            placeholderLabel?.contentMode = contentMode
        }
    }
    
    override var textAlignment: NSTextAlignment {
        didSet {
            placeholderLabel?.textAlignment = textAlignment
        }
    }
    
    override var font: UIFont! {
        didSet {
            placeholderLabel?.font = font
        }
    }
    
    override var textContainerInset: UIEdgeInsets {
        didSet {
            updatePlaceholderLabel()
        }
    }
    
    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero, textContainer: nil)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero, textContainer: nil)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    override init(frame: CGRect, textContainer: NSTextContainer?) {
        super.init(frame: frame, textContainer: textContainer)
        applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
        updatePlaceholderPreferredWidth()
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    // MARK: - Override Functions
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        updateDynamicBorderColor(using: previousTraitCollection)
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.isMultipleTouchEnabled = true
        self.contentMode = .scaleToFill
        self.textAlignment = .natural
        self.textContainerInset = UIEdgeInsets(
            top: ConstraintConstant.Spacing.contentIntraVert,
            left: ConstraintConstant.Spacing.contentTightIntraHori,
            bottom: ConstraintConstant.Spacing.contentIntraVert,
            right: ConstraintConstant.Spacing.contentTightIntraHori)
        self.font = Constant.Visual.Font.primaryRegularLabel
        self.isScrollEnabled = false
        
        self.translatesAutoresizingMaskIntoConstraints = false
        
        NotificationCenter.default.addObserver(self, selector: #selector(textDidChangeNotification), name: UITextView.textDidChangeNotification, object: self)
        
        HoundSizeDebugView.install(on: self)
        
        updateCornerRounding()
    }
    
    @objc private func textDidChangeNotification() {
        updatePlaceholderLabel()
    }
    
    private func updatePlaceholderLabel() {
        let usesPlaceholderLabel = !(placeholder?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ?? true)
        
        guard usesPlaceholderLabel else {
            placeholderLabel?.snp.removeConstraints()
            placeholderLabel?.removeFromSuperview()
            placeholderLabel = nil
            return
        }
        
        if placeholderLabel == nil {
            let label = UILabel()
            label.textColor = .placeholderText
            label.translatesAutoresizingMaskIntoConstraints = false
            label.isUserInteractionEnabled = false
            label.text = placeholder
            placeholderLabel = label
        }
        
        guard let placeholderLabel = placeholderLabel else {
            return
        }
        
        let isEmpty: Bool = (text?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ?? true)
        placeholderLabel.isHidden = !isEmpty
        
        placeholderLabel.numberOfLines = 0
        placeholderLabel.contentMode = contentMode
        placeholderLabel.textAlignment = textAlignment
        placeholderLabel.lineBreakMode = .byWordWrapping
        // placeholderLabel.baselineAdjustment = baselineAdjustment
        placeholderLabel.adjustsFontSizeToFitWidth = false
        // placeholderLabel.minimumScaleFactor = minimumScaleFactor
        placeholderLabel.font = font
        
        if placeholderLabel.superview != self {
            placeholderLabel.removeFromSuperview()
            addSubview(placeholderLabel)
        }
        
        placeholderLabel.snp.remakeConstraints { make in
            make.top.equalTo(self.snp.top).inset(self.textContainerInset.top)
            make.left.equalTo(self.snp.left).inset(self.textContainerInset.left + self.textContainer.lineFragmentPadding)
            make.right.equalTo(self.snp.right).inset(self.textContainerInset.right + self.textContainer.lineFragmentPadding)
            make.bottom.lessThanOrEqualTo(self.snp.bottom).inset(self.textContainerInset.bottom)
        }
        
        updatePlaceholderPreferredWidth()
    }
    
    // Ensures the placeholder label wraps text to multiple lines by setting
    // `preferredMaxLayoutWidth` to the available width inside the text view.
    // Without this, UILabel will not wrap and the placeholder will be clipped.
    private func updatePlaceholderPreferredWidth() {
        guard let placeholderLabel = placeholderLabel else { return }
        
        let leftInset = self.textContainerInset.left + self.textContainer.lineFragmentPadding
        let rightInset = self.textContainerInset.right + self.textContainer.lineFragmentPadding
        let maxWidth = self.bounds.width - leftInset - rightInset
        
        guard placeholderLabel.preferredMaxLayoutWidth != maxWidth else { return }
        
        placeholderLabel.preferredMaxLayoutWidth = maxWidth
        placeholderLabel.setNeedsLayout()
    }
}
//
//  HoundImageView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/28/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundImageView: UIImageView, HoundUIProtocol, HoundDynamicCorners {
    
    // MARK: - HoundUIProtocol
    
    var properties: JSONRequestBody = [:]
    
    // MARK: - Properties
    
    var staticCornerRadius: CGFloat? = Constant.Visual.Layer.defaultCornerRadius
    /// If true, self.layer.cornerRadius = self.bounds.height / 2 is applied upon bounds change. Otherwise, self.layer.cornerRadius = 0 is applied upon bounds change.
    var shouldRoundCorners: Bool = false {
        didSet {
            updateCornerRounding()
        }
    }
    
    // MARK: - Override Properties
    
    /// Resize corner radius when the bounds change
    override var bounds: CGRect {
        didSet {
            updateCornerRounding()
            self.updateScaleImagePointSize()
            self.checkForOversizedFrame()
        }
    }
    
    override var image: UIImage? {
        didSet {
            self.updateScaleImagePointSize()
        }
    }
    
    var shouldAutoAdjustAlpha = false {
        didSet {
            guard let preAdjustmentAlpha = preAdjustmentAlpha else {
                return
            }
            
            // adjust super.alpha to avoid triggering our self.alpha override
            super.alpha = preAdjustmentAlpha
            self.preAdjustmentAlpha = nil
        }
    }
    private var preAdjustmentAlpha: CGFloat?
    override var isUserInteractionEnabled: Bool {
        didSet {
            if shouldAutoAdjustAlpha {
                if preAdjustmentAlpha == nil {
                    preAdjustmentAlpha = alpha
                }
                // adjust super.alpha to avoid triggering our self.alpha override
                super.alpha = isUserInteractionEnabled ? 1 : 0.5
            }
        }
    }
    
    override var alpha: CGFloat {
        didSet {
            self.preAdjustmentAlpha = alpha
        }
    }
    
    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    init() {
        super.init(frame: .zero)
        let priority = UILayoutPriority.defaultLow.rawValue
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(priority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(priority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    override init(image: UIImage?) {
        super.init(image: image)
        self.applyDefaultSetup()
    }
    
    override init(image: UIImage?, highlightedImage: UIImage?) {
        super.init(image: image, highlightedImage: highlightedImage)
        self.applyDefaultSetup()
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleAspectFit
        self.translatesAutoresizingMaskIntoConstraints = false
        
        HoundSizeDebugView.install(on: self)
        
        updateCornerRounding()
        updateScaleImagePointSize()
    }
    
    /// If there is a current, symbol image, scales its point size to the smallest dimension of bounds
    private func updateScaleImagePointSize() {
        guard let image = image, image.isSymbolImage == true else { return }
        
        let smallestDimension = bounds.height <= bounds.width ? bounds.height : bounds.width
        
        super.image = image.applyingSymbolConfiguration(UIImage.SymbolConfiguration.init(pointSize: smallestDimension))
    }
    
}
//
//  MappingLogActionTypeLogUnitType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class MappingLogActionTypeLogUnitType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: MappingLogActionTypeLogUnitType, rhs: MappingLogActionTypeLogUnitType) -> Bool {
        return lhs.mappingId < rhs.mappingId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? MappingLogActionTypeLogUnitType else {
            return false
        }
        return object.mappingId == self.mappingId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let mappingId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.mappingId.rawValue),
            let logActionTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logActionTypeId.rawValue),
            let logUnitTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logUnitTypeId.rawValue)
        else {
            return nil
        }
        self.init(
            mappingId: mappingId,
            logActionTypeId: logActionTypeId,
            logUnitTypeId: logUnitTypeId
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(mappingId, forKey: Constant.Key.mappingId.rawValue)
        aCoder.encode(logActionTypeId, forKey: Constant.Key.logActionTypeId.rawValue)
        aCoder.encode(logUnitTypeId, forKey: Constant.Key.logUnitTypeId.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var mappingId: Int
    private(set) var logActionTypeId: Int
    private(set) var logUnitTypeId: Int
    
    // MARK: - Initialization
    
    init(
        mappingId: Int,
        logActionTypeId: Int,
        logUnitTypeId: Int
    ) {
        self.mappingId = mappingId
        self.logActionTypeId = logActionTypeId
        self.logUnitTypeId = logUnitTypeId
        super.init()
    }
    
    convenience init?(fromBody: JSONResponseBody) {
        guard
            let mappingIdVal = fromBody[Constant.Key.mappingId.rawValue] as? Int,
            let logActionTypeIdVal = fromBody[Constant.Key.logActionTypeId.rawValue] as? Int,
            let logUnitTypeIdVal = fromBody[Constant.Key.logUnitTypeId.rawValue] as? Int
        else {
            return nil
        }
        
        self.init(
            mappingId: mappingIdVal,
            logActionTypeId: logActionTypeIdVal,
            logUnitTypeId: logUnitTypeIdVal
        )
    }
}
//
//  ReminderActionType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class ReminderActionType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: ReminderActionType, rhs: ReminderActionType) -> Bool {
        if lhs.sortOrder != rhs.sortOrder {
            return lhs.sortOrder < rhs.sortOrder
        }
        return lhs.reminderActionTypeId < rhs.reminderActionTypeId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? ReminderActionType else {
            return false
        }
        return object.reminderActionTypeId == self.reminderActionTypeId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let decodedReminderActionTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.reminderActionTypeId.rawValue),
            let decodedInternalValue = aDecoder.decodeOptionalString(forKey: Constant.Key.internalValue.rawValue),
            let decodedReadableValue = aDecoder.decodeOptionalString(forKey: Constant.Key.readableValue.rawValue),
            let decodedEmoji = aDecoder.decodeOptionalString(forKey: Constant.Key.emoji.rawValue),
            let decodedSortOrder = aDecoder.decodeOptionalInteger(forKey: Constant.Key.sortOrder.rawValue),
            let decodedIsDefault = aDecoder.decodeOptionalBool(forKey: Constant.Key.isDefault.rawValue),
            let decodedAllowsCustom = aDecoder.decodeOptionalBool(forKey: Constant.Key.allowsCustom.rawValue)
        else {
            return nil
        }

        self.init(
            reminderActionTypeId: decodedReminderActionTypeId,
            internalValue: decodedInternalValue,
            readableValue: decodedReadableValue,
            emoji: decodedEmoji,
            sortOrder: decodedSortOrder,
            isDefault: decodedIsDefault,
            allowsCustom: decodedAllowsCustom
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(reminderActionTypeId, forKey: Constant.Key.reminderActionTypeId.rawValue)
        aCoder.encode(internalValue, forKey: Constant.Key.internalValue.rawValue)
        aCoder.encode(readableValue, forKey: Constant.Key.readableValue.rawValue)
        aCoder.encode(emoji, forKey: Constant.Key.emoji.rawValue)
        aCoder.encode(sortOrder, forKey: Constant.Key.sortOrder.rawValue)
        aCoder.encode(isDefault, forKey: Constant.Key.isDefault.rawValue)
        aCoder.encode(allowsCustom, forKey: Constant.Key.allowsCustom.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var reminderActionTypeId: Int
    private(set) var internalValue: String
    private(set) var readableValue: String
    private(set) var emoji: String
    private(set) var sortOrder: Int
    private(set) var isDefault: Bool
    private(set) var allowsCustom: Bool
    
    var associatedLogActionTypes: [LogActionType] {
        let matchingMappings = GlobalTypes.shared.mappingLogActionTypeReminderActionType.filter {
            $0.reminderActionTypeId == self.reminderActionTypeId
        }
        
        let logIds = matchingMappings.map { $0.logActionTypeId }
        
        let results = GlobalTypes.shared.logActionTypes.filter {
            logIds.contains($0.logActionTypeId)
        }
        
        // all reminder actions should map to at least one log action type
        if results.count < 1 {
            HoundLogger.general.warning("associatedLogActionTypes: Expected to find >= 1 LogActionType for ReminderActionType \(self.reminderActionTypeId), but found \(results.count).")
            return []
        }
        
        return results
    }
    
    // MARK: - Initialization
    
    init(
        reminderActionTypeId: Int,
        internalValue: String,
        readableValue: String,
        emoji: String,
        sortOrder: Int,
        isDefault: Bool,
        allowsCustom: Bool
    ) {
        self.reminderActionTypeId = reminderActionTypeId
        self.internalValue = internalValue
        self.readableValue = readableValue
        self.emoji = emoji
        self.sortOrder = sortOrder
        self.isDefault = isDefault
        self.allowsCustom = allowsCustom
        super.init()
    }
    
    convenience init?(fromBody: JSONResponseBody) {
        guard
            let idVal = fromBody[Constant.Key.reminderActionTypeId.rawValue] as? Int,
            let internalVal = fromBody[Constant.Key.internalValue.rawValue] as? String,
            let readableVal = fromBody[Constant.Key.readableValue.rawValue] as? String,
            let emojiVal = fromBody[Constant.Key.emoji.rawValue] as? String,
            let sortOrderVal = fromBody[Constant.Key.sortOrder.rawValue] as? Int,
            let isDefaultVal = fromBody[Constant.Key.isDefault.rawValue] as? Bool,
            let allowsCustomVal = fromBody[Constant.Key.allowsCustom.rawValue] as? Bool
        else {
            return nil
        }
        
        self.init(
            reminderActionTypeId: idVal,
            internalValue: internalVal,
            readableValue: readableVal,
            emoji: emojiVal,
            sortOrder: sortOrderVal,
            isDefault: isDefaultVal,
            allowsCustom: allowsCustomVal
        )
    }
    
    // MARK: - Readable Conversion
    
    static func find(reminderActionTypeId: Int) -> ReminderActionType {
        guard let found = GlobalTypes.shared.reminderActionTypes.first(where: { $0.reminderActionTypeId == reminderActionTypeId }) else {
            HoundLogger.general.error("ReminderActionType.find: No ReminderActionType found for id \(reminderActionTypeId). Returning default ReminderActionType.")
            return GlobalTypes.shared.reminderActionTypes[0]
        }
        return found
    }
    
    func convertToReadableName(
        customActionName: String?,
        includeMatchingEmoji: Bool = false,
    ) -> String {
        var result = ""
        
        if allowsCustom, let name = customActionName?.trimmingCharacters(in: .whitespacesAndNewlines), !name.isEmpty {
            result += name
        }
        else {
            result += readableValue
        }
        
        if includeMatchingEmoji {
            result += " " + emoji
        }
        
        return result
    }
}
//
//  MappingLogActionTypeReminderActionType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class MappingLogActionTypeReminderActionType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: MappingLogActionTypeReminderActionType, rhs: MappingLogActionTypeReminderActionType) -> Bool {
        return lhs.mappingId < rhs.mappingId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? MappingLogActionTypeReminderActionType else {
            return false
        }
        return object.mappingId == self.mappingId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let mappingId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.mappingId.rawValue),
            let logActionTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logActionTypeId.rawValue),
            let reminderActionTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.reminderActionTypeId.rawValue)
        else {
            return nil
        }
        self.init(
            mappingId: mappingId,
            logActionTypeId: logActionTypeId,
            reminderActionTypeId: reminderActionTypeId
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(mappingId, forKey: Constant.Key.mappingId.rawValue)
        aCoder.encode(logActionTypeId, forKey: Constant.Key.logActionTypeId.rawValue)
        aCoder.encode(reminderActionTypeId, forKey: Constant.Key.reminderActionTypeId.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var mappingId: Int
    private(set) var logActionTypeId: Int
    private(set) var reminderActionTypeId: Int
    
    // MARK: - Initialization
    
    init(
        mappingId: Int,
        logActionTypeId: Int,
        reminderActionTypeId: Int
    ) {
        self.mappingId = mappingId
        self.logActionTypeId = logActionTypeId
        self.reminderActionTypeId = reminderActionTypeId
        super.init()
    }
    
    convenience init?(fromBody: JSONResponseBody) {
        guard
            let mappingIdVal = fromBody[Constant.Key.mappingId.rawValue] as? Int,
            let logActionTypeIdVal = fromBody[Constant.Key.logActionTypeId.rawValue] as? Int,
            let reminderActionTypeIdVal = fromBody[Constant.Key.reminderActionTypeId.rawValue] as? Int
        else {
            return nil
        }
        
        self.init(
            mappingId: mappingIdVal,
            logActionTypeId: logActionTypeIdVal,
            reminderActionTypeId: reminderActionTypeIdVal
        )
    }
}
//
//  LogUnitType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/1/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class LogUnitType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: LogUnitType, rhs: LogUnitType) -> Bool {
        if lhs.sortOrder != rhs.sortOrder {
            return lhs.sortOrder < rhs.sortOrder
        }
        return lhs.logUnitTypeId < rhs.logUnitTypeId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? LogUnitType else {
            return false
        }
        return object.logUnitTypeId == self.logUnitTypeId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let logUnitTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logUnitTypeId.rawValue),
            let unitSymbol = aDecoder.decodeOptionalString(forKey: Constant.Key.unitSymbol.rawValue),
            let readableValue = aDecoder.decodeOptionalString(forKey: Constant.Key.readableValue.rawValue),
            let isImperial = aDecoder.decodeOptionalBool(forKey: Constant.Key.isImperial.rawValue),
            let isMetric = aDecoder.decodeOptionalBool(forKey: Constant.Key.isMetric.rawValue),
            let isUnitMass = aDecoder.decodeOptionalBool(forKey: Constant.Key.isUnitMass.rawValue),
            let isUnitVolume = aDecoder.decodeOptionalBool(forKey: Constant.Key.isUnitVolume.rawValue),
            let isUnitLength = aDecoder.decodeOptionalBool(forKey: Constant.Key.isUnitLength.rawValue),
            let sortOrder = aDecoder.decodeOptionalInteger(forKey: Constant.Key.sortOrder.rawValue)
        else {
            return nil
        }
        
        self.init(
            logUnitTypeId: logUnitTypeId,
            unitSymbol: unitSymbol,
            readableValue: readableValue,
            isImperial: isImperial,
            isMetric: isMetric,
            isUnitMass: isUnitMass,
            isUnitVolume: isUnitVolume,
            isUnitLength: isUnitLength,
            sortOrder: sortOrder
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(logUnitTypeId, forKey: Constant.Key.logUnitTypeId.rawValue)
        aCoder.encode(unitSymbol, forKey: Constant.Key.unitSymbol.rawValue)
        aCoder.encode(readableValue, forKey: Constant.Key.readableValue.rawValue)
        aCoder.encode(isImperial, forKey: Constant.Key.isImperial.rawValue)
        aCoder.encode(isMetric, forKey: Constant.Key.isMetric.rawValue)
        aCoder.encode(isUnitMass, forKey: Constant.Key.isUnitMass.rawValue)
        aCoder.encode(isUnitVolume, forKey: Constant.Key.isUnitVolume.rawValue)
        aCoder.encode(isUnitLength, forKey: Constant.Key.isUnitLength.rawValue)
        aCoder.encode(sortOrder, forKey: Constant.Key.sortOrder.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var logUnitTypeId: Int
    private(set) var unitSymbol: String
    private(set) var readableValue: String
    private(set) var isImperial: Bool
    private(set) var isMetric: Bool
    private(set) var isUnitMass: Bool
    private(set) var isUnitVolume: Bool
    private(set) var isUnitLength: Bool
    private(set) var sortOrder: Int
    
    // MARK: - Initialization
    
    init(
        logUnitTypeId: Int,
        unitSymbol: String,
        readableValue: String,
        isImperial: Bool,
        isMetric: Bool,
        isUnitMass: Bool,
        isUnitVolume: Bool,
        isUnitLength: Bool,
        sortOrder: Int
    ) {
        self.logUnitTypeId = logUnitTypeId
        self.unitSymbol = unitSymbol
        self.readableValue = readableValue
        self.isImperial = isImperial
        self.isMetric = isMetric
        self.isUnitMass = isUnitMass
        self.isUnitVolume = isUnitVolume
        self.isUnitLength = isUnitLength
        self.sortOrder = sortOrder
        super.init()
    }
    
    convenience init?(fromBody: JSONResponseBody) {
        guard
            let idVal = fromBody[Constant.Key.logUnitTypeId.rawValue] as? Int,
            let symbolVal = fromBody[Constant.Key.unitSymbol.rawValue] as? String,
            let readableVal = fromBody[Constant.Key.readableValue.rawValue] as? String,
            let isImperialVal = fromBody[Constant.Key.isImperial.rawValue] as? Bool,
            let isMetricVal = fromBody[Constant.Key.isMetric.rawValue] as? Bool,
            let isMassVal = fromBody[Constant.Key.isUnitMass.rawValue] as? Bool,
            let isVolumeVal = fromBody[Constant.Key.isUnitVolume.rawValue] as? Bool,
            let isLengthVal = fromBody[Constant.Key.isUnitLength.rawValue] as? Bool,
            let sortOrderVal = fromBody[Constant.Key.sortOrder.rawValue] as? Int
        else {
            return nil
        }
        
        self.init(
            logUnitTypeId: idVal,
            unitSymbol: symbolVal,
            readableValue: readableVal,
            isImperial: isImperialVal,
            isMetric: isMetricVal,
            isUnitMass: isMassVal,
            isUnitVolume: isVolumeVal,
            isUnitLength: isLengthVal,
            sortOrder: sortOrderVal
        )
    }
    
    // MARK: - Functions
    
    static func find(logUnitTypeId: Int) -> LogUnitType {
        guard let found = GlobalTypes.shared.logUnitTypes.first(where: { $0.logUnitTypeId == logUnitTypeId }) else {
            HoundLogger.general.error("LogUnitType.find: No LogUnitType found for id \(logUnitTypeId). Returning default LogUnitType.")
            return GlobalTypes.shared.logUnitTypes[0]
        }
        return found
    }
    
    /// Produces a logNumberOfLogUnits that is more readable to the user. We accomplish this by rounding the double to two decimal places. Additionally, the decimal separator is varied based on locale (e.g. period in U.S.)
    static func readableRoundedNumUnits(logNumberOfLogUnits: Double?) -> String? {
        guard let logNumberOfLogUnits = logNumberOfLogUnits, logNumberOfLogUnits >= 0.01 else {
            // If logNumberOfLogUnits isn't greater than 0.01, we have nothing to display, return nil
            return nil
        }
        
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.locale = Locale.current
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 2
        
        return formatter.string(from: logNumberOfLogUnits as NSNumber)
    }
    
    static func convertStringToDouble(logNumberOfLogUnits: String?) -> Double? {
        guard let logNumberOfLogUnits = logNumberOfLogUnits else {
            return nil
        }
        
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.locale = Locale.current
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 2
        let doubleValue = formatter.number(from: logNumberOfLogUnits)?.doubleValue
        
        // If logNumberOfLogUnits isn't greater than 0.01, we have nothing to display, return nil
        return (doubleValue ?? 0.0) >= 0.01 ? doubleValue : nil
    }
    
    /// Produces a logUnitType that is more readable to the user. We accomplish this by changing the plurality of a log unit if needed : "cup" -> "cups" (changed needed if numberOfUnits != 1); "g" -> "g" (no change needed ever).
    func pluralReadableValueNoNumUnits(logNumberOfLogUnits: Double?) -> String? {
        let logNumberOfLogUnits = logNumberOfLogUnits ?? 0.0
        
        return (abs(logNumberOfLogUnits - 1.0) < 0.0001) ? self.readableValue : self.readableValue.appending("s")
    }
    
    /// Produces a logUnitType and logNumberOfLogUnits that is more readable to the user. Converts the unit and value of units into the correct system.For example: .cup, 1.5 -> "1.5 cups"; .g, 1.0 -> "1g" Also if the logUnit is in the wrong measurement system, e.g. its grams and the user wants imperial,
    func pluralReadableValueWithNumUnits(logNumberOfLogUnits: Double, toTargetSystem: MeasurementSystem = UserConfiguration.measurementSystem) -> String? {
        let (convertedLogUnit, convertedLogNumberOfLogUnits) = LogUnitTypeConverter.convert(logUnitType: self, numberOfLogUnits: logNumberOfLogUnits, toTargetSystem: toTargetSystem)
        
        // Take our raw values and convert them to something more readable
        let pluralReadableValueNoNumUnits = convertedLogUnit.pluralReadableValueNoNumUnits(logNumberOfLogUnits: convertedLogNumberOfLogUnits)
        let readableNumUnits = LogUnitType.readableRoundedNumUnits(logNumberOfLogUnits: convertedLogNumberOfLogUnits)
        
        guard let pluralReadableValueNoNumUnits = pluralReadableValueNoNumUnits, let readableNumUnits = readableNumUnits else {
            // If we reach this point it likely measure that readableIndividualLogNumberOfLogUnits was < 0.01, which would wouldn't be displayed, so nil was returned
            return nil
        }
        
        return "\(readableNumUnits) \(pluralReadableValueNoNumUnits)"
    }
}
//
//  GlobalTypes.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class GlobalTypes: NSObject, NSCoding, UserDefaultPersistable {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let logActionTypes: [LogActionType] = aDecoder.decodeOptionalObject(forKey: Constant.Key.logActionType.rawValue),
            let reminderActionTypes: [ReminderActionType] = aDecoder.decodeOptionalObject(forKey: Constant.Key.reminderActionType.rawValue),
            let mappingLogActionTypeReminderActionType: [MappingLogActionTypeReminderActionType] = aDecoder.decodeOptionalObject(forKey: Constant.Key.mappingLogActionTypeReminderActionType.rawValue),
            let logUnitTypes: [LogUnitType] = aDecoder.decodeOptionalObject(forKey: Constant.Key.logUnitType.rawValue),
            let mappingLogActionTypeLogUnitType: [MappingLogActionTypeLogUnitType] = aDecoder.decodeOptionalObject(forKey: Constant.Key.mappingLogActionTypeLogUnitType.rawValue)
        else {
            return nil
        }
        self.init(
            logActionTypes: logActionTypes,
            reminderActionTypes: reminderActionTypes,
            mappingLogActionTypeReminderActionType: mappingLogActionTypeReminderActionType,
            logUnitTypes: logUnitTypes,
            mappingLogActionTypeLogUnitType: mappingLogActionTypeLogUnitType
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(logActionTypes, forKey: Constant.Key.logActionType.rawValue)
        aCoder.encode(reminderActionTypes, forKey: Constant.Key.reminderActionType.rawValue)
        aCoder.encode(mappingLogActionTypeReminderActionType, forKey: Constant.Key.mappingLogActionTypeReminderActionType.rawValue)
        aCoder.encode(logUnitTypes, forKey: Constant.Key.logUnitType.rawValue)
        aCoder.encode(mappingLogActionTypeLogUnitType, forKey: Constant.Key.mappingLogActionTypeLogUnitType.rawValue)
    }
    
    // MARK: - UserDefaultPersistable
    
    /// Persists all of the LocalConfiguration variables and the globalGlobalTypes to the specified UserDefaults
    static func persist(toUserDefaults: UserDefaults) {
        guard let globalTypes = GlobalTypes.shared else {
            HoundLogger.general.error("GlobalTypes.persist: GlobalTypes.shared is nil, cannot persist to UserDefaults")
            return
        }
        
        do {
            let dataGlobalTypes = try NSKeyedArchiver.archivedData(withRootObject: globalTypes, requiringSecureCoding: false)
            toUserDefaults.set(dataGlobalTypes, forKey: Constant.Key.globalTypes.rawValue)
        }
        catch {
            HoundLogger.general.error("GlobalTypes.persist: Failed to persist globalTypes with NSKeyedArchiver: \(error)")
        }
    }
    
    /// Load all of the LocalConfiguration variables and the globalGlobalTypes from the specified UserDefaults
    static func load(fromUserDefaults: UserDefaults) {
        guard let dataGlobalTypes = fromUserDefaults.data(forKey: Constant.Key.globalTypes.rawValue) else {
            HoundLogger.general.error("GlobalTypes.load: No data found for globalTypes in UserDefaults")
            GlobalTypes.shared = nil
            return
        }
        do {
            let unarchiver = try NSKeyedUnarchiver(forReadingFrom: dataGlobalTypes)
            unarchiver.requiresSecureCoding = false
            if let globalTypes = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? GlobalTypes {
                GlobalTypes.shared = globalTypes
            }
            else {
                HoundLogger.general.error("GlobalTypes.load: Failed to decode globalTypes with unarchiver")
                GlobalTypes.shared = nil
                // clear dogManager and previousDogManagerSynchronization as if those try to init without global types, the app will crash
                // client needs to fetch global types from server
                PersistenceManager.clearDogManagerStorage()
            }
        }
        catch {
            HoundLogger.general.error("GlobalTypes.load: Failed to unarchive globalTypes: \(error)")
            GlobalTypes.shared = nil
            // clear dogManager and previousDogManagerSynchronization as if those try to init without global types, the app will crash
            // client needs to fetch global types from server
            PersistenceManager.clearDogManagerStorage()
        }
    }
    
    // MARK: - Properties
    
    private(set) var logActionTypes: [LogActionType]
    private(set) var reminderActionTypes: [ReminderActionType]
    private(set) var mappingLogActionTypeReminderActionType: [MappingLogActionTypeReminderActionType]
    private(set) var logUnitTypes: [LogUnitType]
    private(set) var mappingLogActionTypeLogUnitType: [MappingLogActionTypeLogUnitType]
    
    static var shared: GlobalTypes!
    
    // MARK: - Initialization
    
    init(
        logActionTypes: [LogActionType],
        reminderActionTypes: [ReminderActionType],
        mappingLogActionTypeReminderActionType: [MappingLogActionTypeReminderActionType],
        logUnitTypes: [LogUnitType],
        mappingLogActionTypeLogUnitType: [MappingLogActionTypeLogUnitType]
    ) {
        self.logActionTypes = logActionTypes.sorted()
        self.reminderActionTypes = reminderActionTypes.sorted()
        self.mappingLogActionTypeReminderActionType = mappingLogActionTypeReminderActionType.sorted()
        self.logUnitTypes = logUnitTypes.sorted()
        self.mappingLogActionTypeLogUnitType = mappingLogActionTypeLogUnitType.sorted()
        if logActionTypes.isEmpty {
            HoundLogger.general.error("GlobalTypes.init: logActionTypes is empty for GlobalTypes")
        }
        if reminderActionTypes.isEmpty {
            HoundLogger.general.error("GlobalTypes.init: reminderActionTypes is empty for GlobalTypes")
        }
        if mappingLogActionTypeReminderActionType.isEmpty {
            HoundLogger.general.error("GlobalTypes.init: mappingLogActionTypeReminderActionType is empty for GlobalTypes")
        }
        if logUnitTypes.isEmpty {
            HoundLogger.general.error("GlobalTypes.init: logUnitTypes is empty for GlobalTypes")
        }
        if mappingLogActionTypeLogUnitType.isEmpty {
            HoundLogger.general.error("GlobalTypes.init: mappingLogActionTypeLogUnitType is empty for GlobalTypes")
        }
        super.init()
    }
    
    convenience init?(fromBody: JSONResponseBody) {
        guard
            let logActionTypeArr = fromBody[Constant.Key.logActionType.rawValue] as? [JSONResponseBody],
            let reminderActionTypeArr = fromBody[Constant.Key.reminderActionType.rawValue] as? [JSONResponseBody],
            let mappingLogActionTypeReminderActionTypeArr = fromBody[Constant.Key.mappingLogActionTypeReminderActionType.rawValue] as? [JSONResponseBody],
            let logUnitTypesArr = fromBody[Constant.Key.logUnitType.rawValue] as? [JSONResponseBody],
            let mappingLogActionTypeLogUnitTypeArr = fromBody[Constant.Key.mappingLogActionTypeLogUnitType.rawValue] as? [JSONResponseBody]
        else {
            HoundLogger.general.error("GlobalTypes.init: Unable to decode types for GlobalTypes. fromBody is as follows \(fromBody)")
            return nil
        }
        
        let latMapped = logActionTypeArr.compactMap { LogActionType(fromBody: $0) }
        let ratMapped = reminderActionTypeArr.compactMap { ReminderActionType(fromBody: $0) }
        let mlatratMapped = mappingLogActionTypeReminderActionTypeArr.compactMap { MappingLogActionTypeReminderActionType(fromBody: $0) }
        let lutMapped = logUnitTypesArr.compactMap { LogUnitType(fromBody: $0) }
        let mlatlutMapped = mappingLogActionTypeLogUnitTypeArr.compactMap { MappingLogActionTypeLogUnitType(fromBody: $0) }
        
        self.init(
            logActionTypes: latMapped,
            reminderActionTypes: ratMapped,
            mappingLogActionTypeReminderActionType: mlatratMapped,
            logUnitTypes: lutMapped,
            mappingLogActionTypeLogUnitType: mlatlutMapped
        )
    }
}
//
//  LogActionType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class LogActionType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: LogActionType, rhs: LogActionType) -> Bool {
        if lhs.sortOrder != rhs.sortOrder {
            return lhs.sortOrder < rhs.sortOrder
        }
        return lhs.logActionTypeId < rhs.logActionTypeId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? LogActionType else {
            return false
        }
        return object.logActionTypeId == self.logActionTypeId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let decodedLogActionTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logActionTypeId.rawValue),
            let decodedInternalValue = aDecoder.decodeOptionalString(forKey: Constant.Key.internalValue.rawValue),
            let decodedReadableValue = aDecoder.decodeOptionalString(forKey: Constant.Key.readableValue.rawValue),
            let decodedEmoji = aDecoder.decodeOptionalString(forKey: Constant.Key.emoji.rawValue),
            let decodedSortOrder = aDecoder.decodeOptionalInteger(forKey: Constant.Key.sortOrder.rawValue),
            let decodedIsDefault = aDecoder.decodeOptionalBool(forKey: Constant.Key.isDefault.rawValue),
            let decodedAllowsCustom = aDecoder.decodeOptionalBool(forKey: Constant.Key.allowsCustom.rawValue)
        else {
            return nil
        }
        
        self.init(
            logActionTypeId: decodedLogActionTypeId,
            internalValue: decodedInternalValue,
            readableValue: decodedReadableValue,
            emoji: decodedEmoji,
            sortOrder: decodedSortOrder,
            isDefault: decodedIsDefault,
            allowsCustom: decodedAllowsCustom
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(logActionTypeId, forKey: Constant.Key.logActionTypeId.rawValue)
        aCoder.encode(internalValue, forKey: Constant.Key.internalValue.rawValue)
        aCoder.encode(readableValue, forKey: Constant.Key.readableValue.rawValue)
        aCoder.encode(emoji, forKey: Constant.Key.emoji.rawValue)
        aCoder.encode(sortOrder, forKey: Constant.Key.sortOrder.rawValue)
        aCoder.encode(isDefault, forKey: Constant.Key.isDefault.rawValue)
        aCoder.encode(allowsCustom, forKey: Constant.Key.allowsCustom.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var logActionTypeId: Int
    private(set) var internalValue: String
    private(set) var readableValue: String
    private(set) var emoji: String
    private(set) var sortOrder: Int
    private(set) var isDefault: Bool
    private(set) var allowsCustom: Bool
    
    var associatedReminderActionType: ReminderActionType? {
        let matchingMappings = GlobalTypes.shared.mappingLogActionTypeReminderActionType.filter {
            $0.logActionTypeId == self.logActionTypeId
        }
        
        let reminderIds = matchingMappings.map { $0.reminderActionTypeId }
        
        let reminderActionTypes = GlobalTypes.shared.reminderActionTypes.filter {
            reminderIds.contains($0.reminderActionTypeId)
        }
        
        // should only be 1 reverse mapping
        // not all log actions have an associated reminder action type
        
        return reminderActionTypes.first
    }
    
    var associatedLogUnitTypes: [LogUnitType] {
        let matchingMappings = GlobalTypes.shared.mappingLogActionTypeLogUnitType.filter {
            $0.logActionTypeId == self.logActionTypeId
        }
        
        let unitIds = matchingMappings.map { $0.logUnitTypeId }
        
        var logUnitTypes = GlobalTypes.shared.logUnitTypes.filter {
            unitIds.contains($0.logUnitTypeId)
        }
        
        logUnitTypes = logUnitTypes.filter { logUnitType in
            switch UserConfiguration.measurementSystem {
            case .imperial:
                return logUnitType.isImperial
            case .metric:
                return logUnitType.isMetric
            case .both:
                return logUnitType.isMetric || logUnitType.isImperial
            }
        }
        
        return logUnitTypes
    }
    
    // MARK: - Initialization
    
    init(
        logActionTypeId: Int,
        internalValue: String,
        readableValue: String,
        emoji: String,
        sortOrder: Int,
        isDefault: Bool,
        allowsCustom: Bool
    ) {
        self.logActionTypeId = logActionTypeId
        self.internalValue = internalValue
        self.readableValue = readableValue
        self.emoji = emoji
        self.sortOrder = sortOrder
        self.isDefault = isDefault
        self.allowsCustom = allowsCustom
        super.init()
    }
    
    convenience init?(fromBody: JSONResponseBody) {
        guard
            let idVal = fromBody[Constant.Key.logActionTypeId.rawValue] as? Int,
            let internalVal = fromBody[Constant.Key.internalValue.rawValue] as? String,
            let readableVal = fromBody[Constant.Key.readableValue.rawValue] as? String,
            let emojiVal = fromBody[Constant.Key.emoji.rawValue] as? String,
            let sortOrderVal = fromBody[Constant.Key.sortOrder.rawValue] as? Int,
            let isDefaultVal = fromBody[Constant.Key.isDefault.rawValue] as? Bool,
            let allowsCustomVal = fromBody[Constant.Key.allowsCustom.rawValue] as? Bool
        else {
            return nil
        }
        
        self.init(
            logActionTypeId: idVal,
            internalValue: internalVal,
            readableValue: readableVal,
            emoji: emojiVal,
            sortOrder: sortOrderVal,
            isDefault: isDefaultVal,
            allowsCustom: allowsCustomVal
        )
    }
    
    // MARK: - Readable Conversion
    
    static func find(logActionTypeId: Int) -> LogActionType {
        guard let found = GlobalTypes.shared.logActionTypes.first(where: { $0.logActionTypeId == logActionTypeId }) else {
            HoundLogger.general.error("LogActionType.find: No LogActionType found for id \(logActionTypeId). Returning default LogActionType.")
            return GlobalTypes.shared.logActionTypes[0]
        }
        return found
    }
    
    func convertToReadableName(
        customActionName: String?,
        includeMatchingEmoji: Bool = false
    ) -> String {
        var result = ""
        
        if allowsCustom, let name = customActionName?.trimmingCharacters(in: .whitespacesAndNewlines), !name.isEmpty {
            result += name
        }
        else {
            result += readableValue
        }
        
        if includeMatchingEmoji {
            result += " " + emoji
        }
        
        return result
    }
}
//
//  Completion.swift
//  Hound
//
//  Created by Jonathan Xakellis on 9/16/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// CompletionTracker helps manage the progress of multiple async API queries. It checks that these tasks were all successful in order to invoke successfulCompletionHandler or otherwise invokes failureCompletionHandler
final class CompletionTracker: NSObject {
    
    // MARK: - Properties

    /// Number of completions of current tasks
    private var numberOfCompletions: Int = 0

    /// Number of tasks that need to be successful in order to invoke successfulCompletionHandler
    private var numberOfTasks: Int

    /// Once a completedAllTasksCompletionHandler or failedTaskCompletionHandler is invoked, we track it here. This indicates that the CompletionTracker has completed/failed and it should execute no more code
    private var completionTrackerFinished = false

    /// Completion handler invoked every time a task successfully completes
    private var completedTaskCompletionHandler: (() -> Void)

    /// Completion handler invoked if all tasks successfully complete
    private var completedAllTasksCompletionHandler: (() -> Void)

    /// Completion handler invoked if one or more of the tasks failed
    private var failedTaskCompletionHandler: (() -> Void)

    // MARK: - Main

    init(numberOfTasks: Int, completedTaskCompletionHandler: @escaping (() -> Void), completedAllTasksCompletionHandler: @escaping (() -> Void), failedTaskCompletionHandler: @escaping (() -> Void)) {
        self.numberOfTasks = max(numberOfTasks, 0)
        self.completedTaskCompletionHandler = completedTaskCompletionHandler
        self.completedAllTasksCompletionHandler = completedAllTasksCompletionHandler
        self.failedTaskCompletionHandler = failedTaskCompletionHandler
        super.init()
    }
    
    // MARK: - Computed Properties
    
    /// Returns true if either a task has failed or all tasks have completed, meaning the CompletionTracker invoked the corresponding completionHandler and will invoke no further action
    var isFinished: Bool {
        return completionTrackerFinished
    }

    // MARK: - Functions

    /// If a task has been failed or all tasks have been completed, then this function does nothing. Otherwise, this function invokes completedTaskCompletionHandler then if numberOfCompeltion == numberOfTasks, then function also invokes completedAllTasksCompletionHandler
    func completedTask() {
        guard completionTrackerFinished == false else { return }

        numberOfCompletions += 1
        completedTaskCompletionHandler()

        guard numberOfCompletions >= numberOfTasks else { return }

        completionTrackerFinished = true
        completedAllTasksCompletionHandler()
    }

    /// If a task has been failed or all tasks have been completed, then this function does nothing. Otherwise, this function invokes failedTaskCompletionHandler
    func failedTask() {
        guard completionTrackerFinished == false else { return }

        completionTrackerFinished = true
        failedTaskCompletionHandler()
    }
}
//
//  OfflineModeDeletedObject.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/11/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

class OfflineModeDeletedObject: NSObject, NSCoding {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(deletedDate, forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    /// Two OfflineModeDeletedObject are only equal if they are subclasses of OfflineModeDeletedObject whp's overriden == method says they are equal
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedObject else {
            return false
        }
        
        guard type(of: self) == type(of: rhs) else {
            return false
        }
        
        if let lhs = self as? OfflineModeDeletedDog, let rhs = rhs as? OfflineModeDeletedDog {
            return lhs == rhs
        }
        else if let lhs = self as? OfflineModeDeletedReminder, let rhs = rhs as? OfflineModeDeletedReminder {
            return lhs == rhs
        }
        else if let lhs = self as? OfflineModeDeletedLog, let rhs = rhs as? OfflineModeDeletedLog {
            return lhs == rhs
        }
        else if let lhs = self as? OfflineModeDeletedTrigger, let rhs = rhs as? OfflineModeDeletedTrigger {
            return lhs == rhs
        }
        
        return false
    }
    
    // MARK: - Properties
    
    var deletedDate: Date
    
    // MARK: - Main
    
    init(deletedDate: Date) {
        self.deletedDate = deletedDate
    }
}

final class OfflineModeDeletedDog: OfflineModeDeletedObject {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.dogUUID.rawValue))
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            dogUUID: decodedDogUUID ?? Constant.Visual.Text.unknownUUID,
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    override func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogUUID.uuidString, forKey: Constant.Key.dogUUID.rawValue)
        aCoder.encode(deletedDate, forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedDog else {
            return false
        }
        
        return self.dogUUID == rhs.dogUUID
    }
    
    // MARK: - Properties
    
    var dogUUID: UUID
    
    // MARK: - Main
    
    init(dogUUID: UUID, deletedDate: Date) {
        self.dogUUID = dogUUID
        super.init(deletedDate: deletedDate)
    }
}

final class OfflineModeDeletedReminder: OfflineModeDeletedObject {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.dogUUID.rawValue))
        let decodedReminderUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.reminderUUID.rawValue))
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            dogUUID: decodedDogUUID ?? Constant.Visual.Text.unknownUUID,
            reminderUUID: decodedReminderUUID ?? Constant.Visual.Text.unknownUUID,
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    override func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogUUID.uuidString, forKey: Constant.Key.dogUUID.rawValue)
        aCoder.encode(reminderUUID.uuidString, forKey: Constant.Key.reminderUUID.rawValue)
        aCoder.encode(deletedDate, forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedReminder else {
            return false
        }
        
        return self.dogUUID == rhs.dogUUID && self.reminderUUID == rhs.reminderUUID
    }
    
    // MARK: - Properties
    
    var dogUUID: UUID
    var reminderUUID: UUID
    
    // MARK: - Main
    
    init(dogUUID: UUID, reminderUUID: UUID, deletedDate: Date) {
        self.dogUUID = dogUUID
        self.reminderUUID = reminderUUID
        super.init(deletedDate: deletedDate)
    }
}

final class OfflineModeDeletedLog: OfflineModeDeletedObject {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.dogUUID.rawValue))
        let decodedLogUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.logUUID.rawValue))
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            dogUUID: decodedDogUUID ?? Constant.Visual.Text.unknownUUID,
            logUUID: decodedLogUUID ?? Constant.Visual.Text.unknownUUID,
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    override func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogUUID.uuidString, forKey: Constant.Key.dogUUID.rawValue)
        aCoder.encode(logUUID.uuidString, forKey: Constant.Key.logUUID.rawValue)
        aCoder.encode(deletedDate, forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedLog else {
            return false
        }
        
        return self.dogUUID == rhs.dogUUID && self.logUUID == rhs.logUUID
    }
    
    // MARK: - Properties
    
    var dogUUID: UUID
    var logUUID: UUID
    
    // MARK: - Main
    
    init(dogUUID: UUID, logUUID: UUID, deletedDate: Date) {
        self.dogUUID = dogUUID
        self.logUUID = logUUID
        super.init(deletedDate: deletedDate)
    }
}

final class OfflineModeDeletedTrigger: OfflineModeDeletedObject {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.dogUUID.rawValue))
        let decodedTriggerUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.triggerUUID.rawValue))
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            dogUUID: decodedDogUUID ?? Constant.Visual.Text.unknownUUID,
            triggerUUID: decodedTriggerUUID ?? Constant.Visual.Text.unknownUUID,
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    override func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogUUID.uuidString, forKey: Constant.Key.dogUUID.rawValue)
        aCoder.encode(triggerUUID.uuidString, forKey: Constant.Key.triggerUUID.rawValue)
        aCoder.encode(deletedDate, forKey: Constant.Key.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedTrigger else {
            return false
        }
        
        return self.dogUUID == rhs.dogUUID && self.triggerUUID == rhs.triggerUUID
    }
    
    // MARK: - Properties
    
    var dogUUID: UUID
    var triggerUUID: UUID
    
    // MARK: - Main
    
    init(dogUUID: UUID, triggerUUID: UUID, deletedDate: Date) {
        self.dogUUID = dogUUID
        self.triggerUUID = triggerUUID
        super.init(deletedDate: deletedDate)
    }
}
//
//  Dog.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/18/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class Dog: NSObject, NSCoding, NSCopying, Comparable {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = Dog()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        copy.dogId = self.dogId
        copy.dogUUID = self.dogUUID
        copy.dogName = self.dogName
        copy.dogCreated = self.dogCreated
        copy.dogCreatedBy = self.dogCreatedBy
        copy.dogLastModified = self.dogLastModified
        copy.dogLastModifiedBy = self.dogLastModifiedBy
        copy.dogIcon = self.dogIcon?.copy() as? UIImage
        copy.dogReminders = self.dogReminders.copy() as? DogReminderManager ?? DogReminderManager()
        copy.dogLogs = self.dogLogs.copy() as? DogLogManager ?? DogLogManager(parentDog: nil)
        copy.dogLogs.parentDog = copy
        copy.dogTriggers = self.dogTriggers.copy() as? DogTriggerManager ?? DogTriggerManager()
        copy.offlineModeComponents = self.offlineModeComponents.copy() as? OfflineModeComponents ?? OfflineModeComponents()
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogId: Int? = aDecoder.decodeOptionalInteger(forKey: Constant.Key.dogId.rawValue)
        let decodedDogUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.dogUUID.rawValue))
        let decodedDogName: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.dogName.rawValue)
        let decodedDogCreated: Date? = (aDecoder.decodeOptionalString(forKey: Constant.Key.dogCreated.rawValue)?.formatISO8601IntoDate())
        let decodedDogCreatedBy: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.dogCreatedBy.rawValue) ?? Constant.Class.Log.defaultUserId
        let decodedDogLastModified: Date? = (aDecoder.decodeOptionalString(forKey: Constant.Key.dogLastModified.rawValue)?.formatISO8601IntoDate())
        let decodedDogLastModifiedBy: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.dogLastModifiedBy.rawValue)
        let decodedDogReminders: DogReminderManager? = aDecoder.decodeOptionalObject(forKey: Constant.Key.dogReminders.rawValue)
        let decodedDogLogs: DogLogManager? = aDecoder.decodeOptionalObject(forKey: Constant.Key.dogLogs.rawValue)
        let decodedDogTriggers: DogTriggerManager? = aDecoder.decodeOptionalObject(forKey: Constant.Key.dogTriggers.rawValue)
        let decodedOfflineModeComponents: OfflineModeComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeComponents.rawValue)
        self.init(
            dogId: decodedDogId,
            dogUUID: decodedDogUUID,
            dogName: decodedDogName,
            dogCreated: decodedDogCreated,
            dogCreatedBy: decodedDogCreatedBy,
            dogLastModified: decodedDogLastModified,
            dogLastModifiedBy: decodedDogLastModifiedBy,
            dogReminders: decodedDogReminders,
            dogLogs: decodedDogLogs,
            dogTriggers: decodedDogTriggers,
            offlineModeComponents: decodedOfflineModeComponents
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        if let dogId = dogId {
            aCoder.encode(dogId, forKey: Constant.Key.dogId.rawValue)
        }
        aCoder.encode(dogUUID.uuidString, forKey: Constant.Key.dogUUID.rawValue)
        aCoder.encode(dogCreated.ISO8601FormatWithFractionalSeconds(), forKey: Constant.Key.dogCreated.rawValue)
        aCoder.encode(dogCreatedBy, forKey: Constant.Key.dogCreatedBy.rawValue)
        if let dogLastModified = dogLastModified {
            aCoder.encode(dogLastModified.ISO8601FormatWithFractionalSeconds(), forKey: Constant.Key.dogLastModified.rawValue)
        }
        if let dogLastModifiedBy = dogLastModifiedBy {
            aCoder.encode(dogLastModifiedBy, forKey: Constant.Key.dogLastModifiedBy.rawValue)
        }
        aCoder.encode(dogName, forKey: Constant.Key.dogName.rawValue)
        aCoder.encode(dogReminders, forKey: Constant.Key.dogReminders.rawValue)
        aCoder.encode(dogLogs, forKey: Constant.Key.dogLogs.rawValue)
        aCoder.encode(dogTriggers, forKey: Constant.Key.dogTriggers.rawValue)
        aCoder.encode(offlineModeComponents, forKey: Constant.Key.offlineModeComponents.rawValue)
    }
    
    // MARK: - Comparable
    
    static func < (lhs: Dog, rhs: Dog) -> Bool {
        guard let lhsDogId = lhs.dogId else {
            guard rhs.dogId != nil else {
                // Neither have an id
                let compare = lhs.dogName.localizedCaseInsensitiveCompare(rhs.dogName)
                if compare == .orderedAscending {
                    return true
                }
                if compare == .orderedDescending {
                    return false
                }
                
                return lhs.dogUUID.uuidString < rhs.dogUUID.uuidString
            }
            
            // lhs doesn't have a dogId but rhs does. rhs should come first
            return false
        }
        
        guard let rhsDogId = rhs.dogId else {
            // lhs has a dogId but rhs doesn't. lhs should come first
            return true
        }
        
        return lhsDogId <= rhsDogId
    }
    
    // MARK: - Properties
    
    var dogId: Int?

    var dogUUID: UUID = UUID()

    private(set) var dogCreated: Date = Date()
    private(set) var dogCreatedBy: String = Constant.Class.Log.defaultUserId
    private(set) var dogLastModified: Date?
    private(set) var dogLastModifiedBy: String?

    var dogIcon: UIImage?

    private(set) var dogName: String = Constant.Class.Dog.defaultDogName
    
    /// DogReminderManager that handles all specified reminders for a dog, e.g. being taken to the outside every time interval or being fed.
    private(set) var dogReminders: DogReminderManager = DogReminderManager()
    
    /// DogLogManager that handles all the logs for a dog. delegate is set to nil, as it is set in the init method
    private(set) var dogLogs: DogLogManager = DogLogManager(parentDog: nil)
    
    /// DogTriggerManager that handles all the dogTriggers for a dog
    private(set) var dogTriggers: DogTriggerManager = DogTriggerManager()
    
    /// Components that are used to track an object to determine whether it was synced with the Hound server and whether it needs to be when the device comes back online
    private(set) var offlineModeComponents: OfflineModeComponents = OfflineModeComponents()
    
    // MARK: - Main
    
    init(
        dogId: Int? = nil,
        dogUUID: UUID? = nil,
        dogName: String? = nil,
        dogCreated: Date? = nil,
        dogCreatedBy: String? = nil,
        dogLastModified: Date? = nil,
        dogLastModifiedBy: String? = nil,
        dogReminders: DogReminderManager? = nil,
        dogLogs: DogLogManager? = nil,
        dogTriggers: DogTriggerManager? = nil,
        offlineModeComponents: OfflineModeComponents? = nil
    ) {
        super.init()
        self.dogId = dogId ?? self.dogId
        self.dogUUID = dogUUID ?? self.dogUUID
        changeDogName(dogName: dogName)
        self.dogCreated = dogCreated ?? self.dogCreated
        self.dogCreatedBy = dogCreatedBy ?? self.dogCreatedBy
        self.dogLastModified = dogLastModified ?? self.dogLastModified
        self.dogLastModifiedBy = dogLastModifiedBy ?? self.dogLastModifiedBy
        self.dogIcon = DogIconManager.getIcon(dogUUID: dogUUID ?? self.dogUUID)
        self.dogReminders = dogReminders ?? self.dogReminders
        self.dogLogs = dogLogs ?? self.dogLogs
        self.dogLogs.parentDog = self
        self.dogTriggers = dogTriggers ?? self.dogTriggers
        self.offlineModeComponents = offlineModeComponents ?? self.offlineModeComponents
    }
    
    /// Provide a dictionary literal of dog properties to instantiate dog. Optionally, provide a dog to override with new properties from fromBody.
    convenience init?(fromBody: JSONResponseBody, dogToOverride: Dog?) {
        // Don't pull dogId or dogIsDeleted from dogToOverride. A valid fromBody needs to provide this itself
        let dogId: Int? = fromBody[Constant.Key.dogId.rawValue] as? Int
        let dogUUID: UUID? = UUID.fromString(UUIDString: fromBody[Constant.Key.dogUUID.rawValue] as? String)
        let dogCreated: Date? = (fromBody[Constant.Key.dogCreated.rawValue] as? String)?.formatISO8601IntoDate()
        let dogIsDeleted: Bool? = fromBody[Constant.Key.dogIsDeleted.rawValue] as? Bool
        
        guard let dogId = dogId, let dogUUID = dogUUID, let dogCreated = dogCreated, let dogIsDeleted = dogIsDeleted else {
            return nil
        }
        
        guard dogIsDeleted == false else {
            return nil
        }
        
        let dogLastModified: Date? = (fromBody[Constant.Key.dogLastModified.rawValue] as? String)?.formatISO8601IntoDate()
        
        // If we have pulled an update from the server which is more outdated than our local change, then ignore the data from the server. Otherwise, the newer update takes precedence over our update
        if let dogToOverride = dogToOverride, let initialAttemptedSyncDate = dogToOverride.offlineModeComponents.initialAttemptedSyncDate, initialAttemptedSyncDate >= dogLastModified ?? dogCreated {
            self.init(
                dogId: dogToOverride.dogId,
                dogUUID: dogToOverride.dogUUID,
                dogName: dogToOverride.dogName,
                dogCreated: dogToOverride.dogCreated,
                dogCreatedBy: dogToOverride.dogCreatedBy,
                dogLastModified: dogToOverride.dogLastModified,
                dogLastModifiedBy: dogToOverride.dogLastModifiedBy,
                dogReminders: dogToOverride.dogReminders,
                dogLogs: dogToOverride.dogLogs,
                dogTriggers: dogToOverride.dogTriggers,
                offlineModeComponents: dogToOverride.offlineModeComponents
            )
            return
        }

        // if the dog is the same, then we pull values from dogToOverride
        // if the dog is updated, then we pull values from fromBody
        let dogCreatedBy: String? = fromBody[Constant.Key.dogCreatedBy.rawValue] as? String ?? dogToOverride?.dogCreatedBy
        let dogLastModifiedBy: String? = fromBody[Constant.Key.dogLastModifiedBy.rawValue] as? String ?? dogToOverride?.dogLastModifiedBy
        let dogName: String? = fromBody[Constant.Key.dogName.rawValue] as? String ?? dogToOverride?.dogName
        
        let dogReminders: DogReminderManager? = {
            guard let reminderBodies = fromBody[Constant.Key.dogReminders.rawValue] as? [JSONResponseBody] else {
                return nil
            }
            
            return DogReminderManager(fromReminderBodies: reminderBodies, dogReminderManagerToOverride: dogToOverride?.dogReminders)
        }()
        
        let dogLogs: DogLogManager? = {
            guard let logBodies = fromBody[Constant.Key.dogLogs.rawValue] as? [JSONResponseBody] else {
                return nil
            }
            
            // delegate is set to nil, as it is set in the init method
            return DogLogManager(fromLogBodies: logBodies, dogLogManagerToOverride: dogToOverride?.dogLogs, parentDog: nil)
        }()
        
        let dogTriggers: DogTriggerManager? = {
            guard let triggerBodies = fromBody[Constant.Key.dogTriggers.rawValue] as? [JSONResponseBody] else {
                return nil
            }
            
            return DogTriggerManager(fromTriggerBodies: triggerBodies, dogTriggerManagerToOverride: dogToOverride?.dogTriggers)
        }()
        
        self.init(
            dogId: dogId,
            dogUUID: dogUUID,
            dogName: dogName,
            dogCreated: dogCreated,
            dogCreatedBy: dogCreatedBy,
            dogLastModified: dogLastModified,
            dogLastModifiedBy: dogLastModifiedBy,
            dogReminders: dogReminders,
            dogLogs: dogLogs,
            dogTriggers: dogTriggers,
            // Verified that the update from the server happened more recently than our local changes, so no need to offline sync anymore
            offlineModeComponents: nil
        )
        
    }
    
    // MARK: - Function
    
    @discardableResult
    func changeDogName(dogName: String?) -> Bool {
        guard let dogName = dogName, dogName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false else {
            return false
        }
        
        self.dogName = String(dogName.prefix(Constant.Class.Dog.dogNameCharacterLimit))
        return true
    }
    
    /// For a given logActionType and logCustomActionName, finds all enabled reminders that match these two properties. We attempt to translate LogActionType into ReminderActionType, but that can possibly fail, as the mapping isn't 1:1 (some LogActionTypes have no corresponding ReminderActionType), therefore in that case we return nothing
    func matchingReminders(logActionType: LogActionType, logCustomActionName: String?) -> [Reminder] {
        // Must have a reminder action and our conversion failed as no corresponding reminderActionType exists for the logActionType
        guard let associatedReminderActionType = logActionType.associatedReminderActionType else {
            return []
        }
        
        let matchingReminders = dogReminders.dogReminders.filter { dogReminder in
            guard dogReminder.reminderIsEnabled == true else {
                // Reminder needs to be enabled to be considered
                return false
            }
            
            guard dogReminder.reminderActionTypeId == associatedReminderActionType.reminderActionTypeId else {
                // Both reminderActionTypes need to match
                return false
            }
            
            // If the reminderActionType can have customActionName, then the customActionName need to also match.
            return associatedReminderActionType.allowsCustom == false
            || (dogReminder.reminderCustomActionName == logCustomActionName)
        }
        
        return matchingReminders
    }
    
    /// Returns an array literal of the dog's properties (does not include nested properties, e.g. logs or reminders). This is suitable to be used as the JSON body for a HTTP request
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.dogId.rawValue] = .int(dogId)
        body[Constant.Key.dogUUID.rawValue] = .string(dogUUID.uuidString)
        body[Constant.Key.dogName.rawValue] = .string(dogName)
        body[Constant.Key.dogCreated.rawValue] = .string(dogCreated.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.dogCreatedBy.rawValue] = .string(dogCreatedBy)
        body[Constant.Key.dogLastModified.rawValue] = .string(dogLastModified?.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.dogLastModifiedBy.rawValue] = .string(dogLastModifiedBy)
        return body
    }
}
//
//  OfflineModeComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/9/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class OfflineModeComponents: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        return OfflineModeComponents(
            initialAttemptedSyncDate: self.initialAttemptedSyncDate,
            initialCreationDate: self.initialCreationDate
        )
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedInitialAttemptedSyncDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeComponentsInitialAttemptedSyncDate.rawValue)
        let decodedInitialCreationDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeComponentsInitialCreationDate.rawValue)
        
        self.init(
            initialAttemptedSyncDate: decodedInitialAttemptedSyncDate,
            initialCreationDate: decodedInitialCreationDate
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(initialAttemptedSyncDate, forKey: Constant.Key.offlineModeComponentsInitialAttemptedSyncDate.rawValue)
        aCoder.encode(initialCreationDate, forKey: Constant.Key.offlineModeComponentsInitialCreationDate.rawValue)
    }
    
    // MARK: - Properties
    
    /// If this flag is true, the offline manager will attempt to sync this object at a later date when connectivity is restored. The values of this flag depends on whether or not initialAttemptedSyncDate is nil
    var needsSyncedWithHoundServer: Bool {
        return initialAttemptedSyncDate != nil
    }
    
    /// This is the date which the object was attempted to be synced with the Hound server but failed due to no connection. If this is set to a
    private(set) var initialAttemptedSyncDate: Date?
    /// Function used externally to manage initialAttemptedSyncDate
    func updateInitialAttemptedSyncDate(initialAttemptedSyncDate: Date?) {
        guard let initialAttemptedSyncDate = initialAttemptedSyncDate else {
            // Override initialAttemptedSyncDate to set it to nil
            self.initialAttemptedSyncDate = initialAttemptedSyncDate
            return
        }
        
        guard self.initialAttemptedSyncDate != nil else {
            // initialAttemptedSyncDate isn't nil but initialAttemptedSyncDate is, override initialAttemptedSyncDate with the value
            self.initialAttemptedSyncDate = initialAttemptedSyncDate
            return
        }
        
        // Both initialAttemptedSyncDate and initialAttemptedSyncDate aren't nil, therefore do nothing as the initialAttemptedSyncDate shouldn't be overriden with another value.
    }
    
    /// This is the date which the object was created by the user
    private(set) var initialCreationDate: Date = Date()
    
    // MARK: - Main
    
    init(
        initialAttemptedSyncDate: Date? = nil,
        initialCreationDate: Date? = nil
    ) {
        self.initialAttemptedSyncDate = initialAttemptedSyncDate ?? self.initialAttemptedSyncDate
        self.initialCreationDate = initialCreationDate ?? self.initialCreationDate
    }
}
//
//  trigger.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/14/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

// TODO AUTOMATIONS track trigger activations and display last activation in trigger tvc

enum TriggerType: String, CaseIterable {
    
    init?(rawValue: String) {
        for type in TriggerType.allCases where type.rawValue.lowercased() == rawValue.lowercased() {
            self = type
            return
        }
        
        self = .timeDelay
        return
    }
    case timeDelay
    case fixedTime
    
    var readable: String {
        switch self {
        case .timeDelay: return "After a Delay"
        case .fixedTime: return "At a Specific Time"
        }
    }
}

final class Trigger: NSObject, NSCoding, NSCopying, Comparable {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = Trigger()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        copy.triggerId = self.triggerId
        copy.triggerUUID = self.triggerUUID
        copy.triggerCreated = self.triggerCreated
        copy.triggerCreatedBy = self.triggerCreatedBy
        copy.triggerLastModified = self.triggerLastModified
        copy.triggerLastModifiedBy = self.triggerLastModifiedBy
        for logActionReaction in triggerLogReactions {
            if let logActionReactionCopy = logActionReaction.copy() as? TriggerLogReaction {
                copy.triggerLogReactions.append(logActionReactionCopy)
            }
        }
        copy.triggerReminderResult = self.triggerReminderResult.copy() as? TriggerReminderResult ?? TriggerReminderResult()
        copy.triggerType = self.triggerType
        
        copy.timeDelayComponents = self.timeDelayComponents.copy() as? TriggerTimeDelayComponents ?? TriggerTimeDelayComponents()
        copy.fixedTimeComponents = self.fixedTimeComponents.copy() as? TriggerFixedTimeComponents ?? TriggerFixedTimeComponents()
        
        copy.triggerManualCondition = self.triggerManualCondition
        copy.triggerAlarmCreatedCondition = self.triggerAlarmCreatedCondition
        copy.offlineModeComponents = self.offlineModeComponents.copy() as? OfflineModeComponents ?? OfflineModeComponents()
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let triggerId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.triggerId.rawValue)
        let triggerUUID = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.triggerUUID.rawValue))
        let triggerCreated: Date? = (aDecoder.decodeOptionalString(forKey: Constant.Key.triggerCreated.rawValue)?.formatISO8601IntoDate())
        let triggerCreatedBy: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.triggerCreatedBy.rawValue)
        let triggerLastModified: Date? = (aDecoder.decodeOptionalString(forKey: Constant.Key.triggerLastModified.rawValue)?.formatISO8601IntoDate())
        let triggerLastModifiedBy: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.triggerLastModifiedBy.rawValue)
        let triggerLogReactions: [TriggerLogReaction]? = aDecoder.decodeOptionalObject(forKey: Constant.Key.triggerLogReactions.rawValue)
        let triggerReminderResult: TriggerReminderResult? = aDecoder.decodeOptionalObject(forKey: Constant.Key.triggerReminderResult.rawValue)
        let triggerType = TriggerType(rawValue: aDecoder.decodeOptionalString(forKey: Constant.Key.triggerType.rawValue) ?? Constant.Class.Trigger.defaultTriggerType.rawValue)
        
        let triggerTimeDelayComponents: TriggerTimeDelayComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.triggerTimeDelayComponents.rawValue)
        let triggerFixedTimeComponents: TriggerFixedTimeComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.triggerFixedTimeComponents.rawValue)
        
        let triggerManualCondition = aDecoder.decodeOptionalBool(forKey: Constant.Key.triggerManualCondition.rawValue) ?? Constant.Class.Trigger.defaultTriggerManualCondition
        let triggerAlarmCreatedCondition = aDecoder.decodeOptionalBool(forKey: Constant.Key.triggerAlarmCreatedCondition.rawValue) ?? Constant.Class.Trigger.defaultTriggerAlarmCreatedCondition
        let offlineModeComponents: OfflineModeComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeComponents.rawValue)
        
        self.init(
            triggerId: triggerId,
            triggerUUID: triggerUUID,
            triggerCreated: triggerCreated,
            triggerCreatedBy: triggerCreatedBy,
            triggerLastModified: triggerLastModified,
            triggerLastModifiedBy: triggerLastModifiedBy,
            triggerLogReactions: triggerLogReactions,
            triggerReminderResult: triggerReminderResult,
            triggerType: triggerType,
            triggerTimeDelayComponents: triggerTimeDelayComponents,
            triggerFixedTimeComponents: triggerFixedTimeComponents,
            triggerManualCondition: triggerManualCondition,
            triggerAlarmCreatedCondition: triggerAlarmCreatedCondition,
            offlineModeComponents: offlineModeComponents
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(triggerId, forKey: Constant.Key.triggerId.rawValue)
        aCoder.encode(triggerUUID.uuidString, forKey: Constant.Key.triggerUUID.rawValue)
        aCoder.encode(triggerCreated.ISO8601FormatWithFractionalSeconds(), forKey: Constant.Key.triggerCreated.rawValue)
        aCoder.encode(triggerCreatedBy, forKey: Constant.Key.triggerCreatedBy.rawValue)
        if let triggerLastModified = triggerLastModified {
            aCoder.encode(triggerLastModified.ISO8601FormatWithFractionalSeconds(), forKey: Constant.Key.triggerLastModified.rawValue)
        }
        if let triggerLastModifiedBy = triggerLastModifiedBy {
            aCoder.encode(triggerLastModifiedBy, forKey: Constant.Key.triggerLastModifiedBy.rawValue)
        }
        aCoder.encode(triggerLogReactions, forKey: Constant.Key.triggerLogReactions.rawValue)
        aCoder.encode(triggerReminderResult, forKey: Constant.Key.triggerReminderResult.rawValue)
        aCoder.encode(triggerType.rawValue, forKey: Constant.Key.triggerType.rawValue)
        
        aCoder.encode(timeDelayComponents, forKey: Constant.Key.triggerTimeDelayComponents.rawValue)
        
        aCoder.encode(fixedTimeComponents, forKey: Constant.Key.triggerFixedTimeComponents.rawValue)
        
        aCoder.encode(triggerManualCondition, forKey: Constant.Key.triggerManualCondition.rawValue)
        aCoder.encode(triggerAlarmCreatedCondition, forKey: Constant.Key.triggerAlarmCreatedCondition.rawValue)
        aCoder.encode(offlineModeComponents, forKey: Constant.Key.offlineModeComponents.rawValue)
    }
    
    // MARK: - Comparable
    
    static func < (lhs: Trigger, rhs: Trigger) -> Bool {
        // 1. timeDelay comes before fixedTime
        switch (lhs.triggerType, rhs.triggerType) {
        case (.timeDelay, .fixedTime): return true
        case (.fixedTime, .timeDelay): return false
        case (.timeDelay, .timeDelay):
            // 2a. if both timeDelay, smaller time delay comes first (if one is smaller)
            if lhs.timeDelayComponents.triggerTimeDelay < rhs.timeDelayComponents.triggerTimeDelay {
                return true
            }
            else if lhs.timeDelayComponents.triggerTimeDelay > rhs.timeDelayComponents.triggerTimeDelay {
                return false
            }
        case (.fixedTime, .fixedTime):
            // 2a. if both fixedTime, smaller fixed time comes first (if one is smaller)
            // If they are of the same fixed time type, ignore this check
            // If diff fixed time types, the smaller one comes first
            switch (lhs.fixedTimeComponents.triggerFixedTimeType, rhs.fixedTimeComponents.triggerFixedTimeType) {
            case let (lhsType, rhsType) where lhsType == rhsType: break
            case (.day, _): return true
            case (.week, .day): return false
            case (.week, .month): return true
            case (.month, _): return false
            default: break
            }
            
            // One with smaller fixed time type amount comes first
            // If equal, need a different tie breaker
            if lhs.fixedTimeComponents.triggerFixedTimeTypeAmount < rhs.fixedTimeComponents.triggerFixedTimeTypeAmount {
                return true
            }
            else if lhs.fixedTimeComponents.triggerFixedTimeTypeAmount > rhs.fixedTimeComponents.triggerFixedTimeTypeAmount {
                return false
            }
            
            // One with smaller fixed time hour comes first
            // If equal, need a different tie breaker
            if lhs.fixedTimeComponents.triggerFixedTimeHour < rhs.fixedTimeComponents.triggerFixedTimeHour {
                return true
            }
            else if lhs.fixedTimeComponents.triggerFixedTimeHour > rhs.fixedTimeComponents.triggerFixedTimeHour {
                return false
            }
            
            // One with smaller fixed time minute comes first
            // If equal, need a different tie breaker
            if lhs.fixedTimeComponents.triggerFixedTimeMinute < rhs.fixedTimeComponents.triggerFixedTimeMinute {
                return true
            }
            else if lhs.fixedTimeComponents.triggerFixedTimeMinute > rhs.fixedTimeComponents.triggerFixedTimeMinute {
                return false
            }
        }
        
        // 3. compare trigger id, the smaller/oldest one should come first
        switch (lhs.triggerId, rhs.triggerId) {
        case let (lhsId, rhsId) where lhsId == nil && rhsId == nil: break
        case let (lhsId, _) where lhsId == nil: return false
        case let (_, rhsId) where rhsId == nil: return true
        case let (lhsId, rhsId) where lhsId! <= rhsId!: return true // swiftlint:disable:this force_unwrapping
        default: break
        }
        
        // If all else fails, compare triggerUUID
        return lhs.triggerUUID.uuidString <= rhs.triggerUUID.uuidString
        
    }
    
    // MARK: - Properties
    
    /// The triggerId given to this trigger from the Hound database
    var triggerId: Int?
    
    /// The UUID of this dynamic log that is generated locally upon creation. Useful in identifying the dynamic log before/in the process of creating it
    var triggerUUID: UUID = UUID()

    private(set) var triggerCreated: Date = Date()
    private(set) var triggerCreatedBy: String = Constant.Class.Log.defaultUserId
    private(set) var triggerLastModified: Date?
    private(set) var triggerLastModifiedBy: String?

    private(set) var triggerLogReactions: [TriggerLogReaction] = [] {
        didSet {
            triggerLogReactions.sort { lhs, rhs in
                let lhsType = LogActionType.find(logActionTypeId: lhs.logActionTypeId)
                let rhsType = LogActionType.find(logActionTypeId: rhs.logActionTypeId)
                let lhsOrder = lhsType.sortOrder
                let rhsOrder = rhsType.sortOrder
                
                if lhsOrder != rhsOrder { return lhsOrder < rhsOrder }
                if lhs.logActionTypeId != rhs.logActionTypeId { return lhs.logActionTypeId < rhs.logActionTypeId }
                
                return lhs.logCustomActionName.localizedCaseInsensitiveCompare(rhs.logCustomActionName) == .orderedAscending
            }
        }
    }
    func setTriggerLogReactions(_ newLogReactions: [TriggerLogReaction]) -> Bool {
        if newLogReactions.isEmpty { return false }
        var seen = Set<String>()
        triggerLogReactions = newLogReactions.filter { reaction in
            let identifier = "\(reaction.logActionTypeId)-\(reaction.logCustomActionName)"
            return seen.insert(identifier).inserted
        }
        return true
    }
    
    var triggerReminderResult: TriggerReminderResult = TriggerReminderResult()
    
    var triggerType: TriggerType = Constant.Class.Trigger.defaultTriggerType
    
    private(set) var timeDelayComponents: TriggerTimeDelayComponents = TriggerTimeDelayComponents()
    private(set) var fixedTimeComponents: TriggerFixedTimeComponents = TriggerFixedTimeComponents()
    
    /// If true, the trigger will be activated by logs that were manually created by the user (no reminder/alarm)
    var triggerManualCondition: Bool = Constant.Class.Trigger.defaultTriggerManualCondition
    /// If true, the trigger will be activated by logs that were automatically created by an alarm
    var triggerAlarmCreatedCondition: Bool = Constant.Class.Trigger.defaultTriggerAlarmCreatedCondition
    
    /// Components that are used to track an object to determine whether it was synced with the Hound server and whether it needs to be when the device comes back online
    private(set) var offlineModeComponents: OfflineModeComponents = OfflineModeComponents()
    
    // MARK: - Main
    
    init(
        triggerId: Int? = nil,
        triggerUUID: UUID? = nil,
        triggerCreated: Date? = nil,
        triggerCreatedBy: String? = nil,
        triggerLastModified: Date? = nil,
        triggerLastModifiedBy: String? = nil,
        triggerLogReactions: [TriggerLogReaction]? = nil,
        triggerReminderResult: TriggerReminderResult? = nil,
        triggerType: TriggerType? = nil,
        triggerTimeDelayComponents: TriggerTimeDelayComponents? = nil,
        triggerFixedTimeComponents: TriggerFixedTimeComponents? = nil,
        triggerManualCondition: Bool? = nil,
        triggerAlarmCreatedCondition: Bool? = nil,
        offlineModeComponents: OfflineModeComponents? = nil
    ) {
        super.init()
        self.triggerId = triggerId ?? self.triggerId
        self.triggerUUID = triggerUUID ?? self.triggerUUID
        self.triggerCreated = triggerCreated ?? self.triggerCreated
        self.triggerCreatedBy = triggerCreatedBy ?? self.triggerCreatedBy
        self.triggerLastModified = triggerLastModified ?? self.triggerLastModified
        self.triggerLastModifiedBy = triggerLastModifiedBy ?? self.triggerLastModifiedBy
        self.triggerLogReactions = triggerLogReactions ?? self.triggerLogReactions
        self.triggerReminderResult = triggerReminderResult ?? self.triggerReminderResult
        self.triggerType = triggerType ?? self.triggerType
        self.timeDelayComponents = triggerTimeDelayComponents ?? self.timeDelayComponents
        self.fixedTimeComponents = triggerFixedTimeComponents ?? self.fixedTimeComponents
        self.triggerManualCondition = triggerManualCondition ?? self.triggerManualCondition
        self.triggerAlarmCreatedCondition = triggerAlarmCreatedCondition ?? self.triggerAlarmCreatedCondition
        self.offlineModeComponents = offlineModeComponents ?? self.offlineModeComponents
    }
    
    /// Provide a dictionary literal of reminder trigger properties to instantiate reminder trigger. Optionally, provide a reminder trigger to override with new properties from fromBody.
    convenience init?(fromBody: JSONResponseBody, triggerToOverride: Trigger?) {
        // Don't pull triggerId or triggerIsDeleted from triggerToOverride. A valid fromBody needs to provide this itself
        let triggerId = fromBody[Constant.Key.triggerId.rawValue] as? Int
        let triggerUUID = UUID.fromString(UUIDString: fromBody[Constant.Key.triggerUUID.rawValue] as? String)
        let triggerCreated = (fromBody[Constant.Key.triggerCreated.rawValue] as? String)?.formatISO8601IntoDate()
        let triggerIsDeleted = fromBody[Constant.Key.triggerIsDeleted.rawValue] as? Bool

        guard let triggerId = triggerId, let triggerUUID = triggerUUID, let triggerCreated = triggerCreated, let triggerIsDeleted = triggerIsDeleted else {
            return nil
        }

        guard triggerIsDeleted == false else {
            return nil
        }
        
        let triggerLastModified = (fromBody[Constant.Key.triggerLastModified.rawValue] as? String)?.formatISO8601IntoDate()
        
        // If we have pulled an update from the server which is more outdated than our local change, then ignore the data from the server. Otherwise, the newer server update takes precedence over our offline update
        if let triggerToOverride = triggerToOverride, let initialAttemptedSyncDate = triggerToOverride.offlineModeComponents.initialAttemptedSyncDate, initialAttemptedSyncDate >= triggerLastModified ?? triggerCreated {
            self.init(
                triggerId: triggerToOverride.triggerId,
                triggerUUID: triggerToOverride.triggerUUID,
                triggerCreated: triggerToOverride.triggerCreated,
                triggerCreatedBy: triggerToOverride.triggerCreatedBy,
                triggerLastModified: triggerToOverride.triggerLastModified,
                triggerLastModifiedBy: triggerToOverride.triggerLastModifiedBy,
                triggerLogReactions: triggerToOverride.triggerLogReactions,
                triggerReminderResult: triggerToOverride.triggerReminderResult,
                triggerType: triggerToOverride.triggerType,
                triggerTimeDelayComponents: triggerToOverride.timeDelayComponents,
                triggerFixedTimeComponents: triggerToOverride.fixedTimeComponents,
                triggerManualCondition: triggerToOverride.triggerManualCondition,
                triggerAlarmCreatedCondition: triggerToOverride.triggerAlarmCreatedCondition,
                offlineModeComponents: triggerToOverride.offlineModeComponents
            )
            return
        }
        
        // if the reminder trigger is the same, then we pull values from triggerToOverride
        // if the reminder trigger is updated, then we pull values from fromBody
        let triggerCreatedBy = fromBody[Constant.Key.triggerCreatedBy.rawValue] as? String ?? triggerToOverride?.triggerCreatedBy
        let triggerLastModifiedBy = fromBody[Constant.Key.triggerLastModifiedBy.rawValue] as? String ?? triggerToOverride?.triggerLastModifiedBy
        
        let reactionsBody = fromBody[Constant.Key.triggerLogReactions.rawValue] as? [JSONResponseBody]
        let triggerLogReactions = reactionsBody?.compactMap { body -> TriggerLogReaction? in
            guard let id = body[Constant.Key.logActionTypeId.rawValue] as? Int else { return nil }
            let name = body[Constant.Key.logCustomActionName.rawValue] as? String
            return TriggerLogReaction(logActionTypeId: id, logCustomActionName: name)
        } ?? triggerToOverride?.triggerLogReactions
        
        let triggerReminderResult: TriggerReminderResult? = {
            guard let body = fromBody[Constant.Key.triggerReminderResult.rawValue] as? JSONResponseBody else {
                return nil
            }
            
            return TriggerReminderResult(fromBody: body, toOverride: triggerToOverride?.triggerReminderResult)
        }() ?? triggerToOverride?.triggerReminderResult.copy() as? TriggerReminderResult
        
        let triggerType: TriggerType? = {
            guard let triggerTypeString = fromBody[Constant.Key.triggerType.rawValue] as? String else {
                return nil
            }
            return TriggerType(rawValue: triggerTypeString)
        }() ?? triggerToOverride?.triggerType
        
        let triggerTimeDelayComponents = TriggerTimeDelayComponents(fromBody: fromBody, componentToOverride: triggerToOverride?.timeDelayComponents)
        let triggerFixedTimeComponents = TriggerFixedTimeComponents(fromBody: fromBody, componentToOverride: triggerToOverride?.fixedTimeComponents)
        
        let triggerManualCondition = fromBody[Constant.Key.triggerManualCondition.rawValue] as? Bool ?? triggerToOverride?.triggerManualCondition
        let triggerAlarmCreatedCondition = fromBody[Constant.Key.triggerAlarmCreatedCondition.rawValue] as? Bool ?? triggerToOverride?.triggerAlarmCreatedCondition
        
        self.init(
            triggerId: triggerId,
            triggerUUID: triggerUUID,
            triggerCreated: triggerCreated,
            triggerCreatedBy: triggerCreatedBy,
            triggerLastModified: triggerLastModified,
            triggerLastModifiedBy: triggerLastModifiedBy,
            triggerLogReactions: triggerLogReactions,
            triggerReminderResult: triggerReminderResult,
            triggerType: triggerType,
            triggerTimeDelayComponents: triggerTimeDelayComponents,
            triggerFixedTimeComponents: triggerFixedTimeComponents,
            triggerManualCondition: triggerManualCondition,
            triggerAlarmCreatedCondition: triggerAlarmCreatedCondition,
            offlineModeComponents: nil
        )
    }
    
    // MARK: - Functions
    
    func readableTime() -> String {
        switch triggerType {
        case .timeDelay:
            return timeDelayComponents.readableTime()
        case .fixedTime:
            return fixedTimeComponents.readableTime()
        }
    }
    
    func shouldActivateTrigger(log: Log) -> Bool {
        if triggerManualCondition == false && log.logCreatedByReminderUUID == nil {
            return false
        }
        if triggerAlarmCreatedCondition == false && log.logCreatedByReminderUUID != nil {
            return false
        }
        
        for reaction in triggerLogReactions where reaction.logActionTypeId == log.logActionTypeId {
            guard reaction.logCustomActionName.hasText() else {
                return true
            }
            if reaction.logCustomActionName == log.logCustomActionName { return true }
        }
        
        return false
    }
    
    func nextReminderDate(afterDate date: Date, in inTimeZone: TimeZone = UserConfiguration.timeZone) -> Date? {
        switch triggerType {
        case .timeDelay:
            return timeDelayComponents.nextReminderDate(afterDate: date)
        case .fixedTime:
            return fixedTimeComponents.nextReminderDate(afterDate: date, in: inTimeZone)
        }
    }
    
    func nextReminderDate(afterLog log: Log, in inTimeZone: TimeZone = UserConfiguration.timeZone) -> Date? {
        let date = log.logEndDate ?? log.logStartDate
        
        return nextReminderDate(afterDate: date, in: inTimeZone)
    }
    
    /// Attempts to construct a reminder for the trigger result of this trigger, after the given log's end date (or start date). However, if this reminder is in the past, return nil as we don't want to create a reminder that is already overdue.
    func createTriggerResultReminder(afterLog log: Log, in inTimeZone: TimeZone = UserConfiguration.timeZone, currentDate: Date = Date()) -> Reminder? {
        guard let executionDate = nextReminderDate(afterLog: log, in: inTimeZone) else {
            return nil
        }
        
        // Allow for proper construction of the reminder result and if it already happened, then we don't need it
        guard executionDate > currentDate else {
            return nil
        }
        
        return Reminder(
            reminderActionTypeId: triggerReminderResult.reminderActionTypeId,
            reminderCustomActionName: triggerReminderResult.reminderCustomActionName,
            reminderType: .oneTime,
            reminderExecutionBasis: Date(),
            reminderIsTriggerResult: true,
            reminderRecipientUserIds: Constant.Class.Reminder.defaultReminderRecipientUserIds,
            oneTimeComponents: OneTimeComponents(oneTimeDate: executionDate)
        )
    }
    
    func createBody(dogUUID: UUID) -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.dogUUID.rawValue] = .string(dogUUID.uuidString)
        body[Constant.Key.triggerId.rawValue] = .int(triggerId)
        body[Constant.Key.triggerUUID.rawValue] = .string(triggerUUID.uuidString)
        body[Constant.Key.triggerCreated.rawValue] = .string(triggerCreated.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.triggerCreatedBy.rawValue] = .string(triggerCreatedBy)
        body[Constant.Key.triggerLastModified.rawValue] = .string(triggerLastModified?.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.triggerLastModifiedBy.rawValue] = .string(triggerLastModifiedBy)
        body[Constant.Key.triggerLogReactions.rawValue] = .array(triggerLogReactions.map { .object($0.createBody()) })
        body[Constant.Key.triggerReminderResult.rawValue] = .object(triggerReminderResult.createBody())
        body[Constant.Key.triggerType.rawValue] = .string(triggerType.rawValue)
        body.merge(timeDelayComponents.createBody()) { _, new in
            return new
        }
        body.merge(fixedTimeComponents.createBody()) { _, new in
            return new
        }
        body[Constant.Key.triggerManualCondition.rawValue] = .bool(triggerManualCondition)
        body[Constant.Key.triggerAlarmCreatedCondition.rawValue] = .bool(triggerAlarmCreatedCondition)
        return body
    }
    
    // MARK: - Compare
    
    /// Returns true if all server-synced properties are identical to another trigger
    func isSame(as other: Trigger) -> Bool {
        if triggerId != other.triggerId { return false }
        if triggerUUID != other.triggerUUID { return false }
        if triggerCreated != other.triggerCreated { return false }
        if triggerCreatedBy != other.triggerCreatedBy { return false }
        if triggerLastModified != other.triggerLastModified { return false }
        if triggerLastModifiedBy != other.triggerLastModifiedBy { return false }
        if triggerLogReactions.count != other.triggerLogReactions.count { return false }
        for (a, b) in zip(triggerLogReactions, other.triggerLogReactions) where !a.isSame(as: b) {
            return false
        }
        if !triggerReminderResult.isSame(as: other.triggerReminderResult) { return false }
        if triggerType != other.triggerType { return false }
        if !timeDelayComponents.isSame(as: other.timeDelayComponents) { return false }
        if !fixedTimeComponents.isSame(as: other.fixedTimeComponents) { return false }
        if triggerManualCondition != other.triggerManualCondition { return false }
        if triggerAlarmCreatedCondition != other.triggerAlarmCreatedCondition { return false }
        return true
    }
}
//
//  TriggerTimeDelayComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class TriggerTimeDelayComponents: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = TriggerTimeDelayComponents()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        
        copy.triggerTimeDelay = self.triggerTimeDelay
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let triggerTimeDelay = aDecoder.decodeOptionalDouble(forKey: Constant.Key.triggerTimeDelay.rawValue)
        
        self.init(triggerTimeDelay: triggerTimeDelay)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(triggerTimeDelay, forKey: Constant.Key.triggerTimeDelay.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var triggerTimeDelay: Double = Constant.Class.Trigger.defaultTriggerTimeDelay
    func changeTriggerTimeDelay(_ newTimeDelay: Double) -> Bool {
        guard newTimeDelay > 0 else { return false }
        triggerTimeDelay = newTimeDelay
        return true
    }
    
    // MARK: - Main
    
    init(
        triggerTimeDelay: Double? = nil
    ) {
        super.init()
        self.triggerTimeDelay = triggerTimeDelay ?? self.triggerTimeDelay
    }
    
    /// Provide a dictionary literal of reminder trigger properties to instantiate reminder trigger. Optionally, provide a reminder trigger to override with new properties from fromBody.
    convenience init?(fromBody: JSONResponseBody, componentToOverride: TriggerTimeDelayComponents?) {
        let triggerTimeDelay = fromBody[Constant.Key.triggerTimeDelay.rawValue] as? Double ?? componentToOverride?.triggerTimeDelay
        
        self.init(triggerTimeDelay: triggerTimeDelay)
    }
    
    // MARK: - Functions
    
    func readableTime() -> String {
        return "\(triggerTimeDelay.readable(capitalizeWords: false, abbreviationLevel: .short)) later"
    }
    
    func nextReminderDate(afterDate date: Date) -> Date? {
        return date.addingTimeInterval(triggerTimeDelay)
    }
    
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.triggerTimeDelay.rawValue] = .double(triggerTimeDelay)
        return body
    }
    
    // MARK: - Compare
    
    /// Returns true if all server-synced properties are identical to another trigger
    func isSame(as other: TriggerTimeDelayComponents) -> Bool {
        if triggerTimeDelay != other.triggerTimeDelay { return false }
        return true
    }
}
//
//  TriggerFixedTimeComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum TriggerFixedTimeType: String, CaseIterable {
    
    init?(rawValue: String) {
        for type in TriggerFixedTimeType.allCases where type.rawValue.lowercased() == rawValue.lowercased() {
            self = type
            return
        }
        
        self = .day
        return
    }
    
    case day
    case week
    case month
    
    var calendarComponent: Calendar.Component {
        switch self {
        case .day:
            return .day
        case .week:
            return .weekOfYear
        case .month:
            return .month
        }
    }
}

final class TriggerFixedTimeComponents: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = TriggerFixedTimeComponents()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        
        copy.triggerFixedTimeType = self.triggerFixedTimeType
        copy.triggerFixedTimeTypeAmount = self.triggerFixedTimeTypeAmount
        copy.triggerFixedTimeHour = self.triggerFixedTimeHour
        copy.triggerFixedTimeMinute = self.triggerFixedTimeMinute
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let triggerFixedTimeType = TriggerFixedTimeType(rawValue: aDecoder.decodeOptionalString(forKey: Constant.Key.triggerFixedTimeType.rawValue) ?? Constant.Class.Trigger.defaultTriggerFixedTimeType.rawValue)
        let triggerFixedTimeTypeAmount = aDecoder.decodeOptionalInteger(forKey: Constant.Key.triggerFixedTimeTypeAmount.rawValue)
        let triggerFixedTimeHour = aDecoder.decodeOptionalInteger(forKey: Constant.Key.triggerFixedTimeHour.rawValue)
        let triggerFixedTimeMinute = aDecoder.decodeOptionalInteger(forKey: Constant.Key.triggerFixedTimeMinute.rawValue)
        
        self.init(
            triggerFixedTimeType: triggerFixedTimeType,
            triggerFixedTimeTypeAmount: triggerFixedTimeTypeAmount,
            triggerFixedTimeHour: triggerFixedTimeHour,
            triggerFixedTimeMinute: triggerFixedTimeMinute,
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(triggerFixedTimeType.rawValue, forKey: Constant.Key.triggerFixedTimeType.rawValue)
        aCoder.encode(triggerFixedTimeTypeAmount, forKey: Constant.Key.triggerFixedTimeTypeAmount.rawValue)
        aCoder.encode(triggerFixedTimeHour, forKey: Constant.Key.triggerFixedTimeHour.rawValue)
        aCoder.encode(triggerFixedTimeMinute, forKey: Constant.Key.triggerFixedTimeMinute.rawValue)
    }
    // MARK: - Properties
    
    /// triggerFixedTimeType isn't used currently. leave as its default of .day
    private(set) var triggerFixedTimeType: TriggerFixedTimeType = Constant.Class.Trigger.defaultTriggerFixedTimeType
    private(set) var triggerFixedTimeTypeAmount: Int = Constant.Class.Trigger.defaultTriggerFixedTimeTypeAmount
    func changeTriggerFixedTimeTypeAmount(_ newAmount: Int) -> Bool {
        guard newAmount >= 0 else { return false }
        triggerFixedTimeTypeAmount = newAmount
        return true
    }
    /// 0-23
    private(set) var triggerFixedTimeHour: Int = Constant.Class.Trigger.defaultTriggerFixedTimeHour
    func changeFixedTimeHour(_ newHour: Int) -> Bool {
        guard (0...23).contains(newHour) else { return false }
        triggerFixedTimeHour = newHour
        return true
    }
    /// 0-59
    private(set) var triggerFixedTimeMinute: Int = Constant.Class.Trigger.defaultTriggerFixedTimeMinute
    func changeFixedTimeMinute(_ newMinute: Int) -> Bool {
        guard (0...59).contains(newMinute) else { return false }
        triggerFixedTimeMinute = newMinute
        return true
    }
    
    // MARK: - Main
    
    init(
        triggerFixedTimeType: TriggerFixedTimeType? = nil,
        triggerFixedTimeTypeAmount: Int? = nil,
        triggerFixedTimeHour: Int? = nil,
        triggerFixedTimeMinute: Int? = nil,
    ) {
        super.init()
        self.triggerFixedTimeType = triggerFixedTimeType ?? self.triggerFixedTimeType
        self.triggerFixedTimeTypeAmount = triggerFixedTimeTypeAmount ?? self.triggerFixedTimeTypeAmount
        self.triggerFixedTimeHour = triggerFixedTimeHour ?? self.triggerFixedTimeHour
        self.triggerFixedTimeMinute = triggerFixedTimeMinute ?? self.triggerFixedTimeMinute
    }
    
    convenience init?(fromBody: JSONResponseBody, componentToOverride: TriggerFixedTimeComponents?) {
        
        let triggerFixedTimeType: TriggerFixedTimeType? = {
            guard let triggerFixedTimeTypeString = fromBody[Constant.Key.triggerFixedTimeType.rawValue] as? String else {
                return nil
            }
            return TriggerFixedTimeType(rawValue: triggerFixedTimeTypeString)
        }() ?? componentToOverride?.triggerFixedTimeType
        
        let triggerFixedTimeTypeAmount = fromBody[Constant.Key.triggerFixedTimeTypeAmount.rawValue] as? Int ?? componentToOverride?.triggerFixedTimeTypeAmount
        let triggerFixedTimeHour = fromBody[Constant.Key.triggerFixedTimeHour.rawValue] as? Int ?? componentToOverride?.triggerFixedTimeHour
        let triggerFixedTimeMinute = fromBody[Constant.Key.triggerFixedTimeMinute.rawValue] as? Int ?? componentToOverride?.triggerFixedTimeMinute
   
        self.init(
            triggerFixedTimeType: triggerFixedTimeType,
            triggerFixedTimeTypeAmount: triggerFixedTimeTypeAmount,
            triggerFixedTimeHour: triggerFixedTimeHour,
            triggerFixedTimeMinute: triggerFixedTimeMinute
        )
    }
    
    // MARK: - Functions
    
    func readableTime() -> String {
        var text = ""
        switch triggerFixedTimeTypeAmount {
        case 0: text += "same day"
        case 1: text += "next day"
        default: text += "\(triggerFixedTimeTypeAmount) days later"
        }
        text += " @ \(String.convert(hour: triggerFixedTimeHour, minute: triggerFixedTimeMinute))"
        return text
    }
    
    func nextReminderDate(afterDate date: Date, in inTimeZone: TimeZone = UserConfiguration.timeZone) -> Date? {
        let calendar = Calendar.fromZone(inTimeZone)

        // Compute the start of day in the user's current time zone so the
        // "day" component aligns with local expectations.
        let startOfDay = calendar.startOfDay(for: date)
        
        // Advance by the configured component (e.g., day, week, month)
        let advanced = calendar.date(byAdding: triggerFixedTimeType.calendarComponent,
                                     value: triggerFixedTimeTypeAmount,
                                     to: startOfDay) ?? Date()

        // Set the hour/minute in the provided TZ
        let executionDate = calendar.date(
            bySettingHour: triggerFixedTimeHour,
            minute: triggerFixedTimeMinute,
            second: 0,
            of: advanced,
            matchingPolicy: .nextTimePreservingSmallerComponents,
            repeatedTimePolicy: .first,
            direction: .forward
        )

        if let executionDate = executionDate, executionDate > date {
            return executionDate
        }
        
        // specified trigger is before the date it should be after
        
        if triggerFixedTimeTypeAmount == 0 {
            // if the reminder is set for same day/week/month etc, then roll over to next day
            // e.g. its 6:00pm and trigger is for 5:00PM today, so roll over to next day
            
            let nextDay = calendar.date(byAdding: .day, value: 1, to: advanced) ?? advanced
            let nextDayDate = calendar.date(
                bySettingHour: triggerFixedTimeHour,
                minute: triggerFixedTimeMinute,
                second: 0,
                of: nextDay,
                matchingPolicy: .nextTime,
                repeatedTimePolicy: .first,
                direction: .forward
            )
            return nextDayDate
        }
        
        // this really shouldn't happen, triggerFixedTimeTypeAmount is >= 1, so (executionDate > date) should've been true as it added x number of days/weeks/months to the start of day.
        return nil
    }
    
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.triggerFixedTimeType.rawValue] = .string(triggerFixedTimeType.rawValue)
        body[Constant.Key.triggerFixedTimeTypeAmount.rawValue] = .int(triggerFixedTimeTypeAmount)
        body[Constant.Key.triggerFixedTimeHour.rawValue] = .int(triggerFixedTimeHour)
        body[Constant.Key.triggerFixedTimeMinute.rawValue] = .int(triggerFixedTimeMinute)
        return body
    }
    
    // MARK: - Compare
    
    /// Returns true if all server-synced properties are identical to another trigger
    func isSame(as other: TriggerFixedTimeComponents) -> Bool {
        if triggerFixedTimeType != other.triggerFixedTimeType { return false }
        if triggerFixedTimeTypeAmount != other.triggerFixedTimeTypeAmount { return false }
        if triggerFixedTimeHour != other.triggerFixedTimeHour { return false }
        if triggerFixedTimeMinute != other.triggerFixedTimeMinute { return false }
        return true
    }
}
//
//  DogTriggerManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/14/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class DogTriggerManager: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = DogTriggerManager()
        for trigger in dogTriggers {
            if let triggerCopy = trigger.copy() as? Trigger {
                copy.dogTriggers.append(triggerCopy)
            }
        }
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard let dogTriggers: [Trigger] = aDecoder.decodeOptionalObject(forKey: KeyConstant.dogTriggers.rawValue) else {
            return nil
        }
        
        self.init(dogTriggers: dogTriggers)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogTriggers,
                      forKey: KeyConstant.dogTriggers.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var dogTriggers: [Trigger] = []
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    init(dogTriggers: [Trigger] = []) {
        super.init()
        addTriggers(dogTriggers: dogTriggers)
    }
    
    convenience init(
        fromTriggerBodies: [JSONResponseBody],
        dogTriggerManagerToOverride: DogTriggerManager?
    ) {
        self.init(dogTriggers:
                    dogTriggerManagerToOverride?.dogTriggers ?? []
        )
        
        for fromBody in fromTriggerBodies {
            let triggerId = fromBody[KeyConstant.triggerId.rawValue] as? Int
            let triggerUUID = UUID.fromString(
                UUIDString: fromBody[KeyConstant.triggerUUID.rawValue] as? String
            )
            let triggerIsDeleted = fromBody[KeyConstant.triggerIsDeleted.rawValue] as? Bool
            
            guard triggerId != nil,
                  let triggerUUID = triggerUUID,
                  let triggerIsDeleted = triggerIsDeleted
            else {
                continue
            }
            
            guard triggerIsDeleted == false else {
                removeTrigger(triggerUUID: triggerUUID)
                continue
            }
            
            if let trigger = Trigger(
                fromBody: fromBody,
                triggerToOverride: findTrigger(triggerUUID: triggerUUID)
            ) {
                addTrigger(trigger: trigger)
            }
        }
    }
    
    // MARK: - Functions
    
    /// finds and returns the reference of a trigger matching the given UUID
    func findTrigger(
        triggerUUID: UUID
    ) -> Trigger? {
        dogTriggers.first {
            $0.triggerUUID == triggerUUID
        }
    }
    
    /// Helper function: remove existing then append without sorting
    private func addTriggerWithoutSorting(
        trigger: Trigger
    ) {
        dogTriggers.removeAll {
            $0.triggerUUID == trigger.triggerUUID
        }
        dogTriggers.append(trigger)
    }
    
    /// If a trigger with the same UUID exists, replaces it, then sorts
    func addTrigger(trigger: Trigger) {
        addTriggerWithoutSorting(trigger: trigger)
        dogTriggers.sort(by: { $0 <= $1 })
    }
    
    /// Invokes addTrigger(trigger:) for each, sorting once
    func addTriggers(
        dogTriggers: [Trigger]
    ) {
        for trigger in dogTriggers {
            addTriggerWithoutSorting(trigger: trigger)
        }
        self.dogTriggers.sort(by: { $0 <= $1 })
    }
    
    /// Returns true if at least one trigger was removed by UUID
    @discardableResult
    func removeTrigger(
        triggerUUID: UUID
    ) -> Bool {
        var didRemoveObject = false
        /// finds and returns the reference of a trigger matching the given UUID
        dogTriggers.removeAll { trigger in
            guard trigger.triggerUUID == triggerUUID else {
                return false
            }
            didRemoveObject = true
            return true
        }
        
        return didRemoveObject
    }
    
    func matchingActivatedTriggers(log: Log) -> [Trigger] {
        return dogTriggers.filter { trigger in trigger.shouldActivateTrigger(log: log) }
    }
}
//
//  TriggerLogReaction.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/10/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class TriggerLogReaction: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = TriggerLogReaction()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        copy.logActionTypeId = self.logActionTypeId
        copy.logCustomActionName = self.logCustomActionName
        
        return copy
    }
    
    // MARK: - NSCoding

    required convenience init?(coder aDecoder: NSCoder) {
        guard let decodedLogActionTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logActionTypeId.rawValue) else {
            return nil
        }
        let decodedCustomName = aDecoder.decodeOptionalString(forKey: Constant.Key.logCustomActionName.rawValue)
        self.init(logActionTypeId: decodedLogActionTypeId, logCustomActionName: decodedCustomName)
    }

    func encode(with aCoder: NSCoder) {
        aCoder.encode(logActionTypeId, forKey: Constant.Key.logActionTypeId.rawValue)
        aCoder.encode(logCustomActionName, forKey: Constant.Key.logCustomActionName.rawValue)
    }
    
    // MARK: - Properties

    private(set) var logActionTypeId: Int = Constant.Class.Log.defaultLogActionTypeId
    private(set) var logCustomActionName: String = ""
    
    // MARK: - Main

    init(logActionTypeId: Int? = nil, logCustomActionName: String? = nil) {
        self.logActionTypeId = logActionTypeId ?? self.logActionTypeId
        self.logCustomActionName = logCustomActionName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? self.logCustomActionName
        super.init()
    }
    
    convenience init(fromBody: JSONResponseBody, toOverride: TriggerLogReaction?) {
        let logActionTypeId = fromBody[Constant.Key.logActionTypeId.rawValue] as? Int ?? toOverride?.logActionTypeId
        let logCustomActionName = fromBody[Constant.Key.logCustomActionName.rawValue] as? String ?? toOverride?.logCustomActionName
        
        self.init(logActionTypeId: logActionTypeId, logCustomActionName: logCustomActionName)
    }
    
    // MARK: - Functions
    
    func readableName(includeMatchingEmoji: Bool) -> String {
        return LogActionType.find(logActionTypeId: logActionTypeId).convertToReadableName(customActionName: logCustomActionName, includeMatchingEmoji: includeMatchingEmoji)
    }
    
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.logActionTypeId.rawValue] = .int(logActionTypeId)
        body[Constant.Key.logCustomActionName.rawValue] = .string(logCustomActionName)
        return body
        
    }
    
    // MARK: - Compare
    
    /// Returns true if all server-synced properties are identical to another trigger
    func isSame(as other: TriggerLogReaction) -> Bool {
        if logActionTypeId != other.logActionTypeId { return false }
        if logCustomActionName != other.logCustomActionName { return false }
        return true
    }
    
}
//
//  TriggerReminderResult.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/10/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class TriggerReminderResult: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = TriggerReminderResult()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        copy.reminderActionTypeId = self.reminderActionTypeId
        copy.reminderCustomActionName = self.reminderCustomActionName
        
        return copy
    }
    
    // MARK: - NSCoding

    required convenience init?(coder aDecoder: NSCoder) {
        guard let decodedReminderActionTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.reminderActionTypeId.rawValue) else {
            return nil
        }
        let decodedCustomName = aDecoder.decodeOptionalString(forKey: Constant.Key.reminderCustomActionName.rawValue)
        self.init(reminderActionTypeId: decodedReminderActionTypeId, reminderCustomActionName: decodedCustomName)
    }

    func encode(with aCoder: NSCoder) {
        aCoder.encode(reminderActionTypeId, forKey: Constant.Key.reminderActionTypeId.rawValue)
        aCoder.encode(reminderCustomActionName, forKey: Constant.Key.reminderCustomActionName.rawValue)
    }
    
    // MARK: - Properties

    private(set) var reminderActionTypeId: Int = Constant.Class.Reminder.defaultReminderActionTypeId
    private(set) var reminderCustomActionName: String = ""
    
    var readableName: String {
        return ReminderActionType.find(reminderActionTypeId: reminderActionTypeId).convertToReadableName(customActionName: reminderCustomActionName, includeMatchingEmoji: true)
    }
    
    // MARK: - Main

    init(reminderActionTypeId: Int? = nil, reminderCustomActionName: String? = nil) {
        self.reminderActionTypeId = reminderActionTypeId ?? self.reminderActionTypeId
        self.reminderCustomActionName = reminderCustomActionName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? self.reminderCustomActionName
        super.init()
    }
    
    convenience init(fromBody: JSONResponseBody, toOverride: TriggerReminderResult?) {
        let reminderActionTypeId = fromBody[Constant.Key.reminderActionTypeId.rawValue] as? Int ?? toOverride?.reminderActionTypeId
        let reminderCustomActionName = fromBody[Constant.Key.reminderCustomActionName.rawValue] as? String ?? toOverride?.reminderCustomActionName
        
        self.init(reminderActionTypeId: reminderActionTypeId, reminderCustomActionName: reminderCustomActionName)
    }
    
    // MARK: - Functions
    
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.reminderActionTypeId.rawValue] = .int(reminderActionTypeId)
        body[Constant.Key.reminderCustomActionName.rawValue] = .string(reminderCustomActionName)
        return body
        
    }
    
    // MARK: - Compare
    
    /// Returns true if all server-synced properties are identical to another trigger
    func isSame(as other: TriggerReminderResult) -> Bool {
        if reminderActionTypeId != other.reminderActionTypeId { return false }
        if reminderCustomActionName != other.reminderCustomActionName { return false }
        return true
    }
    
}
//
//  Remindert.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/21/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ReminderType: String, CaseIterable {
    
    init?(rawValue: String) {
        for type in ReminderType.allCases where type.rawValue.lowercased() == rawValue.lowercased() {
            self = type
            return
        }
        
        self = .countdown
        return
    }
    case oneTime
    case countdown
    case weekly
    case monthly
    
    var readable: String {
        switch self {
        case .oneTime:
            return "Just Once"
        case .countdown:
            return "After Set Time"
        case .weekly:
            return "On Days of Week"
        case .monthly:
            return "Every Month"
        }
    }
}

final class Reminder: NSObject, NSCoding, NSCopying, Comparable {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = Reminder()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        copy.reminderId = self.reminderId
        copy.reminderUUID = self.reminderUUID
        copy.reminderCreated = self.reminderCreated
        copy.reminderCreatedBy = self.reminderCreatedBy
        copy.reminderLastModified = self.reminderLastModified
        copy.reminderLastModifiedBy = self.reminderLastModifiedBy
        copy.reminderActionTypeId = self.reminderActionTypeId
        copy.reminderCustomActionName = self.reminderCustomActionName
        copy.reminderType = self.reminderType
        copy.reminderExecutionBasis = self.reminderExecutionBasis
        copy.reminderIsTriggerResult = self.reminderIsTriggerResult
        copy.storedReminderIsEnabled = self.storedReminderIsEnabled
        copy.reminderRecipientUserIds = self.reminderRecipientUserIds
        copy.reminderTimeZone = self.reminderTimeZone
        
        copy.countdownComponents = self.countdownComponents.copy() as? CountdownComponents ?? CountdownComponents()
        copy.weeklyComponents = self.weeklyComponents.copy() as? WeeklyComponents ?? WeeklyComponents()
        copy.monthlyComponents = self.monthlyComponents.copy() as? MonthlyComponents ?? MonthlyComponents()
        copy.oneTimeComponents = self.oneTimeComponents.copy() as? OneTimeComponents ?? OneTimeComponents()
        copy.snoozeComponents = self.snoozeComponents.copy() as? SnoozeComponents ?? SnoozeComponents()
        copy.offlineModeComponents = self.offlineModeComponents.copy() as? OfflineModeComponents ?? OfflineModeComponents()
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedReminderId: Int? = aDecoder.decodeOptionalInteger(forKey: Constant.Key.reminderId.rawValue)
        let decodedReminderUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.reminderUUID.rawValue))
        let decodedReminderCreated: Date? = (aDecoder.decodeOptionalString(forKey: Constant.Key.reminderCreated.rawValue)?.formatISO8601IntoDate())
        let decodedReminderCreatedBy: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.reminderCreatedBy.rawValue)
        let decodedReminderLastModified: Date? = (aDecoder.decodeOptionalString(forKey: Constant.Key.reminderLastModified.rawValue)?.formatISO8601IntoDate())
        let decodedReminderLastModifiedBy: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.reminderLastModifiedBy.rawValue)
        let decodedReminderActionTypeId: Int? = aDecoder.decodeOptionalInteger(forKey: Constant.Key.reminderActionTypeId.rawValue)
        let decodedReminderCustomActionName: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.reminderCustomActionName.rawValue)
        let decodedReminderType: ReminderType? = ReminderType(rawValue: aDecoder.decodeOptionalString(forKey: Constant.Key.reminderType.rawValue) ?? Constant.Class.Reminder.defaultReminderType.rawValue)
        let decodedReminderExecutionBasis: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.reminderExecutionBasis.rawValue)
        let decodedReminderIsTriggerResult: Bool? = aDecoder.decodeOptionalBool(forKey: Constant.Key.reminderIsTriggerResult.rawValue)
        let decodedReminderIsEnabled: Bool? = aDecoder.decodeOptionalBool(forKey: Constant.Key.reminderIsEnabled.rawValue)
        let decodedReminderRecipientUserIds: [String]? = aDecoder.decodeOptionalObject(forKey: Constant.Key.reminderRecipientUserIds.rawValue)
        let decodedReminderTimeZone: TimeZone? = TimeZone.from(aDecoder.decodeOptionalString(forKey: Constant.Key.reminderTimeZone.rawValue))
        
        let decodedCountdownComponents: CountdownComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.countdownComponents.rawValue)
        let decodedWeeklyComponents: WeeklyComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.weeklyComponents.rawValue)
        let decodedMonthlyComponents: MonthlyComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.monthlyComponents.rawValue)
        let decodedOneTimeComponents: OneTimeComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.oneTimeComponents.rawValue)
        let decodedSnoozeComponents: SnoozeComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.snoozeComponents.rawValue)
        let decodedOfflineModeComponents: OfflineModeComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeComponents.rawValue)
        
        self.init(
            reminderId: decodedReminderId,
            reminderUUID: decodedReminderUUID,
            reminderCreated: decodedReminderCreated,
            reminderCreatedBy: decodedReminderCreatedBy,
            reminderLastModified: decodedReminderLastModified,
            reminderLastModifiedBy: decodedReminderLastModifiedBy,
            reminderActionTypeId: decodedReminderActionTypeId,
            reminderCustomActionName: decodedReminderCustomActionName,
            reminderType: decodedReminderType,
            reminderExecutionBasis: decodedReminderExecutionBasis,
            reminderIsTriggerResult: decodedReminderIsTriggerResult,
            reminderIsEnabled: decodedReminderIsEnabled,
            reminderRecipientUserIds: decodedReminderRecipientUserIds,
            reminderTimeZone: decodedReminderTimeZone,
            countdownComponents: decodedCountdownComponents,
            weeklyComponents: decodedWeeklyComponents,
            monthlyComponents: decodedMonthlyComponents,
            oneTimeComponents: decodedOneTimeComponents,
            snoozeComponents: decodedSnoozeComponents,
            offlineModeComponents: decodedOfflineModeComponents
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeInt, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        if let reminderId = reminderId {
            aCoder.encode(reminderId, forKey: Constant.Key.reminderId.rawValue)
        }
        aCoder.encode(reminderUUID.uuidString, forKey: Constant.Key.reminderUUID.rawValue)
        aCoder.encode(reminderCreated.ISO8601FormatWithFractionalSeconds(), forKey: Constant.Key.reminderCreated.rawValue)
        aCoder.encode(reminderCreatedBy, forKey: Constant.Key.reminderCreatedBy.rawValue)
        if let reminderLastModified = reminderLastModified {
            aCoder.encode(reminderLastModified.ISO8601FormatWithFractionalSeconds(), forKey: Constant.Key.reminderLastModified.rawValue)
        }
        if let reminderLastModifiedBy = reminderLastModifiedBy {
            aCoder.encode(reminderLastModifiedBy, forKey: Constant.Key.reminderLastModifiedBy.rawValue)
        }
        aCoder.encode(reminderActionTypeId, forKey: Constant.Key.reminderActionTypeId.rawValue)
        aCoder.encode(reminderCustomActionName, forKey: Constant.Key.reminderCustomActionName.rawValue)
        aCoder.encode(reminderType.rawValue, forKey: Constant.Key.reminderType.rawValue)
        aCoder.encode(reminderExecutionBasis, forKey: Constant.Key.reminderExecutionBasis.rawValue)
        aCoder.encode(reminderIsTriggerResult, forKey: Constant.Key.reminderIsTriggerResult.rawValue)
        aCoder.encode(reminderIsEnabled, forKey: Constant.Key.reminderIsEnabled.rawValue)
        aCoder.encode(reminderRecipientUserIds, forKey: Constant.Key.reminderRecipientUserIds.rawValue)
        aCoder.encode(reminderTimeZone.identifier, forKey: Constant.Key.reminderTimeZone.rawValue)
        
        aCoder.encode(countdownComponents, forKey: Constant.Key.countdownComponents.rawValue)
        aCoder.encode(weeklyComponents, forKey: Constant.Key.weeklyComponents.rawValue)
        aCoder.encode(monthlyComponents, forKey: Constant.Key.monthlyComponents.rawValue)
        aCoder.encode(oneTimeComponents, forKey: Constant.Key.oneTimeComponents.rawValue)
        aCoder.encode(snoozeComponents, forKey: Constant.Key.snoozeComponents.rawValue)
        aCoder.encode(offlineModeComponents, forKey: Constant.Key.offlineModeComponents.rawValue)
    }
    
    // MARK: - Comparable
    
    static func < (lhs: Reminder, rhs: Reminder) -> Bool {
        guard lhs.reminderType == rhs.reminderType else {
            // lhs and rhs are known to be different styles
            switch lhs.reminderType {
            case .countdown:
                // rhs can't be .countdown and .countdown always comes first, so lhs comes first
                return true
            case .weekly:
                // rhs can't be weekly. Therefore, the only way it can come before is if its .countdown
                return (rhs.reminderType == .countdown) ? false : true
            case .monthly:
                // rhs can't be monthly. Therefore, the only way it can come before is if its .countdown or .weekly
                return (rhs.reminderType == .countdown || rhs.reminderType == .weekly) ? false : true
            case .oneTime:
                // rhs can't be oneTime. Therefore, it will come before as it has to be one of the other types
                return false
            }
        }
        
        /// Analyzes both the reminderId and reminderUUID, finding which reminder is lessor than the other reminder.
        func isLHSBeforeRHS(lhs: Reminder, rhs: Reminder) -> Bool {
            guard let lhsReminderId = lhs.reminderId else {
                guard rhs.reminderId != nil else {
                    // neither lhs nor rhs has a reminderId. The one that was created first should come first
                    return lhs.offlineModeComponents.initialCreationDate.distance(to: rhs.offlineModeComponents.initialCreationDate) >= 0
                }
                
                // lhs doesn't have a reminderId but rhs does. rhs should come first
                return false
            }
            
            guard let rhsReminderId = rhs.reminderId else {
                // lhs has a reminderId but rhs doesn't. lhs should come first
                return true
            }
            
            return lhsReminderId <= rhsReminderId
        }
        
        let displayTZ = UserConfiguration.timeZone
        
        switch lhs.reminderType {
        case .countdown:
            // both countdown
            let lhsExecutionInterval = lhs.countdownComponents.executionInterval
            let rhsExecutionInterval = rhs.countdownComponents.executionInterval
            
            guard lhsExecutionInterval != rhsExecutionInterval else {
                // if equal, then smaller reminderId comes first
                return isLHSBeforeRHS(lhs: lhs, rhs: rhs)
            }
            // shorter executionInterval comes first
            return lhsExecutionInterval < rhsExecutionInterval
        case .weekly:
            // both weekly
            // earlier in the day is listed first
            let lhsTime = lhs.weeklyComponents.localTimeOfDay(reminderExecutionBasis: lhs.reminderExecutionBasis, reminderTimeZone: lhs.reminderTimeZone, displayTimeZone: displayTZ)
            let rhsTime = rhs.weeklyComponents.localTimeOfDay(reminderExecutionBasis: rhs.reminderExecutionBasis, reminderTimeZone: rhs.reminderTimeZone, displayTimeZone: displayTZ)
            
            if lhsTime.hour != rhsTime.hour {
                return lhsTime.hour < rhsTime.hour
            }
            if lhsTime.minute != rhsTime.minute {
                return lhsTime.minute < rhsTime.minute
            }
            
            return isLHSBeforeRHS(lhs: lhs, rhs: rhs)
        case .monthly:
            // both monthly
            let lhsDay = lhs.monthlyComponents.localDayOfMonth(reminderExecutionBasis: lhs.reminderExecutionBasis, reminderTimeZone: lhs.reminderTimeZone, displayTimeZone: displayTZ)
            let rhsDay = rhs.monthlyComponents.localDayOfMonth(reminderExecutionBasis: rhs.reminderExecutionBasis, reminderTimeZone: rhs.reminderTimeZone, displayTimeZone: displayTZ)
            if lhsDay != rhsDay {
                return lhsDay < rhsDay
            }
            
            let lhsTime = lhs.monthlyComponents.localTimeOfDay(reminderExecutionBasis: lhs.reminderExecutionBasis, reminderTimeZone: lhs.reminderTimeZone, displayTimeZone: displayTZ)
            let rhsTime = rhs.monthlyComponents.localTimeOfDay(reminderExecutionBasis: rhs.reminderExecutionBasis, reminderTimeZone: rhs.reminderTimeZone, displayTimeZone: displayTZ)
            
            if lhsTime.hour != rhsTime.hour {
                return lhsTime.hour < rhsTime.hour
            }
            if lhsTime.minute != rhsTime.minute {
                return lhsTime.minute < rhsTime.minute
            }
            
            return isLHSBeforeRHS(lhs: lhs, rhs: rhs)
        case .oneTime:
            // both oneTime
            let lhsDistanceToPast = Date().distance(to: lhs.oneTimeComponents.oneTimeDate)
            let rhsDistanceToPast = Date().distance(to: rhs.oneTimeComponents.oneTimeDate)
            
            guard lhsDistanceToPast != rhsDistanceToPast else {
                // if equal, then smaller reminderId comes first
                return isLHSBeforeRHS(lhs: lhs, rhs: rhs)
            }
            // not equal, the oldest one comes first
            return lhsDistanceToPast < rhsDistanceToPast
        }
    }
    
    // MARK: - Properties
    
    /// The reminderId given to this log from the Hound database
    var reminderId: Int?

    /// The UUID of this reminder that is generated locally upon creation. Useful in identifying the reminder before/in the process of creating it
    var reminderUUID: UUID = UUID()

    private(set) var reminderCreated: Date = Date()
    private(set) var reminderCreatedBy: String = Constant.Class.Log.defaultUserId
    private(set) var reminderLastModified: Date?
    private(set) var reminderLastModifiedBy: String?
    
    /// This is a user selected label for the reminder. It dictates the name that is displayed in the UI for this reminder.
    var reminderActionTypeId: Int = Constant.Class.Reminder.defaultReminderActionTypeId
    
    var reminderActionType: ReminderActionType {
        return ReminderActionType.find(reminderActionTypeId: reminderActionTypeId)
    }
    
    private var storedReminderCustomActionName: String = ""
    var reminderCustomActionName: String {
        get {
            return storedReminderCustomActionName
        }
        set {
            storedReminderCustomActionName = String((newValue.trimmingCharacters(in: .whitespacesAndNewlines)).prefix(Constant.Class.Reminder.reminderCustomActionNameCharacterLimit))
        }
    }
    
    /// Tells the reminder what components to use to make sure its in the correct timing style. Changing this changes between countdown, weekly, monthly, and oneTime mode.
    private(set) var reminderType: ReminderType = Constant.Class.Reminder.defaultReminderType
    /// Changes reminderType invokes resetForNextAlarm if reminderType is different than the current one
    func changeReminderType(_ newReminderType: ReminderType) {
        if newReminderType != reminderType {
            // If switching to a different reminder type, reset all of thew components
            resetForNextAlarm()
        }
        
        reminderType = newReminderType
    }
    
    /// This is what the reminder should base its timing off it. This is either the last time a user responded to a reminder alarm or the last time a user changed a timing related property of the reminder. For example, 5 minutes into the timer you change the countdown from 30 minutes to 15. To start the timer fresh, having it count down from the moment it was changed, reset reminderExecutionBasis to Date()
    private(set) var reminderExecutionBasis: Date = Constant.Class.Reminder.defaultReminderExecutionBasis
    
    private(set) var reminderIsTriggerResult: Bool = false
    
    private var storedReminderIsEnabled: Bool = Constant.Class.Reminder.defaultReminderIsEnabled
    /// Whether or not the reminder  is enabled, if disabled all reminders will not fire.
    var reminderIsEnabled: Bool {
        get {
            storedReminderIsEnabled
        }
        set {
            // going from disable to enabled
            if reminderIsEnabled == false && newValue == true {
                resetForNextAlarm()
            }
            
            storedReminderIsEnabled = newValue
        }
    }
    
    var reminderRecipientUserIds: [String] = Constant.Class.Reminder.defaultReminderRecipientUserIds
    
    var reminderTimeZone: TimeZone = UserConfiguration.timeZone
    
    // Reminder Components
    
    private(set) var countdownComponents: CountdownComponents = CountdownComponents()
    private(set) var weeklyComponents: WeeklyComponents = WeeklyComponents()
    private(set) var monthlyComponents: MonthlyComponents = MonthlyComponents()
    private(set) var oneTimeComponents: OneTimeComponents = OneTimeComponents()
    private(set) var snoozeComponents: SnoozeComponents = SnoozeComponents()
    /// Components that are used to track an object to determine whether it was synced with the Hound server and whether it needs to be when the device comes back online
    private(set) var offlineModeComponents: OfflineModeComponents = OfflineModeComponents()
    
    // MARK: - Main
    
    init(
        reminderId: Int? = nil,
        reminderUUID: UUID? = nil,
        reminderCreated: Date? = nil,
        reminderCreatedBy: String? = nil,
        reminderLastModified: Date? = nil,
        reminderLastModifiedBy: String? = nil,
        reminderActionTypeId: Int? = nil,
        reminderCustomActionName: String? = nil,
        reminderType: ReminderType? = nil,
        reminderExecutionBasis: Date? = nil,
        reminderIsTriggerResult: Bool? = nil,
        reminderIsEnabled: Bool? = nil,
        reminderRecipientUserIds: [String]? = nil,
        reminderTimeZone: TimeZone? = nil,
        countdownComponents: CountdownComponents? = nil,
        weeklyComponents: WeeklyComponents? = nil,
        monthlyComponents: MonthlyComponents? = nil,
        oneTimeComponents: OneTimeComponents? = nil,
        snoozeComponents: SnoozeComponents? = nil,
        offlineModeComponents: OfflineModeComponents? = nil
    ) {
        super.init()

        self.reminderId = reminderId ?? self.reminderId
        self.reminderUUID = reminderUUID ?? self.reminderUUID
        self.reminderCreated = reminderCreated ?? self.reminderCreated
        self.reminderCreatedBy = reminderCreatedBy ?? self.reminderCreatedBy
        self.reminderLastModified = reminderLastModified ?? self.reminderLastModified
        self.reminderLastModifiedBy = reminderLastModifiedBy ?? self.reminderLastModifiedBy
        self.reminderActionTypeId = reminderActionTypeId ?? self.reminderActionTypeId
        self.reminderCustomActionName = reminderCustomActionName ?? self.reminderCustomActionName
        self.reminderType = reminderType ?? self.reminderType
        self.reminderExecutionBasis = reminderExecutionBasis ?? self.reminderExecutionBasis
        self.reminderIsTriggerResult = reminderIsTriggerResult ?? self.reminderIsTriggerResult
        self.reminderIsEnabled = reminderIsEnabled ?? self.reminderIsEnabled
        self.reminderRecipientUserIds = reminderRecipientUserIds ?? self.reminderRecipientUserIds
        self.reminderTimeZone = reminderTimeZone ?? self.reminderTimeZone

        self.countdownComponents = countdownComponents ?? self.countdownComponents
        self.weeklyComponents = weeklyComponents ?? self.weeklyComponents
        self.monthlyComponents = monthlyComponents ?? self.monthlyComponents
        self.oneTimeComponents = oneTimeComponents ?? self.oneTimeComponents
        self.snoozeComponents = snoozeComponents ?? self.snoozeComponents
        self.offlineModeComponents = offlineModeComponents ?? self.offlineModeComponents
    }
    
    /// Provide a dictionary literal of reminder properties to instantiate reminder. Optionally, provide a reminder to override with new properties from fromBody.
    convenience init?(fromBody: JSONResponseBody, reminderToOverride: Reminder?) {
        // Don't pull reminderId or reminderIsDeleted from reminderToOverride. A valid fromBody needs to provide this itself
        let reminderId: Int? = fromBody[Constant.Key.reminderId.rawValue] as? Int
        let reminderUUID: UUID? = UUID.fromString(UUIDString: fromBody[Constant.Key.reminderUUID.rawValue] as? String)
        let reminderCreated: Date? = (fromBody[Constant.Key.reminderCreated.rawValue] as? String)?.formatISO8601IntoDate()
        let reminderIsDeleted: Bool? = fromBody[Constant.Key.reminderIsDeleted.rawValue] as? Bool

        guard let reminderId = reminderId, let reminderUUID = reminderUUID, let reminderCreated = reminderCreated, let reminderIsDeleted = reminderIsDeleted else {
            return nil
        }
        
        guard reminderIsDeleted == false else {
            return nil
        }
        
        let reminderLastModified: Date? = (fromBody[Constant.Key.reminderLastModified.rawValue] as? String)?.formatISO8601IntoDate()
        
        // If we have pulled an update from the server which is more outdated than our local change, then ignore the data from the server. Otherwise, the newer update takes precedence over our update
        if let reminderToOverride = reminderToOverride, let initialAttemptedSyncDate = reminderToOverride.offlineModeComponents.initialAttemptedSyncDate, initialAttemptedSyncDate >= reminderLastModified ?? reminderCreated {
            self.init(
                reminderId: reminderToOverride.reminderId,
                reminderUUID: reminderToOverride.reminderUUID,
                reminderCreated: reminderToOverride.reminderCreated,
                reminderCreatedBy: reminderToOverride.reminderCreatedBy,
                reminderLastModified: reminderToOverride.reminderLastModified,
                reminderLastModifiedBy: reminderToOverride.reminderLastModifiedBy,
                reminderActionTypeId: reminderToOverride.reminderActionTypeId,
                reminderCustomActionName: reminderToOverride.reminderCustomActionName,
                reminderType: reminderToOverride.reminderType,
                reminderExecutionBasis: reminderToOverride.reminderExecutionBasis,
                reminderIsTriggerResult: reminderToOverride.reminderIsTriggerResult,
                reminderIsEnabled: reminderToOverride.reminderIsEnabled,
                reminderRecipientUserIds: reminderToOverride.reminderRecipientUserIds,
                reminderTimeZone: reminderToOverride.reminderTimeZone,
                countdownComponents: reminderToOverride.countdownComponents,
                weeklyComponents: reminderToOverride.weeklyComponents,
                monthlyComponents: reminderToOverride.monthlyComponents,
                oneTimeComponents: reminderToOverride.oneTimeComponents,
                snoozeComponents: reminderToOverride.snoozeComponents,
                offlineModeComponents: reminderToOverride.offlineModeComponents
            )
            return
        }
        
        // if the reminder is the same, then we pull values from reminderToOverride
        // if the reminder is updated, then we pull values from fromBody
        // reminder
        let reminderCreatedBy: String? = fromBody[Constant.Key.reminderCreatedBy.rawValue] as? String ?? reminderToOverride?.reminderCreatedBy
        let reminderLastModifiedBy: String? = fromBody[Constant.Key.reminderLastModifiedBy.rawValue] as? String ?? reminderToOverride?.reminderLastModifiedBy
        
        let reminderActionTypeId: Int? = fromBody[Constant.Key.reminderActionTypeId.rawValue] as? Int ?? reminderToOverride?.reminderActionTypeId
        let reminderCustomActionName: String? = fromBody[Constant.Key.reminderCustomActionName.rawValue] as? String
        let reminderType: ReminderType? = {
            guard let reminderTypeString = fromBody[Constant.Key.reminderType.rawValue] as? String else {
                return nil
            }
            return ReminderType(rawValue: reminderTypeString)
        }() ?? reminderToOverride?.reminderType
        let reminderExecutionBasis: Date? = {
            guard let reminderExecutionBasisString = fromBody[Constant.Key.reminderExecutionBasis.rawValue] as? String else {
                return nil
            }
            return reminderExecutionBasisString.formatISO8601IntoDate()
        }() ?? reminderToOverride?.reminderExecutionBasis
        let reminderIsTriggerResult: Bool? = fromBody[Constant.Key.reminderIsTriggerResult.rawValue] as? Bool ?? reminderToOverride?.reminderIsTriggerResult
        let reminderIsEnabled: Bool? = fromBody[Constant.Key.reminderIsEnabled.rawValue] as? Bool ?? reminderToOverride?.reminderIsEnabled
        let reminderRecipientUserIds: [String]? = fromBody[Constant.Key.reminderRecipientUserIds.rawValue] as? [String] ?? reminderToOverride?.reminderRecipientUserIds
        let reminderTimeZone: TimeZone? = TimeZone.from(fromBody[Constant.Key.reminderTimeZone.rawValue] as? String) ?? reminderToOverride?.reminderTimeZone
        
        // reminderCustomActionName can be nil
        guard let reminderActionTypeId = reminderActionTypeId,
              let reminderCustomActionName = reminderCustomActionName,
              let reminderType = reminderType,
              let reminderExecutionBasis = reminderExecutionBasis,
              let reminderIsTriggerResult = reminderIsTriggerResult,
              let reminderIsEnabled = reminderIsEnabled,
              let reminderRecipientUserIds = reminderRecipientUserIds,
              let reminderTimeZone = reminderTimeZone else {
            return nil
        }
        
        let countdownComponents = CountdownComponents(fromBody: fromBody, componentToOverride: reminderToOverride?.countdownComponents)
        let weekdayComponents = WeeklyComponents(fromBody: fromBody, componentToOverride: reminderToOverride?.weeklyComponents)
        let monthlyComponents = MonthlyComponents(fromBody: fromBody, componentToOverride: reminderToOverride?.monthlyComponents)
        let oneTimeComponents = OneTimeComponents(fromBody: fromBody, componentToOverride: reminderToOverride?.oneTimeComponents)
        let snoozeComponents = SnoozeComponents(fromBody: fromBody, componentToOverride: reminderToOverride?.snoozeComponents)
        
        self.init(
            reminderId: reminderId,
            reminderUUID: reminderUUID,
            reminderCreated: reminderCreated,
            reminderCreatedBy: reminderCreatedBy,
            reminderLastModified: reminderLastModified,
            reminderLastModifiedBy: reminderLastModifiedBy,
            reminderActionTypeId: reminderActionTypeId,
            reminderCustomActionName: reminderCustomActionName,
            reminderType: reminderType,
            reminderExecutionBasis: reminderExecutionBasis,
            reminderIsTriggerResult: reminderIsTriggerResult,
            reminderIsEnabled: reminderIsEnabled,
            reminderRecipientUserIds: reminderRecipientUserIds,
            reminderTimeZone: reminderTimeZone,
            countdownComponents: countdownComponents,
            weeklyComponents: weekdayComponents,
            monthlyComponents: monthlyComponents,
            oneTimeComponents: oneTimeComponents,
            snoozeComponents: snoozeComponents,
            // Verified that the update from the server happened more recently than our local changes, so no need to offline sync anymore
            offlineModeComponents: nil
        )
    }
    
    // MARK: - Functions
    
    func readableRecurrance(displayTimeZone: TimeZone = UserConfiguration.timeZone) -> String {
        switch self.reminderType {
        case .countdown:
            return countdownComponents.readableRecurrance
        case .weekly:
            return weeklyComponents.readableRecurrance(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone, displayTimeZone: displayTimeZone)
        case .monthly:
            return monthlyComponents.readableRecurrence(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone, displayTimeZone: displayTimeZone)
        case .oneTime:
            return oneTimeComponents.readableRecurrance(displayTimeZone: displayTimeZone)
        }
    }
    // MARK: - Timing
    
    var reminderExecutionDate: Date? {
        guard reminderIsEnabled == true else {
            return nil
        }
        
        if snoozeComponents.isSnoozing, let snooze = snoozeComponents.executionInterval {
            return Date(timeInterval: snooze, since: reminderExecutionBasis)
        }
        
        switch reminderType {
        case .oneTime:
            return oneTimeComponents.oneTimeDate
        case .countdown:
            return Date(timeInterval: countdownComponents.executionInterval, since: reminderExecutionBasis)
        case .weekly:
            return weeklyComponents.nextExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
        case .monthly:
            return monthlyComponents.nextExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
        }
    }
    
    /// Restores the reminder to a state where it is ready for its next alarm. This resets reminderExecutionBasis, clears skippedDates, and clears snooze. Typically use if reminder's alarm executed and user responded to it or if reminder's timing has updated and needs a complete reset.
    func resetForNextAlarm() {
        reminderExecutionBasis = Date()
        
        snoozeComponents.changeExecutionInterval(nil)
        weeklyComponents.skippedDate = nil
        monthlyComponents.skippedDate = nil
    }
    
    /// Finds the date which the reminder should be transformed from isSkipping to not isSkipping. This is the date at which the skipped reminder would have occured.
    var disableIsSkippingDate: Date? {
        guard reminderIsEnabled && !snoozeComponents.isSnoozing else {
            return nil
        }
        
        if reminderType == .monthly && monthlyComponents.isSkipping == true {
            return monthlyComponents.notSkippingExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
        }
        else if reminderType == .weekly && weeklyComponents.isSkipping == true {
            return weeklyComponents.notSkippingExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
        }
        
        return nil
    }
    
    /// Call this function when a user driven action directly intends to enable the skip status of the weekly or monthy components. This function only timing related data, no logs are added or removed. Additioanlly, if oneTime is getting skipped, it must be deleted externally.
    func enableIsSkipping(skippedDate: Date?) {
        guard reminderIsEnabled else { return }
        
        switch reminderType {
        case .oneTime: break
            // oneTime can't skip
        case .countdown:
            resetForNextAlarm()
        case .weekly:
            weeklyComponents.skippedDate = skippedDate
        case .monthly:
            monthlyComponents.skippedDate = skippedDate
        }
    }
    
    /// Call this function when a user driven action directly intends to disable the skip status of the weekly or monthy components. This function only timing related data, no logs are added or removed.
    func disableIsSkipping() {
        guard reminderIsEnabled else { return }
        
        switch reminderType {
        case .oneTime: break
        case .countdown: break
        case .weekly:
            weeklyComponents.skippedDate = nil
        case .monthly:
            monthlyComponents.skippedDate = nil
        }
    }
    
}

extension Reminder {
    
    // MARK: - Duplicate
    
    /// Copys a reminder then removes/resets certain properties. This allows a reminder to be an independent copy of a reminder (aka a duplicate) instead of an exact 1:1 clone
    func duplicate() -> Reminder? {
        guard let duplicate = self.copy() as? Reminder else {
            return nil
        }
        
        duplicate.reminderId = nil
        duplicate.reminderUUID = UUID()
        duplicate.reminderExecutionBasis = Constant.Class.Reminder.defaultReminderExecutionBasis
        
        duplicate.resetForNextAlarm()
        
        return duplicate
    }
    
    // MARK: - Compare
    
    /// Returns true if all the server synced properties for the reminder are the same. This includes all the base properties here (yes the reminderId too) and the reminder components for the corresponding reminderActionTypeId
    func isSame(as other: Reminder) -> Bool {
        if reminderId != other.reminderId {
            return false
        }
        else if reminderUUID != other.reminderUUID {
            return false
        }
        else if reminderCreated != other.reminderCreated {
            return false
        }
        else if reminderCreatedBy != other.reminderCreatedBy {
            return false
        }
        else if reminderLastModified != other.reminderLastModified {
            return false
        }
        else if reminderLastModifiedBy != other.reminderLastModifiedBy {
            return false
        }
        else if reminderActionTypeId != other.reminderActionTypeId {
            return false
        }
        else if reminderCustomActionName != other.reminderCustomActionName {
            return false
        }
        else if reminderType != other.reminderType {
            return false
        }
        else if reminderExecutionBasis != other.reminderExecutionBasis {
            return false
        }
        else if reminderIsEnabled != other.reminderIsEnabled {
            return false
        }
        else if Set(reminderRecipientUserIds) != Set(other.reminderRecipientUserIds) {
            return false
        }
        else if reminderIsTriggerResult != other.reminderIsTriggerResult {
            return false
        }
        else if reminderTimeZone != other.reminderTimeZone {
            return false
        }
        
        // known at this point that the reminderTypes are the same
        switch reminderType {
        case .countdown:
            if !countdownComponents.isSame(as: other.countdownComponents) {
                return false
            }
        case .weekly:
            if !weeklyComponents.isSame(as: other.weeklyComponents) {
                return false
            }
        case .monthly:
            if !monthlyComponents.isSame(as: other.monthlyComponents) {
                return false
            }
        case .oneTime:
            if !oneTimeComponents.isSame(as: other.oneTimeComponents) {
                return false
            }
        }
        
        if !snoozeComponents.isSame(as: other.snoozeComponents) {
            return false
        }
        
        return true
    }
    
    // MARK: - Request
    
    /// Returns an array literal of the reminders's properties. This is suitable to be used as the JSON body for a HTTP request
    func createBody(dogUUID: UUID) -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.dogUUID.rawValue] = .string(dogUUID.uuidString)
        body[Constant.Key.reminderId.rawValue] = .int(reminderId)
        body[Constant.Key.reminderUUID.rawValue] = .string(reminderUUID.uuidString)
        body[Constant.Key.reminderCreated.rawValue] = .string(reminderCreated.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.reminderCreatedBy.rawValue] = .string(reminderCreatedBy)
        body[Constant.Key.reminderLastModified.rawValue] = .string(reminderLastModified?.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.reminderLastModifiedBy.rawValue] = .string(reminderLastModifiedBy)
        body[Constant.Key.reminderActionTypeId.rawValue] = .int(reminderActionTypeId)
        body[Constant.Key.reminderCustomActionName.rawValue] = .string(reminderCustomActionName)
        body[Constant.Key.reminderType.rawValue] = .string(reminderType.rawValue)
        body[Constant.Key.reminderExecutionBasis.rawValue] = .string(reminderExecutionBasis.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.reminderExecutionDate.rawValue] = .string(reminderExecutionDate?.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.reminderIsTriggerResult.rawValue] = .bool(reminderIsTriggerResult)
        body[Constant.Key.reminderIsEnabled.rawValue] = .bool(reminderIsEnabled)
        body[Constant.Key.reminderRecipientUserIds.rawValue] = .array(reminderRecipientUserIds.map { .string($0) })
        body[Constant.Key.reminderTimeZone.rawValue] = .string(reminderTimeZone.identifier)
        
        body.merge(countdownComponents.createBody()) { _, new in
            return new
        }
        body.merge(weeklyComponents.createBody()) { _, new in
            return new
        }
        body.merge(monthlyComponents.createBody()) { _, new in
            return new
        }
        body.merge(oneTimeComponents.createBody()) { _, new in
            return new
        }
        body.merge(snoozeComponents.createBody()) { _, new in
            return new
        }
        return body
    }
}
//
//  Reminder.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/20/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class DogReminderManager: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = DogReminderManager()
        for dogReminder in dogReminders {
            if let reminderCopy = dogReminder.copy() as? Reminder {
                copy.dogReminders.append(reminderCopy)            }
        }
        return copy
    }
    
    // MARK: - NSCoding
    
    required init?(coder aDecoder: NSCoder) {
        dogReminders = aDecoder.decodeOptionalObject(forKey: Constant.Key.dogReminders.rawValue) ?? dogReminders
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogReminders, forKey: Constant.Key.dogReminders.rawValue)
    }
    
    // MARK: - Properties
    
    /// Array of dogReminders
    private(set) var dogReminders: [Reminder] = []
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    init(reminders: [Reminder] = []) {
        super.init()
        addReminders(reminders: reminders)
    }
    
    /// Provide an array of dictionary literal of reminder properties to instantiate dogReminders. Provide a reminderManager to have the dogReminders add themselves into, update themselves in, or delete themselves from.
    convenience init(fromReminderBodies: [JSONResponseBody], dogReminderManagerToOverride: DogReminderManager?) {
        self.init(reminders: dogReminderManagerToOverride?.dogReminders ?? [])
        
        for fromBody in fromReminderBodies {
            // Don't pull properties from reminderToOverride. A valid fromBody needs to provide this itself
            let reminderId = fromBody[Constant.Key.reminderId.rawValue] as? Int
            let reminderUUID = UUID.fromString(UUIDString: fromBody[Constant.Key.reminderUUID.rawValue] as? String)
            let reminderIsDeleted = fromBody[Constant.Key.reminderIsDeleted.rawValue] as? Bool
            
            guard reminderId != nil, let reminderUUID = reminderUUID, let reminderIsDeleted = reminderIsDeleted else {
                // couldn't construct essential components to intrepret reminder
                continue
            }
            
            guard reminderIsDeleted == false else {
                removeReminder(reminderUUID: reminderUUID)
                continue
            }
            
            if let reminder = Reminder(fromBody: fromBody, reminderToOverride: findReminder(reminderUUID: reminderUUID)) {
                addReminder(reminder: reminder)
            }
        }
    }
    
    // MARK: - Functions
    
    /// finds and returns the reference of a reminder matching the given reminderUUID
    func findReminder(reminderUUID: UUID) -> Reminder? {
        dogReminders.first(where: { $0.reminderUUID == reminderUUID })
    }
    
    /// Helper function allows us to use the same logic for addReminder and addReminders and allows us to only sort at the end. Without this function, addReminders would invoke addReminder repeadly and sortReminders() with each call.
    private func addReminderWithoutSorting(reminder: Reminder) {
        dogReminders.removeAll { r in
            return r.reminderUUID == reminder.reminderUUID
        }
        
        dogReminders.append(reminder)
    }
    
    /// If a reminder with the same UUID is already present, removes it. Then adds the new dogReminders
    func addReminder(reminder: Reminder) {
        
        addReminderWithoutSorting(reminder: reminder)
        
        dogReminders.sort(by: { $0 <= $1 })
    }
    
    /// Invokes addReminder(reminder: Reminder) for newReminder.count times (but only sorts once at the end to be more efficent)
    func addReminders(reminders: [Reminder]) {
        for reminder in reminders {
            addReminderWithoutSorting(reminder: reminder)
        }
        
        dogReminders.sort(by: { $0 <= $1 })
    }
    
    /// Returns true if it removed at least one reminder with the same reminderUUID
    @discardableResult func removeReminder(reminderUUID: UUID) -> Bool {
        var didRemoveObject = false
        
        dogReminders.removeAll { r in
            guard r.reminderUUID == reminderUUID else {
                return false
            }
            
            didRemoveObject = true
            return true
        }
        
        return didRemoveObject
    }
}
//
//  PreviousReminderCustomActionName.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/6/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

class PreviousReminderCustomActionName: NSObject, NSCoding {

    // MARK: - NSCoding

    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let decodedReminderActionTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.reminderActionTypeId.rawValue),
            let decodedReminderCustomActionName = aDecoder.decodeOptionalString(forKey: Constant.Key.reminderCustomActionName.rawValue)
        else {
            return nil
        }
        self.init(reminderActionTypeId: decodedReminderActionTypeId, reminderCustomActionName: decodedReminderCustomActionName)
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(reminderActionTypeId, forKey: Constant.Key.reminderActionTypeId.rawValue)
        aCoder.encode(reminderCustomActionName, forKey: Constant.Key.reminderCustomActionName.rawValue)
    }

    // MARK: - Properties
    
    private(set) var reminderActionTypeId: Int
    private(set) var reminderCustomActionName: String
    
    static let maxStored = 3
    
    // MARK: - Main
    
    init(reminderActionTypeId: Int, reminderCustomActionName: String) {
        self.reminderActionTypeId = reminderActionTypeId
        self.reminderCustomActionName = reminderCustomActionName
        super.init()
    }
    
}
//
//  countdownComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class CountdownComponents: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = CountdownComponents()
        copy.executionInterval = executionInterval
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let executionInterval = aDecoder.decodeOptionalDouble(forKey: Constant.Key.countdownExecutionInterval.rawValue)
        self.init(executionInterval: executionInterval)
    }
    
    func encode(with aCoder: NSCoder) {
        aCoder.encode(executionInterval, forKey: Constant.Key.countdownExecutionInterval.rawValue)
    }
    
    // MARK: - Properties
    
    var readableTimeOfDay: String {
        return executionInterval.readable(capitalizeWords: true, abbreviationLevel: .long)
    }
    
    var readableRecurrance: String {
        return "Every \(readableTimeOfDay)"
    }
    
    /// Interval at which a countdown should be last for reminder
    var executionInterval: Double = Constant.Class.ReminderComponent.defaultCountdownExecutionInterval
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    init(executionInterval: Double? = nil) {
        super.init()
        self.executionInterval = executionInterval ?? self.executionInterval
    }
    
    convenience init(fromBody: JSONResponseBody, componentToOverride: CountdownComponents?) {
        let countdownExecutionInterval: Double? = fromBody[Constant.Key.countdownExecutionInterval.rawValue] as? Double ?? componentToOverride?.executionInterval
        
        self.init(executionInterval: countdownExecutionInterval)
    }
    
    // MARK: - Compare
    
    /// Returns true if all stored properties are equivalent
    func isSame(as other: CountdownComponents) -> Bool {
        return executionInterval == other.executionInterval
    }
    
    // MARK: - Request
    
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.countdownExecutionInterval.rawValue] = .double(executionInterval)
        return body
    }
    
}
//
//  SnoozeComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class SnoozeComponents: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = SnoozeComponents()
        copy.executionInterval = executionInterval
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let executionInterval = aDecoder.decodeOptionalDouble(forKey: Constant.Key.snoozeExecutionInterval.rawValue)
        
        self.init(executionInterval: executionInterval)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        if let executionInterval = executionInterval {
            aCoder.encode(executionInterval, forKey: Constant.Key.snoozeExecutionInterval.rawValue)
        }
    }
    
    // MARK: - Properties
    
    /// Interval at which a snooze should be last for reminder. If this value isn't nil, then the reminder is snoozing.
    private(set) var executionInterval: Double?
    var isSnoozing: Bool {
        return executionInterval != nil && (executionInterval ?? 0.0) > 0.0
    }
    @discardableResult
    func changeExecutionInterval(_ newExecutionInterval: Double?) -> Bool {
        guard let newExecutionInterval = newExecutionInterval else {
            executionInterval = nil
            return true
        }
        
        guard newExecutionInterval > 0 else {
            return false
        }
        
        executionInterval = newExecutionInterval
        return true
    }
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    convenience init(executionInterval: Double? = nil) {
        self.init()
        
        self.executionInterval = executionInterval ?? self.executionInterval
    }
    
    convenience init(fromBody: JSONResponseBody, componentToOverride: SnoozeComponents?) {
        let snoozeExecutionInterval: Double? = fromBody[Constant.Key.snoozeExecutionInterval.rawValue] as? Double ?? componentToOverride?.executionInterval
        
        self.init(executionInterval: snoozeExecutionInterval)
    }
    
    // MARK: - Compare
    
    /// Returns true if all stored properties are equivalent
    func isSame(as other: SnoozeComponents) -> Bool {
        return executionInterval == other.executionInterval
    }
    
    // MARK: - Request
    
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.snoozeExecutionInterval.rawValue] = .double(executionInterval)
        return body
    }
    
}
//
//  MonthlyComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class MonthlyComponents: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = MonthlyComponents()
        copy.zonedDay = self.zonedDay
        copy.zonedHour = self.zonedHour
        copy.zonedMinute = self.zonedMinute
        copy.skippedDate = self.skippedDate
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let zonedDay = aDecoder.decodeOptionalInteger(forKey: Constant.Key.monthlyZonedDay.rawValue)
        let zonedHour = aDecoder.decodeOptionalInteger(forKey: Constant.Key.monthlyZonedHour.rawValue)
        let zonedMinute = aDecoder.decodeOptionalInteger(forKey: Constant.Key.monthlyZonedMinute.rawValue)
        let skippedDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.monthlySkippedDate.rawValue)
        
        self.init(zonedDay: zonedDay, zonedHour: zonedHour, zonedMinute: zonedMinute, skippedDate: skippedDate)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        aCoder.encode(zonedDay, forKey: Constant.Key.monthlyZonedDay.rawValue)
        aCoder.encode(zonedHour, forKey: Constant.Key.monthlyZonedHour.rawValue)
        aCoder.encode(zonedMinute, forKey: Constant.Key.monthlyZonedMinute.rawValue)
        if let skippedDate = skippedDate {
            aCoder.encode(skippedDate, forKey: Constant.Key.monthlySkippedDate.rawValue)
        }
    }
    
    // MARK: - Properties
    
    /// User-selected day of month in the source time zone (1-31).
    /// If this value exceeds the days in a particular month (e.g. 31 in April), the calculation will roll down to the last day of the month (e.g. April 30).
    private(set) var zonedDay: Int = Constant.Class.ReminderComponent.defaultZonedDay
    /// User-selected hour in the source time zone (0-23).
    private(set) var zonedHour: Int = Constant.Class.ReminderComponent.defaultZonedHour
    /// User-selected minute in the source time zone (0-59).
    private(set) var zonedMinute: Int = Constant.Class.ReminderComponent.defaultZonedMinute
    
    /// Set to non-nil if the next scheduled execution should be skipped (e.g. due to a user-initiated skip).
    var skippedDate: Date?
    var isSkipping: Bool { skippedDate != nil }
    
    // MARK: - Initializers
    
    override init() {
        super.init()
    }
    
    convenience init(zonedDay: Int? = nil, zonedHour: Int? = nil, zonedMinute: Int? = nil, skippedDate: Date? = nil) {
        self.init()
        self.zonedDay = zonedDay ?? self.zonedDay
        self.zonedHour = zonedHour ?? self.zonedHour
        self.zonedMinute = zonedMinute ?? self.zonedMinute
        self.skippedDate = skippedDate ?? self.skippedDate
    }
    
    convenience init(fromBody: JSONResponseBody, componentToOverride: MonthlyComponents?) {
        let monthlyZonedDay = fromBody[Constant.Key.monthlyZonedDay.rawValue] as? Int ?? componentToOverride?.zonedDay
        let monthlyZonedHour = fromBody[Constant.Key.monthlyZonedHour.rawValue] as? Int ?? componentToOverride?.zonedHour
        let monthlyZonedMinute = fromBody[Constant.Key.monthlyZonedMinute.rawValue] as? Int ?? componentToOverride?.zonedMinute
        let monthlySkippedDate = (fromBody[Constant.Key.monthlySkippedDate.rawValue] as? String)?.formatISO8601IntoDate() ?? componentToOverride?.skippedDate
        
        self.init(zonedDay: monthlyZonedDay, zonedHour: monthlyZonedHour, zonedMinute: monthlyZonedMinute, skippedDate: monthlySkippedDate)
    }
    
    // MARK: - Functions
    
    func localTimeOfDay(reminderExecutionBasis: Date, reminderTimeZone: TimeZone, displayTimeZone: TimeZone? = nil) -> (hour: Int, minute: Int) {
        let referenceDate = notSkippingExecutionDate(
            reminderExecutionBasis: reminderExecutionBasis,
            reminderTimeZone: reminderTimeZone
        )
        
        return reminderTimeZone.convert(hour: zonedHour, minute: zonedMinute, to: displayTimeZone ?? reminderTimeZone, referenceDate: referenceDate ?? Date())
    }
    
    func localDayOfMonth(reminderExecutionBasis: Date, reminderTimeZone: TimeZone, displayTimeZone: TimeZone? = nil) -> Int {
        let referenceDate = notSkippingExecutionDate(
            reminderExecutionBasis: reminderExecutionBasis,
            reminderTimeZone: reminderTimeZone
        )
        
        let (day, _, _) = reminderTimeZone.convert(
            day: zonedDay,
            hour: zonedHour,
            minute: zonedMinute,
            to: displayTimeZone ?? reminderTimeZone,
            referenceDate: referenceDate ?? reminderExecutionBasis
        )
        return day
    }
    
    /// Returns a readable recurrence string in the *destination* time zone.
    /// Example: "Every 31st at 7:30 PM" (will adjust hour/minute for destination zone).
    /// NOTE: If the requested day does not exist in a month, the reminder will run on the last valid day of that month (e.g. "31" on April will run April 30).
    func readableRecurrence(reminderExecutionBasis: Date, reminderTimeZone: TimeZone, displayTimeZone: TimeZone? = nil) -> String {
        let referenceDate = notSkippingExecutionDate(
            reminderExecutionBasis: reminderExecutionBasis,
            reminderTimeZone: reminderTimeZone
        )
        
        let (day, hour, minute) = reminderTimeZone.convert(
            day: zonedDay,
            hour: zonedHour,
            minute: zonedMinute,
            to: displayTimeZone ?? reminderTimeZone,
            referenceDate: referenceDate ?? reminderExecutionBasis
        )
        
        return "Every \(day)\(day.daySuffix()) at \(String.convert(hour: hour, minute: minute))"
    }
    
    // MARK: - Mutation
    
    /// Updates the component using the provided date in the specified time zone.
    func configure(from date: Date, timeZone: TimeZone) {
        let calendar = Calendar.fromZone(timeZone)
        let comps = calendar.dateComponents([.day, .hour, .minute], from: date)
        if let day = comps.day { zonedDay = day }
        if let hour = comps.hour { zonedHour = hour }
        if let minute = comps.minute { zonedMinute = minute }
    }
    
    /// Copies zoned values from another monthly component.
    func apply(from other: MonthlyComponents) {
        zonedDay = other.zonedDay
        zonedHour = other.zonedHour
        zonedMinute = other.zonedMinute
    }
    
    // MARK: - Timing
    
    /// Finds the next valid execution date after `reminderExecutionBasis`, using the user-selected day/hour/minute in the specified reminderTimeZone.
    /// - If isSkipping is true, skips the soonest and returns the following date.
    /// - If the selected day does not exist in a month (e.g. 31st in February), the calculation will roll down to the last day of the month.
    /// - Handles DST and ambiguous/missing times using `.nextTimePreservingSmallerComponents`.
    func nextExecutionDate(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> Date? {
        isSkipping
        ? skippingExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
        : notSkippingExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
    }
    
    /// Returns the first valid execution date strictly after the basis, or 1970 if none.
    func notSkippingExecutionDate(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> Date? {
        futureExecutionDates(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
            .first(where: { $0 > reminderExecutionBasis })
    }
    
    /// Finds the previous valid execution date before the basis.
    /// Handles day roll-down if day exceeds days in target month, and is robust to DST.
    func previousExecutionDate(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> Date? {
        let calendar = Calendar.fromZone(reminderTimeZone)
        var searchBasis = reminderExecutionBasis.addingTimeInterval(-1)
        
        for _ in 0..<12 { // Look back up to 12 months to find a valid previous date
            let daysInMonth = calendar.range(of: .day, in: .month, for: searchBasis)?.count ?? zonedDay
            let targetDay = min(zonedDay, daysInMonth)
            
            var components = calendar.dateComponents(in: reminderTimeZone, from: searchBasis)
            components.day = targetDay
            components.hour = zonedHour
            components.minute = zonedMinute
            components.second = 0
            
            if let previousDate = calendar.date(from: components), previousDate < reminderExecutionBasis {
                return previousDate
            }
            
            // Step back one month if no valid date found yet
            guard let newSearchBasis = calendar.date(byAdding: .month, value: -1, to: searchBasis) else {
                return nil
            }
            searchBasis = newSearchBasis
        }
        
        return nil
    }
    
    /// Returns the next valid execution date after the one that would normally be triggered (skipping state).
    private func skippingExecutionDate(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> Date? {
        guard let nextExecution = notSkippingExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone) else {
            return nil
        }
        let futureDates = futureExecutionDates(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
        return futureDates.first(where: { $0 > nextExecution })
    }
    
    /// Finds up to 3 future execution dates based on the user-selected day/hour/minute in the reminderTimeZone.
    /// - For months where `zonedDay` exceeds days in month, calculation rolls down to last valid day.
    /// - Robust to DST (handles both non-existent and repeated times).
    /// - Always returns strictly increasing dates; searchBasis is advanced by one second each iteration.
    private func futureExecutionDates(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> [Date] {
        var dates: [Date] = []
        var searchBasis = reminderExecutionBasis
        let calendar = Calendar.fromZone(reminderTimeZone)
        
        for _ in 0..<3 {
            var components = DateComponents()
            // Clamp the day to the last valid day of the month to avoid rollovers (e.g., "31" in April becomes April 30).
            let daysInMonth = calendar.range(of: .day, in: .month, for: searchBasis)?.count ?? zonedDay
            components.day = min(zonedDay, daysInMonth)
            components.hour = zonedHour
            components.minute = zonedMinute
            components.second = 0
            
            // Use .nextTimePreservingSmallerComponents for DST safety.
            guard let nextDate = calendar.nextDate(
                after: searchBasis,
                matching: components,
                matchingPolicy: .nextTimePreservingSmallerComponents
            ) else {
                break
            }
            dates.append(nextDate)
            // Advance search basis to avoid repeated/ambiguous times.
            searchBasis = nextDate.addingTimeInterval(1)
        }
        
        return dates
    }
    
    // MARK: - Request
    
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.monthlyZonedDay.rawValue] = .int(zonedDay)
        body[Constant.Key.monthlyZonedHour.rawValue] = .int(zonedHour)
        body[Constant.Key.monthlyZonedMinute.rawValue] = .int(zonedMinute)
        body[Constant.Key.monthlySkippedDate.rawValue] = .string(skippedDate?.ISO8601FormatWithFractionalSeconds())
        return body
    }
    
    // MARK: - Compare
    
    func isSame(as other: MonthlyComponents) -> Bool {
        zonedDay == other.zonedDay &&
        zonedHour == other.zonedHour &&
        zonedMinute == other.zonedMinute &&
        skippedDate == other.skippedDate
    }
}
//
//  OneTimeComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class OneTimeComponents: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = OneTimeComponents()
        copy.oneTimeDate = self.oneTimeDate
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let oneTimeDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.oneTimeDate.rawValue)
        
        self.init(oneTimeDate: oneTimeDate)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeInteger, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(oneTimeDate, forKey: Constant.Key.oneTimeDate.rawValue)
    }
    
    // MARK: - Properties
    
    func readableDayOfYear(displayTimeZone: TimeZone? = nil) -> String {
        let tz = displayTimeZone ?? UserConfiguration.timeZone
        let calendar = Calendar.fromZone(tz)
        let dateYear = calendar.component(.year, from: oneTimeDate)
        let currentYear = calendar.component(.year, from: Date())
        
        // January 25 OR January 25, 2023
        let template = dateYear == currentYear ? "MMMMd" : "MMMMdyyyy"
        return oneTimeDate.houndFormatted(.template(template), displayTimeZone: tz)
    }
    
    func readableTimeOfDay(displayTimeZone: TimeZone? = nil) -> String {
        let tz = displayTimeZone ?? UserConfiguration.timeZone
        // 7:53 AM
        return oneTimeDate.houndFormatted(.formatStyle(date: .omitted, time: .shortened), displayTimeZone: tz)
    }
    
    func readableRecurrance(displayTimeZone: TimeZone? = nil) -> String {
        return readableDayOfYear(displayTimeZone: displayTimeZone).appending(" at \(readableTimeOfDay(displayTimeZone: displayTimeZone))")
    }
    
    /// The Date that the alarm should fire
    var oneTimeDate: Date = Date()
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    convenience init(oneTimeDate: Date? = nil) {
        self.init()
        self.oneTimeDate = oneTimeDate ?? Date()
    }
    
    convenience init(fromBody: JSONResponseBody, componentToOverride: OneTimeComponents?) {
        let oneTimeDate: Date? = (fromBody[Constant.Key.oneTimeDate.rawValue] as? String)?.formatISO8601IntoDate() ?? componentToOverride?.oneTimeDate
        
        self.init(oneTimeDate: oneTimeDate)
    }
    
    // MARK: - Compare
    
    /// Returns true if the stored date matches another one-time component
    func isSame(as other: OneTimeComponents) -> Bool {
        return oneTimeDate == other.oneTimeDate
    }
    
    // MARK: - Request
    
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.oneTimeDate.rawValue] = .string(oneTimeDate.ISO8601FormatWithFractionalSeconds())
        return body
    }
    
}
//
//  WeeklyComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum Weekday: Int, CaseIterable, Comparable {
    case sunday = 1
    case monday
    case tuesday
    case wednesday
    case thursday
    case friday
    case saturday
    
    var shortAbbreviation: String {
        switch self {
        case .sunday:    return "Su"
        case .monday:    return "M"
        case .tuesday:   return "Tu"
        case .wednesday: return "W"
        case .thursday:  return "Th"
        case .friday:    return "F"
        case .saturday:  return "Sa"
        }
    }
    var longName: String {
        switch self {
        case .sunday:    return "Sunday"
        case .monday:    return "Monday"
        case .tuesday:   return "Tuesday"
        case .wednesday: return "Wednesday"
        case .thursday:  return "Thursday"
        case .friday:    return "Friday"
        case .saturday:  return "Saturday"
        }
    }
    
    static func < (lhs: Weekday, rhs: Weekday) -> Bool { lhs.rawValue < rhs.rawValue }
}

final class WeeklyComponents: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = WeeklyComponents()
        copy.zonedSunday = self.zonedSunday
        copy.zonedMonday = self.zonedMonday
        copy.zonedTuesday = self.zonedTuesday
        copy.zonedWednesday = self.zonedWednesday
        copy.zonedThursday = self.zonedThursday
        copy.zonedFriday = self.zonedFriday
        copy.zonedSaturday = self.zonedSaturday
        copy.zonedHour = self.zonedHour
        copy.zonedMinute = self.zonedMinute
        copy.skippedDate = self.skippedDate
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let zonedSunday = aDecoder.decodeOptionalBool(forKey: Constant.Key.weeklyZonedSunday.rawValue)
        let zonedMonday = aDecoder.decodeOptionalBool(forKey: Constant.Key.weeklyZonedMonday.rawValue)
        let zonedTuesday = aDecoder.decodeOptionalBool(forKey: Constant.Key.weeklyZonedTuesday.rawValue)
        let zonedWednesday = aDecoder.decodeOptionalBool(forKey: Constant.Key.weeklyZonedWednesday.rawValue)
        let zonedThursday = aDecoder.decodeOptionalBool(forKey: Constant.Key.weeklyZonedThursday.rawValue)
        let zonedFriday = aDecoder.decodeOptionalBool(forKey: Constant.Key.weeklyZonedFriday.rawValue)
        let zonedSaturday = aDecoder.decodeOptionalBool(forKey: Constant.Key.weeklyZonedSaturday.rawValue)
        let zonedHour = aDecoder.decodeOptionalInteger(forKey: Constant.Key.weeklyZonedHour.rawValue)
        let zonedMinute = aDecoder.decodeOptionalInteger(forKey: Constant.Key.weeklyZonedMinute.rawValue)
        let skippedDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.weeklySkippedDate.rawValue)
        
        self.init(
            zonedSunday: zonedSunday,
            zonedMonday: zonedMonday,
            zonedTuesday: zonedTuesday,
            zonedWednesday: zonedWednesday,
            zonedThursday: zonedThursday,
            zonedFriday: zonedFriday,
            zonedSaturday: zonedSaturday,
            zonedHour: zonedHour,
            zonedMinute: zonedMinute,
            skippedDate: skippedDate
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(zonedSunday, forKey: Constant.Key.weeklyZonedSunday.rawValue)
        aCoder.encode(zonedMonday, forKey: Constant.Key.weeklyZonedMonday.rawValue)
        aCoder.encode(zonedTuesday, forKey: Constant.Key.weeklyZonedTuesday.rawValue)
        aCoder.encode(zonedWednesday, forKey: Constant.Key.weeklyZonedWednesday.rawValue)
        aCoder.encode(zonedThursday, forKey: Constant.Key.weeklyZonedThursday.rawValue)
        aCoder.encode(zonedFriday, forKey: Constant.Key.weeklyZonedFriday.rawValue)
        aCoder.encode(zonedSaturday, forKey: Constant.Key.weeklyZonedSaturday.rawValue)
        aCoder.encode(zonedHour, forKey: Constant.Key.weeklyZonedHour.rawValue)
        aCoder.encode(zonedMinute, forKey: Constant.Key.weeklyZonedMinute.rawValue)
        if let skippedDate = skippedDate {
            aCoder.encode(skippedDate, forKey: Constant.Key.weeklySkippedDate.rawValue)
        }
    }
    
    // MARK: - Properties
    
    private var zonedSunday: Bool = true
    private var zonedMonday: Bool = true
    private var zonedTuesday: Bool = true
    private var zonedWednesday: Bool = true
    private var zonedThursday: Bool = true
    private var zonedFriday: Bool = true
    private var zonedSaturday: Bool = true
    var zonedWeekdays: [Weekday] {
        var weekdays: [Weekday] = []
        if zonedSunday { weekdays.append(.sunday) }
        if zonedMonday { weekdays.append(.monday) }
        if zonedTuesday { weekdays.append(.tuesday) }
        if zonedWednesday { weekdays.append(.wednesday) }
        if zonedThursday { weekdays.append(.thursday) }
        if zonedFriday { weekdays.append(.friday) }
        if zonedSaturday { weekdays.append(.saturday) }
        return weekdays
    }
    @discardableResult
    func setZonedWeekdays(_ weekdays: [Weekday]) -> Bool {
        guard !weekdays.isEmpty else {
            return false
        }
        zonedSunday = weekdays.contains(.sunday)
        zonedMonday = weekdays.contains(.monday)
        zonedTuesday = weekdays.contains(.tuesday)
        zonedWednesday = weekdays.contains(.wednesday)
        zonedThursday = weekdays.contains(.thursday)
        zonedFriday = weekdays.contains(.friday)
        zonedSaturday = weekdays.contains(.saturday)
        return true
    }
    
    var zonedHour: Int = Constant.Class.ReminderComponent.defaultZonedHour
    var zonedMinute: Int = Constant.Class.ReminderComponent.defaultZonedMinute
    
    /// The date at which the user changed the isSkipping to true.  If is skipping is true, then a certain log date was appended. If unskipped, then we have to remove that previously added log. Slight caveat: if the skip log was modified (by the user changing its date) we don't remove it.
    var skippedDate: Date?
    var isSkipping: Bool {
        skippedDate != nil
    }
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    convenience init(
        zonedSunday: Bool? = nil,
        zonedMonday: Bool? = nil,
        zonedTuesday: Bool? = nil,
        zonedWednesday: Bool? = nil,
        zonedThursday: Bool? = nil,
        zonedFriday: Bool? = nil,
        zonedSaturday: Bool? = nil,
        zonedHour: Int? = nil,
        zonedMinute: Int? = nil,
        skippedDate: Date? = nil
    ) {
        self.init()
        self.zonedSunday = zonedSunday ?? self.zonedSunday
        self.zonedMonday = zonedMonday ?? self.zonedMonday
        self.zonedTuesday = zonedTuesday ?? self.zonedTuesday
        self.zonedWednesday = zonedWednesday ?? self.zonedWednesday
        self.zonedThursday = zonedThursday ?? self.zonedThursday
        self.zonedFriday = zonedFriday ?? self.zonedFriday
        self.zonedSaturday = zonedSaturday ?? self.zonedSaturday
        self.zonedHour = zonedHour ?? self.zonedHour
        self.zonedMinute = zonedMinute ?? self.zonedMinute
        self.skippedDate = skippedDate ?? self.skippedDate
    }
    
    convenience init(fromBody: JSONResponseBody, componentToOverride: WeeklyComponents?) {
        let weeklyZonedSunday: Bool? = fromBody[Constant.Key.weeklyZonedSunday.rawValue] as? Bool ?? componentToOverride?.zonedSunday
        let weeklyZonedMonday: Bool? = fromBody[Constant.Key.weeklyZonedMonday.rawValue] as? Bool ?? componentToOverride?.zonedMonday
        let weeklyZonedTuesday: Bool? = fromBody[Constant.Key.weeklyZonedTuesday.rawValue] as? Bool ?? componentToOverride?.zonedTuesday
        let weeklyZonedWednesday: Bool? = fromBody[Constant.Key.weeklyZonedWednesday.rawValue] as? Bool ?? componentToOverride?.zonedWednesday
        let weeklyZonedThursday: Bool? = fromBody[Constant.Key.weeklyZonedThursday.rawValue] as? Bool ?? componentToOverride?.zonedThursday
        let weeklyZonedFriday: Bool? = fromBody[Constant.Key.weeklyZonedFriday.rawValue] as? Bool ?? componentToOverride?.zonedFriday
        let weeklyZonedSaturday: Bool? = fromBody[Constant.Key.weeklyZonedSaturday.rawValue] as? Bool ?? componentToOverride?.zonedSaturday
        let weeklyZonedHour: Int? = fromBody[Constant.Key.weeklyZonedHour.rawValue] as? Int ?? componentToOverride?.zonedHour
        let weeklyZonedMinute: Int? = fromBody[Constant.Key.weeklyZonedMinute.rawValue] as? Int ?? componentToOverride?.zonedMinute
        let weeklySkippedDate: Date? = (fromBody[Constant.Key.weeklySkippedDate.rawValue] as? String)?.formatISO8601IntoDate() ?? componentToOverride?.skippedDate
        
        self.init(
            zonedSunday: weeklyZonedSunday,
            zonedMonday: weeklyZonedMonday,
            zonedTuesday: weeklyZonedTuesday,
            zonedWednesday: weeklyZonedWednesday,
            zonedThursday: weeklyZonedThursday,
            zonedFriday: weeklyZonedFriday,
            zonedSaturday: weeklyZonedSaturday,
            zonedHour: weeklyZonedHour,
            zonedMinute: weeklyZonedMinute,
            skippedDate: weeklySkippedDate
        )
    }
    
    // MARK: - Functions
    
    func localTimeOfDay(reminderExecutionBasis: Date, reminderTimeZone: TimeZone, displayTimeZone: TimeZone? = nil) -> (hour: Int, minute: Int) {
        let referenceDate = notSkippingExecutionDate(
            reminderExecutionBasis: reminderExecutionBasis,
            reminderTimeZone: reminderTimeZone
        )
        
        return reminderTimeZone.convert(hour: zonedHour, minute: zonedMinute, to: displayTimeZone ?? reminderTimeZone, referenceDate: referenceDate ?? reminderExecutionBasis)
    }
    
    func localWeekdays(reminderExecutionBasis: Date, reminderTimeZone: TimeZone, displayTimeZone: TimeZone? = nil) -> [Weekday] {
        let referenceDate = notSkippingExecutionDate(
            reminderExecutionBasis: reminderExecutionBasis,
            reminderTimeZone: reminderTimeZone
        )
        
        return reminderTimeZone.convert(weekdays: zonedWeekdays, hour: zonedHour, minute: zonedMinute, to: displayTimeZone ?? reminderTimeZone, referenceDate: referenceDate ?? reminderExecutionBasis)
    }
    
    func readableDaysOfWeek(reminderExecutionBasis: Date, reminderTimeZone: TimeZone, displayTimeZone: TimeZone? = nil) -> String {
        let referenceDate = notSkippingExecutionDate(
            reminderExecutionBasis: reminderExecutionBasis,
            reminderTimeZone: reminderTimeZone
        )
        
        let mappedWeekdays = reminderTimeZone.convert(
            weekdays: zonedWeekdays,
            hour: zonedHour,
            minute: zonedMinute,
            to: displayTimeZone ?? reminderTimeZone,
            referenceDate: referenceDate ?? reminderExecutionBasis
        )
        switch Set(mappedWeekdays) {
        case Set(Weekday.allCases): return "Everyday"
        case [.sunday, .saturday]: return "Weekends"
        case [.monday, .tuesday, .wednesday, .thursday, .friday]: return "Weekdays"
        default:
            let abbreviate = mappedWeekdays.count > 1
            return mappedWeekdays.sorted().map { abbreviate ? $0.shortAbbreviation : $0.longName }.joined(separator: ", ")
        }
    }
    
    func readableTimeOfDay(reminderExecutionBasis: Date, reminderTimeZone: TimeZone, displayTimeZone: TimeZone? = nil) -> String {
        let referenceDate = notSkippingExecutionDate(
            reminderExecutionBasis: reminderExecutionBasis,
            reminderTimeZone: reminderTimeZone
        )
        
        let (hour, minute) = reminderTimeZone.convert(hour: zonedHour, minute: zonedMinute, to: displayTimeZone ?? reminderTimeZone, referenceDate: referenceDate ?? reminderExecutionBasis)
        return String.convert(hour: hour, minute: minute)
    }
    
    func readableRecurrance(reminderExecutionBasis: Date, reminderTimeZone: TimeZone, displayTimeZone: TimeZone? = nil) -> String {
        let readableDaysOfWeek = readableDaysOfWeek(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone, displayTimeZone: displayTimeZone)
        let readableTimeOfDay = readableTimeOfDay(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone, displayTimeZone: displayTimeZone)
    
        return readableDaysOfWeek.appending(" at \(readableTimeOfDay)")
    }
    
    // MARK: - Mutation
    
    /// Updates the component using a date in the provided time zone and a set of weekdays.
    /// - Returns: `true` if weekdays were valid and applied.
    @discardableResult
    func configure(from date: Date, timeZone: TimeZone, weekdays: [Weekday]) -> Bool {
        let calendar = Calendar.fromZone(timeZone)
        let comps = calendar.dateComponents([.hour, .minute], from: date)
        zonedHour = comps.hour ?? zonedHour
        zonedMinute = comps.minute ?? zonedMinute
        return setZonedWeekdays(weekdays)
    }
    
    // MARK: - Timing
    
    /// Determines the next execution date, considering isSkipping state, based on `reminderTimeZone`.
    func nextExecutionDate(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> Date? {
        return isSkipping
        ? skippingExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
        : notSkippingExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
    }
    
    /// Finds the next execution date after `reminderExecutionBasis`, using zoned weekdays/hours/minutes in the specified `reminderTimeZone`.
    /// Skipping state is NOT factored in.
    /// - Returns: The closest valid future execution date (or default date if none found).
    func notSkippingExecutionDate(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> Date? {
        let futureDates = futureExecutionDates(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
        return futureDates.first(where: { $0 > reminderExecutionBasis })
    }
    
    /// If a reminder is skipping, find the next soonest execution date after the skipped one.
    /// Returns: The next valid execution date strictly after the skipped one, or default date if none found.
    private func skippingExecutionDate(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> Date? {
        guard let nextExecution = notSkippingExecutionDate(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone) else {
            return nil
        }
        let futureDates = futureExecutionDates(reminderExecutionBasis: reminderExecutionBasis, reminderTimeZone: reminderTimeZone)
        return futureDates.first(where: { $0 > nextExecution })
    }
    
    /// Finds the most recent valid execution date strictly before `reminderExecutionBasis`
    /// based on the component's zoned weekdays, hour, and minute, in the specified `reminderTimeZone`.
    /// Robust to DST and ambiguous/skipped times.
    func previousExecutionDate(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> Date? {
        let calendar = Calendar.fromZone(reminderTimeZone)
        
        let searchBasis = reminderExecutionBasis.addingTimeInterval(-1)
        var latestPrevious: Date?
        // Try all active weekdays to find the most recent valid date < basis
        for zonedWeekday in zonedWeekdays {
            var components = DateComponents()
            components.weekday = zonedWeekday.rawValue
            components.hour = zonedHour
            components.minute = zonedMinute
            components.second = 0
            
            // Use direction: .backward to get previous matching
            if let previous = calendar.nextDate(
                after: searchBasis,
                matching: components,
                matchingPolicy: .nextTimePreservingSmallerComponents,
                repeatedTimePolicy: .first,
                direction: .backward
            ) {
                if latestPrevious == nil {
                    latestPrevious = previous
                }
                else if let lp = latestPrevious, previous > lp {
                    latestPrevious = previous
                }
            }
        }
        // Return the latest found or your chosen default
        return latestPrevious
    }
    
    /// Computes the next three valid execution dates (in strict chronological order) in the specified source time zone,
    /// using the object's zoned weekdays, hour, and minute, relative to `reminderExecutionBasis`.
    /// This function is robust to DST changes, ambiguous times, and ensures results are always valid for the zone provided.
    private func futureExecutionDates(reminderExecutionBasis: Date, reminderTimeZone: TimeZone) -> [Date] {
        let calendar = Calendar.fromZone(reminderTimeZone)
        var dates: [Date] = []
        var searchBasis = reminderExecutionBasis
        
        // Compute the next 3 valid, non-ambiguous, non-skipped occurrences.
        for _ in 0..<3 {
            var soonest: Date?
            for zonedWeekday in zonedWeekdays {
                var components = DateComponents()
                components.weekday = zonedWeekday.rawValue
                components.hour = zonedHour
                components.minute = zonedMinute
                components.second = 0
                
                // Use .nextTimePreservingSmallerComponents to handle DST and real-world scheduling.
                if let next = calendar.nextDate(
                    after: searchBasis,
                    matching: components,
                    matchingPolicy: .nextTimePreservingSmallerComponents,
                    repeatedTimePolicy: .first,
                    direction: .forward
                ) {
                    if soonest == nil {
                        soonest = next
                    }
                    else if let s = soonest, next < s {
                        soonest = next
                    }
                }
            }
            if let found = soonest {
                dates.append(found)
                // Advance search basis for next iteration
                searchBasis = found.addingTimeInterval(1)
            }
            else {
                break // No further dates found
            }
        }
        return dates.sorted { d1, d2 in
            return d1 < d2
        }
    }
    
    // MARK: - Compare
    
    /// Returns true if all stored properties are equivalent
    func isSame(as other: WeeklyComponents) -> Bool {
        if zonedSunday != other.zonedSunday { return false }
        if zonedMonday != other.zonedMonday { return false }
        if zonedTuesday != other.zonedTuesday { return false }
        if zonedWednesday != other.zonedWednesday { return false }
        if zonedThursday != other.zonedThursday { return false }
        if zonedFriday != other.zonedFriday { return false }
        if zonedSaturday != other.zonedSaturday { return false }
        if zonedHour != other.zonedHour { return false }
        if zonedMinute != other.zonedMinute { return false }
        if isSkipping != other.isSkipping { return false }
        if skippedDate != other.skippedDate { return false }
        return true
    }
    
    // MARK: - Request
    
    func createBody() -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.weeklyZonedSunday.rawValue] = .bool(zonedSunday)
        body[Constant.Key.weeklyZonedMonday.rawValue] = .bool(zonedMonday)
        body[Constant.Key.weeklyZonedTuesday.rawValue] = .bool(zonedTuesday)
        body[Constant.Key.weeklyZonedWednesday.rawValue] = .bool(zonedWednesday)
        body[Constant.Key.weeklyZonedThursday.rawValue] = .bool(zonedThursday)
        body[Constant.Key.weeklyZonedFriday.rawValue] = .bool(zonedFriday)
        body[Constant.Key.weeklyZonedSaturday.rawValue] = .bool(zonedSaturday)
        body[Constant.Key.weeklyZonedHour.rawValue] = .int(zonedHour)
        body[Constant.Key.weeklyZonedMinute.rawValue] = .int(zonedMinute)
        body[Constant.Key.weeklySkippedDate.rawValue] = .string(skippedDate?.ISO8601FormatWithFractionalSeconds())
        return body
    }
}
//
//  PreviousLogCustomActionName.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/6/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

class PreviousLogCustomActionName: NSObject, NSCoding {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let decodedLogActionTypeId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logActionTypeId.rawValue),
            let decodedLogCustomActionName = aDecoder.decodeOptionalString(forKey: Constant.Key.logCustomActionName.rawValue)
        else {
            return nil
        }
        self.init(logActionTypeId: decodedLogActionTypeId, logCustomActionName: decodedLogCustomActionName)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(logActionTypeId, forKey: Constant.Key.logActionTypeId.rawValue)
        aCoder.encode(logCustomActionName, forKey: Constant.Key.logCustomActionName.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var logActionTypeId: Int
    private(set) var logCustomActionName: String
    
    static let maxStored = 3
    
    // MARK: - Main
    
    init(logActionTypeId: Int, logCustomActionName: String) {
        self.logActionTypeId = logActionTypeId
        self.logCustomActionName = logCustomActionName
        super.init()
    }
    
}
//
//  ReminderLog.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/25/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class Log: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = Log()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        copy.logId = self.logId
        copy.logUUID = self.logUUID
        copy.logCreated = self.logCreated
        copy.logCreatedBy = self.logCreatedBy
        copy.logLastModified = self.logLastModified
        copy.logLastModifiedBy = self.logLastModifiedBy
        copy.logActionTypeId = self.logActionTypeId
        copy.storedLogCustomActionName = self.logCustomActionName
        copy.logStartDate = self.logStartDate
        copy.logEndDate = self.logEndDate
        copy.storedLogNote = self.logNote
        copy.logUnitTypeId = self.logUnitTypeId
        copy.logNumberOfLogUnits = self.logNumberOfLogUnits
        copy.logCreatedByReminderUUID = self.logCreatedByReminderUUID
        copy.offlineModeComponents = self.offlineModeComponents.copy() as? OfflineModeComponents ?? OfflineModeComponents()
        copy.likedByUserIds = self.likedByUserIds
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedLogId: Int? = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logId.rawValue)
        let decodedLogUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalString(forKey: Constant.Key.logUUID.rawValue))
        let decodedLogCreated: Date? = (aDecoder.decodeOptionalString(forKey: Constant.Key.logCreated.rawValue)?.formatISO8601IntoDate())
        let decodedLogCreatedBy: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.logCreatedBy.rawValue)
        let decodedLogLastModified: Date? = (aDecoder.decodeOptionalString(forKey: Constant.Key.logLastModified.rawValue)?.formatISO8601IntoDate())
        let decodedLogLastModifiedBy: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.logLastModifiedBy.rawValue)
        let decodedLogActionTypeId: Int = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logActionTypeId.rawValue) ?? Constant.Class.Log.defaultLogActionTypeId
        let decodedLogCustomActionName: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.logCustomActionName.rawValue)
        let decodedLogStartDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.logStartDate.rawValue)
        let decodedLogEndDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.logEndDate.rawValue)
        let decodedLogNote: String? = aDecoder.decodeOptionalString(forKey: Constant.Key.logNote.rawValue)
        let decodedLogUnitTypeId: Int? = aDecoder.decodeOptionalInteger(forKey: Constant.Key.logUnitTypeId.rawValue)
        let decodedLogNumberOfLogUnits: Double? = aDecoder.decodeOptionalDouble(forKey: Constant.Key.logNumberOfLogUnits.rawValue)
        let decodedLogCreatedByReminderUUID: UUID? = UUID.fromString(UUIDString: aDecoder.decodeOptionalObject(forKey: Constant.Key.logCreatedByReminderUUID.rawValue))
        let decodedLikedByUserIds: [String]? = aDecoder.decodeOptionalObject(forKey: Constant.Key.logLikedByUserIds.rawValue)
        let decodedOfflineModeComponents: OfflineModeComponents? = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeComponents.rawValue)
        
        self.init(
            logId: decodedLogId,
            logUUID: decodedLogUUID,
            logCreated: decodedLogCreated,
            logCreatedBy: decodedLogCreatedBy,
            logLastModified: decodedLogLastModified,
            logLastModifiedBy: decodedLogLastModifiedBy,
            logActionTypeId: decodedLogActionTypeId,
            logCustomActionName: decodedLogCustomActionName,
            logStartDate: decodedLogStartDate,
            logEndDate: decodedLogEndDate,
            logNote: decodedLogNote,
            logUnitTypeId: decodedLogUnitTypeId,
            logNumberOfUnits: decodedLogNumberOfLogUnits,
            logCreatedByReminderUUID: decodedLogCreatedByReminderUUID,
            likedByUserIds: Set(decodedLikedByUserIds ?? []),
            offlineModeComponents: decodedOfflineModeComponents
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        if let logId = logId {
            aCoder.encode(logId, forKey: Constant.Key.logId.rawValue)
        }
        aCoder.encode(logUUID.uuidString, forKey: Constant.Key.logUUID.rawValue)
        aCoder.encode(logCreated.ISO8601FormatWithFractionalSeconds(), forKey: Constant.Key.logCreated.rawValue)
        aCoder.encode(logCreatedBy, forKey: Constant.Key.logCreatedBy.rawValue)
        if let logLastModified = logLastModified {
            aCoder.encode(logLastModified.ISO8601FormatWithFractionalSeconds(), forKey: Constant.Key.logLastModified.rawValue)
        }
        if let logLastModifiedBy = logLastModifiedBy {
            aCoder.encode(logLastModifiedBy, forKey: Constant.Key.logLastModifiedBy.rawValue)
        }
        aCoder.encode(logActionTypeId, forKey: Constant.Key.logActionTypeId.rawValue)
        aCoder.encode(logCustomActionName, forKey: Constant.Key.logCustomActionName.rawValue)
        aCoder.encode(logStartDate, forKey: Constant.Key.logStartDate.rawValue)
        if let logEndDate = logEndDate {
            aCoder.encode(logEndDate, forKey: Constant.Key.logEndDate.rawValue)
        }
        aCoder.encode(logNote, forKey: Constant.Key.logNote.rawValue)
        if let logUnitTypeId = logUnitTypeId {
            aCoder.encode(logUnitTypeId, forKey: Constant.Key.logUnitTypeId.rawValue)
        }
        if let logNumberOfLogUnits = logNumberOfLogUnits {
            aCoder.encode(logNumberOfLogUnits, forKey: Constant.Key.logNumberOfLogUnits.rawValue)
        }
        if let logCreatedByReminderUUID = logCreatedByReminderUUID {
            aCoder.encode(logCreatedByReminderUUID.uuidString, forKey: Constant.Key.logCreatedByReminderUUID.rawValue)
        }
        aCoder.encode(Array(likedByUserIds), forKey: Constant.Key.logLikedByUserIds.rawValue)
        aCoder.encode(offlineModeComponents, forKey: Constant.Key.offlineModeComponents.rawValue)
    }
    
    // MARK: - Properties
    
    /// The logId given to this log from the Hound database
    var logId: Int?
    
    /// The UUID of this log that is generated locally upon creation. Useful in identifying the log before/in the process of creating it
    private(set) var logUUID: UUID = UUID()
    
    private(set) var logCreated: Date = Date()
    private(set) var logCreatedBy: String = Constant.Class.Log.defaultUserId
    private(set) var logLastModified: Date?
    private(set) var logLastModifiedBy: String?
    
    var logActionTypeId: Int = Constant.Class.Log.defaultLogActionTypeId {
        didSet {
            // Check to see if logUnitTypeId are compatible with the new logActionTypeId
            let logUnitTypeIds = LogActionType.find(logActionTypeId: logActionTypeId).associatedLogUnitTypes.map { $0.logUnitTypeId }
            
            guard let logUnitTypeId = logUnitTypeId else {
                self.logNumberOfLogUnits = nil
                self.logUnitTypeId = nil
                return
            }
            
            if logUnitTypeIds.contains(logUnitTypeId) == false {
                self.logNumberOfLogUnits = nil
                self.logUnitTypeId = nil
            }
        }
    }
    
    var logActionType: LogActionType {
        return LogActionType.find(logActionTypeId: logActionTypeId)
    }
    
    private var storedLogCustomActionName: String = ""
    var logCustomActionName: String {
        get {
            return storedLogCustomActionName
        }
        set {
            storedLogCustomActionName = String((newValue.trimmingCharacters(in: .whitespacesAndNewlines)).prefix(Constant.Class.Log.logCustomActionNameCharacterLimit))
        }
    }
    
    private(set) var logStartDate: Date = Constant.Class.Log.defaultLogStartDate
    private(set) var logEndDate: Date?
    /// logStartDate takes precendence over logEndDate. Therefore, if the times overlap incorrectly, i.e. logStartDate is after logEndDate, then logStartDate is set its value, then logEndDate is adjusted so that it is later than logStartDate.
    func setLogDate(logStartDate: Date, logEndDate: Date?) {
        self.logStartDate = logStartDate
        
        if let logEndDate = logEndDate {
            // If logStartDate is after logEndDate, that is incorrect. Therefore, disregard it
            self.logEndDate = logStartDate >= logEndDate ? nil : logEndDate
        }
        else {
            self.logEndDate = nil
        }
    }
    
    private var storedLogNote: String = ""
    var logNote: String {
        get {
            return storedLogNote
        }
        set {
            storedLogNote = String(newValue.prefix(Constant.Class.Log.logNoteCharacterLimit))
        }
    }
    
    private(set) var logUnitTypeId: Int?
    
    var logUnitType: LogUnitType? {
        guard let logUnitTypeId = logUnitTypeId else {
            return nil
        }
        return LogUnitType.find(logUnitTypeId: logUnitTypeId)
    }
    private(set) var logNumberOfLogUnits: Double?
    /// If numberOfUnits or logUnitTypeId is nil, both are set to nil. The logUnitTypeId provided must be in the array of LogUnitTypes that are valid for this log's logActionTypeId.
    func setLogUnit(logUnitTypeId: Int?, logNumberOfLogUnits: Double?) {
        guard let logUnitTypeId = logUnitTypeId, let logNumberOfLogUnits = logNumberOfLogUnits else {
            self.logNumberOfLogUnits = nil
            self.logUnitTypeId = nil
            return
        }
        
        let logUnitTypeIds = logActionType.associatedLogUnitTypes.map { $0.logUnitTypeId }
        
        guard logUnitTypeIds.contains(logUnitTypeId) else {
            self.logNumberOfLogUnits = nil
            self.logUnitTypeId = nil
            return
        }
        
        self.logNumberOfLogUnits = round(logNumberOfLogUnits * 100.0) / 100.0
        self.logUnitTypeId = logUnitTypeId
    }
    
    private(set) var logCreatedByReminderUUID: UUID?

    private(set) var likedByUserIds: Set<String> = []
    func setLogLike(_ liked: Bool) {
        if liked {
            likedByUserIds.insert(Constant.Class.Log.defaultUserId)
        }
        else {
            likedByUserIds.remove(Constant.Class.Log.defaultUserId)
        }
    }
    func setLogLikes(_ userIds: Set<String>) {
        likedByUserIds = userIds
    }

    /// Components that are used to track an object to determine whether it was synced with the Hound server and whether it needs to be when the device comes back online
    private(set) var offlineModeComponents: OfflineModeComponents = OfflineModeComponents()
    
    // MARK: - Main
    
    init(
        logId: Int? = nil,
        logUUID: UUID? = nil,
        logCreated: Date? = nil,
        logCreatedBy: String? = nil,
        logLastModified: Date? = nil,
        logLastModifiedBy: String? = nil,
        logActionTypeId: Int? = nil,
        logCustomActionName: String? = nil,
        logStartDate: Date? = nil,
        logEndDate: Date? = nil,
        logNote: String? = nil,
        logUnitTypeId: Int? = nil,
        logNumberOfUnits: Double? = nil,
        logCreatedByReminderUUID: UUID? = nil,
        likedByUserIds: Set<String>? = nil,
        offlineModeComponents: OfflineModeComponents? = nil
    ) {
        super.init()
        self.logId = logId ?? self.logId
        self.logUUID = logUUID ?? self.logUUID
        self.logCreated = logCreated ?? self.logCreated
        self.logCreatedBy = logCreatedBy ?? self.logCreatedBy
        self.logLastModified = logLastModified ?? self.logLastModified
        self.logLastModifiedBy = logLastModifiedBy ?? self.logLastModifiedBy
        self.logActionTypeId = logActionTypeId ?? self.logActionTypeId
        self.logCustomActionName = logCustomActionName ?? self.logCustomActionName
        self.logStartDate = logStartDate ?? self.logStartDate
        self.logEndDate = logEndDate ?? self.logEndDate
        self.logNote = logNote ?? self.logNote
        self.setLogUnit(logUnitTypeId: logUnitTypeId, logNumberOfLogUnits: logNumberOfUnits)
        self.logCreatedByReminderUUID = logCreatedByReminderUUID ?? logCreatedByReminderUUID
        self.likedByUserIds = likedByUserIds ?? self.likedByUserIds
        self.offlineModeComponents = offlineModeComponents ?? self.offlineModeComponents
    }
    
    /// Provide a dictionary literal of log properties to instantiate log. Optionally, provide a log to override with new properties from fromBody.
    convenience init?(fromBody: JSONResponseBody, logToOverride: Log?) {
        // Don't pull logId or logIsDeleted from logToOverride. A valid fromBody needs to provide this itself
        let logId: Int? = fromBody[Constant.Key.logId.rawValue] as? Int
        let logUUID: UUID? = UUID.fromString(UUIDString: fromBody[Constant.Key.logUUID.rawValue] as? String)
        let logCreated: Date? = (fromBody[Constant.Key.logCreated.rawValue] as? String)?.formatISO8601IntoDate()
        let logIsDeleted: Bool? = fromBody[Constant.Key.logIsDeleted.rawValue] as? Bool
        
        guard let logId = logId, let logUUID = logUUID, let logCreated = logCreated, let logIsDeleted = logIsDeleted else {
            return nil
        }
        
        guard logIsDeleted == false else {
            return nil
        }
        
        let logLastModified: Date? = (fromBody[Constant.Key.logLastModified.rawValue] as? String)?.formatISO8601IntoDate()
        
        // If we have pulled an update from the server which is more outdated than our local change, then ignore the data from the server. Otherwise, the newer server update takes precedence over our offline update
        if let logToOverride = logToOverride, let initialAttemptedSyncDate = logToOverride.offlineModeComponents.initialAttemptedSyncDate, initialAttemptedSyncDate >= logLastModified ?? logCreated {
            self.init(
                    logId: logToOverride.logId,
                    logUUID: logToOverride.logUUID,
                    logCreated: logToOverride.logCreated,
                    logCreatedBy: logToOverride.logCreatedBy,
                    logLastModified: logToOverride.logLastModified,
                    logLastModifiedBy: logToOverride.logLastModifiedBy,
                    logActionTypeId: logToOverride.logActionTypeId,
                    logCustomActionName: logToOverride.logCustomActionName,
                    logStartDate: logToOverride.logStartDate,
                    logEndDate: logToOverride.logEndDate,
                    logNote: logToOverride.logNote,
                    logUnitTypeId: logToOverride.logUnitTypeId,
                    logNumberOfUnits: logToOverride.logNumberOfLogUnits,
                    logCreatedByReminderUUID: logToOverride.logCreatedByReminderUUID,
                    likedByUserIds: logToOverride.likedByUserIds,
                    offlineModeComponents: logToOverride.offlineModeComponents
                )
            return
        }
        
        // if the log is the same, then we pull values from logToOverride
        // if the log is updated, then we pull values from fromBody
        let logCreatedBy = fromBody[Constant.Key.logCreatedBy.rawValue] as? String ?? logToOverride?.logCreatedBy
        let logLastModifiedBy: String? = fromBody[Constant.Key.logLastModifiedBy.rawValue] as? String ?? logToOverride?.logLastModifiedBy
        
        let logActionTypeId: Int? = fromBody[Constant.Key.logActionTypeId.rawValue] as? Int ?? logToOverride?.logActionTypeId
        
        let logCustomActionName: String? = fromBody[Constant.Key.logCustomActionName.rawValue] as? String ?? logToOverride?.logCustomActionName
        
        let logStartDate: Date? = {
            if let logStartDateString = fromBody[Constant.Key.logStartDate.rawValue] as? String {
                return logStartDateString.formatISO8601IntoDate()
            }
            return nil
        }() ?? logToOverride?.logStartDate
        
        let logEndDate: Date? = {
            if let logEndDateString = fromBody[Constant.Key.logEndDate.rawValue] as? String {
                return logEndDateString.formatISO8601IntoDate()
            }
            return nil
        }() ?? logToOverride?.logEndDate
        
        let logNote: String? = fromBody[Constant.Key.logNote.rawValue] as? String ?? logToOverride?.logNote
        
        let logUnitTypeId: Int? = fromBody[Constant.Key.logUnitTypeId.rawValue] as? Int ?? logToOverride?.logUnitTypeId
        
        let logNumberOfLogUnits: Double? = fromBody[Constant.Key.logNumberOfLogUnits.rawValue] as? Double ?? logToOverride?.logNumberOfLogUnits
        let logCreatedByReminderUUID: UUID? = UUID.fromString(UUIDString: fromBody[Constant.Key.logCreatedByReminderUUID.rawValue] as? String) ?? logToOverride?.logCreatedByReminderUUID

        let likedByUserIds: Set<String>? = {
            if let arr = fromBody[Constant.Key.logLikedByUserIds.rawValue] as? [String] {
                return Set(arr)
            }
            return logToOverride?.likedByUserIds
        }()
        
        self.init(
            logId: logId,
            logUUID: logUUID,
            logCreated: logCreated,
            logCreatedBy: logCreatedBy,
            logLastModified: logLastModified,
            logLastModifiedBy: logLastModifiedBy,
            logActionTypeId: logActionTypeId,
            logCustomActionName: logCustomActionName,
            logStartDate: logStartDate,
            logEndDate: logEndDate,
            logNote: logNote,
            logUnitTypeId: logUnitTypeId,
            logNumberOfUnits: logNumberOfLogUnits,
            logCreatedByReminderUUID: logCreatedByReminderUUID,
            likedByUserIds: likedByUserIds,
            // Verified that the update from the server happened more recently than our local changes, so no need to offline sync anymore
            offlineModeComponents: nil
        )
    }
    
    // MARK: - Functions
    
    /// Returns true if any major property of the log matches the provided search text
    func matchesSearchText(_ searchText: String) -> Bool {
        let trimmed = searchText.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        guard trimmed.isEmpty == false else { return true }
        
        if logActionType.readableValue.lowercased().contains(trimmed) { return true }
        if logCustomActionName.lowercased().contains(trimmed) { return true }
        if logActionType.convertToReadableName(customActionName: logCustomActionName, includeMatchingEmoji: true).lowercased().contains(trimmed) { return true }
        
        if logNote.lowercased().contains(trimmed) { return true }
        
        if let logUnitType = logUnitType, let num = logNumberOfLogUnits {
            if logUnitType.pluralReadableValueWithNumUnits(logNumberOfLogUnits: num)?.lowercased().contains(trimmed) ?? false { return true }
        }
        
        return false
    }
    
    /// Returns an array literal of the logs's properties. This is suitable to be used as the JSON body for a HTTP request
    func createBody(dogUUID: UUID) -> JSONRequestBody {
        var body: JSONRequestBody = [:]
        body[Constant.Key.dogUUID.rawValue] = .string(dogUUID.uuidString)
        body[Constant.Key.logId.rawValue] = .int(logId)
        body[Constant.Key.logUUID.rawValue] = .string(logUUID.uuidString)
        body[Constant.Key.logCreated.rawValue] = .string(logCreated.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.logCreatedBy.rawValue] = .string(logCreatedBy)
        body[Constant.Key.logLastModified.rawValue] = .string(logLastModified?.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.logLastModifiedBy.rawValue] = .string(logLastModifiedBy)
        body[Constant.Key.logActionTypeId.rawValue] = .int(logActionTypeId)
        body[Constant.Key.logCustomActionName.rawValue] = .string(logCustomActionName)
        body[Constant.Key.logStartDate.rawValue] = .string(logStartDate.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.logEndDate.rawValue] = .string(logEndDate?.ISO8601FormatWithFractionalSeconds())
        body[Constant.Key.logNote.rawValue] = .string(logNote)
        body[Constant.Key.logUnitTypeId.rawValue] = .int(logUnitTypeId)
        body[Constant.Key.logNumberOfLogUnits.rawValue] = .double(logNumberOfLogUnits)
        body[Constant.Key.logCreatedByReminderUUID.rawValue] = .string(logCreatedByReminderUUID?.uuidString)
        body[Constant.Key.logLikedByUserIds.rawValue] = .array(likedByUserIds.map { .string($0) })
        return body
    }
}
//
//  LogsSort.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/4/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum LogsSortField: CaseIterable {
    case logStartDate
    case logEndDate
    case createdDate
    case modifiedDate
    
    static let defaultSortField = LogsSortField.logStartDate
    
    var readableValue: String {
        switch self {
        case .createdDate:
            return "Created Date"
        case .modifiedDate:
            return "Modified Date"
        case .logStartDate:
            return "Start Date"
        case .logEndDate:
            return "End Date"
        }
    }
    
    func date(_ log: Log) -> Date {
        switch self {
        case .createdDate:
            return log.logCreated
        case .modifiedDate:
            return log.logLastModified ?? log.logCreated
        case .logStartDate:
            return log.logStartDate
        case .logEndDate:
            return log.logEndDate ?? log.logStartDate
        }
    }
    
    func compare(lhs: Log, rhs: Log) -> ComparisonResult {
        return self.date(lhs).compare(self.date(rhs))
    }
}

enum LogsSortDirection: CaseIterable {
    case descending
    case ascending
    
    static let defaultSortDirection = LogsSortDirection.descending

    var readableValue: String {
        switch self {
        case .ascending:
            return "Oldest First"
        case .descending:
            return "Newest First"
        }
    }
}

final class LogsSort: NSObject, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = LogsSort()
        copy.sortField = self.sortField
        copy.sortDirection = self.sortDirection
        return copy
    }
    
    // MARK: - Properties
    
    var sortField: LogsSortField = LogsSortField.defaultSortField
    
    var sortDirection: LogsSortDirection = LogsSortDirection.defaultSortDirection
    
    // MARK: - Computed Properties
    
    var availableFields: [LogsSortField] {
        return LogsSortField.allCases
    }
    
    var availableDirections: [LogsSortDirection] {
        return LogsSortDirection.allCases
    }
    
    var hasActiveSort: Bool {
        return self.sortField != LogsSortField.defaultSortField || self.sortDirection != LogsSortDirection.defaultSortDirection
    }
    
    // MARK: - Main
    
    init(sortField: LogsSortField? = nil, sortDirection: LogsSortDirection? = nil) {
        self.sortField = sortField ?? self.sortField
        self.sortDirection = sortDirection ?? self.sortDirection
    }
    
    // MARK: - Function
    
    func reset() {
        self.sortField = LogsSortField.defaultSortField
        self.sortDirection = LogsSortDirection.defaultSortDirection
    }
    
    func sort(_ logs: [Log]) -> [Log] {
        return LogsSort.sort(logs, sortField: self.sortField, sortDirection: self.sortDirection)
    }
    
    /// Sorts an array of logs based on the current sort field and direction.
    static func sort(_ logs: [Log], sortField: LogsSortField, sortDirection: LogsSortDirection) -> [Log] {
        let sortedLogs: [Log] = logs.sorted { (lhs: Log, rhs: Log) in
            let comparisonResult = sortField.compare(lhs: lhs, rhs: rhs)
            return sortDirection == .ascending ? (comparisonResult == .orderedAscending) : (comparisonResult == .orderedDescending)
        }
        
        return sortedLogs
    }
}
//
//  LogsFilter.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/28/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

class LogsFilter: NSObject, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = LogsFilter(dogManager: dogManager)
        copy.searchText = self.searchText
        copy.filteredDogsUUIDs = self.filteredDogsUUIDs
        copy.filteredLogActionActionTypeIds = self.filteredLogActionActionTypeIds
        copy.filteredFamilyMemberUserIds = self.filteredFamilyMemberUserIds
        copy.timeRangeField = self.timeRangeField
        copy.timeRangeFromDate = self.timeRangeFromDate
        copy.timeRangeToDate = self.timeRangeToDate
        copy.onlyShowLikes = self.onlyShowLikes
        return copy
    }
    
    // MARK: - Properties
    
    private(set) var dogManager: DogManager = DogManager()
    
    /// Text used to broadly search through logs. If empty, no search text is applied
    private(set) var searchText: String = ""
    
    private(set) var filteredDogsUUIDs: Set<UUID> = []
    
    private(set) var filteredLogActionActionTypeIds: Set<Int> = []
    
    private(set) var filteredFamilyMemberUserIds: Set<String> = []

    private(set) var timeRangeField: LogsSortField = LogsSortField.defaultSortField
    private(set) var timeRangeFromDate: Date?
    private(set) var timeRangeToDate: Date?
    private(set) var onlyShowLikes: Bool = false
    
    var isFromDateEnabled: Bool {
        return timeRangeFromDate != nil
    }
    var isToDateEnabled: Bool {
        return timeRangeToDate != nil
    }
    
    var hasActiveFilter: Bool {
        return (numActiveFilters ?? 0) > 0
    }
    
    var numActiveFilters: Int? {
        let num = (searchText.isEmpty ? 0 : 1)
        + filteredDogsUUIDs.count
        + filteredLogActionActionTypeIds.count
        + filteredFamilyMemberUserIds.count
        + (onlyShowLikes ? 1 : 0)
        + (isFromDateEnabled ? 1 : 0)
        + (isToDateEnabled ? 1 : 0)
        
        return num == 0 ? nil : num
    }
    
    // MARK: - Main
    
    init(dogManager: DogManager) {
        super.init()
        apply(dogManager: dogManager)
    }
    
    // MARK: - Computed Properties
    
    var availableTimeRangeFields: [LogsSortField] {
        return LogsSortField.allCases
    }
    
    var availableDogs: [Dog] {
        return dogManager.dogs
    }
    
    var availableLogActions: [LogActionType] {
        return GlobalTypes.shared.logActionTypes
    }
    
    var availableFamilyMembers: [FamilyMember] {
        return FamilyInformation.familyMembers
    }
    
    // MARK: - Functions
    
    func reset() {
        apply(filterDogs: [])
        apply(filterLogActions: [])
        apply(filterFamilyMembers: [])
        apply(onlyShowLikes: false)
        apply(searchText: "")
        apply(timeRangeField: LogsSortField.defaultSortField)
        apply(timeRangeFromDate: nil)
        apply(timeRangeToDate: nil)
    }
    
    func apply(dogManager: DogManager) {
        self.dogManager = dogManager
    }
    
    // filteredDogsUUIDs
    func apply(filterDogs: [Dog]) {
        filteredDogsUUIDs = Set(filterDogs.map({ $0.dogUUID }))
    }
    func add(filterDogUUID: UUID) {
        filteredDogsUUIDs.insert(filterDogUUID)
    }
    func remove(filterDogUUID: UUID) {
        filteredDogsUUIDs.remove(filterDogUUID)
    }
    
    // filteredLogActionActionTypeIds
    func apply(filterLogActions: [LogActionType]) {
        filteredLogActionActionTypeIds = Set(filterLogActions.map({ $0.logActionTypeId }))
    }
    func add(logActionTypeId: Int) {
        filteredLogActionActionTypeIds.insert(logActionTypeId)
    }
    func remove(logActionTypeId: Int) {
        filteredLogActionActionTypeIds.remove(logActionTypeId)
    }
    
    // filteredFamilyMemberUserIds
    func apply(filterFamilyMembers: [FamilyMember]) {
        filteredFamilyMemberUserIds = Set(filterFamilyMembers.map({ $0.userId }))
    }
    func add(userId: String) {
        filteredFamilyMemberUserIds.insert(userId)
    }
    func remove(userId: String) {
        filteredFamilyMemberUserIds.remove(userId)
    }

    func apply(onlyShowLikes: Bool) {
        self.onlyShowLikes = onlyShowLikes
    }
    
    // searchText
    func apply(searchText: String) {
        self.searchText = searchText.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    // timeRangeField, timeRangeFromDate, timeRangeToDate
    func apply(timeRangeField: LogsSortField) {
        self.timeRangeField = timeRangeField
    }
    func apply(timeRangeFromDate: Date?) {
        self.timeRangeFromDate = timeRangeFromDate
    }
    func apply(timeRangeToDate: Date?) {
        self.timeRangeToDate = timeRangeToDate
    }
    
}
//
//  DogLogManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

/// Manages a collection of logs for a dog and provides efficient sorted access.
/// Sorted arrays are cached and only rebuilt when the underlying data changes.
final class DogLogManager: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = DogLogManager(parentDog: parentDog)
        for dogLog in dogLogs {
            if let logCopy = dogLog.copy() as? Log {
                copy.dogLogs.append(logCopy)
            }
        }
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogLogs: [Log]? = aDecoder.decodeOptionalObject(forKey: Constant.Key.dogLogs.rawValue)
        self.init(logs: decodedDogLogs ?? [], parentDog: nil)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogLogs, forKey: Constant.Key.dogLogs.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var dogLogs: [Log] = []
    
    private var sortedDogLogsCreated: [Log]?
    private var sortedDogLogsModified: [Log]?
    private var sortedDogLogsStart: [Log]?
    private var sortedDogLogsEnd: [Log]?
    
    weak var parentDog: Dog?
    
    // MARK: - Main
    
    init(logs: [Log] = [], parentDog: Dog?) {
        self.parentDog = parentDog
        super.init()
        addLogs(logs: logs, invokeDogTriggers: false)
    }
    
    /// Provide an array of dictionary literal of log properties to instantiate dogLogs. Provide a logManager to have the dogLogs add themselves into, update themselves in, or delete themselves from.
    convenience init(fromLogBodies: [JSONResponseBody], dogLogManagerToOverride: DogLogManager?, parentDog: Dog?) {
        self.init(logs: dogLogManagerToOverride?.dogLogs ?? [], parentDog: parentDog)
        
        for fromBody in fromLogBodies {
            // Don't pull logId or logIsDeleted from logToOverride. A valid fromBody needs to provide this itself
            let logId: Int? = fromBody[Constant.Key.logId.rawValue] as? Int
            let logUUID: UUID? = UUID.fromString(UUIDString: fromBody[Constant.Key.logUUID.rawValue] as? String)
            let logIsDeleted: Bool? = fromBody[Constant.Key.logIsDeleted.rawValue] as? Bool
            
            guard logId != nil, let logUUID = logUUID, let logIsDeleted = logIsDeleted else {
                // couldn't construct essential components to intrepret log
                continue
            }
            
            guard logIsDeleted == false else {
                removeLog(logUUID: logUUID)
                continue
            }
            
            if let log = Log(fromBody: fromBody, logToOverride: findLog(logUUID: logUUID)) {
                addLog(log: log, invokeDogTriggers: false)
            }
        }
    }

    // MARK: - Functions

    /// finds and returns the reference of a log matching the given logUUID
    func findLog(logUUID: UUID) -> Log? {
        dogLogs.first(where: { $0.logUUID == logUUID })
    }

    private func invalidateSortedCaches() {
        sortedDogLogsCreated = nil
        sortedDogLogsModified = nil
        sortedDogLogsStart = nil
        sortedDogLogsEnd = nil
    }

    func sortedDogLogs(sortField: LogsSortField, sortDirection: LogsSortDirection) -> [Log] {
        let ascendingLogs: [Log]
        switch sortField {
        case .createdDate:
            if sortedDogLogsCreated == nil {
                sortedDogLogsCreated = LogsSort.sort(dogLogs, sortField: .createdDate, sortDirection: .ascending)
            }
            ascendingLogs = sortedDogLogsCreated ?? []
        case .modifiedDate:
            if sortedDogLogsModified == nil {
                sortedDogLogsModified = LogsSort.sort(dogLogs, sortField: .modifiedDate, sortDirection: .ascending)
            }
            ascendingLogs = sortedDogLogsModified ?? []
        case .logStartDate:
            if sortedDogLogsStart == nil {
                sortedDogLogsStart = LogsSort.sort(dogLogs, sortField: .logStartDate, sortDirection: .ascending)
            }
            ascendingLogs = sortedDogLogsStart ?? []
        case .logEndDate:
            if sortedDogLogsEnd == nil {
                sortedDogLogsEnd = LogsSort.sort(dogLogs, sortField: .logEndDate, sortDirection: .ascending)
            }
            ascendingLogs = sortedDogLogsEnd ?? []
        }

        return sortDirection == .ascending ? ascendingLogs : Array(ascendingLogs.reversed())
    }
    
    /// Adds a log to the dogLogs array and sorts. If invokeDogTriggers is true, it will the dog to see if any triggers are activated (and if so, generate reminders from them and return those reminders)
    @discardableResult
    func addLog(log: Log, invokeDogTriggers: Bool) -> [Reminder] {
        removeLog(logUUID: log.logUUID)
        
        dogLogs.append(log)
        invalidateSortedCaches()
        
        var generatedReminders: [Reminder] = []
        if invokeDogTriggers {
            if let dog = parentDog {
                let triggers = dog.dogTriggers.matchingActivatedTriggers(log: log)
                for trigger in triggers {
                    if let reminder = trigger.createTriggerResultReminder(afterLog: log) {
                        generatedReminders.append(reminder)
                    }
                }
            }
            else {
                HoundLogger.general.error("DogLogManager.addLog\t: Dog is nil & invokeDogTriggers is true, cannot invoke dog triggers for log: \(log.logUUID) \(log.logActionTypeId) \(log.logCustomActionName)")
            }
        }
        
        return generatedReminders
    }
    
    /// Adds a log to the dogLogs array and sorts. If invokeDogTriggers is true, it will the dog to see if any triggers are activated (and if so, generate reminders from them and return those reminders)
    @discardableResult
    func addLogs(logs: [Log], invokeDogTriggers: Bool) -> [Reminder] {
        removeLogs(logUUIDs: logs.map { $0.logUUID })
        
        dogLogs.append(contentsOf: logs)
        invalidateSortedCaches()
        
        var generatedReminders: [Reminder] = []
        if invokeDogTriggers {
            if let dog = parentDog {
                for log in logs {
                    let triggers = dog.dogTriggers.matchingActivatedTriggers(log: log)
                    for trigger in triggers {
                        if let reminder = trigger.createTriggerResultReminder(afterLog: log) {
                            generatedReminders.append(reminder)
                        }
                    }
                }
            }
        }
        
        return generatedReminders
    }
    
    @discardableResult func removeLog(logUUID: UUID) -> Bool {
        var didRemoveObject = false
        
        dogLogs.removeAll { log in
            guard log.logUUID == logUUID else {
                return false
            }

            didRemoveObject = true
            return true
        }

        if didRemoveObject {
            invalidateSortedCaches()
        }

        return didRemoveObject
    }

    @discardableResult func removeLogs(logUUIDs: [UUID]) -> Bool {
        var didRemoveObject = false

        dogLogs.removeAll { l in
            guard logUUIDs.contains(l.logUUID) else {
                return false
            }

            didRemoveObject = true
            return true
        }

        if didRemoveObject {
            invalidateSortedCaches()
        }

        return didRemoveObject
    }
}
//
//  DogManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/21/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class DogManager: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = DogManager()
        for dog in dogs {
            if let dogCopy = dog.copy() as? Dog {
                copy.dogs.append(dogCopy)
            }
        }
        return copy
    }
    
    // MARK: - NSCoding
    
    required init?(coder aDecoder: NSCoder) {
        let decodedDogs: [Dog]? = aDecoder.decodeOptionalObject(forKey: Constant.Key.dogs.rawValue)
        dogs = decodedDogs ?? dogs
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogs, forKey: Constant.Key.dogs.rawValue)
    }
    
    // MARK: - Properties
    
    /// This dogManager is typically used for persistence. If we are passing a dogManager through area of code not easily navigated by view controllers
    static var globalDogManager: DogManager?
    
    /// Stores all the dogs. This is get only to make sure integrite of dogs added is kept
    private(set) var dogs: [Dog] = []
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    /// initializes, sets dogs to []
    /// Provide an array of dictionary literal of dog properties to instantiate dogs. Provide a dogManager to have the dogs add themselves into, update themselves in, or delete themselves from.
    convenience init?(fromDogBodies: [JSONResponseBody], dogManagerToOverride: DogManager?) {
        self.init()
        self.addDogs(dogs: dogManagerToOverride?.dogs ?? [])
        
        for fromBody in fromDogBodies {
            // Don't pull these properties from overrideDog. A valid fromBody needs to provide this itself
            let dogId: Int? = fromBody[Constant.Key.dogId.rawValue] as? Int
            let dogUUID: UUID? = UUID.fromString(UUIDString: fromBody[Constant.Key.dogUUID.rawValue] as? String)
            let dogIsDeleted: Bool? = fromBody[Constant.Key.dogIsDeleted.rawValue] as? Bool
            
            guard dogId != nil, let dogUUID = dogUUID, let dogIsDeleted = dogIsDeleted else {
                // couldn't construct essential components to intrepret dog
                continue
            }
            
            guard dogIsDeleted == false else {
                DogIconManager.removeIcon(dogUUID: dogUUID)
                removeDog(dogUUID: dogUUID)
                continue
            }
            
            if let dog = Dog(fromBody: fromBody, dogToOverride: findDog(dogUUID: dogUUID)) {
                addDog(dog: dog)
            }
        }
    }
    
    // MARK: - Computed Properties
    
    /// Returns true if ANY the dogs present has at least 1 CREATED reminder
    var hasCreatedReminder: Bool {
        for dog in dogs where dog.dogReminders.dogReminders.isEmpty == false {
            return true
        }
        return false
    }
    
    // MARK: - Functions
    
    /// Returns reference of a dog with the given dogUUID
    func findDog(dogUUID: UUID) -> Dog? {
        dogs.first(where: { $0.dogUUID == dogUUID })
    }
    
    /// Helper function allows us to use the same logic for addDog and addDogs and allows us to only sort at the end. Without this function, addDogs would invoke addDog repeadly and sortDogs() with each call.
    func addDogWithoutSorting(dog: Dog) {
        
        // removes any existing dogs that have the same dogUUID as they would cause problems.
        dogs.removeAll { d in
            return d.dogUUID == dog.dogUUID
        }
        
        dogs.append(dog)
    }
    
    /// Checks to see if a dog is already present. If its dogUUID is, then is removes the old dog and replaces it with the new.
    func addDog(dog: Dog) {
        
        addDogWithoutSorting(dog: dog)
        
        dogs.sort(by: { $0 <= $1 })
    }
    
    /// Adds array of dogs with addDog(dog: Dog) repition  (but only sorts once at the end to be more efficent)
    func addDogs(dogs: [Dog]) {
        for dog in dogs {
            addDogWithoutSorting(dog: dog)
        }
        
        self.dogs.sort(by: { $0 <= $1 })
    }
    
    /// Returns true if it removed at least one dog with the same dogUUID
    @discardableResult func removeDog(dogUUID: UUID) -> Bool {
        var didRemoveObject = false
        
        dogs.removeAll { d in
            guard d.dogUUID == dogUUID else {
                return false
            }
            
            didRemoveObject = true
            return true
        }
        
        return didRemoveObject
    }
    
    /// Returns an array of tuples [[(dogUUID, log)]]. This array has all of the logs for all of the dogs grouped by the unique day/month/year they occurred on.
    ///
    /// The previous implementation collected every matching log and performed an additional sort before grouping. For large
    /// datasets this required sorting many more elements than were ultimately displayed. The logic below performs a k-way
    /// merge across each dog's already‑sorted logs and only materializes up to `limit` entries. This
    /// drastically reduces the amount of work when the total log count is high while keeping the result deterministic and
    /// free of cache invalidation concerns.
    func allLogsGroupedByDate(filter: LogsFilter, sort: LogsSort, limit: Int) -> [[(UUID, Log)]] {
        // Prepare sequences of sorted logs for all dogs that pass the dog filter
        typealias DogLogSequence = (uuid: UUID, logs: [Log], index: Int)
        var sequences: [DogLogSequence] = []

        for dog in dogs {
            if filter.filteredDogsUUIDs.isEmpty == false && filter.filteredDogsUUIDs.contains(dog.dogUUID) == false {
                continue
            }

            let sortedLogs = dog.dogLogs.sortedDogLogs(sortField: sort.sortField, sortDirection: sort.sortDirection)
            sequences.append((uuid: dog.dogUUID, logs: sortedLogs, index: 0))
        }

        // Helper to evaluate whether a log passes all of the provided filters
        func logPassesFilter(_ log: Log) -> Bool {
            if filter.filteredLogActionActionTypeIds.isEmpty == false &&
                filter.filteredLogActionActionTypeIds.contains(log.logActionTypeId) == false {
                return false
            }

            if filter.filteredFamilyMemberUserIds.isEmpty == false &&
                filter.filteredFamilyMemberUserIds.contains(log.logCreatedBy) == false {
                return false
            }

            if filter.isFromDateEnabled, let fromDate = filter.timeRangeFromDate,
               filter.timeRangeField.date(log) <= fromDate { return false }

            if filter.isToDateEnabled, let toDate = filter.timeRangeToDate,
               filter.timeRangeField.date(log) >= toDate { return false }

            if filter.searchText.isEmpty == false && log.matchesSearchText(filter.searchText) == false {
                return false
            }

            if filter.onlyShowLikes {
                guard let userId = UserInformation.userId, log.likedByUserIds.contains(userId) else { return false }
            }

            return true
        }

        // Merge sequences by repeatedly selecting the next log across all dogs
        var dogUUIDLogPairs: [(UUID, Log)] = []
        dogUUIDLogPairs.reserveCapacity(limit)

        // This loop performs a k-way merge across all dogs' sorted logs, only materializing up to the display limit.
        while dogUUIDLogPairs.count < limit {
            var bestSequenceIndex: Int?

            // Find the next "best" log among all dogs, according to the sort order
            for i in sequences.indices {
                // Advance each sequence to the next log that satisfies the filters
                while sequences[i].index < sequences[i].logs.count &&
                        logPassesFilter(sequences[i].logs[sequences[i].index]) == false {
                    sequences[i].index += 1
                }

                // If this sequence is exhausted, skip it
                guard sequences[i].index < sequences[i].logs.count else { continue }

                if let currentBest = bestSequenceIndex {
                    let currentBestLog = sequences[currentBest].logs[sequences[currentBest].index]
                    let candidateLog = sequences[i].logs[sequences[i].index]
                    // Compare logs using the requested sort field and direction
                    let comparison = sort.sortField.compare(lhs: candidateLog, rhs: currentBestLog)
                    let replace = sort.sortDirection == .ascending
                        ? (comparison == .orderedAscending)
                        : (comparison == .orderedDescending)
                    // First valid candidate found
                    if replace { bestSequenceIndex = i }
                }
                else {
                    bestSequenceIndex = i
                }
            }

            // If no more logs are available, break
            guard let sequenceIndex = bestSequenceIndex else { break }

            // Add the selected log to the result and advance its sequence
            let sequence = sequences[sequenceIndex]
            let log = sequence.logs[sequence.index]
            dogUUIDLogPairs.append((sequence.uuid, log))
            sequences[sequenceIndex].index += 1
        }

        // Group the chronologically ordered logs by day/month/year
        var allLogsGroupedByDate: [[(UUID, Log)]] = []

        for (dogUUID, log) in dogUUIDLogPairs {
            // If the last group is for the same day, append; otherwise, start a new group
            if let lastDateGroup = allLogsGroupedByDate.last,
               let (_, lastLog) = lastDateGroup.last,
               Calendar.user.isDate(sort.sortField.date(log), inSameDayAs: sort.sortField.date(lastLog)) {
                allLogsGroupedByDate[allLogsGroupedByDate.count - 1].append((dogUUID, log))
            }
            else {
                allLogsGroupedByDate.append([(dogUUID, log)])
            }
        }

        return allLogsGroupedByDate
    }
    
    /// Iterates through all dogs for a given array of dogUUIDs. Finds all reminders for each of those dogs where the reminder is enabled, its reminderActionType matches, and its reminderCustomActionName matches.
    func matchingReminders(dogUUIDs: [UUID], logActionType: LogActionType, logCustomActionName: String?) -> [(UUID, Reminder)] {
        var allMatchingReminders: [(UUID, Reminder)] = []
        
        // Find the dogs that are currently selected
        let dogs = dogs.filter { dog in
            dogUUIDs.contains(dog.dogUUID)
        }
        
        // Search through all of the dogs currently selected. For each dog, find the matching reminders
        for dog in dogs {
            let matchingReminders = dog.matchingReminders(logActionType: logActionType, logCustomActionName: logCustomActionName)
            
            // We found any reminders that match, map them with their dogUUID to return them
            allMatchingReminders += matchingReminders.map({ reminder in
                (dog.dogUUID, reminder)
            })
        }
        
        return allMatchingReminders
    }
}
//
//  GeneralLayoutConstraint.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/17/25.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

/// Wrapper for NSLayoutConstraint that preserves original constant and multiplier,
/// and handles safe replacement (activation, deactivation) if the multiplier is changed.
/// All references and changes should be made through this class.
final class GeneralLayoutConstraint {
    
    // MARK: - Properties
    
    /// The minimum allowed multiplier (to avoid UIKit bugs from multiplier == 0.0)
    static let minimumMultiplier: CGFloat = 0.00000001

    /// The currently active NSLayoutConstraint managed by this wrapper.
    private(set) var constraint: NSLayoutConstraint
    
    /// The original constant value.
    let originalConstant: CGFloat
    
    /// The original multiplier value, if applicable.
    let originalMultiplier: CGFloat?
    
    /// Tracks if the constraint is in a "collapsed" state.
    var isCollapsed: Bool {
        return abs(multiplier ?? 1.0) < Self.minimumMultiplier
    }
    
    // MARK: - Init
    
    /// Wraps an existing NSLayoutConstraint, capturing its initial constant and multiplier (if any).
    init(_ wrapping: NSLayoutConstraint) {
        self.constraint = wrapping
        self.originalConstant = wrapping.constant
        self.originalMultiplier = GeneralLayoutConstraint.extractMultiplier(from: wrapping)
    }
    
    // MARK: - API
    
    /// The current constant.
    var constant: CGFloat {
        get { constraint.constant }
        set { constraint.constant = newValue }
    }
    
    /// The current multiplier (if any).
    var multiplier: CGFloat? {
        GeneralLayoutConstraint.extractMultiplier(from: constraint)
    }
    
    var isActive: Bool {
        get { constraint.isActive }
        set { constraint.isActive = newValue }
    }
    
    /// Change the multiplier. If a zero multiplier is passed, will coalesce to minimumMultiplier instead.
    func setMultiplier(_ newMultiplier: CGFloat) {
        // Coalesce zero to minimumMultiplier for UIKit safety
        let safeMultiplier: CGFloat = (abs(newMultiplier) < Self.minimumMultiplier) ? Self.minimumMultiplier : newMultiplier

        guard let origMultiplier = multiplier else {
            assertionFailure("Tried to set multiplier on a constraint without one (likely created with constant, not relative constraint)")
            return
        }
        guard abs(origMultiplier - safeMultiplier) > Self.minimumMultiplier else { return }
        guard let newConstraint = GeneralLayoutConstraint.rebuildConstraint(
            from: constraint, withMultiplier: safeMultiplier
        ) else {
            assertionFailure("Failed to rebuild constraint with new multiplier")
            return
        }
        swapConstraint(to: newConstraint)
    }
    
    /// Restore both constant and multiplier to original values.
    func restore() {
        constraint.constant = originalConstant
        if let origMultiplier = originalMultiplier {
            setMultiplier(origMultiplier)
        }
    }
    
    // MARK: - Internal Replacement
    
    /// Swaps the currently managed NSLayoutConstraint for a new one, activating and deactivating as needed.
    private func swapConstraint(to newConstraint: NSLayoutConstraint) {
        let wasActive = constraint.isActive
        constraint.isActive = false
        NSLayoutConstraint.deactivate([constraint])
        newConstraint.priority = constraint.priority
        newConstraint.identifier = constraint.identifier
        newConstraint.isActive = wasActive
        if wasActive {
            NSLayoutConstraint.activate([newConstraint])
        }
        self.constraint = newConstraint
    }
    
    // MARK: - Helpers
    
    /// Attempts to extract the multiplier from the constraint (KVC, as UIKit doesn't expose this).
    private static func extractMultiplier(from constraint: NSLayoutConstraint) -> CGFloat? {
        if constraint.firstAttribute != .notAnAttribute && constraint.secondItem != nil {
            return (constraint.value(forKey: "multiplier") as? CGFloat)
        }
        return nil
    }
    
    /// Build a new constraint by copying all parameters except multiplier, and using the specified multiplier.
    private static func rebuildConstraint(from old: NSLayoutConstraint, withMultiplier multiplier: CGFloat) -> NSLayoutConstraint? {
        guard let firstItem = old.firstItem else { return nil }
        let secondItem = old.secondItem
        
        if old.firstAttribute == .notAnAttribute || secondItem == nil {
            return nil
        }
        let newConstraint = NSLayoutConstraint(
            item: firstItem,
            attribute: old.firstAttribute,
            relatedBy: old.relation,
            toItem: secondItem,
            attribute: old.secondAttribute,
            multiplier: multiplier,
            constant: old.constant
        )
        newConstraint.priority = old.priority
        newConstraint.identifier = old.identifier
        return newConstraint
    }
}
//
//  Sender.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/27/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class Sender: NSObject {
    
    // MARK: - Properties

    let origin: AnyObject?
    var localized: AnyObject?
    
    // MARK: - Main

    init(origin: AnyObject, localized: AnyObject) {
        if let sender = origin as? Sender {
            self.origin = sender.origin
        }
        else {
            self.origin = origin
        }

        // localized cannot be sender, however we can let it pass
        if let sender = localized as? Sender {
            self.localized = sender.localized
        }
        else {
            self.localized = localized
        }
    }

}
//
//  HoundError.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/22/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundError: Error {
    // MARK: - Properties

    /// Constant name of error. When HoundErrors are accessed from the Error Constant enum, they calculated properties. That means each time a HoundError is accessed, it's description might have changed. However, it's name and type will always be the same.
    private(set) var name: String
    /// Dynamic descripton of error. When HoundErrors are accessed from the Error Constant enum, they calculated properties. That means each time a HoundError is accessed, it's description might have changed. However, it's name and type will always be the same.
    private(set) var description: String

    /// If a HoundError is generated, a banner is shown for it, and the user taps the banner, this is the action that will be taken (after the banner is tapped).
    private(set) var onTap: (() -> Void)

    // MARK: - Main
    init(name: String, description: String, onTap: (() -> Void)?) {
        self.name = name
        self.description = description
        let userId = UserInformation.userId

        /// If onTap isn't specified, this is the default action to take.
        let defaultOnTap: (() -> Void) = {
            var message = "Name: \(name)\nDescription: \(description)"
            if let userId = userId {
                message.append("\nSupport ID: \(userId)")
            }

            let errorInformationAlertController = UIAlertController(title: "Error Information", message: message, preferredStyle: .alert)
            let copyAlertAction = UIAlertAction(title: "Copy to Clipboard", style: .default) { _ in
                UIPasteboard.general.setPasteboard(string: message)
            }
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
            errorInformationAlertController.addAction(copyAlertAction)
            errorInformationAlertController.addAction(cancelAlertAction)
            PresentationManager.enqueueAlert(errorInformationAlertController)
        }

        self.onTap = onTap ?? defaultOnTap
    }

    // MARK: - Functions

    /// Alerts the user to this error. If the error is an appVersionOutdated error, presents a undismissable alert to update the app (bricking Hound until they update). Otherwise, presents a banner about the error
    func alert() {
        HoundLogger.general.error("HoundError.alert(): Alerting user for error: \(self.description)")

        guard name != Constant.Error.GeneralResponseError.appVersionOutdated(requestId: -1, responseId: -1).name else {
            let vc = AppVersionOutdatedVC()
            PresentationManager.enqueueViewController(vc)
            return
        }
        
        guard name != Constant.Error.FamilyResponseError.limitFamilyMemberExceeded(requestId: -1, responseId: -1).name else {
            let vc = LimitExceededViewController()
            PresentationManager.enqueueViewController(vc)
            return
        }

        PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.errorAlertTitle, subtitle: description, style: .danger) {
            self.onTap()
        }
    }
}

final class HoundServerError: HoundError {

    // MARK: - Properties

    /// The requestId of a request to the Hound server that failed and generated an error
    private(set) var requestId: Int

    /// The responseId of a response from the Hound server due to a request that failed and generated an error
    private(set) var responseId: Int

    // MARK: - Main
    
    init(name: String, description: String, onTap: (() -> Void)?, requestId: Int, responseId: Int) {
        self.requestId = requestId
        self.responseId = responseId
        let userId = UserInformation.userId

        /// If onTap isn't specified, this is the default action to take.
        let defaultOnTap: (() -> Void) = {
            var message = "Name: \(name)\nDescription: \(description)\nRequest ID: \(requestId)\nResponse ID: \(responseId)"
            if let userId = userId {
                message.append("\nSupport ID: \(userId)")
            }

            let errorInformationAlertController = UIAlertController(title: "Error Information", message: message, preferredStyle: .alert)
            let copyAlertAction = UIAlertAction(title: "Copy to Clipboard", style: .default) { _ in
                UIPasteboard.general.setPasteboard(string: message)
            }
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
            errorInformationAlertController.addAction(copyAlertAction)
            errorInformationAlertController.addAction(cancelAlertAction)
            PresentationManager.enqueueAlert(errorInformationAlertController)
        }

        super.init(name: name, description: description, onTap: onTap ?? defaultOnTap)
    }
}
//
//  Subscription.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/14/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum SubscriptionGroup20965379Product: String, CaseIterable {

    // This order is specific, the lower indicies get sorted to the first positions
    case sixFamilyMembersOneYear = "com.jonathanxakellis.hound.sixfamilymembers.oneyear"
    case sixFamilyMembersSixMonth = "com.jonathanxakellis.hound.sixfamilymembers.sixmonth"
    case sixFamilyMembersOneMonth = "com.jonathanxakellis.hound.sixfamilymembers.onemonth"

    // case twoFMTwoDogs = "com.jonathanxakellis.hound.twofamilymemberstwodogs.monthly"
    // case fourFMFourDogs = "com.jonathanxakellis.hound.fourfamilymembersfourdogs.monthly"
    // case sixFMSixDogs = "com.jonathanxakellis.hound.sixfamilymemberssixdogs.monthly"
    // case tenFMTenDogs = "com.jonathanxakellis.hound.tenfamilymemberstendogs.monthly"
}

final class Subscription: NSObject, NSCoding {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedTransactionId = aDecoder.decodeOptionalInteger(forKey: Constant.Key.transactionId.rawValue)
        let decodedProductId = aDecoder.decodeOptionalString(forKey: Constant.Key.productId.rawValue)
        let decodedPurchaseDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.purchaseDate.rawValue)
        let decodedExpiresDate: Date? = aDecoder.decodeOptionalObject(forKey: Constant.Key.expiresDate.rawValue)
        let decodedNumberOfFamilyMembers = aDecoder.decodeOptionalInteger(forKey: Constant.Key.numberOfFamilyMembers.rawValue)
        let decodedIsActive = aDecoder.decodeOptionalBool(forKey: Constant.Key.isActive.rawValue)
        let decodedAutoRenewStatus = aDecoder.decodeOptionalBool(forKey: Constant.Key.autoRenewStatus.rawValue)
        let decodedAutoRenewProductId = aDecoder.decodeOptionalString(forKey: Constant.Key.autoRenewProductId.rawValue)

        self.init(
            internalTransactionId: decodedTransactionId,
            internalProductId: decodedProductId,
            internalPurchaseDate: decodedPurchaseDate,
            internalExpiresDate: decodedExpiresDate,
            internalNumberOfFamilyMembers: decodedNumberOfFamilyMembers,
            internalIsActive: decodedIsActive,
            internalAutoRenewStatus: decodedAutoRenewStatus,
            internalAutoRenewProductId: decodedAutoRenewProductId
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.

        if let transactionId = transactionId {
            aCoder.encode(transactionId, forKey: Constant.Key.transactionId.rawValue)
        }
        aCoder.encode(productId, forKey: Constant.Key.productId.rawValue)
        if let purchaseDate = purchaseDate {
            aCoder.encode(purchaseDate, forKey: Constant.Key.purchaseDate.rawValue)
        }
        if let expiresDate = expiresDate {
            aCoder.encode(expiresDate, forKey: Constant.Key.expiresDate.rawValue)
        }
        aCoder.encode(numberOfFamilyMembers, forKey: Constant.Key.numberOfFamilyMembers.rawValue)
        aCoder.encode(isActive, forKey: Constant.Key.isActive.rawValue)
        aCoder.encode(autoRenewStatus, forKey: Constant.Key.autoRenewStatus.rawValue)
        aCoder.encode(autoRenewProductId, forKey: Constant.Key.autoRenewProductId.rawValue)
    }
    
    // MARK: - Properties

    /// Transaction Id that of the subscription purchase
    private(set) var transactionId: Int?

    /// ProductId that the subscription purchase was for. No product means its a default subscription
    private(set) var productId: String

    /// Date at which the subscription was purchased and completed processing on Hound's server
    private(set) var purchaseDate: Date?

    /// Date at which the subscription will expire
    private(set) var expiresDate: Date?

    /// How many family members the subscription allows into the family
    private(set) var numberOfFamilyMembers: Int

    /// Indicates whether or not this subscription is the one thats active for the family
    var isActive: Bool

    /// Indicates whether or not this subscription will renew itself when it expires
    private(set) var autoRenewStatus: Bool

    /// The product identifier of the product that renews at the next billing period./
    private(set) var autoRenewProductId: String

    // MARK: - Main

    init(
        transactionId: Int?,
        productId: String,
        purchaseDate: Date?,
        expiresDate: Date?,
        numberOfFamilyMembers: Int,
        isActive: Bool,
        autoRenewStatus: Bool,
        autoRenewProductId: String
    ) {
        self.transactionId = transactionId
        self.productId = productId
        self.purchaseDate = purchaseDate
        self.expiresDate = expiresDate
        self.numberOfFamilyMembers = numberOfFamilyMembers
        self.isActive = isActive
        self.autoRenewStatus = autoRenewStatus
        self.autoRenewProductId = autoRenewProductId
        super.init()
    }
    
    private convenience init(
        internalTransactionId: Int?,
        internalProductId: String?,
        internalPurchaseDate: Date?,
        internalExpiresDate: Date?,
        internalNumberOfFamilyMembers: Int?,
        internalIsActive: Bool?,
        internalAutoRenewStatus: Bool?,
        internalAutoRenewProductId: String?
    ) {
        self.init(
            transactionId: internalTransactionId,
            productId: internalProductId ?? Constant.Class.Subscription.defaultProductId,
            purchaseDate: internalPurchaseDate,
            expiresDate: internalExpiresDate,
            numberOfFamilyMembers: internalNumberOfFamilyMembers ?? Constant.Class.Subscription.defaultSubscriptionNumberOfFamilyMembers,
            isActive: internalIsActive ?? false,
            autoRenewStatus: internalAutoRenewStatus ?? true,
            autoRenewProductId: internalAutoRenewProductId ?? internalProductId ?? Constant.Class.Subscription.defaultProductId
        )
    }

    /// Assume array of family properties
    convenience init(fromBody body: JSONResponseBody) {
        let transactionId: Int? = body[Constant.Key.transactionId.rawValue] as? Int
        let productId: String? = body[Constant.Key.productId.rawValue] as? String
        let purchaseDate: Date? = (body[Constant.Key.purchaseDate.rawValue] as? String)?.formatISO8601IntoDate()
        let expiresDate: Date? = (body[Constant.Key.expiresDate.rawValue] as? String)?.formatISO8601IntoDate()
        let numberOfFamilyMembers = body[Constant.Key.numberOfFamilyMembers.rawValue] as? Int
        let isActive = body[Constant.Key.isActive.rawValue] as? Bool
        let autoRenewStatus = body[Constant.Key.autoRenewStatus.rawValue] as? Bool
        let autoRenewProductId = body[Constant.Key.autoRenewProductId.rawValue] as? String

        self.init(
            internalTransactionId: transactionId,
            internalProductId: productId,
            internalPurchaseDate: purchaseDate,
            internalExpiresDate: expiresDate,
            internalNumberOfFamilyMembers: numberOfFamilyMembers,
            internalIsActive: isActive,
            internalAutoRenewStatus: autoRenewStatus,
            internalAutoRenewProductId: autoRenewProductId
        )
    }

}
//
//  HoundLogger.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import os.log
import UIKit

struct HoundLogger {
    static var general = HoundLogger(subsystem: "com.example.Pupotty", category: "General")
    static var lifecycle = HoundLogger(subsystem: "com.example.Pupotty", category: "Life Cycle")
    static var apiRequest  = HoundLogger(subsystem: "com.example.Pupotty", category: "API Request")
    static var apiResponse = HoundLogger(subsystem: "com.example.Pupotty", category: "API Response")
    
    private let logger: Logger
    private let category: String
    private let forwardToLogger: Bool = false
    
    init(subsystem: String, category: String) {
        self.logger = Logger(subsystem: subsystem, category: category)
        self.category = category
    }
    
    private static let timeFormat: HoundDateFormat = .template("HH:mm:ss")
    
    private func formattedMessage(_ message: String) -> String {
        let time = Date().houndFormatted(Self.timeFormat, displayTimeZone: TimeZone.current)
        return "\(time) [\(category)] \(message)"
    }
    
    func notice(_ message: String) {
        let formatted = formattedMessage(message)
        print(formatted)
        if forwardToLogger {
            logger.notice("\(message)")
        }
    }
    
    func debug(_ message: String) {
        let formatted = formattedMessage(message)
        print(formatted)
        if forwardToLogger {
            logger.debug("\(message)")
        }
    }
    
    func error(_ message: String) {
        let formatted = formattedMessage(message)
        print(formatted)
        if forwardToLogger {
            logger.error("\(message)")
        }
    }
    
    func fault(_ message: String) {
        let formatted = formattedMessage(message)
        print(formatted)
        if forwardToLogger {
            logger.fault("\(message)")
        }
    }
    
    func warning(_ message: String) {
        let formatted = formattedMessage(message)
        print(formatted)
        if forwardToLogger {
            logger.log(level: .default, "\(message)")
        }
    }
}
//
//  Family.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/5/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class FamilyMember: NSObject, NSCoding, Comparable {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedUserId = aDecoder.decodeOptionalString(forKey: Constant.Key.userId.rawValue)
        let decodedUserFirstName = aDecoder.decodeOptionalString(forKey: Constant.Key.userFirstName.rawValue)
        let decodedUserLastName = aDecoder.decodeOptionalString(forKey: Constant.Key.userLastName.rawValue)

        self.init(
            internalUserId: decodedUserId,
            internalFirstName: decodedUserFirstName,
            internalLastName: decodedUserLastName
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(userId, forKey: Constant.Key.userId.rawValue)
        if let firstName = firstName {
            aCoder.encode(firstName, forKey: Constant.Key.userFirstName.rawValue)
        }
        if let lastName = lastName {
            aCoder.encode(lastName, forKey: Constant.Key.userLastName.rawValue)
        }
    }
    
    // MARK: - Comparable
    
    static func < (lhs: FamilyMember, rhs: FamilyMember) -> Bool {
        // the family head should always be first
        if lhs.isUserFamilyHead == true {
            // 1st element is head so should come before therefore return true
            return true
        }
        else if rhs.isUserFamilyHead == true {
            // 2nd element is head so should come before therefore return false
            return false
        }
        
        // Sort based upon name
        let lhsName = lhs.displayFullName ?? ""
        let rhsName = rhs.displayFullName ?? ""
        
        if lhsName.isEmpty && rhsName.isEmpty {
            // Both names are blank, use userId to determine order
            return lhs.userId <= rhs.userId
        }
        // we know one of OR both of the lhsName and rhsName are != nil &&.isEmpty == false
        else if lhsName.isEmpty {
            // no lhs name but has a rhs name
            return false
        }
        else if rhsName.isEmpty {
            // no rhs name but has lhs name
            return true
        }
        
        // Neither names are empty
        // "Bella" would come before "Zach"
        return lhsName <= rhsName
    }

    // MARK: - Properties
    
    /// The family member's userId
    private(set) var userId: String

    /// The family member's first name
    private(set) var firstName: String?

    /// The family member's last name
    private(set) var lastName: String?
    
    // MARK: - Main

    init(userId: String, firstName: String?, lastName: String?) {
        self.userId = userId
        self.firstName = firstName
        self.lastName = lastName
        super.init()
    }
    
    private convenience init(
        internalUserId: String?,
        internalFirstName: String?,
        internalLastName: String?
    ) {
        self.init(
            userId: internalUserId ?? Constant.Visual.Text.unknownHash,
            firstName: internalFirstName,
            lastName: internalLastName
        )
    }

    /// Assume array of family properties
    convenience init(fromBody body: JSONResponseBody) {
        let userId = body[Constant.Key.userId.rawValue] as? String
        let firstName = body[Constant.Key.userFirstName.rawValue] as? String
        let lastName = body[Constant.Key.userLastName.rawValue] as? String
        self.init(
            internalUserId: userId,
            internalFirstName: firstName,
            internalLastName: lastName
        )
    }
    
    // MARK: - Computed Properties
    
    /// True if this object's userId matches FamilyInformation.familyHeadUserId
    var isUserFamilyHead: Bool {
        return self.userId == FamilyInformation.familyHeadUserId
    }
    
    /// True if this object's userId matches UserInformation.userId
    var isUserSelf: Bool {
        return self.userId == UserInformation.userId
    }
    
    /// The family member's full name. Handles cases where the first name and/or last name may be ""
    var displayFullName: String? {
        let trimmedFirstName = firstName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        let trimmedLastName = lastName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""

        // check to see if anything is blank
        if trimmedFirstName.isEmpty && trimmedLastName.isEmpty {
            return nil
        }
        // we know one of OR both of the trimmedFirstName and trimmedLast name are != nil &&.isEmpty == false
        else if trimmedFirstName.isEmpty {
            // no first name but has last name
            return "\(trimmedLastName)\(isUserSelf ? " (Me)" : "")"
        }
        else if trimmedLastName.isEmpty {
            // no last name but has first name
            return "\(trimmedFirstName)\(isUserSelf ? " (Me)" : "")"
        }
        else {
            return "\(trimmedFirstName) \(trimmedLastName)\(isUserSelf ? " (Me)" : "")"
        }
    }

    /// The family member's first name. Handles cases where the first name may be "", therefore trying to use the last name to substitute
    var displayPartialName: String? {
        if let trimmedFirstName = firstName?.trimmingCharacters(in: .whitespacesAndNewlines) {
            return trimmedFirstName
        }
        else if let trimmedLastName = lastName?.trimmingCharacters(in: .whitespacesAndNewlines) {
            return trimmedLastName
        }
        
        return nil
    }
}
//
//  GenerationManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 12/5/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum GenerationManager {
    private static func generateRandomAlphanumericString(ofLength: Int) -> String {
        let characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        var randomString = ""
        
        for _ in 0..<ofLength {
            randomString.append(characters.randomElement() ?? Character(""))
        }
        
        return randomString
    }
    
    /// For a given dogManager, generates numberOfLogs of logs total and distrubutes them randomly among its dogs. Once all of these logs have been added to the Hound server, invoked completionHandler
    static func generateRandomLogs(toDogManager: DogManager, numberOfLogs: Int, completionHandler: (() -> Void)?) {
        
        let completionTracker = CompletionTracker(numberOfTasks: numberOfLogs) {
            // Do nothing if one task was completed
        } completedAllTasksCompletionHandler: {
            // Invoke completionHandler if all tasks completed
            completionHandler?()
        } failedTaskCompletionHandler: {
            // Invoke completionHandler if one task failed
            completionHandler?()
        }

        for i in 0..<numberOfLogs {
            guard let logActionType = GlobalTypes.shared.logActionTypes.randomElement() else {
                return
            }
            // If the logActionType is custom, then 50% chance for a random note and 50% chance for no note
            let logCustomActionName = logActionType.allowsCustom
            ? (Int.random(in: 0...1) == 0 ? generateRandomAlphanumericString(ofLength: Int.random(in: 0...32)) : nil)
            : nil
            
            let referenceDate = Calendar.user.date(byAdding: .month, value: -1, to: Date()) ?? Date(timeIntervalSinceReferenceDate: 0.0)
            let logStartDate = referenceDate.addingTimeInterval(
                Double.random(in: 0.0...referenceDate.distance(to: Date()))
            )
            let logEndDate = Int.random(in: 0...1) == 0
            ? nil
            : logStartDate.addingTimeInterval(Double.random(in: 0.0...logStartDate.distance(to: Date())))
            
            let logNote = Int.random(in: 0...1) == 0
            ? nil
            : generateRandomAlphanumericString(ofLength: Int.random(in: 0...100))
            
            let logUnitType = logActionType.associatedLogUnitTypes.randomElement()
            
            let logNumberOfUnits = Double.random(in: 0.0...1000.0)
            
            let log = Log(
                logId: nil,
                logActionTypeId: logActionType.logActionTypeId,
                logCustomActionName: logCustomActionName,
                logStartDate: logStartDate,
                logEndDate: logEndDate,
                logNote: logNote,
                logUnitTypeId: logUnitType?.logUnitTypeId,
                logNumberOfUnits: logNumberOfUnits,
                logCreatedByReminderUUID: nil
            )
            
            let dog = toDogManager.dogs.randomElement()
            
            guard let dog = dog else {
                continue
            }
            
            DispatchQueue.main.asyncAfter(deadline: .now() + (Double(i) * 0.1)) {
                guard completionTracker.isFinished == false else {
                    return
                }
                
                LogsRequest.create(errorAlert: .automaticallyAlertForNone, dogUUID: dog.dogUUID, log: log) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    
                    completionTracker.completedTask()
                    dog.dogLogs.addLog(log: log, invokeDogTriggers: false)
                }
            }
        }
    }
    
    /// Generates a representative set of two dogs with realistic reminders, logs, and automations
    /// for use in App Store screenshots. Data is relative to the user's current time zone.
    /// Both dogs have routines that show clear, real-world use of Hound across today/yesterday.
    /// Generates a default, screenshot-friendly DogManager with two realistic dogs, reminders, logs, and triggers.
    /// All dates are relative to today/yesterday and the user's time zone.
    static func generateScreenshotDogManager() -> DogManager? {
        func logType(_ internalValue: String) -> LogActionType? {
            GlobalTypes.shared.logActionTypes.first { $0.internalValue == internalValue }
        }
        func reminderTypeId(_ internalValue: String) -> Int? {
            GlobalTypes.shared.reminderActionTypes.first { $0.internalValue == internalValue }?.reminderActionTypeId
        }
        func logUnit(_ symbol: String) -> LogUnitType? {
            GlobalTypes.shared.logUnitTypes.first { $0.unitSymbol == symbol }
        }
        func todayAt(_ hour: Int, _ minute: Int) -> Date {
            let cal = Calendar.user
            let today = cal.startOfDay(for: Date())
            return cal.date(bySettingHour: hour, minute: minute, second: 0, of: today) ?? today
        }
        func yesterdayAt(_ hour: Int, _ minute: Int) -> Date {
            let cal = Calendar.user
            let today = cal.startOfDay(for: Date())
            let yesterday = cal.date(byAdding: .day, value: -1, to: today) ?? today
            return cal.date(bySettingHour: hour, minute: minute, second: 0, of: yesterday) ?? yesterday
        }
        func walkUnitSymbol() -> String {
            UserConfiguration.measurementSystem == .metric ? "km" : "mi"
        }
        func foodUnitSymbol() -> String { "cup" }
        
        // --- 1. Dogs ---
        let bella = Dog()
        bella.changeDogName(dogName: "Bella")
        let charlie = Dog()
        charlie.changeDogName(dogName: "Charlie")
        
        // --- 2. Reminders ---
        if let pottyId = reminderTypeId("potty") {
            let countdown = CountdownComponents()
            countdown.executionInterval = 60 * 60 * 2
            let reminder = Reminder(
                reminderActionTypeId: pottyId,
                reminderType: .countdown,
                reminderTimeZone: UserConfiguration.timeZone,
                countdownComponents: countdown
            )
            bella.dogReminders.addReminder(reminder: reminder)
        }
        if let feedId = reminderTypeId("feed") {
            let weekly = WeeklyComponents()
            weekly.setZonedWeekdays(Weekday.allCases)
            weekly.zonedHour = 7
            weekly.zonedMinute = 0
            let reminder = Reminder(
                reminderActionTypeId: feedId,
                reminderType: .weekly,
                reminderTimeZone: UserConfiguration.timeZone,
                weeklyComponents: weekly
            )
            bella.dogReminders.addReminder(reminder: reminder)
        }
        if let medicineId = reminderTypeId("medicine") {
            let monthly = MonthlyComponents(zonedDay: 1, zonedHour: 9, zonedMinute: 0, skippedDate: nil)
            let reminder = Reminder(
                reminderActionTypeId: medicineId,
                reminderType: .monthly,
                reminderTimeZone: UserConfiguration.timeZone,
                monthlyComponents: monthly
            )
            bella.dogReminders.addReminder(reminder: reminder)
        }
        
        // Charlie: Feed (8:00am), Water (12:00pm), Walk (6:00pm) - all days
        if let feedId = reminderTypeId("feed") {
            let weekly = WeeklyComponents()
            weekly.setZonedWeekdays(Weekday.allCases)
            weekly.zonedHour = 8
            weekly.zonedMinute = 0
            let reminder = Reminder(
                reminderActionTypeId: feedId,
                reminderType: .weekly,
                reminderTimeZone: UserConfiguration.timeZone,
                weeklyComponents: weekly
            )
            charlie.dogReminders.addReminder(reminder: reminder)
        }
        if let waterId = reminderTypeId("water") {
            let weekly = WeeklyComponents()
            weekly.setZonedWeekdays(Weekday.allCases)
            weekly.zonedHour = 12
            weekly.zonedMinute = 0
            let reminder = Reminder(
                reminderActionTypeId: waterId,
                reminderType: .weekly,
                reminderTimeZone: UserConfiguration.timeZone,
                weeklyComponents: weekly
            )
            charlie.dogReminders.addReminder(reminder: reminder)
        }
        if let walkId = reminderTypeId("walk") {
            let weekly = WeeklyComponents()
            weekly.setZonedWeekdays(Weekday.allCases)
            weekly.zonedHour = 18
            weekly.zonedMinute = 0
            let reminder = Reminder(
                reminderActionTypeId: walkId,
                reminderType: .weekly,
                reminderTimeZone: UserConfiguration.timeZone,
                weeklyComponents: weekly
            )
            charlie.dogReminders.addReminder(reminder: reminder)
        }
        
        // --- 3. Triggers / Automations ---
        bella.dogTriggers.addTriggers(dogTriggers: Constant.Class.Trigger.defaultTriggers)
        charlie.dogTriggers.addTriggers(dogTriggers: Constant.Class.Trigger.defaultTriggers)
        
        // --- 4. Logs (balanced between aesthetic, realistic, and feature showcase) ---
        func addLog(
            to dog: Dog,
            action: String,
            customName: String? = nil,
            start: Date,
            end: Date? = nil,
            unitSymbol: String? = nil,
            units: Double? = nil,
            note: String? = nil
        ) {
            guard let logType = logType(action) else { return }
            let unitId = unitSymbol.flatMap { logUnit($0)?.logUnitTypeId }
            let log = Log(
                logActionTypeId: logType.logActionTypeId,
                logCustomActionName: customName,
                logStartDate: start,
                logEndDate: end,
                logNote: note,
                logUnitTypeId: unitId,
                logNumberOfUnits: units
            )
            dog.dogLogs.addLog(log: log, invokeDogTriggers: false)
        }
        
        // Bella (Yesterday and Today)
        addLog(
            to: bella,
            action: "feed",
            start: yesterdayAt(7, 0),
            unitSymbol: foodUnitSymbol(),
            units: 1.5,
            note: "Dry kibble"
        )
        addLog(
            to: bella,
            action: "both",
            start: yesterdayAt(7, 18)
        )
        addLog(
            to: bella,
            action: "walk",
            start: yesterdayAt(17, 0),
            end: yesterdayAt(17, 35),
            unitSymbol: walkUnitSymbol(),
            units: 1.1,
            note: "Nice long walk"
        )
        addLog(
            to: bella,
            action: "feed",
            start: todayAt(7, 0),
            unitSymbol: foodUnitSymbol(),
            units: 1.25,
            note: "Dry kibble"
        )
        addLog(
            to: bella,
            action: "both",
            start: todayAt(7, 14)
        )
        addLog(
            to: bella,
            action: "walk",
            start: todayAt(17, 0),
            end: todayAt(17, 34),
            unitSymbol: walkUnitSymbol(),
            units: 1.0,
            note: "She sniffed around a lot!"
        )
        addLog(
            to: bella,
            action: "treat",
            start: todayAt(18, 58),
            note: "After training"
        )
        
        // Charlie (Yesterday and Today)
        addLog(
            to: charlie,
            action: "feed",
            start: yesterdayAt(8, 0),
            unitSymbol: foodUnitSymbol(),
            units: 0.9
        )
        addLog(
            to: charlie,
            action: "water",
            customName: "Refilled bowl",
            start: yesterdayAt(12, 15),
        )
        addLog(
            to: charlie,
            action: "walk",
            start: yesterdayAt(18, 0),
            end: yesterdayAt(18, 33),
            unitSymbol: walkUnitSymbol(),
            units: 1.4
        )
        addLog(
            to: charlie,
            action: "treat",
            start: yesterdayAt(19, 12)
        )
        addLog(
            to: charlie,
            action: "feed",
            start: todayAt(8, 0),
            unitSymbol: foodUnitSymbol(),
            units: 1.0
        )
        addLog(
            to: charlie,
            action: "water",
            start: todayAt(12, 11),
            unitSymbol: "cup",
            units: 1.75
        )
        addLog(
            to: charlie,
            action: "medicine",
            customName: "Heartworm",
            start: todayAt(20, 0)
        )
        addLog(
            to: charlie,
            action: "pee",
            start: todayAt(18, 42)
        )
        addLog(
            to: charlie,
            action: "walk",
            start: todayAt(18, 0),
            end: todayAt(18, 28),
            unitSymbol: walkUnitSymbol(),
            units: 1.2
        )
        
        // --- 5. Compose manager ---
        let manager = DogManager()
        manager.addDogs(dogs: [bella, charlie])
        return manager
    }

}
//
//  ReminderAlarmManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/20/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol ReminderAlarmManagerDelegate: AnyObject {
    func didAddLog(sender: Sender, dogUUID: UUID, log: Log, invokeDogTriggers: Bool)
    func didAddReminder(sender: Sender, dogUUID: UUID, reminder: Reminder)
    func didRemoveReminder(sender: Sender, dogUUID: UUID, reminderUUID: UUID)
}

final class ReminderAlarmManager {
    private class AlarmQueueItem {
        private(set) var dogName: String
        private(set) var dogUUID: UUID
        private(set) var reminder: Reminder

        init(dogName: String, dogUUID: UUID, reminder: Reminder) {
            self.dogName = dogName
            self.dogUUID = dogUUID
            self.reminder = reminder
        }
    }
    static weak var delegate: ReminderAlarmManagerDelegate!

    /// If the globalPresenter is not loaded, indicating that the app is in the background, we store all willCreateAndShowReminderAlarm calls in this alarmQueue. This ensures that once the app is opened, the alarm queue is executed so that it refreshes the most current information from the server.
    private static var alarmQueue: [AlarmQueueItem] = []

    /// Creates HoundAlarmAlertController to show the user about their alarm going off. We query the server with the information provided first to make sure it is up to date.
    static func willCreateAndShowReminderAlarm(dogName: String, dogUUID: UUID, reminder: Reminder) {
        // If the app is in the background, add the willCreateAndShowReminderAlarm to the queue. Once the app is brought to the foreground, executes synchronizeReminderAlarmQueueIfNeeded to attempt to reshow all of these alarms. This ensures that when the alarms are presented, the app is open. Otherwise, we could refresh the information for an alarm and present it, only for it to sit in the background for an hour while the app is closed, making the alarm outdated.
        guard UIApplication.shared.applicationState != .background else {
            // make sure we don't have multiple of the same alarm in the alarm queue
            alarmQueue.removeAll { item in
                item.dogUUID == dogUUID && item.reminder.reminderUUID == reminder.reminderUUID
            }
            alarmQueue.append(AlarmQueueItem(dogName: dogName, dogUUID: dogUUID, reminder: reminder))
            return
        }

        // before presenting alarm, make sure we are up to date locally
        RemindersRequest.get(errorAlert: .automaticallyAlertForNone, dogUUID: dogUUID, reminder: reminder) { responseReminder, responseStatus, _ in
            guard responseStatus != .failureResponse else {
                return
            }

            guard let responseReminder = responseReminder else {
                // If the response was successful but no reminder was returned, that means the reminder was deleted. Therefore, tell the delegate as such.
                delegate.didRemoveReminder(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, reminderUUID: reminder.reminderUUID)
                return
            }

            // reminderExecutionDate must not be nil, otherwise if reminderExecutionDate is nil then the reminder was potentially was disabled or the reminder's timing components are broken.
            // the distance from present to executionDate must be negitive, otherwise if the distance is negative then executionDate in past
            guard let reminderExecutionDate = responseReminder.reminderExecutionDate, Date().distance(to: reminderExecutionDate) < 0 else {
                // We were able to retrieve the reminder and something was wrong with it. Something was disabled, the reminder was pushed back to the future, or it simply just has invalid timing components.
                // MARK: IMPORTANT - Do not try to refresh DogManager as that can (and does) cause an infinite loop. The reminder can exist but for some reason have invalid data leading to a nil executionDate. If we refresh the DogManager, we could retrieve the same invalid reminder data which leads back to this statement (and thus starts the infinite loop)

                self.delegate.didAddReminder(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, reminder: responseReminder)
                return
            }

            // the reminder exists, its executionDate exists, and its executionDate is in the past (meaning it should be valid).

            // the dogUUID and reminderUUID exist if we got a reminder back
            let title = "\(responseReminder.reminderActionType.convertToReadableName(customActionName: responseReminder.reminderCustomActionName)) - \(dogName)"

            let alarmAlertController = HoundAlarmAlertController(
                title: title,
                message: nil,
                preferredStyle: .alert)
            alarmAlertController.setup(dogUUID: dogUUID, reminder: responseReminder)

            var alertActionsForLog: [UIAlertAction] = []

            // Cant convert a reminderActionType of potty directly to logActionType, as it has serveral possible outcomes. Otherwise, logActionType and reminderActionType 1:1
            let logActionTypes: [LogActionType] = responseReminder.reminderActionType.associatedLogActionTypes

            for logActionType in logActionTypes {
                let logAlertAction = UIAlertAction(
                    title: "Log \(logActionType.convertToReadableName(customActionName: responseReminder.reminderCustomActionName))",
                    style: .default,
                    handler: { _ in
                        // alarmAlertController could have been absorbed into another alarmAlertController
                        let alartController = alarmAlertController.absorbedIntoAlarmAlertController ?? alarmAlertController

                        guard let alarmReminders = alartController.reminders else {
                            return
                        }

                        for alarmReminder in alarmReminders {
                            ReminderAlarmManager.userSelectedLogAlarm(dogUUID: dogUUID, reminder: alarmReminder, logActionType: logActionType)
                            ReminderTimingManager.didCompleteForReminderTimer(reminderUUID: alarmReminder.reminderUUID, type: .alarmTimer)
                        }
                        
                        ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
                    })
                alertActionsForLog.append(logAlertAction)
            }

            let snoozeAlertAction = UIAlertAction(
                title: "Snooze for \(UserConfiguration.snoozeLength.readable(capitalizeWords: false, abbreviationLevel: .short))",
                style: .default,
                handler: { (_: UIAlertAction!)  in
                    // alarmAlertController could have been absorbed into another alarmAlertController
                    let alartController = alarmAlertController.absorbedIntoAlarmAlertController ?? alarmAlertController

                    guard let alarmReminders = alartController.reminders else {
                        return
                    }

                    for alarmReminder in alarmReminders {
                        ReminderAlarmManager.userSelectedSnoozeAlarm(dogUUID: dogUUID, reminder: alarmReminder)
                        ReminderTimingManager.didCompleteForReminderTimer(reminderUUID: alarmReminder.reminderUUID, type: .alarmTimer)
                    }
                    
                    ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
                })

            let dismissAlertAction = UIAlertAction(
                title: "Dismiss",
                style: .cancel,
                handler: { (_: UIAlertAction!)  in
                    // alarmAlertController could have been absorbed into another alarmAlertController
                    let alartController = alarmAlertController.absorbedIntoAlarmAlertController ?? alarmAlertController

                    guard let alarmReminders = alartController.reminders else {
                        return
                    }

                    for alarmReminder in alarmReminders {
                        ReminderAlarmManager.userSelectedDismissAlarm(dogUUID: dogUUID, reminder: alarmReminder)
                        ReminderTimingManager.didCompleteForReminderTimer(reminderUUID: alarmReminder.reminderUUID, type: .alarmTimer)
                    }
                    
                    ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
                })

            for logAlertAction in alertActionsForLog {
                alarmAlertController.addAction(logAlertAction)
            }
            
            alarmAlertController.addAction(snoozeAlertAction)
            alarmAlertController.addAction(dismissAlertAction)

            delegate.didAddReminder(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, reminder: responseReminder)
            
            PresentationManager.enqueueAlert(alarmAlertController)
        }
    }

    /// Once the app is brought back into the foreground, meaning the alarms in the alarm queue can be presented, call this function to iterate through and present any alarms in the alarm queue
    static func synchronizeReminderAlarmQueueIfNeeded() {

        // Only attempt to show the alarms if the app isn't in the background
        guard UIApplication.shared.applicationState != .background else { return }

        let copiedAlarmQueue = alarmQueue
        alarmQueue = []

        // We can't iterate over alarmQueue as willCreateAndShowReminderAlarm could potentially add items to alarmQueue. That means we need to empty alarmQueue before iterating over to avoid mixing.
        for (index, alarmQueueItem) in copiedAlarmQueue.enumerated() {
            // First alarm (at front of queue... should come first): execute queries right now
            // Second alarm: execute queries after 25 ms to help ensure it comes second
            // Thirds alarm: execute queries after 50 ms to help ensure it comes third
            DispatchQueue.main.asyncAfter(deadline: .now() + (0.05 * Double(index)), execute: {
                willCreateAndShowReminderAlarm(dogName: alarmQueueItem.dogName, dogUUID: alarmQueueItem.dogUUID, reminder: alarmQueueItem.reminder)
            })
        }
    }
    
    /// User responded to the reminder's alarm that popped up on their screen. They selected to 'Snooze' the reminder. Therefore we modify the timing data so the reminder turns into .snooze mode, alerting them again soon. We don't add a log
    private static func userSelectedSnoozeAlarm(dogUUID: UUID, reminder: Reminder) {
        reminder.resetForNextAlarm()
        reminder.snoozeComponents.changeExecutionInterval(UserConfiguration.snoozeLength)

        // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
        RemindersRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminders: [reminder]) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                return
            }

            delegate.didAddReminder(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, reminder: reminder)
        }

    }

    /// User responded to the reminder's alarm that popped up on their screen. They selected to 'Dismiss' the reminder. Therefore we reset the timing data and don't add a log.
    private static func userSelectedDismissAlarm(dogUUID: UUID, reminder: Reminder) {
        // special case. Once a oneTime reminder executes, it must be delete. Therefore there are special server queries.
        if reminder.reminderType == .oneTime {
            // just make request to delete reminder for oneTime remidner
            RemindersRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminderUUIDs: [reminder.reminderUUID]) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }

                delegate.didRemoveReminder(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, reminderUUID: reminder.reminderUUID)
            }
        }
        // Nest all the other cases inside this else statement as otherwise .oneTime alarms would make request with the above code then again down here.
        else {
            // the reminder just executed an alarm/alert, so we want to reset its stuff
            reminder.resetForNextAlarm()

            // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
            RemindersRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminders: [reminder]) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }

                delegate.didAddReminder(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, reminder: reminder)
            }
        }

    }

    /// User responded to the reminder's alarm that popped up on their screen. They selected to 'Log' the reminder. Therefore we reset the timing data and add a log.
    private static func userSelectedLogAlarm(dogUUID: UUID, reminder: Reminder, logActionType: LogActionType) {
        let log = Log(logCreatedByReminderUUID: reminder.reminderUUID)
        log.logActionTypeId = logActionType.logActionTypeId
        log.logCustomActionName = reminder.reminderCustomActionName
        log.setLogDate(logStartDate: Date(), logEndDate: nil)

        // special case. Once a oneTime reminder executes, it must be delete. Therefore there are special server queries.
        if reminder.reminderType == .oneTime {
            // make request to add log, then (if successful) make request to delete reminder

            // delete the reminder on the server
            RemindersRequest.delete(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminderUUIDs: [reminder.reminderUUID]) { responseStatusReminderDelete, _ in
                guard responseStatusReminderDelete != .failureResponse else {
                    return
                }

                delegate.didRemoveReminder(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, reminderUUID: reminder.reminderUUID)
                // create log on the server and then assign it the logUUID and then add it to the dog
                LogsRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, log: log) { responseStatusLogCreate, _ in
                    guard responseStatusLogCreate != .failureResponse else {
                        return
                    }

                    delegate.didAddLog(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, log: log, invokeDogTriggers: reminder.reminderIsTriggerResult == false)
                }
            }
        }
        // Nest all the other cases inside this else statement as otherwise .oneTime alarms would make request with the above code then again down here.
        else {
            // the reminder just executed an alarm/alert, so we want to reset its stuff
            reminder.resetForNextAlarm()

            // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
            RemindersRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, reminders: [reminder]) { responseStatusReminderUpdate, _ in
                guard responseStatusReminderUpdate != .failureResponse else {
                    return
                }

                delegate.didAddReminder(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, reminder: reminder)
                // we need to persist a log as well
                LogsRequest.create(errorAlert: .automaticallyAlertOnlyForFailure, dogUUID: dogUUID, log: log) { responseStatusLogCreate, _ in
                    guard responseStatusLogCreate != .failureResponse else {
                        return
                    }

                    delegate.didAddLog(sender: Sender(origin: self, localized: self), dogUUID: dogUUID, log: log, invokeDogTriggers: reminder.reminderIsTriggerResult == false)
                }
            }
        }

    }
}
//
//  ShowBonusInformationManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/10/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import CallKit
import StoreKit

enum ShowBonusInformationManager {
    
    /// Displays release notes about a new version to the user if they have that setting enabled and the app was updated to that new version
    static func showReleaseNotesBannerIfNeeded() {
        // Check that the app was opened before, as we don't want to show the user release notes on their first launch
        // Then, check that the current version doesn't match the previous version, meaning an upgrade or downgrade. The latter shouldnt be possible
        guard AppVersion.previousAppVersion != AppVersion.current else { return }
        
        if let previous = AppVersion.previousAppVersion {
            guard previous > AppVersion.current else {
                return
            }
        }
        
        // make sure we haven't shown the release notes for this version before. To do this, we check to see if our array of app versions that we showed release notes for contains the app version of the current version. If the array does not contain the current app version, then we haven't shown release notes for this new version and we are ok to proceed.
        guard LocalConfiguration.localAppVersionsWithReleaseNotesShown.contains(AppVersion.current) == false else { return }
        
        PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.houndUpdatedTitle, subtitle: Constant.Visual.BannerText.houndUpdatedSubtitle, style: .info) {
            let releaseNotesVC = ReleaseNotesVC()
            releaseNotesVC.setup(version: AppVersion.current)
            PresentationManager.enqueueViewController(releaseNotesVC)
        }
        
        // we successfully showed the banner, so store the version we showed it for
        LocalConfiguration.localAppVersionsWithReleaseNotesShown.append(AppVersion.current)
    }
    
    /// This is the number of seconds in a day
    private static let dayDurationInSeconds: Double = 24.0 * 60.0 * 60.0
    
    /// We want to user to review Hound every increasingDaysBetween * numberOfTimesAskedToAppReviewReview days. Additionally, we offset this value by 0.2 day (4.8 hour) to ask during different times of day.
    private static let increasingDaysBetweenAppStoreReview: Double = 5.0 + 0.2
    /// We can only ask a user three time a year to review Hound, therefore, cap the interval to a value slightly over year / 3.
    private static let maximumDaysBetweenAppStoreReview: Double = 122.0 + 0.2
    
    /// We want to user to share Hound every increasingDaysBetween * numberOfTimesAskedToSurveyAppExperience days. Additionally, we offset this value by 0.2 day (4.8 hour) to ask during different times of day.
    private static let increasingDaysBetweenSurveyAppExperience = 3.0 + 0.2
    /// We begin by asking the user to review Hound with at a minimum frequency. This interval progressively grows, but we don't want the interval to grow too large where we ask too infrequently. This variable caps the interval to ensure a certain frequency.
    private static let maximumDaysBetweenSurveyAppExperience: Double = 40.0 + 0.2
    
    /// Displays a view controller that asks for user's rating of hound
    static func requestSurveyAppExperienceIfNeeded() {
        // This is the duration, in seconds, that Hound should wait before repeating showing the user the pop up to review the app. Currently, we wait 6 months before asking a user for a survey again
        let durationToWaitBeforeRepeatingSurvey = 180.0 * dayDurationInSeconds
        
        guard let lastDateSurveyAppExperienceRequested = LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.last else {
            LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.append(Date())
            return
        }
        
        if let lastDateUserSurveyFeedbackAppExperienceSubmitted = LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted.last {
            if lastDateUserSurveyFeedbackAppExperienceSubmitted.distance(to: Date()) < durationToWaitBeforeRepeatingSurvey {
                return
            }
        }
        
        // Check if we WANT to show the user a pop-up to share Hound.
        let isDueForSurveyAppExperienceRequest: Bool = {
            // count == 1: Been asked zero times before (first Date() is a placeholder). We ask 5.2 days after the initial install.
            // count == 2: asked one time; 10.4 days since last ask
            // count == 3: asked two times; 15.6 days since last ask
            // count == 4: asked three times; 20.8 days since last ask
            
            let numberOfDaysToWaitForNextSurveyAppExperience: Double = min(
                Double(LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.count) * increasingDaysBetweenSurveyAppExperience,
                maximumDaysBetweenSurveyAppExperience
            )
            
            let timeWaitedSinceLastAsk = lastDateSurveyAppExperienceRequested.distance(to: Date())
            let timeNeededToWaitForNextAsk = numberOfDaysToWaitForNextSurveyAppExperience * dayDurationInSeconds
            
            return timeWaitedSinceLastAsk > timeNeededToWaitForNextAsk
        }()
        
        guard isDueForSurveyAppExperienceRequest == true else { return }
        
        // Delay this call slightly so that current ui elements have time to complete
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            let vc = SurveyAppExperienceVC()
            PresentationManager.enqueueViewController(vc)
        }
    }
    
}
//
//  InAppPurchaseManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/13/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import KeychainSwift
import StoreKit

// This main class provides a streamlined way to perform the main two queries
final class InAppPurchaseManager {

    /// Initialized InternalInAppPurchaseManager.shared. This creates the InternalInAppPurchaseManager() object, and this in turn sets that object as a observer for the PaymentQueue and as a observer for the price increase consent
    static func initialize() {
        _ = InternalInAppPurchaseManager.shared
        
        InternalInAppPurchaseManager.shared.fetchProducts { _ in
            return
        }
    }

    /// When you increase the price of a subscription, the system asks your delegate’s function paymentQueueShouldShowPriceConsent() whether to immediately display the price consent sheet, or to delay displaying the sheet until later. For example, you may want to delay showing the sheet if it would interrupt a multistep user interaction, such as setting up a user account. Return false in paymentQueueShouldShowPriceConsent() to prevent the dialog from displaying immediately. To show the price consent sheet after a delay, call showPriceConsentIfNeeded(), which shows the sheet only if the user hasn’t responded to the price increase notifications.
    static func showPriceConsentIfNeeded() {
        InternalInAppPurchaseManager.shared.showPriceConsentIfNeeded()
    }

    /// Attempts to show the App Store manage subscriptions page. If an error occurs with that, then opens the apple.com manage subscritpions page
    static func showManageSubscriptions() {
        // iOS gets picky and throws errors if this isn't on the main thread so ensure that it is
        DispatchQueue.main.async {
            guard let windowScene = UIApplication.keyWindow?.windowScene else {
                guard let url = URL(string: "https://apps.apple.com/account/subscriptions") else {
                    return
                }
                UIApplication.shared.open(url)
                return
            }

            Task {
                do {
                    try await AppStore.showManageSubscriptions(in: windowScene)
                }
                catch {
                    guard let url = URL(string: "https://apps.apple.com/account/subscriptions") else {
                        return
                    }
                    _ = await UIApplication.shared.open(url)
                }
            }
        }
    }

    static var subscriptionProducts: [SKProduct] {
        return InternalInAppPurchaseManager.shared.subscriptionProducts ?? []
    }

    /// Query apple servers to purchase a certain product. If successful, then queries Hound servers to have transaction verified and applied. If there is an error, ErrorManager is automatically invoked and nil is returned.
    static func purchaseProduct(
        product: SKProduct,
        completionHandler: @escaping (String?) -> Void
    ) {
        InternalInAppPurchaseManager.shared.purchase(product: product) { productIdentifier in
            completionHandler(productIdentifier)
        }
    }

    /// Asks the payment queue to restore previously completed purchases. Once they are restored, the receipt is communicated to the Hound server and any missing record is added.
    static func restorePurchases(completionHandler: @escaping (Bool) -> Void) {
        InternalInAppPurchaseManager.shared.restorePurchases { Bool in
            completionHandler(Bool)
        }
    }

    /// Displays a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.
    static func presentCodeRedemptionSheet() {
        // Make sure the user has the Hound permissions to perform such a request
        guard UserInformation.isUserFamilyHead else {
            Constant.Error.InAppPurchaseError.purchasePermission().alert()
            return
        }

        SKPaymentQueue.default().presentCodeRedemptionSheet()
    }
}

// Handles the important code of InAppPurchases with Apple server communication. Segmented from main class to reduce clutter
private final class InternalInAppPurchaseManager: NSObject, SKProductsRequestDelegate, SKPaymentTransactionObserver, SKPaymentQueueDelegate {

    // MARK: - Properties

    static let shared = InternalInAppPurchaseManager()

    /// Keeps track of if the system is asyncronously, in the background, updating the transaction records on the hound server. This can occur if there is a subscription renewal which gets added to the paymentQueue.
    var backgroundPurchaseInProgress: Bool = false

    override init() {
        super.init()
        // Observe Price Increase Consent
        SKPaymentQueue.default().delegate = self
        // Observe Pending Transactions
        SKPaymentQueue.default().add(self)
    }

    // MARK: - Consent To Subscription Price Increase

    func paymentQueueShouldShowPriceConsent(_ paymentQueue: SKPaymentQueue) -> Bool {
        // Check to make sure that mainTabBarController exists and is loaded.
        guard MainTabBarController.isInViewHierarchy else {
            // The mainTabBarController doesn't exist yet and/or isn't loaded. Therefore we should defer until its loaded. mainTabBarController will call showPriceConsentIfNeeded once it loads and take care of the deferrment
            return false
        }

        // mainTabBarController exists and is loaded, so lets show the price consent
        return true
    }

    /// When you increase the price of a subscription, the system asks your delegate’s function paymentQueueShouldShowPriceConsent() whether to immediately display the price consent sheet, or to delay displaying the sheet until later. For example, you may want to delay showing the sheet if it would interrupt a multistep user interaction, such as setting up a user account. Return false in paymentQueueShouldShowPriceConsent() to prevent the dialog from displaying immediately. To show the price consent sheet after a delay, call showPriceConsentIfNeeded(), which shows the sheet only if the user hasn’t responded to the price increase notifications.
    func showPriceConsentIfNeeded() {
        SKPaymentQueue.default().showPriceConsentIfNeeded()
    }

    // MARK: - Fetch Products

    /// Keep track of the current request completionHandler
    private var productsRequestCompletionHandler: ((HoundError?) -> Void)?

    /// Products retrieved from SKProductsRequest that are subscription products
    private(set) var subscriptionProducts: [SKProduct]?

    func fetchProducts(completionHandler: @escaping (HoundError?) -> Void) {
        // We have subscription products, so no need to fetch more
        guard subscriptionProducts == nil else {
            completionHandler(nil)
            return
        }
    
        guard productsRequestCompletionHandler == nil else {
            // If another request is initated while there is currently an on going request, we want to reject that request
            completionHandler(Constant.Error.InAppPurchaseError.productRequestInProgress())
            return
        }

        let request = SKProductsRequest(productIdentifiers: Set(SubscriptionGroup20965379Product.allCases.compactMap({ $0.rawValue })))
        request.delegate = self
        request.start()
        productsRequestCompletionHandler = completionHandler
    }

    /// Get available products from Apple Servers
    func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) {
        let products = response.products.sorted(by: { unknownProduct1, unknownProduct2 in
            // The product with a product identifier that is closer to index 0 of the InAppPurchase enum allCases should come first. If a product identifier is unknown, the known one comes first. If both product identiifers are known, we have the <= productIdentifer come first.

            let product1 = SubscriptionGroup20965379Product(rawValue: unknownProduct1.productIdentifier)
            let product2 = SubscriptionGroup20965379Product(rawValue: unknownProduct2.productIdentifier)

            if product1 == nil && product2 == nil {
                // the product identifiers aren't known to us. Therefore we should sort based upon the product identifier strings themselves
                return unknownProduct1.productIdentifier <= unknownProduct2.productIdentifier
            }

            // at least one of them isn't nil
            guard let product1 = product1 else {
                // since product1 isn't known and therefore product2 is known, product2 should come first
                return false
            }

            guard let product2 = product2 else {
                // since product1 is known and product2 isn't, product1 should come first
                return true
            }

            guard let indexOfProduct1: Int = SubscriptionGroup20965379Product.allCases.firstIndex(of: product1), let indexOfProduct2: Int = SubscriptionGroup20965379Product.allCases.firstIndex(of: product2) else {
                // if we can't find their indexes, compare them based off their productIdentifiers
                return unknownProduct1.productIdentifier <= unknownProduct2.productIdentifier
            }

            // the product with product identifier that has the lower index in .allCases of the InAppPurchase enum comes first
            return indexOfProduct1 <= indexOfProduct2
            })

        // Call everything on async thread. Otherwise, productsRequestCompletionHandler will be set to nil slightly before productsRequestCompletionHandler(result, result) can be called, therefore not calling the completionHandler.
        DispatchQueue.main.async {
            guard products.count >= 1 else {
                self.productsRequestCompletionHandler?(Constant.Error.InAppPurchaseError.productRequestNotFound())
                self.productsRequestCompletionHandler = nil
                return
            }
            
            self.subscriptionProducts = products.filter({ product in
                product.subscriptionPeriod != nil
            })
            self.productsRequestCompletionHandler?(nil)
        }
    }

    /// Observe if there was an error when retrieving the products
    func request(_ request: SKRequest, didFailWithError error: Error) {
        HoundLogger.general.error("InAppPurchaseManager.request: Error retrieving in-app purchase products: \(error.localizedDescription)")
        // return to completion handler then reset for next products request
        DispatchQueue.main.async {
            self.productsRequestCompletionHandler?(Constant.Error.InAppPurchaseError.productRequestFailed())
            self.productsRequestCompletionHandler = nil
        }
    }

    // MARK: - Purchase a Product

    private var productPurchaseCompletionHandler: ((String?) -> Void)?

    // Prompt a product payment transaction
    func purchase(
        product: SKProduct,
        completionHandler: @escaping (String?) -> Void
    ) {
        // Make sure the user has the Hound permissions to perform such a request
        guard UserInformation.isUserFamilyHead else {
            Constant.Error.InAppPurchaseError.purchasePermission().alert()
            completionHandler(nil)
            return
        }

        // Make sure that the user has the correct Apple permissions to perform such a request
        guard SKPaymentQueue.canMakePayments() else {
            Constant.Error.InAppPurchaseError.purchaseRestricted().alert()
            completionHandler(nil)
            return
        }

        // Make sure there isn't a purchase transaction in process
        guard productPurchaseCompletionHandler == nil else {
            Constant.Error.InAppPurchaseError.purchaseInProgress().alert()
            completionHandler(nil)
            return
        }

        // Make sure there isn't a restore request in process
        guard InternalInAppPurchaseManager.shared.productRestoreCompletionHandler == nil else {
            Constant.Error.InAppPurchaseError.restoreInProgress().alert()
            completionHandler(nil)
            return
        }

        // Make sure the system isn't doing anything async in the background
        guard backgroundPurchaseInProgress == false else {
            Constant.Error.InAppPurchaseError.backgroundPurchaseInProgress().alert()
            completionHandler(nil)
            return
        }

        // Don't test for SKPaymentQueue.default().transactions. This could lock the code from ever executing. E.g. the user goes to buy something (so its in the payment queue) but they stop mid way (maybe leaving the transaction as .purchasing or .deferred). Then the background async processing isn't invoked to start (or it simply can't process whats in the queue) so we are left with transactions in the queue that are stuck and are locking
        productPurchaseCompletionHandler = completionHandler
        let payment = SKMutablePayment(product: product)
        payment.applicationUsername = UserInformation.userAppAccountToken
        SKPaymentQueue.default().add(payment)
    }

    // Observe a transaction state
    func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {
        // Only the family head can perform in-app purchases. This guard statement is here to stop background purchases from attempting to process. They will always fail if the user isn't the family head so no reason to even attempt them.
        guard UserInformation.isUserFamilyHead else { return }

        // If either of these are nil, there is not an ongoing manual request by a user (as there is no callback to provide information to). Therefore, we are dealing with asyncronously bought transactions (e.g. renewals, phone died while purchasing, etc.) that should be processed in the background.
        guard productPurchaseCompletionHandler != nil || productRestoreCompletionHandler != nil else {
            backgroundPurchaseInProgress = true

            // These are transactions that we know have completely failed. Clear them.
            let failedTransactionsInQueue = transactions.filter { transaction in
                transaction.transactionState == .failed
            }

            failedTransactionsInQueue.forEach { failedTransaction in
                SKPaymentQueue.default().finishTransaction(failedTransaction)
            }

            // These are transactions that we know have completely succeeded. Process and clear them.
            let completedTransactionsInQueue = transactions.filter { transaction in
                transaction.transactionState == .purchased || transaction.transactionState == .restored
            }

            // If we have succeeded transactions, silently contact the server in the background to let it know
            guard completedTransactionsInQueue.count >= 1 else {
                backgroundPurchaseInProgress = false
                return
            }

            TransactionsRequest.create(errorAlert: .automaticallyAlertForNone) { responseStatus, _ in
                self.backgroundPurchaseInProgress = false
                guard responseStatus == .successResponse else {
                    return
                }

                // If successful, then we know ALL of the completed transactions in queue have been updated
                completedTransactionsInQueue.forEach { completedTransaction in
                    SKPaymentQueue.default().finishTransaction(completedTransaction)
                }

                // If the subscriptions page is loaded and onscreen, then we refresh it
                SettingsSubscriptionVC.willRefreshIfNeeded()
            }
            return
        }

        // Check if the user is attempting to purchase a product
        guard let productPurchaseCompletionHandler = productPurchaseCompletionHandler else {
            // User is restoring a transaction
            guard let productRestoreCompletionHandler = productRestoreCompletionHandler else {
                return
            }

            let restoredTransactionsInQueue = transactions.filter { transaction in
                transaction.transactionState == .restored
            }

            // If we have restored transactions, contact the server to let it know
            guard restoredTransactionsInQueue.count >= 1 else {
                productRestoreCompletionHandler(false)
                self.productRestoreCompletionHandler = nil
                return
            }

            TransactionsRequest.create(errorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                guard responseStatus == .successResponse else {
                    productRestoreCompletionHandler(false)
                    self.productRestoreCompletionHandler = nil
                    return
                }

                // If successful, then we know ALL of the completed transactions in queue have been updated
                restoredTransactionsInQueue.forEach { restoredTransaction in
                    SKPaymentQueue.default().finishTransaction(restoredTransaction)
                }

                productRestoreCompletionHandler(true)
                self.productRestoreCompletionHandler = nil
            }
            return
        }

        // User is purchasing a product

        for transaction in transactions {
            // We use the main thread so completion handler is on main thread
            DispatchQueue.main.async {
                switch transaction.transactionState {
                case .purchasing:
                    // A transaction that is being processed by the App Store.

                    //  Don't finish transaction, it is still in a processing state
                    break
                case .purchased:
                    // A successfully processed transaction.
                    // Your application should provide the content the user purchased.
                    // Write to the keychain if user has made a purchase
                    let keychain = KeychainSwift()
                    if SubscriptionGroup20965379Product(rawValue: transaction.payment.productIdentifier) != nil {
                        keychain.set(true, forKey: Constant.Key.userPurchasedProductFromSubscriptionGroup20965379.rawValue)
                    }
                    keychain.set(true, forKey: Constant.Key.userPurchasedProduct.rawValue)

                    TransactionsRequest.create(errorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                        guard responseStatus == .successResponse else {
                            productPurchaseCompletionHandler(nil)
                            self.productPurchaseCompletionHandler = nil
                            return
                        }

                        productPurchaseCompletionHandler(transaction.payment.productIdentifier)
                        self.productPurchaseCompletionHandler = nil
                        SKPaymentQueue.default().finishTransaction(transaction)
                    }
                case .failed:
                    // A failed transaction.
                    // Check the error property to determine what happened.
                    Constant.Error.InAppPurchaseError.purchaseFailed().alert()
                    productPurchaseCompletionHandler(nil)
                    self.productPurchaseCompletionHandler = nil
                    SKPaymentQueue.default().finishTransaction(transaction)
                case .restored:
                    // if we have a productPurchaseCompletionHandler, then we lock the transaction queue from other things from interfering
                    // A transaction that restores content previously purchased by the user.
                    // Read the original property to obtain information about the original purchase.

                    TransactionsRequest.create(errorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                        guard responseStatus == .successResponse else {
                            productPurchaseCompletionHandler(nil)
                            self.productPurchaseCompletionHandler = nil
                            return
                        }

                        productPurchaseCompletionHandler(transaction.payment.productIdentifier)
                        self.productPurchaseCompletionHandler = nil
                        SKPaymentQueue.default().finishTransaction(transaction)
                    }
                case .deferred:
                    // A transaction that is in the queue, but its final status is pending external action such as Ask to Buy
                    // Update your UI to show the deferred state, and wait for another callback that indicates the final status.

                    Constant.Error.InAppPurchaseError.purchaseDeferred().alert()
                    productPurchaseCompletionHandler(nil)
                    self.productPurchaseCompletionHandler = nil
                    //  Don't finish transaction, it is still in a processing state
                @unknown default:
                    Constant.Error.InAppPurchaseError.purchaseUnknown().alert()
                    productPurchaseCompletionHandler(nil)
                    self.productPurchaseCompletionHandler = nil
                    // Don't finish transaction, we can't confirm if it succeeded or failed
                }

            }
        }
    }

    /// This delegate function is called when the user starts an in-app purchase in the App Store, and the transaction continues in your app. Specifically, if your app is already installed, the function is called automatically. If your app is not yet installed when the user starts the in-app purchase in the App Store, the user gets a notification when the app installation is complete. This function is called when the user taps the notification. Otherwise, if the user opens the app manually, this function is called only if the app is opened soon after the purchase was started.
    func paymentQueue(_ queue: SKPaymentQueue, shouldAddStorePayment payment: SKPayment, for product: SKProduct) -> Bool {
        SKPaymentQueue.default().add(payment)
        return true
    }

    // MARK: - Restore Purchases

    private var productRestoreCompletionHandler: ((Bool) -> Void)?

    /// Checks to see if the user is eligible to perform a restore transaction request. If they are, invokes  SKPaymentQueue.default().restoreCompletedTransactions() which then will invoke  paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]).
    func restorePurchases(completionHandler: @escaping (Bool) -> Void) {
        // Make sure the user has the permissions to perform such a request
        guard UserInformation.isUserFamilyHead else {
            Constant.Error.InAppPurchaseError.restorePermission().alert()
            completionHandler(false)
            return
        }

        // Don't check for SKPaymentQueue.canMakePayments(), as we are only restoring and not making any purchases

        // Make sure there isn't a restore request in process
        guard InternalInAppPurchaseManager.shared.productRestoreCompletionHandler == nil else {
            Constant.Error.InAppPurchaseError.restoreInProgress().alert()
            completionHandler(false)
            return
        }

        // Make sure there is no purchase request ongoing
        guard productPurchaseCompletionHandler == nil else {
            Constant.Error.InAppPurchaseError.purchaseInProgress().alert()
            completionHandler(false)
            return
        }

        // Make sure the system isn't doing anything async in the background
        guard backgroundPurchaseInProgress == false else {
            Constant.Error.InAppPurchaseError.backgroundPurchaseInProgress().alert()
            completionHandler(false)
            return
        }

        let keychain = KeychainSwift()
        let userPurchasedProduct = keychain.getBool(Constant.Key.userPurchasedProduct.rawValue) ?? false

        guard userPurchasedProduct == true else {
            // If the user hasn't purchased a product, as indicated by our keychain which stores the value regardless if the user's device got blown up by a nuke, then don't invoke restoreCompletedTransactions().
            // This is because if "All transactions are unfinished OR The user did not purchase anything that is restorable OR You tried to restore items that are not restorable, such as a non-renewing subscription or a consumable product", this function will simply never return anything, causing the user

            completionHandler(true)
            return
        }

        // Don't test for SKPaymentQueue.default().transactions. This could lock the code from ever executing. E.g. the user goes to buy something (so its in the payment queue) but they stop mid way (maybe leaving the transaction as .purchasing or .deferred). Then the background async processing isn't invoked to start (or it simply can't process whats in the queue) so we are left with transactions in the queue that are stuck and are locking

        InternalInAppPurchaseManager.shared.productRestoreCompletionHandler = completionHandler
        SKPaymentQueue.default().restoreCompletedTransactions()
    }

    func paymentQueue(_ queue: SKPaymentQueue, restoreCompletedTransactionsFailedWithError error: Error) {
        DispatchQueue.main.async {
            if self.productRestoreCompletionHandler != nil {
                Constant.Error.InAppPurchaseError.restoreFailed().alert()
            }

            self.productRestoreCompletionHandler?(false)
            self.productRestoreCompletionHandler = nil
        }
    }

}
//
//  DogIconManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/12/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum DogIconManager {

    final class LocalDogIcon {
        // MARK: - Main

        init(dogUUID: UUID, dogIcon: UIImage) {
            self.dogUUID = dogUUID
            self.dogIcon = dogIcon
        }

        // MARK: - Properties

        var dogUUID: UUID
        var dogIcon: UIImage

    }

    // MARK: - Get Dog Icon

    /// Present openCameraOrGalleryForDogIconActionSheet to prompt the user with an action sheet asking if they want to open their camera or choose from their gallery for their dogIcon. Set didSelectDogIconController.delegate to allow you to recieve the dog icon that the user selected.
    static let (didSelectDogIconController, openCameraOrGalleryForDogIconActionSheet) = {
        let imagePickerController = UIImagePickerController()

        let imagePickMethodAlertController = UIAlertController(title: "Choose Image", message: "Your personal dog icons aren't shared with other family members", preferredStyle: .actionSheet)

        imagePickMethodAlertController.addAction(UIAlertAction(title: "Camera", style: .default, handler: { _ in
            if UIImagePickerController .isSourceTypeAvailable(UIImagePickerController.SourceType.camera) {
                imagePickerController.sourceType = UIImagePickerController.SourceType.camera
                imagePickerController.allowsEditing = true
                imagePickerController.cameraCaptureMode = .photo
                imagePickerController.cameraDevice = .rear
                PresentationManager.enqueueViewController(imagePickerController)
            }
            else {
                PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.noCameraTitle, subtitle: nil, style: .danger)
            }
        }))

        imagePickMethodAlertController.addAction(UIAlertAction(title: "Gallery", style: .default, handler: { _ in
            imagePickerController.sourceType = UIImagePickerController.SourceType.photoLibrary
            imagePickerController.allowsEditing = true
            PresentationManager.enqueueViewController(imagePickerController)
        }))

        imagePickMethodAlertController.addAction(UIAlertAction.init(title: "Cancel", style: .cancel, handler: nil))

        return (imagePickerController, imagePickMethodAlertController)
    }()

    /// Processes the information returned by the UIImagePickerController, attempts to create an image from it. In the process it scales the image to the point size of the ScaledUiButton of the dogIcon multiplied by the scale factor of the local screen. For Retina displays, the scale factor may be 3.0 or 2.0 and one point can represented by nine or four pixels, respectively. For standard-resolution displays, the scale factor is 1.0 and one point equals one pixel.
    static func processDogIcon(info: [UIImagePickerController.InfoKey: Any]) -> UIImage? {
        let image = info[.editedImage] as? UIImage ?? info[.originalImage] as? UIImage

        guard let image = image else {
            return nil
        }

        // Arbitrary size multiplied by the scale factor of the user's screen
        let scaledSize = 300.0 * UIScreen.main.scale

        let scaledImageSize = CGSize(width: scaledSize, height: scaledSize)

        let renderer = UIGraphicsImageRenderer(size: scaledImageSize)

        let scaledImage = renderer.image { _ in
            image.draw(in: CGRect(origin: .zero, size: scaledImageSize))
        }

        return scaledImage
    }

    // MARK: - Storage of Icons

    /// If we retrieve a dogIcon from files, store it locally. Only retrieve from files if we don't have stored for this life cycle
    private static var icons: [LocalDogIcon] = []

    /// Attempts to create a file path url for the given dogUUID
    private static func getIconURL(dogUUID: UUID) -> URL? {
        // make sure we have a urls to read/write to
        let documentsURLs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)

        // create URL
        guard let url = documentsURLs.first?.appendingPathComponent("dog\(dogUUID).png") else {
            return nil
        }

        return url
    }

    /// Attempts to retrieve the dogIcon for the provided dogUUID. If no dogIcon is found, then nil is returned
    static func getIcon(dogUUID: UUID) -> UIImage? {
        // Before reading icon from files, see if we have it stored in a reference (meaning we've retrieved it before in this lifecycle). Saves us from needlessly reading from files again
        if let icon = icons.first(where: { localDogIcon in
            localDogIcon.dogUUID.uuidString == dogUUID.uuidString
        }) {
            return icon.dogIcon
        }

        // need a url to perform any read/writes to
        guard let url = getIconURL(dogUUID: dogUUID) else {
            return nil
        }

        // attempt to find and return image
        let icon = UIImage(contentsOfFile: url.path)

        if let icon = icon {
            // add dog icon to life cycle storage
            icons.append(LocalDogIcon(dogUUID: dogUUID, dogIcon: icon))
        }

        return icon
    }

    /// Removes all LocalDogIcons stored in LocalConfiguration.dogIcons that match the provided dogUUID, then adds a LocalDogIcon to LocalConfiguration.dogIcons with the provided dogUUID and dogIcon.
    static func addIcon(dogUUID: UUID, dogIcon: UIImage) {

        removeIcon(dogUUID: dogUUID)

        // need a url to perform any read/writes to
        guard let url = getIconURL(dogUUID: dogUUID) else { return }

        // convert dogIcon to data, then attempt to write to url, saving the image
        do {
            try dogIcon.pngData()?.write(to: url)
            // add dog icon to life cycle storage
            icons.append(LocalDogIcon(dogUUID: dogUUID, dogIcon: dogIcon))
        }
        catch {
            // failed to add dog icon
        }
    }

    /// Removes all LocalDogIcons stored in LocalConfiguration.dogIcons that match the provided dogUUID
    static func removeIcon(dogUUID: UUID) {
        // need a url to perform any read/writes to
        guard let url = getIconURL(dogUUID: dogUUID) else { return }

        do {
            // attempt to remove any image at specified url
            try FileManager.default.removeItem(at: url)
            // remove lifecycle storage of dog icon
            icons.removeAll { icon in
                icon.dogUUID == dogUUID
            }
        }
        catch {
            // failed to remove dog icon
        }
    }
}
//
//  NetworkManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/9/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import Network

final class NetworkManager: NSObject {
    @objc static let shared = NetworkManager()
    
    private let queue = DispatchQueue.global()
    private let monitor: NWPathMonitor
    
    @objc private(set) dynamic var isConnected: Bool = false
    
    override private init() {
        monitor = NWPathMonitor()
        super.init()
        monitor.start(queue: queue)
        isConnected = monitor.currentPath.status == .satisfied
        monitor.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            self.isConnected = path.status == .satisfied
        }
    }
}
//
//  AudioManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/14/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import AudioToolbox
import AVFoundation
import MediaPlayer
import UIKit

enum AudioManager {

    private static var sharedPlayer: AVAudioPlayer?

    static var isPlaying: Bool {
        // if the shared player is nil, then its impossible to be playing anything
        return sharedPlayer?.isPlaying ?? false
    }

    // MARK: - General Audio

    static func playAudio(audioPath: String) {
        DispatchQueue.global().async {
            guard let path = Bundle.main.path(forResource: audioPath, ofType: "mp3") else {
                return
            }

            let url = URL(fileURLWithPath: path)

            do {
                stopAudio()

                AudioManager.sharedPlayer = try AVAudioPlayer(contentsOf: url)
                AudioManager.sharedPlayer?.numberOfLoops = -1
                AudioManager.sharedPlayer?.volume = 1.0

                // generic .playback audio that mixes with others. most compatible and non intrustive
                try AVAudioSession.sharedInstance().setCategory(.playback, options: [.mixWithOthers])
                try AVAudioSession.sharedInstance().setActive(true)

                AudioManager.sharedPlayer?.play()
            }
            catch {
                HoundLogger.general.error("AudioManager.playAudio: Encountered an error: \(error.localizedDescription)")
            }
        }
    }

    static func stopAudio() {
        DispatchQueue.global().async {
            shouldVibrate = false
            AudioManager.sharedPlayer?.stop()
        }

    }

    // MARK: - Silent Audio

    static func playSilenceAudio() {
        DispatchQueue.global().async {
            guard let path = Bundle.main.path(forResource: "silence", ofType: "mp3") else {
                return
            }

            let url = URL(fileURLWithPath: path)

            do {
                stopAudio()

                AudioManager.sharedPlayer = try AVAudioPlayer(contentsOf: url)
                AudioManager.sharedPlayer?.numberOfLoops = -1
                AudioManager.sharedPlayer?.volume = 0

                // generic .playback audio that mixes with others. most compatible and non intrustive
                try AVAudioSession.sharedInstance().setCategory(.playback, options: [.mixWithOthers])
                try AVAudioSession.sharedInstance().setActive(true)

                AudioManager.sharedPlayer?.play()

            }
            catch {
                HoundLogger.general.error("AudioManager.playSilenceAudio: Encountered an error: \(error.localizedDescription)")
            }

        }
    }

    // MARK: - Loud Audio

    ///
    private static var shouldVibrate = false

    /// Checks to see if the user has notifications enabled, loud notifications enabled, and the app is in the background and, if all conditions are met, then begins loud notification and vibration.
    static func playLoudNotification() {
        // make sure the user wants loud notifications
        // don't check for if there are enabled reminders, as client could be out of sync with server which has a reminder
        guard UserConfiguration.isNotificationEnabled && UserConfiguration.isLoudNotificationEnabled && UIApplication.shared.applicationState == .background else { return }

        shouldVibrate = true
        loopVibrate()
        // make the device repeadedly vibrate
        func loopVibrate() {
            if shouldVibrate == true {
                AudioServicesPlayAlertSoundWithCompletion(SystemSoundID(kSystemSoundID_Vibrate)) {
                    DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) {
                        loopVibrate()
                    }
                }
            }
        }

        // make the device play the loud notification sound
        DispatchQueue.global().async {
            guard let path = Bundle.main.path(forResource: "\(UserConfiguration.notificationSound.rawValue.lowercased())", ofType: "mp3") else {
                return
            }
            let url = URL(fileURLWithPath: path)

            do {
                stopAudio()

                AudioManager.sharedPlayer = try AVAudioPlayer(contentsOf: url)
                AudioManager.sharedPlayer?.numberOfLoops = -1
                AudioManager.sharedPlayer?.volume = 1.0

                MPVolumeView.setVolume(1.0)

                try AVAudioSession.sharedInstance().setCategory(.playback, options: [])
                try AVAudioSession.sharedInstance().setActive(true)

                AudioManager.sharedPlayer?.play()

            }
            catch {
                HoundLogger.general.error("AudioManager.playLoudNotification: Encountered an error: \(error.localizedDescription)")
            }
        }
    }

}

extension MPVolumeView {
    static func setVolume(_ volume: Float) {
        DispatchQueue.main.async {
            let volumeView = MPVolumeView()
            let slider = volumeView.subviews.first(where: { $0 is UISlider }) as? UISlider

            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.05) {
                slider?.value = volume
            }
        }
    }
}
//
//  PersistenceManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/16/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import KeychainSwift
import StoreKit
import UIKit

enum PersistenceManager {
    /// Called by App or Scene Delegate when setting up in didFinishLaunchingWithOptions, can be either the first time setup or a recurring setup (i.e. not the app isnt being opened for the first time)
    static func loadUserDefaults() {
        // MARK: Log Launch
        
        HoundLogger.general.notice("\n-----Device Info-----\n Model: \(UIDevice.current.model) \n Name: \(UIDevice.current.name) \n System Name: \(UIDevice.current.systemName) \n System Version: \(UIDevice.current.systemVersion)")
        
        // MARK: Save App State Values
        
        if let stored = UserDefaults.standard.object(forKey: Constant.Key.localAppVersion.rawValue) as? String {
            AppVersion.previousAppVersion = AppVersion(from: stored)
        }
        else {
            AppVersion.previousAppVersion = nil
        }
        
        // If the previousAppVersion is less than the oldestCompatibleAppVersion, the user's data is no longer compatible and therefore should be redownloaded.
        if !AppVersion.isCompatible(previous: AppVersion.previousAppVersion) {
            clearDogManagerStorage()
        }
        
        UserDefaults.standard.set(AppVersion.current.rawValue, forKey: Constant.Key.localAppVersion.rawValue)
        
        UserDefaults.standard.set(true, forKey: "_UIConstraintBasedLayoutLogUnsatisfiable")
        
        // MARK: Load App Information
        
        // GlobalTypes MUST come first, as otherwise other classes (e.g. dog/logs/reminder) that reference it will crash when they get a null reference for GlobalTypes.shared!
        GlobalTypes.load(fromUserDefaults: UserDefaults.standard)
        
        UserInformation.load(fromUserDefaults: UserDefaults.standard)
        
        FamilyInformation.load(fromUserDefaults: UserDefaults.standard)
        
        UserConfiguration.load(fromUserDefaults: UserDefaults.standard)
        
        LocalConfiguration.load(fromUserDefaults: UserDefaults.standard)
        
        OfflineModeManager.load(fromUserDefaults: UserDefaults.standard)
    }
    
    /// Called by App or Scene Delegate when entering the background, used to save information, can be called when terminating for a slightly modifed case.
    static func didEnterBackground(isTerminating: Bool) {
        // MARK: Loud Notifications and Silent Audio
        
        // Check to see if the user is eligible for loud notifications
        // Don't check for enabled reminders, as client could be out of sync with server
        if UserConfiguration.isNotificationEnabled && UserConfiguration.isLoudNotificationEnabled {
            if isTerminating == true {
                // Send notification to user that their loud notifications won't work
                AlertRequest.create(errorAlert: .automaticallyAlertForNone, completionHandler: { _, _ in
                })
            }
            else {
                // app isn't terminating so add background silence
                AudioManager.stopAudio()
                AudioManager.playSilenceAudio()
            }
        }
        
        // MARK: Save App Information
        
        GlobalTypes.persist(toUserDefaults: UserDefaults.standard)
        
        UserInformation.persist(toUserDefaults: UserDefaults.standard)
        
        FamilyInformation.persist(toUserDefaults: UserDefaults.standard)
        
        UserConfiguration.persist(toUserDefaults: UserDefaults.standard)
        
        LocalConfiguration.persist(toUserDefaults: UserDefaults.standard)
        
        OfflineModeManager.persist(toUserDefaults: UserDefaults.standard)
    }
    
    static func didBecomeActive() {
        // Scene must be active for synchronizeReminderAlarmQueueIfNeeded to work
        ReminderAlarmManager.synchronizeReminderAlarmQueueIfNeeded()
        
        // If the app hasn't refreshed the dogManager for a given amount of time, then refresh the data.
        if let previousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization, previousDogManagerSynchronization.distance(to: Date()) >= 1 {
            MainTabBarController.shouldSilentlyRefreshDogManager = true
            MainTabBarController.shouldSilentlyRefreshFamily = true
        }
        else if LocalConfiguration.previousDogManagerSynchronization == nil {
            MainTabBarController.shouldSilentlyRefreshDogManager = true
            MainTabBarController.shouldSilentlyRefreshFamily = true
        }
    }
    
    static func willEnterForeground() {
        // Invocation of synchronizeNotificationAuthorization from willEnterForeground will only be accurate in conjuction with invocation of synchronizeNotificationAuthorization in viewIsAppearing of MainTabBarController. This makes it so every time Hound is opened, either from the background or from terminated, notifications are properly synced.
        // 1. Hound entering foreground from being terminated. willEnterForeground called upon initial launch of Hound although UserConfiguration (and notification settings) aren't loaded from the server, but viewIsAppearing MainTabBarController will catch as it's invoked once ServerSyncVC is done loading (and notification settings are loaded
        // 2. Hound entering foreground after entering background. viewIsAppearing MainTabBarController won't catch as MainTabBarController's view isn't appearing anymore but willEnterForeground will catch any imbalance as it's called once app is loaded to foreground
        NotificationPermissionsManager.synchronizeNotificationAuthorization()
        
        // stop any loud notifications that may have occured
        AudioManager.stopAudio()
        
        UNUserNotificationCenter.current().removeAllDeliveredNotifications()
    }
    
    /// It is important to persist this value to memory immediately. Apple keeps track of when we ask the user for a rate review and we must keep accurate track. But, if Hound crashes before we can save an updated value of localPreviousDatesUserReviewRequested, then our value and Apple's true value is mismatched.
    static func persistRateReviewRequestedDates() {
        UserDefaults.standard.set(LocalConfiguration.localPreviousDatesUserReviewRequested, forKey: Constant.Key.localPreviousDatesUserReviewRequested.rawValue)
    }
    
    /// Removes values stored in the keychain and UserDefaults for userIdentifier and userId. Additionally, invokes clearStorageToRejoinFamily().
    static func clearStorageToReloginToAccount() {
        /// We write these changes to storage immediately. If not, could cause funky issues if not persisted.
        let keychain = KeychainSwift()
        
        // Clear userIdentifier out of storage so user is forced to login page again
        UserInformation.userIdentifier = nil
        keychain.delete(Constant.Key.userIdentifier.rawValue)
        UserDefaults.standard.removeObject(forKey: Constant.Key.userIdentifier.rawValue)
        
        UserInformation.userId = nil
        keychain.delete(Constant.Key.userId.rawValue)
        UserDefaults.standard.removeObject(forKey: Constant.Key.userId.rawValue)
        
        UserInformation.userAppAccountToken = nil
        UserDefaults.standard.removeObject(forKey: Constant.Key.userAppAccountToken.rawValue)
        
        UserInformation.userNotificationToken = nil
        UserDefaults.standard.removeObject(forKey: Constant.Key.userNotificationToken.rawValue)
        
        clearStorageToRejoinFamily()
    }
    
    /// Removes values stored in the keychain and UserDefaults for localHasCompletedHoundIntroductionViewController, localHasCompletedRemindersIntroductionViewController, localHasCompletedFamilyUpgradeIntroductionViewController, previousDogManagerSynchronization, and dogManager.
    static func clearStorageToRejoinFamily() {
        // We write these changes to storage immediately. If not, could cause funky issues if not persisted.
        
        // MARK: User Information
        
        UserInformation.familyId = nil
        UserDefaults.standard.removeObject(forKey: Constant.Key.familyId.rawValue)
        
        // MARK: Local Configuration
        LocalConfiguration.localHasCompletedHoundIntroductionViewController = false
        UserDefaults.standard.set(LocalConfiguration.localHasCompletedHoundIntroductionViewController, forKey: Constant.Key.localHasCompletedHoundIntroductionViewController.rawValue)
        
        LocalConfiguration.localHasCompletedRemindersIntroductionViewController = false
        UserDefaults.standard.set(LocalConfiguration.localHasCompletedRemindersIntroductionViewController, forKey: Constant.Key.localHasCompletedRemindersIntroductionViewController.rawValue)
        
        LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController = false
        UserDefaults.standard.set(LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController, forKey: Constant.Key.localHasCompletedFamilyUpgradeIntroductionViewController.rawValue)
        
        clearDogManagerStorage()
    }
    
    static func clearDogManagerStorage() {
        LocalConfiguration.previousDogManagerSynchronization = nil
        UserDefaults.standard.removeObject(forKey: Constant.Key.previousDogManagerSynchronization.rawValue)
        DogManager.globalDogManager = nil
        UserDefaults.standard.removeObject(forKey: Constant.Key.dogManager.rawValue)
        OfflineModeManager.shared = OfflineModeManager()
        UserDefaults.standard.removeObject(forKey: Constant.Key.offlineModeManagerShared.rawValue)
    }
    
}
//
//  OfflineModeManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/8/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol OfflineModeManagerDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, dogManager: DogManager)
}

final class OfflineModeManager: NSObject, NSCoding, UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    static func persist(toUserDefaults: UserDefaults) {
        if let dataShared = try? NSKeyedArchiver.archivedData(withRootObject: shared, requiringSecureCoding: false) {
            toUserDefaults.set(dataShared, forKey: Constant.Key.offlineModeManagerShared.rawValue)
        }
    }
    
    static func load(fromUserDefaults: UserDefaults) {
        if let dataShared: Data = UserDefaults.standard.data(forKey: Constant.Key.offlineModeManagerShared.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataShared) {
            unarchiver.requiresSecureCoding = false
            if let shared = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? OfflineModeManager {
                OfflineModeManager.shared = shared
            }
        }
    }
    
    // MARK: - NSCoding

    required init?(coder aDecoder: NSCoder) {
        shouldUpdateUser = aDecoder.decodeOptionalBool(forKey: Constant.Key.offlineModeManagerShouldUpdateUser.rawValue) ?? shouldUpdateUser
        shouldGetUser = aDecoder.decodeOptionalBool(forKey: Constant.Key.offlineModeManagerShouldGetUser.rawValue) ?? shouldGetUser
        shouldGetFamily = aDecoder.decodeOptionalBool(forKey: Constant.Key.offlineModeManagerShouldGetFamily.rawValue) ?? shouldGetFamily
        shouldGetDogManager = aDecoder.decodeOptionalBool(forKey: Constant.Key.offlineModeManagerShouldGetDogManager.rawValue) ?? shouldGetDogManager
        offlineModeDeletedObjects = aDecoder.decodeOptionalObject(forKey: Constant.Key.offlineModeManagerOfflineModeDeletedObjects.rawValue) ?? offlineModeDeletedObjects
        // isWaitingForInternetConnection is false when the object is created; changed when startMonitoring is invoked
        // isSyncInProgress is false when the object is created; changed when startMonitoring is invoked
        // hasDisplayedOfflineModeBanner is false when the object is created; changed when we enter offline mode
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(shouldUpdateUser, forKey: Constant.Key.offlineModeManagerShouldUpdateUser.rawValue)
        aCoder.encode(shouldGetUser, forKey: Constant.Key.offlineModeManagerShouldGetUser.rawValue)
        aCoder.encode(shouldGetFamily, forKey: Constant.Key.offlineModeManagerShouldGetFamily.rawValue)
        aCoder.encode(shouldGetDogManager, forKey: Constant.Key.offlineModeManagerShouldGetDogManager.rawValue)
        aCoder.encode(offlineModeDeletedObjects, forKey: Constant.Key.offlineModeManagerOfflineModeDeletedObjects.rawValue)
        // isWaitingForInternetConnection is false when the object is created; changed when startMonitoring is invoked
        // isSyncInProgress is false when the object is created; changed when startMonitoring is invoked
    }
    
    // MARK: - Properties
    
    static var shared: OfflineModeManager = OfflineModeManager()
    
    // MARK: Sync-able Variables
    /// If true, a updateUser request got no response. The user's local data is updated and needs to be synced with the server. This is set to true if a update request for a user request receives no response from the Hound server
    private(set) var shouldUpdateUser: Bool = false
    /// If true, a getUser request got no response. The user's data is outdated and needs to be fetched from the server. This is set to true if a get request for a user request receives no response from the Hound server
    private var shouldGetUser: Bool = false
    /// If true, a getFamily request got no response. The user's family data is outdated and needs to be fetched from the server. This is set to true if a get request for a family request receives no response from the Hound server
    private var shouldGetFamily: Bool = false
    /// If true, the first invocation of sync from startMonitoring requires that the dogManager be synced. This is set to true if a get request for a dog manager, dog, reminder, or log request receives no response from the Hound server
    private var shouldGetDogManager: Bool = false
    /// Dogs, reminders, or logs that were deleted in offline mode and need their deletion synced with the Hound server
    private var offlineModeDeletedObjects: [OfflineModeDeletedObject] = []
    
    // MARK: Pre-Sync Variables
    private var internetConnectionObserver: NSKeyValueObservation?
    /// If true, OfflineModeManager is currently observing and waiting for the user's device to get internet so that it can start resyncing.
    private var isWaitingForInternetConnection: Bool = false {
        didSet {
            if isWaitingForInternetConnection == true && internetConnectionObserver == nil {
                // If we are going to be waiting for an internet connection and have nothing to monitor for that, start monitoring
                internetConnectionObserver = NetworkManager.shared.observe(\.isConnected, options: [.new]) { _, change in
                    // If isConnected did update and its new value is true, we are now connected to internet
                    if let newValue = change.newValue, newValue == true {
                        self.isWaitingForInternetConnection = false
                    }
                }
            }
            
            if isWaitingForInternetConnection == false && internetConnectionObserver != nil {
                // No longer waiting for an internet connection so destroy
                internetConnectionObserver?.invalidate()
                internetConnectionObserver = nil
                // isWaitingForInternetConnection can only be changed by startMonitoring and internetConnectionObserver. If it was set to false and internetConnectionObserver is not nil, then the observer just observed the user getting internet connection again.
                startMonitoring()
            }
        }
    }
    
    // MARK: Syncing Variables
    /// True if the process of either determining if a sync is needed or actual syncing is in progress. False if there is no active syncing.
    private(set) var isSyncInProgress: Bool = false {
        didSet {
            // When isSyncInProgress gets turned off, meaning the syncing has completed, then reset hasDisplayedOfflineModeBanner so that if offline mode is entered again, the banner will display again
            if oldValue == true && isSyncInProgress == false && isSyncNeeded == false {
                hasDisplayedOfflineModeBanner = false
            }
        }
    }
    /// When Hound first enters offline mode, display a banner that it has done so.
    private(set) var hasDisplayedOfflineModeBanner: Bool = false
    /// The delay that OfflineModeManger waits before attempting to sync again after receiving not response from the Hound server
    private let delayBeforeAttemptingToSyncAgain: Double = 15.0
    /// Sends updates when OfflineModeManager syncs any dog, reminder, or log objects
    weak var delegate: OfflineModeManagerDelegate!
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    // MARK: - Computed Properties
    
    /// Returns true upon finding the first dog, reminder, or log which has needsSyncedWithHoundServer set to true. Returns false if no dog, reminder, or log needs synced.
    private var isDogManagerSyncNeeded: Bool {
        for dog in DogManager.globalDogManager?.dogs ?? [] {
            if dog.offlineModeComponents.needsSyncedWithHoundServer == true {
                return true
            }
            
            for reminder in dog.dogReminders.dogReminders where reminder.offlineModeComponents.needsSyncedWithHoundServer == true {
                return true
            }
            
            for trigger in dog.dogTriggers.dogTriggers where trigger.offlineModeComponents.needsSyncedWithHoundServer == true {
                return true
            }
            
            for log in dog.dogLogs.dogLogs where log.offlineModeComponents.needsSyncedWithHoundServer == true {
                return true
            }
        }
        
        return false
    }
    
    /// Returns true if any of the following need synced: getUser, getFamily, getDogManager, deletedObjects, dogManager. Returns false if nothing needs synced.
    private var isSyncNeeded: Bool {
        if shouldUpdateUser == true {
            return true
        }
        if shouldGetUser == true {
            return true
        }
        if shouldGetFamily == true {
            return true
        }
        if shouldGetDogManager == true {
            return true
        }
        if offlineModeDeletedObjects.isEmpty == false {
            return true
        }
        if isDogManagerSyncNeeded == true {
            return true
        }
        
        return false
    }
    
    // MARK: - Functions
    
    // MARK: Sync Queue Management
    
    enum OfflineModeGetNoResponseTypes {
        case userRequestUpdate
        case userRequestGet
        case familyRequestGet
        case dogManagerGet
    }
    
    /// Invoke this function with the corresponding OfflineModeGetNoResponseTypes if a get user, family, dog manager, dog, reminder, or log request received no response from the server.
    func didGetNoResponse(type: OfflineModeGetNoResponseTypes) {
        switch type {
        case .userRequestUpdate:
            shouldUpdateUser = true
        case .userRequestGet:
            shouldGetUser = true
        case .familyRequestGet:
            shouldGetFamily = true
        case .dogManagerGet:
            shouldGetDogManager = true
        }
    }
    
    /// Invoke this function if a dog, reminder, or log was attempted to be deleted, however it failed due to no response from the Hound server
    func addDeletedObjectToQueue(object: OfflineModeDeletedObject) {
        // Ensure that the queue doesn't already have the deleted object waiting in it.
        guard offlineModeDeletedObjects.contains(where: { o in
            return o == object
        }) == false else { return }
        
        offlineModeDeletedObjects.append(object)
        
        offlineModeDeletedObjects.sort { objectOne, objectTwo in
            // If both objects are the same type, compare by deletedDate
            if type(of: objectOne) == type(of: objectTwo) {
                return objectOne.deletedDate <= objectTwo.deletedDate
            }
            
            // OfflineModeDeletedDog always comes first
            if objectOne is OfflineModeDeletedDog { return true }
            if objectTwo is OfflineModeDeletedDog { return false }
            
            // OfflineModeDeletedReminder comes next (after dogs)
            if objectOne is OfflineModeDeletedReminder { return true }
            if objectTwo is OfflineModeDeletedReminder { return false }
            
            // OfflineModeDeletedLog comes after reminders
            if objectOne is OfflineModeDeletedLog { return true }
            if objectTwo is OfflineModeDeletedLog { return false }
            
            // Remaining case: OfflineModeDeletedTrigger (all others fall here)
            return true
        }
    }
    
    // MARK: Monitoring and Syncing
    
    /// Invoke this function when there is an indication of lost connectivity to either the internet as a whole or the Hound server. OfflineModeManager will attempt to start syncing its data with the Hound server once connection is re-established.
    func startMonitoring() {
        
        // Avoid invoking the code below unless a sync is not in progress
        guard isSyncInProgress == false else {
            // Already syncing
            return
        }
        
        // Perform the isSyncNeeded check second as it is slightly resource intensive. If we can avert it by checking isSyncInProgress first, then that is good.
        guard isSyncNeeded == true else { return }
        
        if hasDisplayedOfflineModeBanner == false {
            hasDisplayedOfflineModeBanner = true
            PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.infoEnteredOfflineModeTitle, subtitle: Constant.Visual.BannerText.infoEnteredOfflineModeSubtitle, style: .info)
        }
        
        guard isWaitingForInternetConnection == false && NetworkManager.shared.isConnected == true else {
            // OfflineModeManager can't do anything until its connected to the internet. We wait until we get a signal that internet connection is restored
            isWaitingForInternetConnection = true
            return
        }
        
        // The sync begins now that a connection is established
        isSyncInProgress = true
        
        syncNextObject()
    }
    
    /// Invoke if an OfflineModeManager request to the Hound server from syncNextObject() received no response. This invoke a delay before the client will restart the syncing process.
    private func noResponseForSync() {
        // Stop all syncing and wait for a delay until we try again to sync. This should begin again from startMonitoring so it goes through the same network checks to see if the user still has connection.
        DispatchQueue.main.asyncAfter(deadline: .now() + delayBeforeAttemptingToSyncAgain) {
            self.isSyncInProgress = false
            self.startMonitoring()
        }
    }
    
    /// Helper function for sync. Attempts to sync getUser. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncGetUser() {
        UserRequest.get(
            errorAlert: .automaticallyAlertForNone,
            sourceFunction: .offlineModeManager
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            // If we got a response for this request, set this flag to false as we no longer need to perform the request. If the request failed, then we ignore it as it will most likely fail again.
            self.shouldGetUser = false
            
            // Continue to sync more upon successful completion
            self.syncNextObject()
        }
    }
    
    /// Helper function for sync. Attempts to sync updateUser. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncUpdateUser() {
        UserRequest.update(
            errorAlert: .automaticallyAlertForNone,
            sourceFunction: .offlineModeManager,
            body: UserConfiguration.createBody(addingOntoBody: [:])) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            // If we got a response for this request, set this flag to false as we no longer need to perform the request. If the request failed, then we ignore it as it will most likely fail again.
            self.shouldUpdateUser = false
            
            // Continue to sync more upon successful completion
            self.syncNextObject()
        }
    }
    
    /// Helper function for sync. Attempts to sync getFamily. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncGetFamily() {
        FamilyRequest.get(
            errorAlert: .automaticallyAlertForNone,
            sourceFunction: .offlineModeManager
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            // If we got a response for this request, set this flag to false as we no longer need to perform the request. If the request failed, then we ignore it as it will most likely fail again.
            self.shouldGetFamily = false
            
            // Continue to sync more upon successful completion
            self.syncNextObject()
        }
    }
    
    /// Helper function for sync. Attempts to sync getDogManager. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncGetDogManager() {
        guard let globalDogManager = DogManager.globalDogManager else {
            // Unable to retrieve a dogManager to use to sync from.
            shouldGetDogManager = false
            syncNextObject()
            return
        }
        
        DogsRequest.get(
            errorAlert: .automaticallyAlertForNone,
            sourceFunction: .offlineModeManager,
            dogManager: globalDogManager
        ) { dogManager, responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            // If we got a response for this request, set this flag to false as we no longer need to perform the request. If the request failed, then we ignore it as it will most likely fail again.
            self.shouldGetDogManager = false
            
            if let dogManager = dogManager {
                self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: dogManager)
            }
            
            // Continue to sync more upon successful completion
            self.syncNextObject()
        }
    }
    
    /// Helper function for sync. Attempts to sync a deleted object. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncDeletedObject() {
        // offlineModeDeletedObjects is already be sorted
        // Primary sort / grouping: dog then reminders then logs
        // Secondary sort within primary group: deletedDate
        
        guard let offlineModeDeletedObject = offlineModeDeletedObjects.first else {
            // No more offlineModeDeletedObjects to sync
            syncNextObject()
            return
        }
        
        // Attempt to cast offlineModeDeletedObject as the three possible different objects. If the cast is successful, then try to sync that object
        if let deletedDog = offlineModeDeletedObject as? OfflineModeDeletedDog {
            DogsRequest.delete(
                errorAlert: .automaticallyAlertForNone,
                sourceFunction: .offlineModeManager,
                dogUUID: deletedDog.dogUUID
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // Got a response for this request. Whether it was successful or a failure, clear this object from being sync'd
                self.offlineModeDeletedObjects.removeAll { o in
                    return o == deletedDog
                }
                
                // If the dog got added back into the dogManager, remove it again and then push the change to everything else
                if let globalDogManager = DogManager.globalDogManager, globalDogManager.removeDog(dogUUID: deletedDog.dogUUID) == true {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: globalDogManager)
                }
                
                self.syncNextObject()
            }
        }
        else if let deletedReminder = offlineModeDeletedObject as? OfflineModeDeletedReminder {
            RemindersRequest.delete(
                errorAlert: .automaticallyAlertForNone,
                sourceFunction: .offlineModeManager,
                dogUUID: deletedReminder.dogUUID,
                reminderUUIDs: [deletedReminder.reminderUUID]
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // Got a response for this request. Whether it was successful or a failure, clear this object from being sync'd
                self.offlineModeDeletedObjects.removeAll { o in
                    return o == deletedReminder
                }
                
                // If the dog got added back into the dogManager, remove it again and then push the change to everything else
                if let globalDogManager = DogManager.globalDogManager, globalDogManager.findDog(dogUUID: deletedReminder.dogUUID)?.dogReminders.removeReminder(reminderUUID: deletedReminder.reminderUUID) == true {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: globalDogManager)
                }
                
                self.syncNextObject()
            }
        }
        else if let deletedLog = offlineModeDeletedObject as? OfflineModeDeletedLog {
            LogsRequest.delete(
                errorAlert: .automaticallyAlertForNone,
                sourceFunction: .offlineModeManager,
                dogUUID: deletedLog.dogUUID,
                logUUID: deletedLog.logUUID
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // Got a response for this request. Whether it was successful or a failure, clear this object from being sync'd
                self.offlineModeDeletedObjects.removeAll { o in
                    return o == deletedLog
                }
                
                // If the dog got added back into the dogManager, remove it again and then push the change to everything else
                if let globalDogManager = DogManager.globalDogManager, globalDogManager.findDog(dogUUID: deletedLog.dogUUID)?.dogLogs.removeLog(logUUID: deletedLog.logUUID) == true {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: globalDogManager)
                }
                
                self.syncNextObject()
            }
        }
        else if let deletedTrigger = offlineModeDeletedObject as? OfflineModeDeletedTrigger {
            TriggersRequest.delete(
                errorAlert: .automaticallyAlertForNone,
                sourceFunction: .offlineModeManager,
                dogUUID: deletedTrigger.dogUUID,
                triggerUUIDs: [deletedTrigger.triggerUUID]
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // Got a response for this request. Whether it was successful or a failure, clear this object from being sync'd
                self.offlineModeDeletedObjects.removeAll { o in
                    return o == deletedTrigger
                }
                
                // If the dog got added back into the dogManager, remove it again and then push the change to everything else
                if let globalDogManager = DogManager.globalDogManager, globalDogManager.findDog(dogUUID: deletedTrigger.dogUUID)?.dogTriggers.removeTrigger(triggerUUID: deletedTrigger.triggerUUID) == true {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: globalDogManager)
                }
                
                self.syncNextObject()
            }
        }
    }
    
    /// Helper function for sync. Attempts to sync all of the unsynced dogs. Recursively invokes itself until all syncNeededDogs have been synced. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncDogs(syncNeededDogs: [Dog]) {
        // Create a copy so that we can remove elements
        var syncNeededDogs = syncNeededDogs
        
        // Get the first dog, which has the more priority, and attempt to sync it
        guard let syncNeededDog = syncNeededDogs.first else {
            // There are no more dogs that need synced
            syncNextObject()
            return
        }
        
        // syncNeededDog exists so its safe to remove the first element from syncNeededDogs
        syncNeededDogs.removeFirst()
        
        guard syncNeededDog.offlineModeComponents.needsSyncedWithHoundServer == true else {
            // Reinvoke helperSyncDogs, except with syncNeededDogs which has this current syncNeededDog removed
            helperSyncDogs(syncNeededDogs: syncNeededDogs)
            return
        }
        
        guard syncNeededDog.dogId != nil else {
            // offlineModeDog doesn't have a dogId, so it hasn't been created on the server
            DogsRequest.create(
                errorAlert: .automaticallyAlertForNone,
                sourceFunction: .offlineModeManager,
                dog: syncNeededDog
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // No need to call the delegate. Object's id is automatically assigned to the value from the server, initialAttemptedSyncDate is automatically set to nil, and we locally have all the information about this object
                
                // Reinvoke helperSyncDogs, except with syncNeededDogs which has this current syncNeededDog removed
                self.helperSyncDogs(syncNeededDogs: syncNeededDogs)
            }
            return
        }
        
        // offlineModeDog has a dogId, so its already been created on the server
        DogsRequest.update(
            errorAlert: .automaticallyAlertForNone,
            sourceFunction: .offlineModeManager,
            dog: syncNeededDog
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            
            // No need to call the delegate. initialAttemptedSyncDate is automatically set to nil and we locally have all the information about this object
            
            // Reinvoke helperSyncDogs, except with syncNeededDogs which has this current syncNeededDog removed
            self.helperSyncDogs(syncNeededDogs: syncNeededDogs)
        }
    }
    
    /// Helper function for sync. Attempts to sync all of the unsynced reminders. Recursively invokes itself until all syncNeededReminders have been synced. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncReminders(syncNeededReminders: [(UUID, Reminder)]) {
        // Create a copy so that we can remove elements
        var syncNeededReminders = syncNeededReminders
        
        // Get the first reminder, which has the more priority, and attempt to sync it
        guard let syncNeededReminder = syncNeededReminders.first else {
            // There are no more reminders that need synced
            syncNextObject()
            return
        }
        
        // syncNeededReminder exists so its safe to remove the first element from syncNeededReminders
        syncNeededReminders.removeFirst()
        
        guard syncNeededReminder.1.offlineModeComponents.needsSyncedWithHoundServer == true else {
            // Reinvoke helperSyncReminders, except with syncNeededReminders which has this current syncNeededReminder removed
            helperSyncReminders(syncNeededReminders: syncNeededReminders)
            return
        }
        
        guard syncNeededReminder.1.reminderId != nil else {
            // offlineModeReminder doesn't have a dogId, so it hasn't been created on the server
            RemindersRequest.create(
                errorAlert: .automaticallyAlertForNone,
                sourceFunction: .offlineModeManager,
                dogUUID: syncNeededReminder.0,
                reminders: [syncNeededReminder.1]
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // No need to call the delegate. Object's id is automatically assigned to the value from the server, initialAttemptedSyncDate is automatically set to nil, and we locally have all the information about this object
                
                // Reinvoke helperSyncReminders, except with syncNeededReminders which has this current syncNeededReminder removed
                self.helperSyncReminders(syncNeededReminders: syncNeededReminders)
            }
            return
        }
        
        // offlineModeReminder has a reminderId, so its already been created on the server
        RemindersRequest.update(
            errorAlert: .automaticallyAlertForNone,
            sourceFunction: .offlineModeManager,
            dogUUID: syncNeededReminder.0,
            reminders: [syncNeededReminder.1]
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            
            // No need to call the delegate. initialAttemptedSyncDate is automatically set to nil and we locally have all the information about this object
            
            // Reinvoke helperSyncReminders, except with syncNeededReminders which has this current syncNeededReminder removed
            self.helperSyncReminders(syncNeededReminders: syncNeededReminders)
        }
    }
    
    /// Helper function for sync. Attempts to sync all of the unsynced logs. Recursively invokes itself until all syncNeededLogs have been synced. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncLogs(syncNeededLogs: [(UUID, Log)]) {
        // Create a copy so that we can remove elements
        var syncNeededLogs = syncNeededLogs
        
        // Get the first log, which has the more priority, and attempt to sync it
        guard let syncNeededLog = syncNeededLogs.first else {
            // There are no more logs that need synced
            syncNextObject()
            return
        }
        
        // syncNeededLog exists so its safe to remove the first element from syncNeededLogs
        syncNeededLogs.removeFirst()
        
        guard syncNeededLog.1.offlineModeComponents.needsSyncedWithHoundServer == true else {
            // Reinvoke helperSyncLogs, except with syncNeededLogs which has this current syncNeededLog removed
            helperSyncLogs(syncNeededLogs: syncNeededLogs)
            return
        }
        
        guard syncNeededLog.1.logId != nil else {
            // offlineModeLog doesn't have a dogId, so it hasn't been created on the server
            LogsRequest.create(
                errorAlert: .automaticallyAlertForNone,
                sourceFunction: .offlineModeManager,
                dogUUID: syncNeededLog.0,
                log: syncNeededLog.1
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // No need to call the delegate. Object's id is automatically assigned to the value from the server, initialAttemptedSyncDate is automatically set to nil, and we locally have all the information about this object
                
                // Reinvoke helperSyncLogs, except with syncNeededLogs which has this current syncNeededLog removed
                self.helperSyncLogs(syncNeededLogs: syncNeededLogs)
            }
            return
        }
        
        // offlineModeLog has a logId, so its already been created on the server
        LogsRequest.update(
            errorAlert: .automaticallyAlertForNone,
            sourceFunction: .offlineModeManager,
            dogUUID: syncNeededLog.0,
            log: syncNeededLog.1
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            
            // No need to call the delegate. initialAttemptedSyncDate is automatically set to nil and we locally have all the information about this object
            
            // Reinvoke helperSyncLogs, except with syncNeededLogs which has this current syncNeededLog removed
            self.helperSyncLogs(syncNeededLogs: syncNeededLogs)
        }
    }
    
    /// Helper function for sync. Attempts to sync all of the unsynced triggers. Recursively invokes itself until all syncNeededTriggers have been synced. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncTriggers(syncNeededTriggers: [(UUID, Trigger)]) {
        // Create a copy so that we can remove elements
        var syncNeededTriggers = syncNeededTriggers
        
        // Get the first trigger, which has the more priority, and attempt to sync it
        guard let syncNeededTrigger = syncNeededTriggers.first else {
            // There are no more triggers that need synced
            syncNextObject()
            return
        }
        
        // syncNeededTrigger exists so its safe to remove the first element from syncNeededTriggers
        syncNeededTriggers.removeFirst()
        
        guard syncNeededTrigger.1.offlineModeComponents.needsSyncedWithHoundServer == true else {
            // Reinvoke helperSyncTriggers, except with syncNeededTriggers which has this current syncNeededTrigger removed
            helperSyncTriggers(syncNeededTriggers: syncNeededTriggers)
            return
        }
        
        guard syncNeededTrigger.1.triggerId != nil else {
            // offlineModeTrigger doesn't have a dogId, so it hasn't been created on the server
            TriggersRequest.create(
                errorAlert: .automaticallyAlertForNone,
                sourceFunction: .offlineModeManager,
                dogUUID: syncNeededTrigger.0,
                dogTriggers: [syncNeededTrigger.1]
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // No need to call the delegate. Object's id is automatically assigned to the value from the server, initialAttemptedSyncDate is automatically set to nil, and we locally have all the information about this object
                
                // Reinvoke helperSyncTriggers, except with syncNeededTriggers which has this current syncNeededTrigger removed
                self.helperSyncTriggers(syncNeededTriggers: syncNeededTriggers)
            }
            return
        }
        
        // offlineModeTrigger has a triggerId, so its already been created on the server
        TriggersRequest.update(
            errorAlert: .automaticallyAlertForNone,
            sourceFunction: .offlineModeManager,
            dogUUID: syncNeededTrigger.0,
            dogTriggers: [syncNeededTrigger.1]
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            
            // No need to call the delegate. initialAttemptedSyncDate is automatically set to nil and we locally have all the information about this object
            
            // Reinvoke helperSyncTriggers, except with syncNeededTriggers which has this current syncNeededTrigger removed
            self.helperSyncTriggers(syncNeededTriggers: syncNeededTriggers)
        }
    }

    /// Helper function for sync. Attempts to sync, in order of priority, unsynced dogs, reminders, and logs. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncDogsRemindersLogsTriggers() {
        guard let globalDogManager = DogManager.globalDogManager else {
            syncNextObject()
            return
        }
        
        // Find all dogs that need to be synced and order them by oldest initialAttemptedSyncDate (index 0) to newest (index end)
        let syncNeededDogs = globalDogManager.dogs.filter { dog in
            return dog.offlineModeComponents.needsSyncedWithHoundServer
        }
            .sorted { dog1, dog2 in
            // If a dog is in this array, needsSyncedWithHoundServer is true, which means that initialAttemptedSyncDate should not be nil.
            return (dog1.offlineModeComponents.initialAttemptedSyncDate ?? dog1.offlineModeComponents.initialCreationDate) <= (dog2.offlineModeComponents.initialAttemptedSyncDate ?? dog2.offlineModeComponents.initialCreationDate)
            }
        
        // If we have dogs to sync, sync them first before the reminders and logs
        guard syncNeededDogs.isEmpty == true else {
            helperSyncDogs(syncNeededDogs: syncNeededDogs)
            return
        }
        
        // Find all reminders that need to be synced and order them by oldest initialAttemptedSyncDate (index 0) to newest (index end)
        let syncNeededReminders = globalDogManager.dogs.flatMap { dog -> [(UUID, Reminder)] in
            return dog.dogReminders.dogReminders
                .filter { $0.offlineModeComponents.needsSyncedWithHoundServer }
                .map { (dog.dogUUID, $0) } // Create a tuple of dogUUID and reminder
        }
        .sorted { tuple1, tuple2 in
            let reminder1 = tuple1.1
            let reminder2 = tuple2.1
            // If a reminder is in this array, needsSyncedWithHoundServer is true, which means that initialAttemptedSyncDate should not be nil.
            return (reminder1.offlineModeComponents.initialAttemptedSyncDate ?? reminder1.offlineModeComponents.initialCreationDate) <= (reminder2.offlineModeComponents.initialAttemptedSyncDate ?? reminder2.offlineModeComponents.initialCreationDate)
        }
        
        // If we have reminders to sync, sync them first before the logs
        guard syncNeededReminders.isEmpty == true else {
            helperSyncReminders(syncNeededReminders: syncNeededReminders)
            return
        }
        
        // Find all logs that need to be synced and order them by oldest initialAttemptedSyncDate (index 0) to newest (index end)
        let syncNeededLogs = globalDogManager.dogs.flatMap { dog -> [(UUID, Log)] in
            return dog.dogLogs.dogLogs
                .filter { $0.offlineModeComponents.needsSyncedWithHoundServer }
                .map { (dog.dogUUID, $0) } // Create a tuple of dogUUID and reminder
        }
        .sorted { tuple1, tuple2 in
            let log1 = tuple1.1
            let log2 = tuple2.1
            // If a log is in this array, needsSyncedWithHoundServer is true, which means that initialAttemptedSyncDate should not be nil.
            return (log1.offlineModeComponents.initialAttemptedSyncDate ?? log1.offlineModeComponents.initialCreationDate) <= (log2.offlineModeComponents.initialAttemptedSyncDate ?? log2.offlineModeComponents.initialCreationDate)
        }
        
        // If we have logs to sync, sync them
        guard syncNeededLogs.isEmpty == true else {
            helperSyncLogs(syncNeededLogs: syncNeededLogs)
            return
        }
        
        // Find all triggers that need to be synced and order them by oldest initialAttemptedSyncDate (index 0) to newest (index end)
        let syncNeededTriggers = globalDogManager.dogs.flatMap { dog -> [(UUID, Trigger)] in
            return dog.dogTriggers.dogTriggers
                .filter { $0.offlineModeComponents.needsSyncedWithHoundServer }
                .map { (dog.dogUUID, $0) } // Create a tuple of dogUUID and trigger
        }
        .sorted { tuple1, tuple2 in
            let trigger1 = tuple1.1
            let trigger2 = tuple2.1
            // If a trigger is in this array, needsSyncedWithHoundServer is true, which means that initialAttemptedSyncDate should not be nil.
            return (trigger1.offlineModeComponents.initialAttemptedSyncDate ?? trigger1.offlineModeComponents.initialCreationDate) <= (trigger2.offlineModeComponents.initialAttemptedSyncDate ?? trigger2.offlineModeComponents.initialCreationDate)
        }

        // If we have triggers to sync, sync them first before the logs
        guard syncNeededTriggers.isEmpty == true else {
            helperSyncTriggers(syncNeededTriggers: syncNeededTriggers)
            return
        }
        
        // We have synced all the dogs, reminders, and logs
        syncNextObject()
    }
    
    /// In order of a heirarchy of priority, begins to perform requests to the Hound server to progressively re-sync the users data with the server. Waits for a single network call to finish before that request's completionHandler invokes syncNextObject()
    private func syncNextObject() {
        // shouldUpdateUser should come before shouldGetUser otherwise shouldGetUser would overwrite the local changes to UserConfiguration
        guard shouldUpdateUser == false else {
            helperSyncUpdateUser()
            return
        }
        
        guard shouldGetUser == false else {
            helperSyncGetUser()
            return
        }
        
        guard shouldGetFamily == false else {
            helperSyncGetFamily()
            return
        }
        
        guard shouldGetDogManager == false else {
            helperSyncGetDogManager()
            return
        }
        
        // Start sync-ing updates according to priority:
        //      1. deleted dogs
        //      2. deleted reminders/logs
        //      3. dogs
        //      4. reminders/logs
        
        guard offlineModeDeletedObjects.isEmpty == true else {
            helperSyncDeletedObject()
            return
        }
        
        guard isDogManagerSyncNeeded == false else {
            helperSyncDogsRemindersLogsTriggers()
            return
        }
        
        // We have finished syncing everything. Push an update to the MainTabBarVC with the update dogManager
        if let globalDogManager = DogManager.globalDogManager {
            delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), dogManager: globalDogManager)
        }
        
        isSyncInProgress = false
    }
}
//
//  TimeZoneManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/28/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class TimeZoneMonitor {
    static let shared = TimeZoneMonitor()

    private var systemObserver: NSObjectProtocol?

    private init() {
        systemObserver = NotificationCenter.default.addObserver(
            forName: .NSSystemTimeZoneDidChange,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.systemTimeZoneDidChange()
        }

        updateDeviceTimeZoneOnServer()
    }

    deinit {
        if let systemObserver {
            NotificationCenter.default.removeObserver(systemObserver)
        }
    }

    private func systemTimeZoneDidChange() {
        updateDeviceTimeZoneOnServer()
        NotificationCenter.default.post(name: .didUpdateUserTimeZone, object: nil)
    }

    func updateDeviceTimeZoneOnServer() {
        guard UserInformation.userId != nil && UserInformation.userIdentifier != nil else {
            HoundLogger.general.error("TimeZoneMonitor.updateDeviceTimeZoneOnServer: Unable to send time zone to server")
            return
        }
        let body: JSONRequestBody = [
            Constant.Key.userConfigurationDeviceTimeZone.rawValue: .string(UserConfiguration.deviceTimeZone.identifier)
        ]
        UserRequest.update(errorAlert: .automaticallyAlertForNone, body: body) { _, _ in }
    }
}
//
//  HapticsManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/22/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum HapticsManager {
    static func impact(_ style: UIImpactFeedbackGenerator.FeedbackStyle) {
        guard UserConfiguration.isHapticsEnabled else { return }
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.prepare()
        generator.impactOccurred()
    }

    static func selectionChanged() {
        guard UserConfiguration.isHapticsEnabled else { return }
        let generator = UISelectionFeedbackGenerator()
        generator.prepare()
        generator.selectionChanged()
    }

    static func notification(_ type: UINotificationFeedbackGenerator.FeedbackType) {
        guard UserConfiguration.isHapticsEnabled else { return }
        let generator = UINotificationFeedbackGenerator()
        generator.prepare()
        generator.notificationOccurred(type)
    }
}
//
//  ExportActivityViewManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 9/12/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ExportActivityViewManager {

    /// Verifys that the family has space for a new family member and is unlocked. If conditions are passed, meaning the family can have a new user join, constructs an activityViewController with the information to share (i.e. the familyCode and short description of Hound) then presents it on viewController
    static func shareFamilyCode(familyCode: String) {
        guard let globalPresenter = PresentationManager.lastFromGlobalPresenterStack else {
            Constant.Error.ExportError.shareFamilyCode().alert()
            return
        }

        // Check that the family has space for at least one new member, otherwise block them from sharing the family.
        guard FamilyInformation.familyMembers.count < FamilyInformation.familyActiveSubscription.numberOfFamilyMembers else {
            SettingsSubscriptionVC.fetchProductsThenGetViewController { vc in
                guard let vc = vc else {
                    // Error message automatically handled
                    return
                }
                
                PresentationManager.enqueueViewController(vc)
            }
            return
        }

        /*
         // Make sure that the family is unlocked so new
        guard FamilyInformation.familyIsLocked == false else {
            PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.invalidLockedFamilyShareTitle, subtitle: Constant.Visual.BannerText.invalidLockedFamilyShareSubtitle, style: .danger)
            return
        }
         */

        let shareHoundText = "Connect our family with Hound! It streamlines our pet care routine with shared logs and timely reminders to look after our dog.\n\nJoin my Hound family today by using the following code: \(familyCode)\n\nhttps://apps.apple.com/app/hound-dog-schedule-organizer/id1564604025"

        exportToActivityViewController(objectToShare: [shareHoundText], globalPresenter: globalPresenter)
    }

    static func exportLogs(dogUUIDLogTuples: [(UUID, Log)]) {
        PresentationManager.beginFetchingInformationIndicator()

        guard let globalPresenter = PresentationManager.lastFromGlobalPresenterStack else {
            PresentationManager.endFetchingInformationIndicator {
                Constant.Error.ExportError.exportLogs().alert()
            }
            return
        }

        // Attempt to get a url to the user's document directory
        guard let documentsDirectoryURL = try? FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true) else {
            PresentationManager.endFetchingInformationIndicator {
                Constant.Error.ExportError.exportLogs().alert()
            }
            return
        }

        // Specifies a short style, typically numeric only, such as “11/23/37” or “3:30 PM”.
        let dateString = Date().houndFormatted(.formatStyle(date: .numeric, time: .omitted), displayTimeZone: UserConfiguration.timeZone).replacingOccurrences(of: "/", with: "-")

        let houndExportedLogsURL: URL = documentsDirectoryURL.appendingPathComponent("Hound-Exported-Logs-\(dateString)").appendingPathExtension("csv")
        // Header for CSV file
        var logsString = "Family Member,Dog Name,Log Action,Log Start Date,Log End Date,Log Unit,Log Note\n\n"
        // to speed up runtime, save a dictionary of dogUUIDs keys and dogNames values here. Skips searching for same dog repeatedly
        var dogUUIDToDogNames: [UUID: String] = [:]
        // to speed up runtime, save a dictionary of userIds keys and full names values here. Skips searching for same family member repeatedly
        var userIdToFamilyMemberFullName: [String: String] = [:]

        // Individual rows for CSV file
        for dogUUIDLogTuple in dogUUIDLogTuples {
            let dogUUID = dogUUIDLogTuple.0
            let log = dogUUIDLogTuple.1

            var familyMemberFullName = userIdToFamilyMemberFullName[log.logCreatedBy]
            if familyMemberFullName == nil {
                // if we don't have familyMemberFullName stored in the dictionary for quick reference, store it
                familyMemberFullName = FamilyInformation.findFamilyMember(userId: log.logCreatedBy)?.displayFullName ?? Constant.Visual.Text.unknownName
                userIdToFamilyMemberFullName[log.logCreatedBy] = familyMemberFullName
            }

            var dogName = dogUUIDToDogNames[dogUUID]
            if dogName == nil {
                // if we don't have dogName stored in the dictionary for quick reference, store it
                dogName = DogManager.globalDogManager?.findDog(dogUUID: dogUUID)?.dogName ?? Constant.Visual.Text.unknownName
                dogUUIDToDogNames[dogUUID] = dogName
            }

           // neither should be nil as in the odd case we can't locate either, we just put in Constant.Visual.Text.unknownName in its place
            guard let dogName = dogName, let familyMemberFullName = familyMemberFullName else {
                continue
            }

            let logActionType = log.logActionType.convertToReadableName(customActionName: log.logCustomActionName)

            // January 25, 2023 at 7:53 AM
            let format = HoundDateFormat.template("MMMMdyyyyhma")
            let logStartDate = log.logStartDate.houndFormatted(format, displayTimeZone: UserConfiguration.timeZone)
            
            let logEndDate = {
                guard let logEndDate = log.logEndDate else {
                    return ""
                }
                
                return logEndDate.houndFormatted(format, displayTimeZone: UserConfiguration.timeZone)
            }()
            
            let logUnit = {
                guard let logUnitType = log.logUnitType, let logNumberOfLogUnits = log.logNumberOfLogUnits else {
                    return ""
                }
                
                return logUnitType.pluralReadableValueWithNumUnits(logNumberOfLogUnits: logNumberOfLogUnits) ?? ""
            }()
            
            let logNote = log.logNote

            var logString = ""
            logString.append("\(familyMemberFullName.formatIntoCSV()),")
            logString.append("\(dogName.formatIntoCSV()),")
            logString.append("\(logActionType.formatIntoCSV()),")
            logString.append("\(logStartDate.formatIntoCSV()),")
            logString.append("\(logEndDate.formatIntoCSV()),")
            logString.append("\(logUnit.formatIntoCSV()),")
            logString.append("\(logNote.formatIntoCSV())")
            logString.append("\n")

            logsString.append(logString)
        }

        guard (try? logsString.write(to: houndExportedLogsURL, atomically: true, encoding: .utf8)) != nil else {
            PresentationManager.endFetchingInformationIndicator {
                Constant.Error.ExportError.exportLogs().alert()
            }
            return
        }

        PresentationManager.endFetchingInformationIndicator {
            exportToActivityViewController(objectToShare: [houndExportedLogsURL], globalPresenter: globalPresenter)
        }
    }

    /// Creates an activityViewController used to share the objects passed. We purposefully pass through globalPresenter here, so if earlier in the flow one of the invoking functions can't resolve a globalPresenter, we are able to present a custom error message then and there
    private static func exportToActivityViewController(objectToShare: [Any], globalPresenter: UIViewController) {
        let activityViewController = UIActivityViewController(activityItems: objectToShare, applicationActivities: nil)
        // Configure so that iPads won't crash
        activityViewController.popoverPresentationController?.sourceView = globalPresenter.view

        // exclude some activity types from the list (optional)
        activityViewController.excludedActivityTypes =
        [ UIActivity.ActivityType.addToReadingList ]

        if #available(iOS 15.4, *) {
            activityViewController.excludedActivityTypes?.append(UIActivity.ActivityType.sharePlay)
        }

        PresentationManager.enqueueViewController(activityViewController)
    }
}
//
//  NotificationPermissionsManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/31/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum NotificationPermissionsManager {

    /**
     If localIsNotificationAuthorized == true && isNotificationEnabled == true, invokes registerForRemoteNotifications then the completionHandler.
     If shouldAdviseUserBeforeRequestingNotifications == false && localIsNotificationAuthorized == false, invokes registerForRemoteNotifications then the completionHandler.
     If shouldAdviseUserBeforeRequestingNotifications == false && localIsNotificationAuthorized == false, invokes performNotificationAuthorizationRequest()
     If shouldAdviseUserBeforeRequestingNotifications == true, presents alert controller that asks the user if they want to turn on notifications. If they say yes, invokes performNotificationAuthorizationRequest(), otherwise invokes registerForRemoteNotifications then the completionHandler.
     
     performNotificationAuthorizationRequest() uses Apple's requestAuthorization to show the classic "Turn On Notifications" message. If they say yes, then we are able to send the user notifications, if they say no, then we are unable to send the user notifications. Regardless of the result, we update LocalConfiguration and contact the Hound server.
     */
    static func requestNotificationAuthorization(shouldAdviseUserBeforeRequestingNotifications: Bool, completionHandler: (() -> Void)?) {
        guard LocalConfiguration.localIsNotificationAuthorized == false || UserConfiguration.isNotificationEnabled == false else {
            // If localIsNotificationAuthorized == true && isNotificationEnabled == true, there is no purpose in asking the user to request notification authorization. They are already authorized and have notifications enabled. Simply, re-register for remote notifications (repeated re-registering recommended by apple; user could be unregistered for remoteNotifications).
            registerForRemoteNotificationsIfAuthorized()
            completionHandler?()
            return
        }

        // If shouldAdviseUserBeforeRequestingNotifications == true, we present our alert controller that asks the user if they want notifications. We only have one use of Apple's notification prompt, so this prevents wasting that one by seeing if the user wants notifications.
        guard shouldAdviseUserBeforeRequestingNotifications == true else {
            // If adviseUserBeforeRequestingNotifications == false, check the localIsNotificationAuthorized status.
            if LocalConfiguration.localIsNotificationAuthorized == true {
                // If localIsNotificationAuthorized == true, then re-register for remote notifications (repeated re-registering recommended by apple; user could be unregistered for remoteNotifications). Don't change user's notification settings as they could have already configured them since localIsNotificationAuthorized == true.
                registerForRemoteNotificationsIfAuthorized()
                completionHandler?()
            }
            else {
                // If localIsNotificationAuthorized == false, then notification haven't been approved. Therefore, we can request notifications and override any non-user-configured notification settings
                performNotificationAuthorizationRequest()
            }
            return
        }

        let askUserAlertController = UIAlertController(title: "Do you want to turn on notifications?", message: "Don't miss out on important events like your dog needing a helping hand or a family member adding a log", preferredStyle: .alert)

        let turnOnNotificationsAlertAction = UIAlertAction(title: "Turn On Notifications", style: .default) { _ in
            performNotificationAuthorizationRequest()
        }

        let notNowAlertAction = UIAlertAction(title: "Not Now", style: .cancel) { _ in
            registerForRemoteNotificationsIfAuthorized()
            completionHandler?()
        }

        askUserAlertController.addAction(turnOnNotificationsAlertAction)
        askUserAlertController.addAction(notNowAlertAction)

        PresentationManager.enqueueAlert(askUserAlertController)

        func performNotificationAuthorizationRequest() {
            let beforeUpdateIsNotificationEnabled = UserConfiguration.isNotificationEnabled
            let beforeUpdateIsLoudNotificationEnabled = UserConfiguration.isLoudNotificationEnabled
            
            UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge, .carPlay]) { isGranted, _ in
                LocalConfiguration.localIsNotificationAuthorized = isGranted
                registerForRemoteNotificationsIfAuthorized()

                UserConfiguration.isNotificationEnabled = isGranted
                UserConfiguration.isLoudNotificationEnabled = isGranted

                // Contact the server about the updated values and, if there is no response or a bad response, revert the values to their previous values. localIsNotificationAuthorized purposefully excluded as server doesn't need to know that and its value is untrust worthy (user can modify the value without us knowing, unlike our custom variables).
                let body: JSONRequestBody = [
                    Constant.Key.userConfigurationIsNotificationEnabled.rawValue: .bool(UserConfiguration.isNotificationEnabled),
                    Constant.Key.userConfigurationIsLoudNotificationEnabled.rawValue: .bool(UserConfiguration.isLoudNotificationEnabled)
                ]

                UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        // Revert local values to previous state due to an error
                        UserConfiguration.isNotificationEnabled = beforeUpdateIsNotificationEnabled
                        UserConfiguration.isLoudNotificationEnabled = beforeUpdateIsLoudNotificationEnabled
                        return
                    }
                    
                    DispatchQueue.main.async {
                        completionHandler?()
                    }
                }
            }
        }

    }

    private static func registerForRemoteNotificationsIfAuthorized() {
        guard LocalConfiguration.localIsNotificationAuthorized == true else { return }

        DispatchQueue.main.async {
            UIApplication.shared.registerForRemoteNotifications()
        }
    }

    /// Checks to see that the status of localIsNotificationAuthorized matches the status of other notification settings. If there is an imbalance in notification settings or a change has occured, then updates the local settings and server settings to fix the issue
    static func synchronizeNotificationAuthorization() {
        let beforeUpdateIsNotificationEnabled = UserConfiguration.isNotificationEnabled
        let beforeUpdateIsLoudNotificationEnabled = UserConfiguration.isLoudNotificationEnabled

        UNUserNotificationCenter.current().getNotificationSettings { permission in
            switch permission.authorizationStatus {
            case .authorized:
                authorizeNotifications()
            case .denied:
                denyNotifications()
            case .notDetermined:
                denyNotifications()
            case .provisional:
                authorizeNotifications()
            case .ephemeral:
                authorizeNotifications()
            @unknown default:
                denyNotifications()
            }
        }

        /// Enables localIsNotificationAuthorized and checks to make sure that the user is registered for remote notifications
        func authorizeNotifications() {
            // Notifications are authorized
            LocalConfiguration.localIsNotificationAuthorized = true
            // Never cache device tokens in your app; instead, get them from the system when you need them. APNs issues a new device token to your app when certain events happen.
            registerForRemoteNotificationsIfAuthorized()
        }

        /// Disables localIsNotificationAuthorized and checks to make sure that the other notification settings align (making sure there is no imbalance, e.g. isNotificationEnabled == true but localIsNotificationAuthorized == false)
        func denyNotifications() {
            LocalConfiguration.localIsNotificationAuthorized = false

            // The user isn't authorized for notifications, therefore all of those settings should be false. If any of those settings aren't false, representing an imbalance, then we should fix this imbalance and update the Hound server
            guard UserConfiguration.isNotificationEnabled == true || UserConfiguration.isLoudNotificationEnabled == true else {
                return
            }

            UserConfiguration.isNotificationEnabled = false
            UserConfiguration.isLoudNotificationEnabled = false
            DispatchQueue.main.async {
                // The isNotificationAuthorized, isNotificationEnabled, and isLoudNotificationEnabled have been potentially updated. Additionally, SettingsNotifsVC could be be the last view opened. Therefore, we need to inform SettingsNotifsVC of these changes so that it can update its switches.
                SettingsNotifsVC.didSynchronizeNotificationAuthorization()
            }
            var body: JSONRequestBody = [:]
            // check for if values were changed, if there were then tell the server
            if UserConfiguration.isNotificationEnabled != beforeUpdateIsNotificationEnabled {
                body[Constant.Key.userConfigurationIsNotificationEnabled.rawValue] = .bool(UserConfiguration.isNotificationEnabled)
            }
            if UserConfiguration.isLoudNotificationEnabled != beforeUpdateIsLoudNotificationEnabled {
                body[Constant.Key.userConfigurationIsLoudNotificationEnabled.rawValue] = .bool(UserConfiguration.isLoudNotificationEnabled)
            }

            guard body.keys.isEmpty == false else {
                return
            }
            UserRequest.update(errorAlert: .automaticallyAlertOnlyForFailure, body: body) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    // Revert local values to previous state due to an error
                    UserConfiguration.isNotificationEnabled = beforeUpdateIsNotificationEnabled
                    UserConfiguration.isLoudNotificationEnabled = beforeUpdateIsLoudNotificationEnabled

                    // The isNotificationAuthorized, isNotificationEnabled, and isLoudNotificationEnabled have been potentially updated. Additionally, SettingsNotifsVC could be be the last view opened. Therefore, we need to inform SettingsNotifsVC of these changes so that it can update its switches.
                    SettingsNotifsVC.didSynchronizeNotificationAuthorization()
                    return
                }
            }
        }
    }

}
//
//  Timing.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/20/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol ReminderTimingManagerDelegate: AnyObject {
    func didAddReminder(sender: Sender, dogUUID: UUID, reminder: Reminder)
    func didRemoveReminder(sender: Sender, dogUUID: UUID, reminderUUID: UUID)
}

final class ReminderTimingManager {
    
    enum ReminderTimerTypes {
        /// Represents a Timer that is used for managing a reminder's alarms (which trigger an alert / alarm for when the reminder is scheduled)
        case alarmTimer
        /// Represents a Timer that is used to change a reminder from isSkipping true to false. This triggers when the current date passes the original reminderExecutionDate that was skipped, indicating the reminder should go back into regular, non-skipping mode.
        case disableIsSkippingTimer
    }
    
    class ReminderTimer {
        var timer: Timer
        var type: ReminderTimerTypes
        var dogName: String
        var dogUUID: UUID
        var reminder: Reminder
        
        init(timer: Timer, type: ReminderTimerTypes, dogName: String, dogUUID: UUID, reminder: Reminder) {
            self.timer = timer
            self.type = type
            self.dogName = dogName
            self.dogUUID = dogUUID
            self.reminder = reminder
        }
    }

    // MARK: - Properties

    static weak var delegate: ReminderTimingManagerDelegate!
    
    private static var reminderTimers: [ReminderTimer] = []

    // MARK: - Main

    /// Initializes all reminder timers
    static func initializeReminderTimers(dogManager: DogManager) {
        removeTimersForDeletedReminders(dogManager: dogManager)
        
        for dog in dogManager.dogs {
            for reminder in dog.dogReminders.dogReminders {
                // if the reminder has a execution date, then create its timers
                guard reminder.reminderIsEnabled == true, let reminderExecutionDate = reminder.reminderExecutionDate else {
                    // The reminder is disabled and can't have any timers
                    removeTimer(reminderUUID: reminder.reminderUUID, type: .alarmTimer)
                    removeTimer(reminderUUID: reminder.reminderUUID, type: .disableIsSkippingTimer)
                    continue
                }
                
                // If the reminder doesn't have a reminderAlarmTimer or the reminderAlarmTimer hasn't fired yet, assign the reminder a new reminderAlarmTimer.
                // If reminderAlarmTimer isn't nil and it has already fired, don't overwrite it. It probably is waiting for a user to response to the HoundAlarmAlertController.
                let reminderAlarmTimer = findTimer(reminderUUID: reminder.reminderUUID, type: .alarmTimer)
                if reminderAlarmTimer == nil || reminderAlarmTimer?.timer.fireDate ?? Date(timeIntervalSince1970: 0.0) > Date() {
                    // Remove the existing timer now that we want to replace it
                    removeTimer(reminderUUID: reminder.reminderUUID, type: .alarmTimer)
                    
                    let reminderAlarmTimer = Timer(
                                      fireAt: reminderExecutionDate,
                                      interval: -1,
                                      target: self,
                                      selector: #selector(self.didExecuteReminderAlarmTimer(sender:)),
                                      userInfo: nil,
                                      repeats: false)
                    reminderTimers.append(
                        ReminderTimer(timer: reminderAlarmTimer,
                                      type: .alarmTimer,
                                      dogName: dog.dogName,
                                      dogUUID: dog.dogUUID,
                                      reminder: reminder)
                    )
                    RunLoop.main.add(reminderAlarmTimer, forMode: .common)
                }

                // Sets a timer that executes when the timer should go from isSkipping true -> false.
                // If the reminder doesn't have a reminderDisableIsSkippingTimer or the reminderDisableIsSkippingTimer hasn't fired yet, assign the reminder a new reminderDisableIsSkippingTimer.
                // If reminderDisableIsSkippingTimer isn't nil and it has already fired, don't overwrite it.
                let reminderDisableIsSkippingTimer = findTimer(reminderUUID: reminder.reminderUUID, type: .disableIsSkippingTimer)
                if reminderDisableIsSkippingTimer == nil
                    || reminderDisableIsSkippingTimer?.timer.fireDate ?? Date(timeIntervalSince1970: 0.0) > Date(), let disableIsSkippingDate = reminder.disableIsSkippingDate {
                    // Remove the existing timer now that we want to replace it
                    removeTimer(reminderUUID: reminder.reminderUUID, type: .disableIsSkippingTimer)
                    
                    let reminderDisableIsSkippingTimer = Timer(fireAt: disableIsSkippingDate,
                                                   interval: -1,
                                                   target: self,
                                                   selector: #selector(didExecuteReminderDisableIsSkippingTimer(sender:)),
                                                   userInfo: nil,
                                                   repeats: false)
                    reminderTimers.append(
                        ReminderTimer(timer: reminderDisableIsSkippingTimer,
                                      type: .disableIsSkippingTimer,
                                      dogName: dog.dogName,
                                      dogUUID: dog.dogUUID,
                                      reminder: reminder)
                    )
                    RunLoop.main.add(reminderDisableIsSkippingTimer, forMode: .common)
                }
            }
        }
    }
    
    // MARK: - Functions
    
    /// For a given reminderUUID, find the first occurance in reminderAlarmTimers of a ReminderTimer with the same reminderUUID.
    private static func findTimer(reminderUUID: UUID, type: ReminderTimerTypes) -> ReminderTimer? {
        return reminderTimers.first { reminderTimer in
            guard reminderTimer.type == type else {
                return false
            }
            
            return reminderTimer.reminder.reminderUUID == reminderUUID
        }
    }
    
    /// Removes all reminderTimers with the same reminderUUID from reminderAlarmTimers, invalidating their timers in the process
    private static func removeTimer(reminderUUID: UUID, type: ReminderTimerTypes) {
        reminderTimers.removeAll { rt in
            guard rt.type == type else {
                return false
            }
            
            guard rt.reminder.reminderUUID == reminderUUID else {
                return false
            }
            
            rt.timer.invalidate()
            return true
        }
    }
    
    private static func removeTimersForDeletedReminders(dogManager: DogManager) {
        reminderTimers.forEach { reminderTimer in
            let dogUUID = reminderTimer.dogUUID
            let reminderUUID = reminderTimer.reminder.reminderUUID
            
            // If the dog or reminder no longer exists, then we have a timer for nothing. Therefore, we should remove it
            if dogManager.findDog(dogUUID: dogUUID)?.dogReminders.findReminder(reminderUUID: reminderUUID) == nil {
                removeTimer(reminderUUID: reminderUUID, type: .alarmTimer)
                removeTimer(reminderUUID: reminderUUID, type: .disableIsSkippingTimer)
            }
        }
    }
    
    /// When a reminderAlarmTimer executes, it invokes ReminderAlarmManager.willCreateAndShowReminderAlarm. This timer stays in the array of timers until the user responds to the alert, otherwise ReminderTimingManager would create more timers which would create more alerts for the user to click through. Therefore, we only remove the timer once the user has responded to the alert.
    static func didCompleteForReminderTimer(reminderUUID: UUID, type: ReminderTimerTypes) {
        removeTimer(reminderUUID: reminderUUID, type: type)
    }

    // MARK: - Timer Actions

    /// Used as a selector when constructing timer in initializeReminderTimers. Invoke ReminderAlarmManager to show alart controller for reminder alarm
    @objc private static func didExecuteReminderAlarmTimer(sender: Timer) {
        guard let reminderTimer = reminderTimers.first(where: { reminderTimer in
            return reminderTimer.timer == sender
        }) else { return }
        
        ReminderAlarmManager.willCreateAndShowReminderAlarm(dogName: reminderTimer.dogName, dogUUID: reminderTimer.dogUUID, reminder: reminderTimer.reminder)
    }

    /// Used as a selector when constructing timer in initializeReminderTimers. It triggers when the current date passes the original reminderExecutionDate that was skipped, indicating the reminder should go back into regular, non-skipping mode. If assigning new timer, invalidates the current timer then assigns reminderDisableIsSkippingTimer to new timer.
    @objc private static func didExecuteReminderDisableIsSkippingTimer(sender: Timer) {
        guard let reminderTimer = reminderTimers.first(where: { reminderTimer in
            return reminderTimer.timer == sender
        }) else { return }
        
        RemindersRequest.get(errorAlert: .automaticallyAlertForNone, dogUUID: reminderTimer.dogUUID, reminder: reminderTimer.reminder) { reminder, responseStatusReminderGet, _ in
            guard responseStatusReminderGet != .failureResponse else {
                return
            }
            
            guard let reminder = reminder else {
                // If the response was successful but no reminder was returned, that means the reminder was deleted. Therefore, update the dogManager to indicate as such.
                self.delegate.didRemoveReminder(sender: Sender(origin: self, localized: self), dogUUID: reminderTimer.dogUUID, reminderUUID: reminderTimer.reminder.reminderUUID)
                return
            }

            reminder.resetForNextAlarm()
            didCompleteForReminderTimer(reminderUUID: reminder.reminderUUID, type: .disableIsSkippingTimer)

            RemindersRequest.update(errorAlert: .automaticallyAlertForNone, dogUUID: reminderTimer.dogUUID, reminders: [reminder]) { responseStatusReminderUpdate, _ in
                guard responseStatusReminderUpdate != .failureResponse else {
                    return
                }

                delegate.didAddReminder(sender: Sender(origin: self, localized: self), dogUUID: reminderTimer.dogUUID, reminder: reminder)
            }
        }
    }
}
//
//  PresentationManager.swift
//  viewControllerPresentationQueue-Example
//
//  Created by William Boles on 26/05/2019.
//  Copyright © 2019 William Boles. All rights reserved.
//
//  Modified by Jonathan Xakellis on 2/5/21.
//

import NotificationBannerSwift
import SnapKit
import SwiftMessages
import UIKit

enum PresentationManager {
    
    // MARK: - Properties
    
    /// A stack of UIViewControllers that represent the globalPresenter. If a UIViewController becomes eligible to present something, it pushes itself onto the stack. If it becomes ineligible, it removes itself from the stack.
    private static var globalPresenterStack: [UIViewController] = []
    static var lastFromGlobalPresenterStack: UIViewController? {
        return globalPresenterStack.last
    }
    
    /// The UIViewController that is presented by PresentationManager
    private static var currentPresentedViewController: UIViewController? {
        didSet {
            HoundLogger.general.notice("currentPresentedViewController: \(self.currentPresentedViewController?.self.description ?? "none") and its presented on \(lastFromGlobalPresenterStack?.description ?? "none")")
            HoundLogger.general.notice("globalPresenterStack: \(globalPresenterStack)")
        }
    }
    
    /// UIAlertController that indicates to the user that the app is currently retrieving information.
    private static let fetchingInformationAlertController: UIAlertController = {
        let fetchingInformationAlertController = UIAlertController(title: "Fetching Information...", message: nil, preferredStyle: .alert)
        fetchingInformationAlertController.view.translatesAutoresizingMaskIntoConstraints = false
        
        let fetchingActivityIndicator = UIActivityIndicatorView(style: .medium)
        fetchingActivityIndicator.translatesAutoresizingMaskIntoConstraints = false
        fetchingActivityIndicator.startAnimating()
        
        fetchingInformationAlertController.view.addSubview(fetchingActivityIndicator)
        
        NSLayoutConstraint.activate([
            fetchingInformationAlertController.view.heightAnchor.constraint(equalToConstant: 90),
            fetchingActivityIndicator.bottomAnchor.constraint(equalTo: fetchingInformationAlertController.view.bottomAnchor, constant: -20),
            fetchingActivityIndicator.centerXAnchor.constraint(equalTo: fetchingInformationAlertController.view.centerXAnchor)
        ])
        
        return fetchingInformationAlertController
    }()
    
    // MARK: Public Global Presenter Management
    
    /// The presenter used for an alert. Sometimes we need to present an alert but the alert to be shown is called from a non UIAlertController class as that is not in the view heirarchy and physically cannot present a view, so this is used instead.
    static func addGlobalPresenterToStack(_ viewController: UIViewController) {
        globalPresenterStack.removeAll { vc in
            // Remove stale presenters that are no longer in the window or
            // duplicate references to the same instance.
            let isDuplicate = vc === viewController
            let isStale = vc.viewIfLoaded?.window == nil
            return isDuplicate || isStale
        }
        
        globalPresenterStack.append(viewController)
        
        if let currentPresentedViewController = currentPresentedViewController, globalPresenterStack.contains(currentPresentedViewController) {
            // This fixes a logical anomoily. If a view controller is presented using PresentationManager, it will become the currentPresentedViewController. This is how we normally treated presented views. However, if this currentPresentedViewController is in the globalPresenterStack, it means it is able to present views itself and is eligible. Therefore, we should unlock the presentation stack by removing it as a currentPresentedViewController and continuing to the next item in the stack.
            self.currentPresentedViewController = nil
            presentNextViewController()
        }
    }
    
    static func removeGlobalPresenterFromStack(_ viewController: UIViewController) {
        globalPresenterStack.removeAll { vc in
            // Remove all matching instances of our global presenter
            return vc === viewController
        }
    }
    
    // MARK: - Static Public Enqueue
    
    /// Invokes enqueueAlert(fetchingInformationAlertController). This indicates to the user that the app is currently retrieving information. fetchingInformationAlertController stays until endFetchingInformationIndicator is called
    static func beginFetchingInformationIndicator() {
        enqueueAlert(fetchingInformationAlertController)
    }
    
    /// Dismisses fetchingInformationAlertController.
    static func endFetchingInformationIndicator(completionHandler: (() -> Void)?) {
        guard fetchingInformationAlertController.isBeingDismissed == false else {
            // We can't dismiss a fetchingInformationAlertController that is already being dismissed. Retry soon, so that completionHandler is invoked when fetchingInformationAlertController is fully dismissed
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                endFetchingInformationIndicator(completionHandler: completionHandler)
            }
            return
        }
        
        guard fetchingInformationAlertController.isBeingPresented == false else {
            // We can't dismiss a fetchingInformationAlertController that is already being presented currently. Retry soon, so that we can dismiss the view onces its presented
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                endFetchingInformationIndicator(completionHandler: completionHandler)
            }
            return
        }
        
        guard fetchingInformationAlertController.presentingViewController != nil else {
            // fetchingInformationAlertController isn't being dismissed and it has no presentingViewController, so it is not presented at all.
            viewControllerPresentationQueue.removeAll { vc in
                // fetchingInformationAlertController hasn't been presented but it could be in the queue to be presented. Remove it so it can't be presented
                return vc === fetchingInformationAlertController
            }
            completionHandler?()
            return
        }
        
        fetchingInformationAlertController.dismiss(animated: true) {
            completionHandler?()
        }
    }
    
    static func enqueueViewController(_ viewController: UIViewController) {
        enqueue(viewController)
    }
    
    static func enqueueBanner(title: String, subtitle: String?, style: BannerStyle, onTap: (() -> Void)? = nil) {
        let trimmedTitle = title.trimmingCharacters(in: .whitespacesAndNewlines)
        let trimmedSubtitle = subtitle?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        
        let duplicateExists = NotificationBannerQueue.default.banners.contains { (banner: BaseNotificationBanner) in
            let bannerTitle = banner.titleLabel?.text?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
            if let floatingBanner = banner as? FloatingNotificationBanner {
                let bannerSubtitle = floatingBanner.subtitleLabel?.text?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
                return bannerTitle == trimmedTitle && bannerSubtitle == trimmedSubtitle
            }
            return bannerTitle == trimmedTitle
        }
        guard duplicateExists == false else { return }
        
        // Reduce the availble styles into a smaller 3 tier group
        // Success
        // Info
        // Danger
        let style: BannerStyle = {
            switch style {
            case .success:
                return .success
            case .info:
                return .info
            case .warning:
                return .warning
            case .danger:
                return .danger
            default:
                return .success
            }
        }()
        
        // Create a left view image that corresponds to the style selected
        let leftViewImage: HoundImageView? = {
            var image: UIImage?
            switch style {
            case .success:
                image = UIImage.init(systemName: "checkmark.circle")
            case .info:
                image = UIImage.init(systemName: "info.circle")
            case .warning:
                image = UIImage.init(systemName: "exclamationmark.triangle")
            case .danger:
                image = UIImage.init(systemName: "exclamationmark.triangle")
            default:
                image = UIImage.init(systemName: "exclamationmark.triangle")
            }
            
            return image == nil ? nil : HoundImageView(image: image)
        }()
        
        leftViewImage?.tintColor = UIColor.white
        
        let banner = FloatingNotificationBanner(title: title, subtitle: subtitle, leftView: leftViewImage, style: style)
        banner.contentMode = .scaleAspectFit
        banner.onTap = onTap
        
        // Select a banner duration that corresponds to the style. A more important style requires a longer duration
        banner.duration = {
            // This is the duration for a title-only banner
            let successDuration = 1.25
            var bannerDuration = successDuration
            switch style {
            case .success:
                bannerDuration = successDuration
            case .info:
                bannerDuration = 4.5
            case .warning:
                bannerDuration = 3.0
            case .danger:
                bannerDuration = 2.25
            default:
                bannerDuration = successDuration
            }
            
            // If a non-nil and non-blank subtitle was provided, give the user extra reading time
            if let subtitle = subtitle, subtitle.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false {
                // The average person reads at 300 WPM, that is 5 words per second
                // The average word in one of these subtitle messages is 6 characters (excluding white spaces)
                // That the average person can read 30 non-whitespace characters a second, or 1 character per 0.033 seconds
                let subtitleCharacters = subtitle.filter { character in
                    character.isWhitespace == false
                }
                let extraSubtitleReadingTime = Double(subtitleCharacters.count) * 0.032
                
                bannerDuration += extraSubtitleReadingTime
            }
            return bannerDuration
        }()
        
        // Select a banner color that corresponds to the style
        banner.backgroundColor = {
            switch style {
            case .success:
                return UIColor.systemGreen
            case .info:
                return UIColor.systemBlue
            case .warning:
                return UIColor.houndYellow
            case .danger:
                return UIColor.systemRed
            default:
                return UIColor.systemGreen
            }
        }()
        
        guard let globalPresenter = PresentationManager.globalPresenterStack.last else {
            HoundLogger.general.error("PresentationManager.enqueueBanner: Unable to present banner, globalPresenterStack is empty")
            return
        }
        
        let topEdgeInset: CGFloat = {
            let safeAreaTop = UIApplication.keyWindow?.safeAreaInsets.top ?? 0.0
            
            // Dynamic Island if top inset is around 54pt (iPhone 14 Pro/15 Pro, etc.)
            let hasDynamicIsland = safeAreaTop > 50.0
            // Notch if top inset is 44pt or more (iPhone X and up)
            let hasNotch = safeAreaTop >= 44.0
            
            let isPortrait: Bool = {
                if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
                    return windowScene.interfaceOrientation.isPortrait
                }
                return true
            }()
            let navBarHidden = globalPresenter.navigationController?.isNavigationBarHidden ?? true
            
            if hasDynamicIsland && isPortrait && navBarHidden {
                return 44.0
            }
            else if hasNotch && isPortrait && navBarHidden {
                return 40.0
            }
            else {
                if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                   let height = windowScene.statusBarManager?.statusBarFrame.height {
                    return height
                }
                return 20.0 // Default fallback
            }
        }()
        
        banner.haptic = !UserConfiguration.isHapticsEnabled
        ? .none
        : {
            switch style {
            case .success:
                return .light
            case .info:
                return .medium
            case .warning:
                return .medium
            case .danger:
                return .heavy
            default:
                return .light
            }
        }()
        
        banner.show(
            // using default queuePosition: ,
            // using default bannerPosition: ,
            // using default queue: ,
            on: globalPresenter,
            // safeAreaInsets of globalPresenter could be flawed, e.g. if the globalPresenter is a pageSheet, then the safeAreaInsets will be zero. Try to find the safeAreaInsets of the entire window if possible, if not fall back to nearestNonPageSheetGlobalPresenter or eventually just accept the globalPresenter
            // If the globalPresenter's top safeAreaInset is not zero, that mean we have to adjust the banner for the safe area for the notch on the top of the screen. This means we need to artifically adjust the banner further down.
            edgeInsets: UIEdgeInsets(top: topEdgeInset, left: 10.0, bottom: 10.0, right: 10.0),
            cornerRadius: Constant.Visual.Layer.defaultCornerRadius,
            shadowColor: UIColor.label,
            shadowOpacity: 0.5,
            shadowBlurRadius: 15.0,
            // little/no effect shadowCornerRadius: 10.0,
            // using default shadowOffset: ,
            shadowEdgeInsets: .zero
        )
    }
    
    static func enqueueAlert(_ alertController: UIAlertController) {
        // We are unable to change .preferredStyle and if its not .alert (and we queue the alert) then we could crash
        guard alertController.preferredStyle == .alert else { return }
        
        enqueue(alertController)
    }
    
    static func enqueueActionSheet(_ alertController: UIAlertController, sourceView: UIView) {
        // We are unable to change .preferredStyle and if its not .actionSheet (and we queue the alert) then we could crash
        guard alertController.preferredStyle == .actionSheet else { return }
        
        // This is needed for iPad, otherwise it will crash
        if UIDevice.current.userInterfaceIdiom == .pad {
            alertController.popoverPresentationController?.sourceView = sourceView
            alertController.popoverPresentationController?.sourceRect = sourceView.bounds
            alertController.popoverPresentationController?.permittedArrowDirections = [.up, .down]
        }
        
        enqueue(alertController)
    }
    
    // MARK: - Private Internal Queue
    
    private static var viewControllerPresentationQueue: [UIViewController] = []
    
    private static func enqueue(_ viewController: UIViewController) {
        // Make sure that the alertController that is being queued isn't already presented or in the queue
        guard currentPresentedViewController !== viewController && viewControllerPresentationQueue.contains(where: { vc in
            return vc === viewController
        }) == false else {
            // Don't call presentNextViewController() as queue didn't change
            return
        }
        
        guard let alarmAlertController = viewController as? HoundAlarmAlertController else {
            // Not dealing with an alarmAlertController, can append alertController to queue
            viewControllerPresentationQueue.append(viewController)
            presentNextViewController()
            return
        }
        
        // User attempted to pass an HoundAlarmAlertController that hasn't been setup and is therefore invalid
        guard alarmAlertController.dogUUID != nil && alarmAlertController.reminders != nil else {
            // Don't call presentNextViewController() as queue didn't change
            return
        }
        
        // If we are dealing with an HoundAlarmAlertController, then attempt to absorb it into the currentPresentedViewController.
        if let presentedAlarmAlertController = (currentPresentedViewController as? HoundAlarmAlertController), presentedAlarmAlertController.absorb(alarmAlertController) {
            // currentPresentedViewController is an HoundAlarmAlertController and we were able to absorb alarmAlertController into it. Therefore, discard alarmAlertController.
            // Don't call presentNextViewController() as queue didn't change
            return
        }
        
        // alarmAlertController couldn't be absorbed into currentPresentedViewController, therefore try absorbing it into other items in queue.
        for viewControllerInQueue in viewControllerPresentationQueue {
            guard let alarmAlertControllerInQueue = viewControllerInQueue as? HoundAlarmAlertController else {
                // viewControllerInQueue isn't an HoundAlarmAlertController and cannot absorb anything. or it is but wasn't able to be combined with alarmAlertController
                continue
            }
            
            guard alarmAlertControllerInQueue.absorb(alarmAlertController) else {
                // alarmAlertControllerInQueue wasn't able to absorb alarmAlertController
                continue
            }
            
            // alarmAlertControllerInQueue was able to successfully absorb alarmAlertController. Discard alarmAlertController
            // Don't call presentNextViewController() as queue didn't change
            return
        }
        
        // Couldn't absorb alarmAlertController with any pre-existing ViewController, therefore append it to queue
        viewControllerPresentationQueue.append(alarmAlertController)
        presentNextViewController()
    }
    
    private static func presentNextViewController() {
        // Check that PresentationManager itself is eligible to present another alert. This means the queue has another controller to present and there isn't a ViewController currently presented
        guard let nextPresentedViewController = viewControllerPresentationQueue.first, self.currentPresentedViewController == nil else { return }
        
        // Check that the globalPresenter can present sometime currently. If not, enter a loop until it can. These temporary conditions normally resolve themselves.
        guard let globalPresenter = PresentationManager.globalPresenterStack.last,
              globalPresenter.isBeingPresented == false,
              globalPresenter.isBeingDismissed == false,
              globalPresenter.presentedViewController == nil,
              globalPresenter.viewIfLoaded?.window != nil else {
            
            HoundLogger.general.debug("PresentationManager.presentNextViewController: Unable to presentNextViewController, trying again soon")
            HoundLogger.general.debug("\t\tglobalPresenter \(PresentationManager.globalPresenterStack.last.debugDescription)")
            HoundLogger.general.debug("\t\tglobalPresenter.isBeingPresented \(PresentationManager.globalPresenterStack.last?.isBeingPresented == true)")
            HoundLogger.general.debug("\t\tglobalPresenter.isBeingDismissed \(PresentationManager.globalPresenterStack.last?.isBeingDismissed == true)")
            HoundLogger.general.debug("\t\tglobalPresenter.presentedViewController \(PresentationManager.globalPresenterStack.last?.presentedViewController.debugDescription ?? "")")
            HoundLogger.general.debug("\t\tglobalPresenter.viewIfLoaded.window \(PresentationManager.globalPresenterStack.last?.viewIfLoaded?.window.debugDescription ?? "")\n")
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                self.presentNextViewController()
            }
            return
        }
        
        viewControllerPresentationQueue.removeFirst()
        self.currentPresentedViewController = nextPresentedViewController
        
        globalPresenter.present(nextPresentedViewController, animated: true)
        
        self.observeCurrentPresentedViewControllerIsBeingDismissed(previousIsBeingDismissed: nextPresentedViewController.isBeingDismissed)
    }
    
    /// currentPresentedViewController.isBeingDismissed is not KVO compliant. Therefore, we must perform a loop that continuously checks the property. Once the previousIsBeingDismissed is true and the current is false, we know the view has completed
    private static func observeCurrentPresentedViewControllerIsBeingDismissed(previousIsBeingDismissed: Bool) {
        guard let currentPresentedViewController = currentPresentedViewController else { return }
        
        let currentIsBeingDismissed = currentPresentedViewController.isBeingDismissed
        
        guard currentPresentedViewController.isBeingPresented == false else {
            // If currentPresentedViewController is still in the process of being presented, we cannot analyze it to see if its being dismissed,
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                self.observeCurrentPresentedViewControllerIsBeingDismissed(previousIsBeingDismissed: currentIsBeingDismissed)
            }
            return
        }
        
        guard previousIsBeingDismissed == true && currentIsBeingDismissed == false else {
            // The currentPresentedViewController has not been dismissed. Keep rechecking until it has been.
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                self.observeCurrentPresentedViewControllerIsBeingDismissed(previousIsBeingDismissed: currentIsBeingDismissed)
            }
            return
        }
        
        // If currentPresentedViewController was being dismissed and now its not (indicating it was dismissed), then it is no longer the currentPresentedViewController
        // If currentPresentedViewController has no presentingViewController (indicating it was never presented), then it is no longer the currentPresentedViewController
        
        // If there are any copies of the dismissed VC in the queue, remove them
        viewControllerPresentationQueue.removeAll { vc in
            return self.currentPresentedViewController === vc
        }
        
        self.currentPresentedViewController = nil
        presentNextViewController()
    }
}
//
//  DataTaskManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/18/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

private final class DataTaskQueueForAppActive {
    private static var tasks: [() -> Void] = []
    private static var isObserving = false

    static func performWhenActive(_ task: @escaping () -> Void) {
        // UIApplication.applicationState must be used from main thread only
        DispatchQueue.main.async {
            guard UIApplication.shared.applicationState != .active else {
                task()
                return
            }
            HoundLogger.apiRequest.warning("AppActiveTaskQueue.performWhenActive: App is not active, queuing task to be performed when app becomes active")
            tasks.append(task)
            startObserving()
        }
    }

    @objc private static func handleDidBecomeActive() {
        guard UIApplication.shared.applicationState == .active else { return }
        HoundLogger.apiRequest.warning("AppActiveTaskQueue.handleDidBecomeActive: App is now active, executing \(tasks.count) tasks immediately")
        let queued = tasks
        tasks.removeAll()
        for task in queued {
            task()
        }
        NotificationCenter.default.removeObserver(self, name: UIApplication.didBecomeActiveNotification, object: nil)
        isObserving = false
    }

    private static func startObserving() {
        guard isObserving == false else { return }
        isObserving = true
        NotificationCenter.default.addObserver(self, selector: #selector(handleDidBecomeActive), name: UIApplication.didBecomeActiveNotification, object: nil)
    }
}

enum DataTaskManager {
    
    // MARK: - Properties
    /// Tracks the date at which a certain task made a request to the Hound server in order to make sure the rate limit isn't exceeded.
    private static var houndServerRequestDates: [Date] = []
    
    /// For a given rateLimitEvaluationTimePeriod, this is the amount of requests that can be performed without triggering a rate limit. Requests per period: The number of requests over the period of time that will trigger the rate limiting rule.
    private static let numberOfRequestsAllowedInTimePeriod: Int = (50 - 1)

    /// The time period in which a specified number of requests can be made to the hound server without getting a rate limit from cloudflare. The true value is multiplied by 1.2 to provide extra padding. Period: The period of time to consider (in seconds) when evaluating the rate.
    private static let rateLimitEvaluationTimePeriod: Double = (10.0 * 1.2)
    
    /// If a rate limit is triggered, this is the time period for how long we are timed out for. The true value is multiplied by 1.2 to provide extra padding
    private static let rateLimitTimeOutTimePeriod: Double = (10.0 * 1.2)
    
    /// If we receive a rate limit from the Hound server, track this date so we can delay
    static var lastDateRateLimitReceived: Date?
    
    /// The queue of URLSessionDataTask that need to perform their requests to the Hound server. Index 0 is highest priority
    private static var taskQueue: [URLSessionDataTask] = []
    
    /// If startTask triggered a delay that is a recursive call to itself, waiting a specified amount of time to avoid the rate limit, then this is true
    private static var isDelayInProgress: Bool = false
    
    /// If a dataTask hasn't been queued yet
    static func enqueueTask(dataTask: URLSessionDataTask) {
        // Guard against enqueuing the same dataTask twice
        guard taskQueue.contains(where: { dt in
            return dt.taskIdentifier == dataTask.taskIdentifier
        }) == false else { return }
        
        // When dataTasks are created, they start in the suspended state. Don't try to initiate from other states
        guard dataTask.state == .suspended else { return }
        
        taskQueue.append(dataTask)
        
        startTask()
    }
    
    /// Attempts to send the dataTask at index 0 of the taskQueue. If the app has sent too many requests in a given time frame, then delays the next requests until
    private static func startTask() {
        // If API calls are made when the app isn't active, we will have pathing errors to internet which is hard to pickup with NetworkMonitor
        DataTaskQueueForAppActive.performWhenActive {
            // startTask already triggered a delay to avoid the rate limit. Wait for that to return
            guard isDelayInProgress == false else {
                return
            }
            
            let delayNeededToAvoidRateLimit: Double = {
                if let lastDateRateLimitReceived = lastDateRateLimitReceived, lastDateRateLimitReceived.distance(to: Date()) <= rateLimitTimeOutTimePeriod {
                    // E.g. rateLimitTimeOutTimePeriod 10 seconds
                    // lastDateRateLimitReceived 30.0 seconds ago -> 30.0 <= 10.0 -> false -> this code not invoked
                    // lastDateRateLimitReceived 5.0 seconds ago -> 10.0 - 5.0 -> 5.0
                    return rateLimitTimeOutTimePeriod - lastDateRateLimitReceived.distance(to: Date())
                }
                
                // Check if enough requests have been performed where we could have exceeded the rate limit
                guard let oldestRequestAtStartOfTimePeriod = houndServerRequestDates[safe: houndServerRequestDates.count - 1 - numberOfRequestsAllowedInTimePeriod] else {
                    return 0.0
                }
                
                // Find the delay in which we wait long enough to perform the next request, so the tail end of the rate limit requests is older than the rate limit period. This ensures that, for examples, we have a 10 second rate limit period where CloudFlare won't allow more than 20 requests, we wait long enough so that 20th request is older than 10 seconds. Ensuring CloudFlare is ready to accept a new request.
                // E.g. rateLimitEvaluationTimePeriod 10 seconds
                // oldestRequestAtStartOfTimePeriod 30.0 seconds ago -> (10.0 - 30.0) -> -20.0 -> 0.0
                // oldestRequestAtStartOfTimePeriod 5.0 seconds ago -> (10.0 - 5.0) -> 5.0 -> 5.0
                return max(0.0, rateLimitEvaluationTimePeriod - oldestRequestAtStartOfTimePeriod.distance(to: Date()))
            }()
            
            guard delayNeededToAvoidRateLimit <= 0.1 else {
                isDelayInProgress = true
                HoundLogger.apiRequest.warning("DataTaskManager.startTask: Rate limit triggered, delaying next request by \(delayNeededToAvoidRateLimit) seconds for \(taskQueue.first?.originalRequest?.url?.description ?? "NO URL")")
                DispatchQueue.global().asyncAfter(deadline: .now() + delayNeededToAvoidRateLimit) {
                    self.isDelayInProgress = false
                    self.startTask()
                }
                return
            }
            
            guard let dataTask = taskQueue.first else {
                // We have no data tasks to send
                return
            }
            
            // If we successfully for the first element from taskQueue, we can explictely remove that element without fear of crashing
            taskQueue.removeFirst()
            
            houndServerRequestDates.append(Date())
            
            dataTask.resume()
            
            startTask()
        }
    }
    
}
//
//  ReleaseNoteBuilder.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/28/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

struct ReleaseNoteItem {
    let title: String
    let description: String
}

struct ReleaseNotesBuilder {
    private var items: [ReleaseNoteItem] = []

    mutating func addFeature(title: String, description: String) {
        items.append(ReleaseNoteItem(title: title, description: description))
    }

    func buildAttributedString() -> NSAttributedString {
        let message = NSMutableAttributedString()

        for item in items {
            let titleAttr: [NSAttributedString.Key: Any] = [.font: Constant.Visual.Font.emphasizedPrimaryRegularLabel]
            let descAttr: [NSAttributedString.Key: Any] = [.font: Constant.Visual.Font.primaryRegularLabel]

            message.append(NSAttributedString(string: "\u{2022} \(item.title)\n", attributes: titleAttr))
            message.append(NSAttributedString(string: item.description, attributes: descAttr))
            message.append(NSAttributedString(string: "\n\n"))
        }
        return message
    }
}
//
//  AppVersion.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/28/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum AppVersion: String, CaseIterable, Comparable {

    case v4_0_0 = "4.0.0"
    
    case v4_0_1 = "4.0.1"
    
    case v4_1_0 = "4.1.0"

    // MARK: - Init
    /// Creates an AppVersion from a raw value. If the raw value does not match a known
    /// version, defaults to the latest known version.
    init?(from string: String) {
        guard let value = AppVersion(rawValue: string) else {
            return nil
        }
        self = value
    }

    // MARK: - Comparable
    
    static func < (lhs: AppVersion, rhs: AppVersion) -> Bool {
        let lhsComponents = lhs.rawValue.split(separator: ".").compactMap { Int($0) }
        let rhsComponents = rhs.rawValue.split(separator: ".").compactMap { Int($0) }
        let count = max(lhsComponents.count, rhsComponents.count)
        var lhsPadded = lhsComponents
        var rhsPadded = rhsComponents
        if lhsPadded.count < count {
            lhsPadded.append(contentsOf: Array(repeating: -1, count: count - lhsPadded.count))
        }
        if rhsPadded.count < count {
            rhsPadded.append(contentsOf: Array(repeating: -1, count: count - rhsPadded.count))
        }
        for (l, r) in zip(lhsPadded, rhsPadded) where l != r {
            return l < r
        }
        return false
    }

    // MARK: - Compatibility
    
    /// Oldest compatible version of the app. Any version older than this should
    /// have its data considered incompatible.
    static var oldestCompatible: AppVersion { .v4_1_0 }

    static func isCompatible(previous: AppVersion?) -> Bool {
        guard let prev = previous else {
            return false
        }
        return prev >= oldestCompatible
    }

    // MARK: - Release Notes
    var releaseNotes: NSAttributedString {
        switch self {
        case .v4_0_0, .v4_0_1:
            var builder = ReleaseNotesBuilder()
            builder.addFeature(
                title: "Automations",
                description: "Hound can now create reminders for you when you add certain logs.\n\nFor example, setup an automation to get reminded to take Bella out 30 mins after you feed her!"
            )
            
            builder.addFeature(
                title: "Fresh Interface",
                description: "A snazzy look built to shine on iPad, plus a slew of visual enhancements"
            )
            
            builder.addFeature(
                title: "Per‑Reminder Notifications",
                description: "Want to be notified for certain reminders but not others? Now you can choose which reminders send notifications and to who."
            )
            
            builder.addFeature(
                title: "New Log Type",
                description: "When your dog doesn't eat, now you can add a \"Did't Eat 🍽️\" log to track it!"
            )
            
            builder.addFeature(
                title: "Skippable Reminders",
                description: "Easily skip a reminder when playtime runs long."
            )
            
            builder.addFeature(
                title: "More Filter Options",
                description: "Filter your logs by text or time range to fetch just what you need"
            )
            
            builder.addFeature(
                title: "Haptics",
                description: "Give your fingertips a break or feel each tap - flip haptics on or off in Settings."
            )
            
            builder.addFeature(
                title: "Time Zones",
                description: "Hound can now adjust to your desired time zone, allowing you to collaborate from anywhere in the world."
            )
            
            builder.addFeature(
                title: "Duplicate-able Reminders",
                description: "Copy a reminder and tweak the details in seconds."
            )
            
            builder.addFeature(
                title: "Release Notes",
                description: "This page keeps you up to date on every new trick."
            )
            
            builder.addFeature(
                title: "Reliable Timing",
                description: "We tuned up our calculations so reminders pop up right on cue."
            )
            
            builder.addFeature(
                title: "New App Icon",
                description: "Spot Hound faster with our crisp new look."
            )
            return builder.buildAttributedString()
        case .v4_1_0:
            var builder = ReleaseNotesBuilder()
            
            // TODO RELEASE NOTES
            // new log sorting
            // log favoriting
            // log tracks creation / modified time and by who
            // sign in w google
            
            return builder.buildAttributedString()
        }
    }

    // MARK: - Helpers
    
    static var current: AppVersion {
        guard let version = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String else {
            return AppVersion.allCases.max() ?? AppVersion.oldestCompatible
        }
        
        return AppVersion(from: version) ?? AppVersion.allCases.max() ?? AppVersion.oldestCompatible
    }
    
    static var previousAppVersion: AppVersion?
        
}
//
//  MeasurementSystem.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum MeasurementSystem: Int, CaseIterable {
    
    init?(rawValue: Int) {
        for system in MeasurementSystem.allCases where system.rawValue == rawValue {
            self = system
            return
        }
        
        return nil
    }
    
    case imperial = 0
    case metric = 1
    case both = 2
    
    func readableMeasurementSystem() -> String {
        switch self {
        case .imperial:
            return "Imperial"
        case .metric:
            return "Metric"
        case .both:
            return "Both"
        }
    }
    
}
//
//  Reminder Action.swift
//  Hound
//
//  Created by Jonathan Xakellis on 9/27/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum ReminderAction: CaseIterable, Comparable {
    
    // MARK: - Comparable
    
    static func < (lhs: ReminderAction, rhs: ReminderAction) -> Bool {
        let lhsIndex = ReminderAction.allCases.firstIndex(of: lhs) ?? .max
        let rhsIndex = ReminderAction.allCases.firstIndex(of: rhs) ?? .max
        
        return lhsIndex <= rhsIndex
    }
    
    // MARK: - Main

    init?(internalValue: String) {
        // <= 3.1.0 other names used, compare to readableValue as well
        for action in ReminderAction.allCases where action.internalValue == internalValue || action.readableValue == internalValue {
            self = action
            return
        }
        
        return nil
    }
    
    // common
    case feed
    case water
    case potty
    case walk
    // next common
    case brush
    case bathe
    case medicine

    // more common than previous but probably used less by user as weird action
    case sleep
    case trainingSession
    case doctor

    case custom
    
    /// The standardized, internal readable value that corresponds to each case, e.g. "feed" for .feed
    var internalValue: String {
        switch self {
        case .feed:
            return LogAndReminderActionConstant.InternalValue.feed.rawValue
        case .water:
            return LogAndReminderActionConstant.InternalValue.water.rawValue
        case .potty:
            return LogAndReminderActionConstant.InternalValue.potty.rawValue
        case .walk:
            return LogAndReminderActionConstant.InternalValue.walk.rawValue
        case .brush:
            return LogAndReminderActionConstant.InternalValue.brush.rawValue
        case .bathe:
            return LogAndReminderActionConstant.InternalValue.bathe.rawValue
        case .medicine:
            return LogAndReminderActionConstant.InternalValue.medicine.rawValue
        case .sleep:
            return LogAndReminderActionConstant.InternalValue.sleep.rawValue
        case .trainingSession:
            return LogAndReminderActionConstant.InternalValue.trainingSession.rawValue
        case .doctor:
            return LogAndReminderActionConstant.InternalValue.doctor.rawValue
        case .custom:
            return LogAndReminderActionConstant.InternalValue.custom.rawValue
        }
    }
    
    /// The readable value that corresponds to each case, e.g. "Feed" for .feed
    var readableValue: String {
        switch self {
        case .feed:
            return LogAndReminderActionConstant.ReadableValue.feed.rawValue
        case .water:
            return LogAndReminderActionConstant.ReadableValue.water.rawValue
        case .potty:
            return LogAndReminderActionConstant.ReadableValue.potty.rawValue
        case .walk:
            return LogAndReminderActionConstant.ReadableValue.walk.rawValue
        case .brush:
            return LogAndReminderActionConstant.ReadableValue.brush.rawValue
        case .bathe:
            return LogAndReminderActionConstant.ReadableValue.bathe.rawValue
        case .medicine:
            return LogAndReminderActionConstant.ReadableValue.medicine.rawValue
        case .sleep:
            return LogAndReminderActionConstant.ReadableValue.sleep.rawValue
        case .trainingSession:
            return LogAndReminderActionConstant.ReadableValue.trainingSession.rawValue
        case .doctor:
            return LogAndReminderActionConstant.ReadableValue.doctor.rawValue
        case .custom:
            return LogAndReminderActionConstant.ReadableValue.custom.rawValue
        }
    }
    
    /// The readable emoji that corresponds to each case, e.g. 🍗 for .feed
    var readableEmoji: String {
        switch self {
        case .feed:
            return LogAndReminderActionConstant.ReadableEmoji.feed.rawValue
        case .water:
            return LogAndReminderActionConstant.ReadableEmoji.water.rawValue
        case .potty:
            return LogAndReminderActionConstant.ReadableEmoji.potty.rawValue
        case .walk:
            return LogAndReminderActionConstant.ReadableEmoji.walk.rawValue
        case .brush:
            return LogAndReminderActionConstant.ReadableEmoji.brush.rawValue
        case .bathe:
            return LogAndReminderActionConstant.ReadableEmoji.bathe.rawValue
        case .medicine:
            return LogAndReminderActionConstant.ReadableEmoji.medicine.rawValue
        case .sleep:
            return LogAndReminderActionConstant.ReadableEmoji.sleep.rawValue
        case .trainingSession:
            return LogAndReminderActionConstant.ReadableEmoji.trainingSession.rawValue
        case .doctor:
            return LogAndReminderActionConstant.ReadableEmoji.doctor.rawValue
        case .custom:
            return LogAndReminderActionConstant.ReadableEmoji.custom.rawValue
        }
    }

    /// Returns the name of the current reminderAction with an appropiate emoji appended. If non-nil, non-"" reminderCustomActionName is provided, then then that is returned, e.g. fullReadableName(nil, valueDoesNotMatter) -> 'Feed 🍗'; fullReadableName(nil, valueDoesNotMatter) -> 'Custom 📝'; fullReadableName('someCustomName', true) -> 'someCustomName'; fullReadableName('someCustomName', false) -> 'Custom 📝: someCustomName'
    func fullReadableName(reminderCustomActionName: String?, includeMatchingEmoji: Bool = true) -> String {
        let fullReadableNameWithoutEmoji: String = {
            guard self == .medicine || self == .custom else {
                return self.readableValue
            }
            
            if let reminderCustomActionName = reminderCustomActionName, reminderCustomActionName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false {
                return reminderCustomActionName
            }
            
            return self.readableValue
        }()
        
        return includeMatchingEmoji ? fullReadableNameWithoutEmoji.appending(" \(self.readableEmoji)") : fullReadableNameWithoutEmoji
    }

}
//
//  Time Quick Select.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/17/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum TimeAgoQuickSelect: String, CaseIterable {
    case custom = "Custom"
    case now = "Now"
    case fiveMinsAgo = "5 mins ago"
    case fifteenMinsAgo = "15 mins ago"
    case thirtyMinsAgo = "30 mins ago"
    case oneHourAgo = "1 hr ago"
    case twoHoursAgo = "2 hrs ago"
    case fourHoursAgo = "4 hrs ago"
    case eightHoursAgo = "8 hrs ago"
    
    static func optionsOccurringBeforeDate(startingPoint: Date, occurringOnOrBefore: Date) -> [TimeAgoQuickSelect] {
        return TimeAgoQuickSelect.allCases.filter { timeQuickSelectOption in
            guard let valueInSeconds = timeQuickSelectOption.valueInSeconds() else {
                // If timeQuickSelectOption has no valueInSeconds, then assume it is a valid option (e.g. .custom)
                return true
            }
            
            // Important that this is a <= comparision. If you provide Date() for startingPoint and occurringOnOrBefore, then it isn't deterministic. Sometimes the Dates()s are the exact same, and sometimes they are off by a few microseconds.
            return startingPoint.addingTimeInterval(valueInSeconds) <= occurringOnOrBefore
        }
    }
    
    /// Returns how many seconds ago the TimeAgoQuickSelect represents. .now represents 0.0 seconds ago, .fiveMinsAgo represents -300.0 seconds ago, and .custom represents nil
    func valueInSeconds() -> Double? {
        switch self {
        case .now:
            return -1.0 * 0.0
        case .fiveMinsAgo:
            return -1.0 * 60.0 * 5.0
        case .fifteenMinsAgo:
            return -1.0 * 60.0 * 15.0
        case .thirtyMinsAgo:
            return -1.0 * 60.0 * 30.0
        case .oneHourAgo:
            return -1.0 * 60.0 * 60.0 * 1.0
        case .twoHoursAgo:
            return -1.0 * 60.0 * 60.0 * 2.0
        case .fourHoursAgo:
            return -1.0 * 60.0 * 60.0 * 4.0
        case .eightHoursAgo:
            return -1.0 * 60.0 * 60.0 * 8.0
        case .custom:
            return nil
        }
    }
}

enum AfterTimeQuickSelect: String, CaseIterable {
    case custom = "Custom"
    case now = "Now"
    case inFiveMins = "After 5 mins"
    case inFifteenMins = "After 15 mins"
    case inThirtyMins = "After 30 mins"
    case inOneHour = "After 1 hr"
    case inTwoHours = "After 2 hrs"
    case inFourHours = "After 4 hrs"
    case inEightHours = "After 8 hrs"
    
    static func optionsOccurringAfterDate(startingPoint: Date, occurringOnOrAfter: Date) -> [AfterTimeQuickSelect] {
        return AfterTimeQuickSelect.allCases.filter { timeQuickSelectOption in
            guard let valueInSeconds = timeQuickSelectOption.valueInSeconds() else {
                // If timeQuickSelectOption has no valueInSeconds, then assume it is a valid option (e.g. .custom)
                return true
            }
            
            // Important that this is a >= comparision. If you provide Date() for startingPoint and occurringOnOrAfter, then it isn't deterministic. Sometimes the Dates()s are the exact same, and sometimes they are off by a few microseconds.
            return startingPoint.addingTimeInterval(valueInSeconds) >= occurringOnOrAfter
        }
    }
    
    func time(startingPoint: Date) -> Date? {
        guard self != .now else {
            return Date()
        }
        guard self != .custom else {
            return nil
        }
        
        guard let valueInSeconds = self.valueInSeconds() else {
            return nil
        }
        
        return startingPoint.addingTimeInterval(valueInSeconds)
    }
    
    /// Returns how many seconds ago the TimeAgoQuickSelect represents. .now represents 0.0 seconds ago, .fiveMinsAgo represents -300.0 seconds ago, and .custom represents nil
    private func valueInSeconds() -> Double? {
        switch self {
        case .now:
            return nil
        case .inFiveMins:
            return 1.0 * 60.0 * 5.0
        case .inFifteenMins:
            return 1.0 * 60.0 * 15.0
        case .inThirtyMins:
            return 1.0 * 60.0 * 30.0
        case .inOneHour:
            return 1.0 * 60.0 * 60.0 * 1.0
        case .inTwoHours:
            return 1.0 * 60.0 * 60.0 * 2.0
        case .inFourHours:
            return 1.0 * 60.0 * 60.0 * 4.0
        case .inEightHours:
            return 1.0 * 60.0 * 60.0 * 8.0
        case .custom:
            return nil
        }
    }
}
//
//  SubscriptionCancellationReason.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/28/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum SubscriptionCancellationReason: CaseIterable {
    
    case tooExpensive
    case lackingKeyFeatures
    case foundBetterAlternative
    case puppyOutgrewApp
    case notUseful
    case tooManyBugs
    case updateMadeThingsWorse
    case somethingElse
    
    /// The standardized, internal readable value that corresponds to each case, e.g. "tooExpensive" for .tooExpensive
    var internalValue: String {
        switch self {
        case .tooExpensive:
            return "tooExpensive"
        case .lackingKeyFeatures:
            return "lackingKeyFeatures"
        case .foundBetterAlternative:
            return "foundBetterAlternative"
        case .puppyOutgrewApp:
            return "puppyOutgrewApp"
        case .notUseful:
            return "notUseful"
        case .tooManyBugs:
            return "tooManyBugs"
        case .updateMadeThingsWorse:
            return "updateMadeThingsWorse"
        case .somethingElse:
            return "somethingElse"
        }
    }
    
    /// The readable value that corresponds to each case, e.g. "Too Expensive 💸" for .tooExpensive
    var readableValue: String {
        switch self {
        case .tooExpensive:
            return "Too Expensive 💸"
        case .lackingKeyFeatures:
            return "Lacking Key Features 🛠️"
        case .foundBetterAlternative:
            return "Found Better Alternative 📱"
        case .puppyOutgrewApp:
            return "Puppy Outgrew App 🐕"
        case .notUseful:
            return "Not Useful 👎"
        case .tooManyBugs:
            return "Too Many Bugs 🪲"
        case .updateMadeThingsWorse:
            return "Update Made Things Worse 💻"
        case .somethingElse:
            return "Something Else 📝"
        }
    }
    
}
//
//  Constants.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/20/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

public enum Constant {
    public typealias Error = ErrorConstant
    public typealias Visual = VisualConstant
    public typealias Constraint = ConstraintConstant
    public typealias Class = ClassConstant
    public typealias Development = DevelopmentConstant
    public typealias Key = KeyConstant
}
//
//  HoundError.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/22/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

public enum ErrorConstant {

    static func serverError(errorCode: String, requestId: Int, responseId: Int) -> HoundServerError? {
        // MARK: - GENERAL
        if errorCode == "ER_GENERAL_APP_VERSION_OUTDATED" {
            return GeneralResponseError.appVersionOutdated(requestId: requestId, responseId: responseId)
        }
        // ER_GENERAL_ENVIRONMENT_INVALID
        // ER_GENERAL_PARSE_FORM_DATA_FAILED
        // ER_GENERAL_PARSE_JSON_FAILED
        // ER_GENERAL_POOL_CONNECTION_FAILED
        // ER_GENERAL_POOL_TRANSACTION_FAILED
        else if errorCode == "ER_GENERAL_APPLE_SERVER_FAILED" {
            return GeneralResponseError.appleServerFailed(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_RATE_LIMIT_EXCEEDED" {
            return GeneralResponseError.rateLimitExceeded(requestId: requestId, responseId: responseId)
        }
        // MARK: - VALUE
        // ER_VALUE_MISSING
        // ER_VALUE_INVALID
        // MARK: - PERMISSION
        // MARK: NO
        else if errorCode == "ER_PERMISSION_NO_USER" {
            return PermissionResponseError.noUser(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_FAMILY" {
            return PermissionResponseError.noFamily(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_DOG" {
            return PermissionResponseError.noDog(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_LOG" {
            return PermissionResponseError.noLog(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_REMINDER" {
            return PermissionResponseError.noReminder(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_TRIGGER" {
            return PermissionResponseError.noTrigger(requestId: requestId, responseId: responseId)
        }
        // MARK: INVALID
        else if errorCode == "ER_PERMISSION_INVALID_FAMILY" {
            return PermissionResponseError.invalidFamily(requestId: requestId, responseId: responseId)
        }
        // MARK: - FAMILY
        // MARK: LIMIT
        else if errorCode == "ER_FAMILY_LIMIT_FAMILY_MEMBER_TOO_LOW" {
            return FamilyResponseError.limitFamilyMemberTooLow(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_DOG_TOO_LOW" {
            return FamilyResponseError.limitDogTooLow(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_LOG_TOO_LOW" {
            return FamilyResponseError.limitLogTooLow(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_REMINDER_TOO_LOW" {
            return FamilyResponseError.limitReminderTooLow(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_TRIGGER_TOO_LOW" {
            return FamilyResponseError.limitTriggerTooLow(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_FAMILY_MEMBER_EXCEEDED" {
            return FamilyResponseError.limitFamilyMemberExceeded(requestId: requestId, responseId: responseId)
        }
        // MARK: DELETED
        else if errorCode == "ER_FAMILY_DELETED_DOG" {
            return FamilyResponseError.deletedDog(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_DELETED_LOG" {
            return FamilyResponseError.deletedLog(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_DELETED_REMINDER" {
            return FamilyResponseError.deletedReminder(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_DELETED_TRIGGER" {
            return FamilyResponseError.deletedTrigger(requestId: requestId, responseId: responseId)
        }
        // MARK: JOIN
        else if errorCode == "ER_FAMILY_JOIN_FAMILY_CODE_INVALID" {
            return FamilyResponseError.joinFamilyCodeInvalid(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_JOIN_FAMILY_LOCKED" {
            return FamilyResponseError.joinFamilyLocked(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_JOIN_IN_FAMILY_ALREADY" {
            return FamilyResponseError.joinInFamilyAlready(requestId: requestId, responseId: responseId)
        }
        // MARK: Leave
        else if errorCode == "ER_FAMILY_LEAVE_SUBSCRIPTION_ACTIVE" {
            return FamilyResponseError.leaveSubscriptionActive(requestId: requestId, responseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LEAVE_STILL_FAMILY_MEMBERS" {
            return FamilyResponseError.leaveStillFamilyMembers(requestId: requestId, responseId: responseId)
        }
        // MARK: - NONE
        return nil
    }

    // MARK: - Text Constants

    private static let contactHoundSupport: String = "If the issue persists, please contact Hound support."
    private static let restartHoundAndRetry: String = "If the issue persists, please restart and retry."
    private static let potentialHoundServerOutage: String = "If the issue persists, Hound's server may be experiencing an outage."
    private static let verifyInternetConnection: String = "Please verify that you are connected to the internet and retry."
    private static let tryShorterOne: String = "Please try a shorter one."
    private static let enterValidCode: String = "Please enter in a valid code and retry."

    // MARK: - API Request

    enum GeneralRequestError {
        static func noInternetConnection() -> HoundError {
            HoundError(
                name: "GeneralRequestError.noInternetConnection",
                description: "Your device doesn't appear to be connected to the internet. \(Constant.Error.verifyInternetConnection)",
                onTap: nil)
        }
    }

    enum FamilyRequestError {
        static func familyCodeBlank() -> HoundError {
            HoundError(
                name: "FamilyRequestError.familyCodeBlank",
                description: "Your family code is blank! \(Constant.Error.enterValidCode)",
                onTap: nil)
        }
        static func familyCodeInvalid() -> HoundError {
            HoundError(
                name: "FamilyRequestError.familyCodeInvalid",
                description: "Your family code's format is invalid! \(Constant.Error.enterValidCode)",
                onTap: nil)
        }
    }

    // MARK: - API Response

    enum GeneralResponseError {
        /// The app version that the user is using is out dated
        static func appVersionOutdated(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "GeneralResponseError.appVersionOutdated",
                description: "It looks like you're using an outdated version of Hound. Update now for the latest features and improvements!",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func appleServerFailed(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "GeneralResponseError.appleServerFailed",
                description: "Hound was unable to contact Apple's iTunes server and complete your request. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func rateLimitExceeded(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "GeneralResponseError.rateLimitExceeded",
                description: "You have exceeded Hound's rate limit. Please wait 10 seconds before retrying your request.",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        
        /// GET: != 200...299, e.g. 400, 404, 500
        static func getFailureResponse(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "GeneralResponseError.getFailureResponse",
                description: "We experienced an issue while retrieving your data Hound's server. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }

        /// GET: Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
        static func getNoResponse() -> HoundError {
            HoundError(
                name: "GeneralResponseError.getNoResponse",
                description: "We were unable to reach Hound's server and retrieve your data. \(Constant.Error.verifyInternetConnection) \(Constant.Error.potentialHoundServerOutage)",
                onTap: nil)
        }

        /// CREATE/POST:  != 200...299, e.g. 400, 404, 500
        static func postFailureResponse(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "GeneralResponseError.postFailureResponse",
                description: "Hound's server experienced an issue in saving your new data. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        /// CREATE/POST: Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
        static func postNoResponse() -> HoundError {
            HoundError(
                name: "GeneralResponseError.postNoResponse",
                description: "We were unable to reach Hound's server and save your new data. \(Constant.Error.verifyInternetConnection) \(Constant.Error.potentialHoundServerOutage)",
                onTap: nil)
        }

        /// UPDATE/PUT:  != 200...299, e.g. 400, 404, 500
        static func putFailureResponse(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "GeneralResponseError.putFailureResponse",
                description: "Hound's server experienced an issue in updating your data. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        /// UPDATE/PUT: Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
        static func putNoResponse() -> HoundError {
            HoundError(
                name: "GeneralResponseError.putNoResponse",
                description: "We were unable to reach Hound's server and update your data. \(Constant.Error.verifyInternetConnection) \(Constant.Error.potentialHoundServerOutage)",
                onTap: nil)
        }

        /// DELETE:  != 200...299, e.g. 400, 404, 500
        static func deleteFailureResponse(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "GeneralResponseError.deleteFailureResponse",
                description: "Hound's server experienced an issue in deleting your data. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        /// DELETE: Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
        static func deleteNoResponse() -> HoundError {
            HoundError(
                name: "GeneralResponseError.deleteNoResponse",
                description: "We were unable to reach Hound's server to delete your data. \(Constant.Error.verifyInternetConnection) \(Constant.Error.potentialHoundServerOutage)",
                onTap: nil)
        }
    }

    enum PermissionResponseError {
        static func noUser(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "PermissionResponseError.noUser",
                description: "You are attempting to access a user that doesn't exist or you don't have permission to. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func noFamily(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "PermissionResponseError.noFamily",
                description: "You are attempting to access a family that doesn't exist or you don't have permission to. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func noDog(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "PermissionResponseError.noDog",
                description: "You are attempting to access a dog that doesn't exist or you don't have permission to. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func noLog(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "PermissionResponseError.noLog",
                description: "You are attempting to access a log that doesn't exist or you don't have permission to. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func noReminder(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "PermissionResponseError.noReminder",
                description: "You are attempting to access a reminder that doesn't exist or you don't have permission to. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func noTrigger(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "PermissionResponseError.noTrigger",
                description: "You are attempting to access a trigger that doesn't exist or you don't have permission to. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }

        static func invalidFamily(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "PermissionResponseError.invalidFamily",
                description: "You are attempting to perform an action that only the family head can perform. Please contact the family head and have them complete this action. \(Constant.Error.contactHoundSupport)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
    }

    enum FamilyResponseError {
        // MARK: Limit
        // Too Low
        static func  limitFamilyMemberTooLow(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "FamilyResponseError.limitFamilyMemberTooLow",
                // DON'T MAKE THIS MESSAGE DYNAMIC. User is attempting to join a family but failed, therefore familyActiveSubscription will be inaccurate as user currently has no family.
                description: "This family can only have a limited number of family members! Please have the family head upgrade their subscription before attempting to join this family.",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func  limitDogTooLow(requestId: Int, responseId: Int) -> HoundServerError {
            // spell out the number of dogs the family can have
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let dogLimitSpelledOut = formatter.string(from: Constant.Class.Dog.maximumNumberOfDogs as NSNumber) ?? "negative one"

            return HoundServerError(
                name: "FamilyResponseError.limitDogTooLow",
                description: "Your family can only have \(dogLimitSpelledOut) dog\(Constant.Class.Dog.maximumNumberOfDogs == 1 ? "" : "s")! Please remove an existing dog before trying to add a new one.",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func  limitLogTooLow(requestId: Int, responseId: Int) -> HoundServerError {
            // spell out the number of logs a dog can have
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let logLimitSpelledOut = formatter.string(from: Constant.Class.Dog.maximumNumberOfLogs as NSNumber) ?? "negative one"

            return HoundServerError(
                name: "FamilyResponseError.limitLogTooLow",
                description: "Your dog can only have \(logLimitSpelledOut) log\(Constant.Class.Dog.maximumNumberOfLogs == 1 ? "" : "s")! Please remove an existing log before trying to add a new one.",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func  limitReminderTooLow(requestId: Int, responseId: Int) -> HoundServerError {
            // spell out the number of logs a dog can have
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let reminderLimitSpelledOut = formatter.string(from: Constant.Class.Dog.maximumNumberOfReminders as NSNumber) ?? "negative one"

            return HoundServerError(
                name: "FamilyResponseError.limitReminderTooLow",
                description: "Your dog can only have \(reminderLimitSpelledOut) reminder\(Constant.Class.Dog.maximumNumberOfReminders == 1 ? "" : "s")! Please remove an existing reminder before trying to add a new one.",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        static func  limitTriggerTooLow(requestId: Int, responseId: Int) -> HoundServerError {
            // spell out the number of logs a dog can have
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let triggerLimitSpelledOut = formatter.string(from: Constant.Class.Dog.maximumNumberOfTriggers as NSNumber) ?? "negative one"

            return HoundServerError(
                name: "FamilyResponseError.limitTriggerTooLow",
                description: "Your dog can only have \(triggerLimitSpelledOut) trigger\(Constant.Class.Dog.maximumNumberOfTriggers == 1 ? "" : "s")! Please remove an existing trigger before trying to add a new one.",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }

        // Exceeded
        static func limitFamilyMemberExceeded(requestId: Int, responseId: Int) -> HoundServerError {
            // find out how many family members can be in the family
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let allowedNumberOfFamilyMembers = FamilyInformation.familyActiveSubscription.numberOfFamilyMembers
            let familyMemberLimitSpelledOut = formatter.string(from: allowedNumberOfFamilyMembers as NSNumber) ?? "\(allowedNumberOfFamilyMembers)"

            let numberOfExceededFamilyMembers = FamilyInformation.familyMembers.count - allowedNumberOfFamilyMembers
            let numberOfExceededFamilyMembersSpelledOut = formatter.string(
                from: numberOfExceededFamilyMembers as NSNumber) ?? "\(numberOfExceededFamilyMembers)"

            // user could be family head or they could be a family member
            var description = "Your family is exceeding it's \(familyMemberLimitSpelledOut) family member limit and is unable to have data added or updated. "

            description.append("To restore functionality, please ")

            if UserInformation.isUserFamilyHead == false {
                description.append("have the family head ")
            }

            if numberOfExceededFamilyMembers >= 1 {
                description.append("remove \(numberOfExceededFamilyMembersSpelledOut) family member\(numberOfExceededFamilyMembers == 1 ? "" : "s") or ")
            }
            
            description.append("upgrade your subscription.")
            
            return HoundServerError(
                name: "FamilyResponseError.limitFamilyMemberExceeded",
                description: description,
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }

        // MARK: Deleted
        /// The dog that the user is trying to access has been marked as deleted
        static func deletedDog(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "FamilyResponseError.deletedDog",
                description: "The dog you are attempting to access has been deleted! Hold on while we refresh your data...",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        /// The log that the user is trying to access has been marked as deleted
        static func deletedLog(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "FamilyResponseError.deletedLog",
                description: "The log you are attempting to access has been deleted! Hold on while we refresh your data...",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        /// The reminder that the user is trying to access has been marked as deleted
        static func deletedReminder(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "FamilyResponseError.deletedReminder",
                description: "The reminder you are attempting to access has been deleted! Hold on while we refresh your data...",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        /// The trigger that the user is trying to access has been marked as deleted
        static func deletedTrigger(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "FamilyResponseError.deletedTrigger",
                description: "The trigger you are attempting to access has been deleted! Hold on while we refresh your data...",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }

        // MARK: Join
        /// Family code was valid but was not linked to any family
        static func joinFamilyCodeInvalid(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "FamilyResponseError.joinFamilyCodeInvalid",
                description: "The family code you input isn't linked to any family. \(Constant.Error.enterValidCode)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        /// Family code was valid and linked to a family but the family was locked
        static func  joinFamilyLocked(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "FamilyResponseError.joinFamilyLocked",
                description: "The family you are trying to join is locked, preventing any new family members from joining. Please have an existing family member unlock it and retry.",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
        /// User is already in a family and therefore can't join a new one
        static func  joinInFamilyAlready(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "FamilyResponseError.joinInFamilyAlready",
                description: "You are already in a family. Please leave your existing family before attempting to join a new one. \(Constant.Error.contactHoundSupport)",
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }

        // MARK: Leave
        static func  leaveSubscriptionActive(requestId: Int, responseId: Int) -> HoundServerError {
            HoundServerError(
                name: "FamilyResponseError.leaveSubscriptionActive",
                description: "You are unable to delete your current family due having an active, auto-renewing subscription. To continue, tap this banner to cancel your subscription. \(Constant.Error.contactHoundSupport)",
                onTap: {
                    // If the user taps the banner, that means they want to cancel their Hound subscription. The only way to cancel a subscription is with Apple's manage subscriptions page.
                    InAppPurchaseManager.showManageSubscriptions()
                },
                requestId: requestId,
                responseId: responseId
            )
        }
        static func  leaveStillFamilyMembers(requestId: Int, responseId: Int) -> HoundServerError {
            // if user is family head, then add piece about removing other family members. this error shouldn't happen if the user isn't the family head, and therefore we direct them more toward hound support
            var description = "You are unable to leave your current family. "
            if UserInformation.isUserFamilyHead {
                description.append("Please remove all existing family members before attempting to leave. ")
            }
            description.append("\(Constant.Error.contactHoundSupport)")

            return HoundServerError(
                name: "FamilyResponseError.leaveStillFamilyMembers",
                description: description,
                onTap: nil,
                requestId: requestId,
                responseId: responseId
            )
        }
    }

    // MARK: - Class

    enum InAppPurchaseError {
        // MARK: Product Request Of Available In-App Purchases
        static func productRequestInProgress() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.productRequestInProgress",
                description: "There is a in-app purchase product request currently in progress. You are unable to initiate another in-app purchase product request until the first one has finished processing. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }
        /// The app cannot request App Store about available IAP products for some reason.
        static func productRequestFailed() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.productRequestFailed",
                description: "Your in-app purchase product request has failed. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }
        /// No in-app purchase products were returned by the App Store because none was found.
        static func productRequestNotFound() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.productRequestNotFound",
                description: "Your in-app purchase product request did not return any results. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }

        // MARK: User Attempting To Make An In-App Purchase
        /// User can't make any in-app purchase because SKPaymentQueue.canMakePayment() == false
        static func purchaseRestricted() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.purchaseRestricted",
                description: "Your device is restricted from accessing the Apple App Store and is unable to make in-app purchases. Please remove this restriction before attempting to make another in-app purchase.",
                onTap: nil)
        }

        /// User can't make any in-app purchase because they are not the family head
        static func purchasePermission() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.purchasePermission",
                description: "You are attempting to perform an action that only the family head can perform. Please contact the family head and have them complete this action. \(Constant.Error.contactHoundSupport)",
                onTap: nil)
        }

        /// There is a in-app purchases in progress, so a new one cannot be initiated currentProductPurchase != nil || productPurchaseCompletionHandler != nil
        static func purchaseInProgress() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.purchaseInProgress",
                description: "There is an in-app purchase currently in progress. You are unable to initiate another in-app purchase until the first one has finished processing. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }

        /// Deferred. Most likely due to pending parent approval from Ask to Buy
        static func purchaseDeferred() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.purchaseDeferred",
                description: "Your in-app purchase is pending an approval from your parent. To complete your purchase, please have your parent approve the request within 24 hours.",
                onTap: nil)
        }

        /// The in app purchase failed and was not completed
        static func purchaseFailed() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.purchaseFailed",
                description: "Your in-app purchase has failed. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }

        /// Unknown error
        static func purchaseUnknown() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.purchaseUnknown",
                description: "Your in-app purchase has experienced an unknown error. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }

        // MARK: User Attempting To Restore An In-App Purchase

        /// User can't make any in-app purchase restoration because they are not the family head
        static func restorePermission() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.restorePermission",
                description: "You are attempting to perform an action that only the family head can perform. Please contact the family head and have them complete this action. \(Constant.Error.contactHoundSupport)",
                onTap: nil)
        }

        /// There is a in-app purchases restoration in progress, so a new one cannot be initiated
        static func restoreInProgress() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.restoreInProgress",
                description: "There is an in-app purchase restoration currently in progress. You are unable to initiate another in-app purchase restoration until the first one has finished processing. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }

        static func restoreFailed() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.restoreFailed",
                description: "Your in-app purchase restoration has failed. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }

        // MARK: System Is Processing Transaction In The Background
        static func backgroundPurchaseInProgress() -> HoundError {
            HoundError(
                name: "InAppPurchaseError.backgroundPurchaseInProgress",
                description: "There is a transaction currently being processed in the background. This is likely due to a subscription renewal. Please wait a moment for this to finish processing. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }
    }

    enum DogError {
        static let dogNameMissing = "Choose a name for your dog"
    }

    enum LogError {
        static let parentDogMissing = "Choose at least one dog"
        static let logActionMissing = "Choose an action"
        static let logStartDateMissing = "Choose a start date"
        static let logStartTooLate = "Start date can't be after end date"
        static let logEndTooEarly = "End date can't be before start date"
    }

    enum ReminderError {
        static let reminderActionMissing = "Choose an action for your reminder"
        static let reminderTimeZoneMissing = "Choose a time zone for your reminder"
    }
    
    enum TriggerError {
        static let reminderResultMissing = "Choose a reminder to create"
        static let logReactionMissing = "Choose at least one log type"
        static let conditionsInvalid = "Choose at least one condition"
        static let timeDelayInvalid = "Choose a valid time delay"
        static let fixedTimeTypeAmountInvalid = "Choose a valid amount of fixed time"
    }

    enum SignInWithAppleError {
        static func canceled() -> HoundError {
            HoundError(
                name: "SignInWithAppleError.canceled",
                description: "The 'Sign In With Apple' page was prematurely canceled. \(Constant.Error.restartHoundAndRetry)",
                onTap: nil)
        }
        static func notSignedIn() -> HoundError {
            HoundError(
                name: "SignInWithAppleError.notSignedIn",
                description: "The 'Sign In With Apple' page failed as you have no Apple ID. Please create an Apple ID with two-factor authentication enabled and retry.",
                onTap: nil)
        }
        static func other() -> HoundError {
            HoundError(
                name: "SignInWithAppleError.other",
                description: "The 'Sign In With Apple' page failed. Please make sure you have an Apple ID with two-factor authentication enabled and retry.",
                onTap: nil)
        }
    }

    enum UnknownError {
        static func unknown() -> HoundError {
            HoundError(
                name: "UnknownError.unknown",
                description: "Hound has experienced an unknown error. \(Constant.Error.contactHoundSupport)",
                onTap: nil)
        }
    }

    enum WeeklyComponentsError {
        static let weekdaysInvalid = "Choose at least one day of week"
    }

    enum ExportError {
        static func shareHound() -> HoundError {
            HoundError(
                name: "ExportError.shareHound",
                description: "Unable to present menu to share Hound",
                onTap: nil)
        }

        static func shareFamilyCode() -> HoundError {
            HoundError(
                name: "ExportError.shareHound",
                description: "Unable to present menu to share family code",
                onTap: nil)
        }

        static func exportLogs() -> HoundError {
            HoundError(
                name: "ExportError.shareHound",
                description: "Unable to present menu to export logs",
                onTap: nil)
        }
    }
}
//
//  Dog Constants.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

public enum ClassConstant {
    public typealias Dog = DogConstant
    public typealias Log = LogConstant
    public typealias Reminder = ReminderConstant
    public typealias ReminderComponent = ReminderComponentConstant
    public typealias Trigger = TriggerConstant
    public typealias Feedback = FeedbackConstant
    public typealias Subscription = SubscriptionConstant
}

public enum SubscriptionConstant {
    static var defaultSubscription: Subscription {
        Subscription(
            transactionId: nil,
            productId: defaultProductId,
            purchaseDate: nil,
            expiresDate: nil,
            numberOfFamilyMembers: defaultSubscriptionNumberOfFamilyMembers,
            isActive: true,
            autoRenewStatus: true,
            autoRenewProductId: defaultProductId)
    }
    static let defaultSubscriptionNumberOfFamilyMembers = 1
    static let defaultSubscriptionSpelledOutNumberOfFamilyMembers = "one"
    static let defaultProductId = "com.jonathanxakellis.hound.default"
}

public enum DogConstant {
    static let defaultDogName: String = "Bella"
    
    static let dogNameCharacterLimit: Int = 32
    // IMPORTANT: If you modify this value, change the value on Hound server's globalConstant LIMIT
    static let maximumNumberOfDogs = 10
    // IMPORTANT: If you modify this value, change the value on Hound server's globalConstant LIMIT
    static let maximumNumberOfLogs = 100000
    // IMPORTANT: If you modify this value, change the value on Hound server's globalConstant LIMIT
    static let maximumNumberOfReminders = 25
    // IMPORTANT: If you modify this value, change the value on Hound server's globalConstant LIMIT
    static let maximumNumberOfTriggers = 25
}

public enum LogConstant {
    static var defaultUserId: String {
        UserInformation.userId ?? Constant.Visual.Text.unknownHash
    }
    static let defaultLogActionTypeId = 1
    static var defaultLogStartDate: Date { Date() }
    static let logCustomActionNameCharacterLimit: Int = 32
    static let logNoteCharacterLimit: Int = 500
}

public enum ReminderConstant {
    static let defaultReminderActionTypeId = 1
    static let defaultReminderType = ReminderType.countdown
    static var defaultReminderExecutionBasis: Date { Date() }
    static let defaultReminderIsEnabled = true
    static var defaultReminderRecipientUserIds: [String] {
        FamilyInformation.familyMembers.map { $0.userId }
    }
    static let reminderCustomActionNameCharacterLimit: Int = 32
    static var defaultReminders: [Reminder] {
        [ defaultReminderOne, defaultReminderTwo, defaultReminderThree, defaultReminderFour ]
    }
    private static var defaultReminderOne: Reminder {
        let reminder = Reminder()
        reminder.reminderActionTypeId = 3
        reminder.changeReminderType(.countdown)
        reminder.countdownComponents.executionInterval = Constant.Class.ReminderComponent.defaultCountdownExecutionInterval
        return reminder
    }
    private static var defaultReminderTwo: Reminder {
        let reminder = Reminder()
        reminder.reminderActionTypeId = 1
        reminder.changeReminderType(.weekly)
        // 7:00 AM local time
        return reminder
    }
    private static var defaultReminderThree: Reminder {
        let reminder = Reminder()
        reminder.reminderActionTypeId = 1
        reminder.changeReminderType(.weekly)
        // 12:00 PM
        reminder.weeklyComponents.zonedHour = 11
        return reminder
    }
    private static var defaultReminderFour: Reminder {
        let reminder = Reminder()
        reminder.reminderActionTypeId = 1
        reminder.changeReminderType(.weekly)
        // 5:00 PM
        reminder.weeklyComponents.zonedHour = 17
        return reminder
    }
}

public enum ReminderComponentConstant {
    static let defaultCountdownExecutionInterval: Double = 60 * 60 * 2
    
    static let defaultZonedDay: Int = 1
    static var defaultZonedHour: Int = 7
    static var defaultZonedMinute: Int = 0
}

public enum TriggerConstant {
    static let defaultTriggerType = TriggerType.timeDelay
    static let defaultTriggerTimeDelay: Double = 60 * 30
    static let defaultTriggerFixedTimeType = TriggerFixedTimeType.day
    static let defaultTriggerFixedTimeTypeAmount = 1
    static let defaultTriggerManualCondition = true
    static let defaultTriggerAlarmCreatedCondition = true
    static let defaultTriggerFixedTimeHour = 16
    static let defaultTriggerFixedTimeMinute = 5
    static var defaultTriggers: [Trigger] {
        // logActionTypeId 1 == feed
        let logReaction = TriggerLogReaction(logActionTypeId: 1, logCustomActionName: nil)
        // reminderActionTypeId 3 == potty
        let reminderResult = TriggerReminderResult(reminderActionTypeId: 3, reminderCustomActionName: nil)
        let trigger = Trigger(
            triggerLogReactions: [logReaction],
            triggerReminderResult: reminderResult,
            triggerType: .timeDelay,
            triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 60.0 * 30.0)
        )
        return [trigger]
    }
}

public enum FeedbackConstant {
    static let subscriptionCancellationSuggestionCharacterLimit: Int = 1000
    static let appExperienceSuggestionCharacterLimit: Int = 1000
}
//
//  View Tag Constant.Class.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/6/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

public enum VisualConstant {

    enum ViewTag {
        // reserve lower bound of tag for potential use within app. tags will never reach anywhere near the upper bound of this reserved range but it costs nothing to reserve some tags.

        static let weekdayEnabled = 1000000004
        static let weekdayDisabled = 1000000005
        static let serverSyncViewControllerRetryLogin = 1000000006
        static let serverSyncViewControllerGoToLoginPage = 1000000007
    }

    enum Font {
        // MARK: Header Labels
        static let megaHeaderLabel = UIFont.systemFont(ofSize: 47.5, weight: .bold)
        
        static let primaryHeaderLabel = UIFont.systemFont(ofSize: 35.0, weight: .bold)
        
        static let secondaryHeaderLabel = UIFont.systemFont(ofSize: 25.0, weight: .medium)
        static let emphasizedSecondaryHeaderLabel = UIFont.systemFont(ofSize: 25.0, weight: .semibold)
        
        static let tertiaryHeaderLabel = UIFont.systemFont(ofSize: 21.5, weight: .regular)
        static let emphasizedTertiaryHeaderLabel = UIFont.systemFont(ofSize: 21.5, weight: .semibold)
        
        // MARK: Regular Labels
        
        static let primaryRegularLabel = UIFont.systemFont(ofSize: 19.0, weight: .regular)
        static let emphasizedPrimaryRegularLabel = UIFont.systemFont(ofSize: 19.0, weight: .semibold)
        
        static let weakSecondaryRegularLabel = UIFont.systemFont(ofSize: 17.0, weight: .light)
        static let secondaryRegularLabel = UIFont.systemFont(ofSize: 17.0, weight: .regular)
        static let emphasizedSecondaryRegularLabel = UIFont.systemFont(ofSize: 17.0, weight: .semibold)
        
        static let tertiaryRegularLabel = UIFont.systemFont(ofSize: 15.5, weight: .regular)
        static let emphasizedTertiaryRegularLabel = UIFont.systemFont(ofSize: 15.5, weight: .semibold)

        // MARK: Description Labels
        static let secondaryColorDescLabel = UIFont.systemFont(ofSize: 15.5, weight: .light)
        static let emphasizedSecondaryColorDescLabel = UIFont.systemFont(ofSize: 15.5, weight: .semibold)
        
        static let tertiaryColorDescLabel = UIFont.systemFont(ofSize: 15.5, weight: .regular)
        static let emphasizedTertiaryColorDescLabel = UIFont.systemFont(ofSize: 15.5, weight: .semibold)

        // MARK: Buttons
        static let wideButton = UIFont.systemFont(ofSize: 27.5, weight: .semibold)
        static let circleButton = UIFont.systemFont(ofSize: 22.5, weight: .medium)
        
        // MARK: Badge
        static let badgeLabel = UIFont.systemFont(ofSize: 12.5, weight: .bold)
    }

    enum Layer {
        static let defaultCornerRadius = 10.0
        static let imageCoveringViewCornerRadius = 27.5
    }

    enum BannerText {
        // MARK: - .success (banner style)
        
        static let successPurchasedSubscriptionTitle = "Welcome to Hound+"
        static let successPurchasedSubscriptionSubtitle = "Dive into the full Hound experience with your family. Enjoy!"

        static let successRestoreTransactionsTitle = "Transactions Back on Track"
        static let successRestoreTransactionsSubtitle = "We've retrieved all your past Hound purchases. Enjoy!"

        static let successRedownloadDataTitle = "Data Re-barked and Ready"
        static let successRedownloadDataSubtitle = "Your dogs, reminders, and logs have been redownloaded from the Hound server and are up-to-date"

        static let successRefreshRemindersTitle = successRedownloadDataTitle
        static let successRefreshRemindersSubtitle = "Your dogs, reminders, and logs are now up-to-date"

        static let successRefreshLogsTitle = successRedownloadDataTitle
        static let successRefreshLogsSubtitle = successRefreshRemindersSubtitle

        static let successRefreshFamilyTitle = "Family Fur-ever Refreshed"
        static let successRefreshFamilySubtitle = "Your family is now up-to-date"

        static let copiedToClipboardTitle = "Copied to Clipboard ✂️"
        static var copiedToClipboardSubtitle: String {
            UIPasteboard.general.string ?? ""
        }
        
        static let surveyFeedbackAppExperienceTitle = "Your Bark, Our Command! 📣"
        static let surveyFeedbackAppExperienceSubtitle = "Thanks for sharing! We're listening and committed to enhancing your Hound experience"

        // MARK: - .info (banner style)

        static let houndUpdatedTitle: String = "Fresh Paws on the Block! 🐾"
        static var houndUpdatedSubtitle: String {
            return "Tap here to check v\(AppVersion.current.rawValue)!"
        }
        
        static let infoEnteredOfflineModeTitle = "Switched to Offline Mode"
        static let infoEnteredOfflineModeSubtitle = "Hang tight! We'll sync your data as soon as we reconnect to the Hound servers"
        
        static let infoRedownloadOnHoldTitle = "Your Updates, Coming Up!"
        static let infoRedownloadOnHoldSubtitle = "Hang tight! We'll redownload the latest on your pups as soon as we reconnect to the Hound servers"

        static let infoRefreshOnHoldTitle = "Your Updates, Coming Up!"
        static let infoRefreshOnHoldSubtitle = "Hang tight! We'll fetch the latest on your pups as soon as we reconnect to the Hound servers"

        // MARK: - .danger (banner style)
        
        static let noCameraTitle = "Camera Needed for Snaps 📷"
        static let noCameraSubtitle = "Enable camera access to capture moments with your pup"

        static let errorAlertTitle = "Uh-oh! We sniffed out an issue 🐾"

        static let notificationsDisabledTitle = "Heads Up! Notifications Disabled 🔕"
        static let notificationsDisabledSubtitle = "To enable notifications go to Settings -> Notifications -> Hound and enable \"Allow Notifications\""

        static let invalidLockedFamilyShareTitle = "Family Sharing Gate Locked 🔒"
        static let invalidLockedFamilyShareSubtitle = "Currently, your Hound family is locked, preventing new users from joining. In order to share your family, please unlock it and retry"

        static let notFamilyHeadInvalidPermissionTitle = "Paws Off! Permission Needed 🚫"
        static let notFamilyHeadInvalidPermissionSubtitle = "Only the family head can modify your family's subscription. Please contact them to complete this action"
        
        // MARK: .warning (banner style)
        
        static let noEditNotificationSettingsTitle = "Heads Up!"
        static let noEditNotificationSettingsSubtitle = "Notifications are turned off, so you'll need to enable them before you can make any changes"

        static let noEditTriggerResultRemindersTitle = "Heads Up!"
        static let noEditTriggerResultRemindersSubtitle = "Reminders created by automations can't be edited (only deleted)"
        
        static let noAddMoreRemindersTitle = "Heads up! Maximum of \(Constant.Class.Dog.maximumNumberOfReminders) reminder\(Constant.Class.Dog.maximumNumberOfReminders == 1 ? "" : "s") per dog 🛑"
        static let noAddMoreRemindersSubtitle: String = "Please remove an existing reminder before trying to add a new one. NOTE: Reminders created by automations do not count towards this limit."
        
        static let noAddMoreTriggersTitle = "Heads up! Maximum of \(Constant.Class.Dog.maximumNumberOfTriggers) automations\(Constant.Class.Dog.maximumNumberOfTriggers == 1 ? "" : "s") per dog 🛑"
        static let noAddMoreTriggersSubtitle: String = "Please remove an existing trigger before trying to add a new one."
    }

    enum Text {
        static let unknownText = "Unknown ⚠️"
        static let unknownName = "Missing Name"
        static let unknownEmail = "Missing Email"
        static let unknownUserId = "Missing User ID"
        static let unknownHash = "0123456789012345678901234567890123456789012345678901234567890123"
        static let unknownUUID: UUID = UUID(uuidString: "00000000-0000-4000-8000-000000000000")! // swiftlint:disable:this force_unwrapping
    }

    enum Animation {
        static let moveMultipleElements = 0.3
        static let showMultipleElements = 0.3
        static let hideMultipleElements = 0.2
        /// Duration after selecting a ui element. For example: toggling weekday(s) for a weekly reminder or setCustomSelected for a drop down table view cell
        static let selectSingleElement = 0.125
        static let showOrHideSingleElement = 0.15
    }
}
//
//  EnumConstant.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/17/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

public enum DevelopmentConstant {
    static let isProduction: Bool = {
#if DEBUG
        return false
#else
        return true
#endif
    }()
    /// True if the server we are contacting is our Ubuntu AWS instance, false if we are local hosting off personal computer
    static let isProductionAWSServer: Bool = {
#if DEBUG
        HoundLogger.general.debug("DEBUG configuration for server")
        // Return true to connect to AWS EC2 instance
        // Return false to connect to local
        return true
#else
        HoundLogger.general.debug("RELEASE configuration for server")
        // MARK: ALWAYS RETURN TRUE, WANT PROD SERVER FOR RELEASE
        return true
#endif
    }()
    /// True if we are contacting the production environment side of our server, false if we are contacting the development side
    static let isProductionDatabase: Bool = {
#if DEBUG
        HoundLogger.general.debug("DEBUG configuration for database")
        // MARK: ALWAYS RETURN FALSE, WANT DEV DATABASE FOR DEBUG
        return false
#else
        HoundLogger.general.debug("RELEASE configuration for database")
        // MARK: ALWAYS RETURN TRUE, WANT PROD DATABASE FOR RELEASE
        return true
#endif
    }()

    /// If testing the development of Hound with its development database, then use this user id for a test account.
    static let developmentDatabaseTestUserId: String? = isProductionDatabase ? nil : nil // "3314e13ce7fab539591cfa2d5c8e4a29105befdd9bc3398bbe457ef30448aa0c"

    /// If testing the development of Hound with its development database, then use this user identifier for a test account.
    static let developmentDatabaseTestUserIdentifier: String? = isProductionDatabase ? nil : "001473.77422360ac5b4f8aabf48f816149efe8.1644"

    /// All Hound servers, development or producton, support HTTPS only
    private static let urlScheme: String = isProductionAWSServer ? "https://" : "http://"
    /// The production server is attached to a real domain name, whereas our development server is off the local network
    private static let urlDomainName: String = {
        if isProductionAWSServer && isProductionDatabase {
            return "api.houndorganizer.com"
        }
        else if isProductionAWSServer && !isProductionDatabase {
            return "development.houndorganizer.com"
        }
        else {
            return "0.0.0.0"
        }
    }()
    /// The production server uses https on port 443 for the production database and 8443 for the development database. The development server always uses http on port 80.
    private static let urlPort: String = ":443"
    /// All Hound app requests go under the app path
    private static let urlAppPath: String = "/app"
    /// The base url that api requests go to
    static let url: String = urlScheme + urlDomainName + urlPort + urlAppPath
    /// The interval at which the date picker should display minutes. Use this property to set the interval displayed by the minutes wheel (for example, 15 minutes). The interval value must be evenly divided into 60; if it is not, the default value is used. The default and minimum values are 1; the maximum value is 30.
    static let minuteInterval = isProductionDatabase ? 5 : 1
}
//
//  Constant.Constraint.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/17/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

let maxScaleFactor = 1.3
let screenWidth = 414.0

public enum ConstraintConstant {
    enum Spacing {
        // MARK: Inset of All Content Elements From Bounding View
        static let absoluteHoriInset: CGFloat = 20.0
        static let absoluteVertInset: CGFloat = 10.0
        static let absoluteCircleHoriInset: CGFloat = 10.0
        
        // MARK: Spacing Between Content Elements
        static let contentTightIntraHori: CGFloat = 3.75
        static let contentIntraHori: CGFloat = 7.5
        
        static let contentTightIntraVert: CGFloat = 3.75
        static let contentIntraVert: CGFloat = 7.5
        static let contentTallIntraVert: CGFloat = 22.5
        static let contentSectionVert: CGFloat = 45.0
    }
    enum Text {
        // MARK: Header Label & Spacing
        static let megaHeaderLabelHeightMultipler: CGFloat = Self.primaryHeaderLabelHeightMultipler * (Constant.Visual.Font.megaHeaderLabel.pointSize / Constant.Visual.Font.primaryHeaderLabel.pointSize)
        static let megaHeaderLabelMaxHeight: CGFloat = Self.primaryHeaderLabelMaxHeight * (Constant.Visual.Font.megaHeaderLabel.pointSize / Constant.Visual.Font.primaryHeaderLabel.pointSize)
        
        static let primaryHeaderLabelHeightMultipler: CGFloat = 40.0 / screenWidth
        static let primaryHeaderLabelMaxHeight: CGFloat = Self.primaryHeaderLabelHeightMultipler * screenWidth * maxScaleFactor
        
        // MARK: Section Label & Spacing
        static let sectionLabelHeightMultipler: CGFloat = 25.0 / screenWidth
        static let sectionLabelMaxHeight: CGFloat = Self.sectionLabelHeightMultipler * screenWidth * maxScaleFactor
        
        // MARK: Paw With Hands
        static let pawHeightMultiplier: CGFloat = 145.0 / screenWidth
        static let pawMaxHeight: CGFloat = Self.pawHeightMultiplier * screenWidth * maxScaleFactor
    }
    enum Button {
        // MARK: Full Size Circle Button
        static let largeCircleHeightMultiplier: CGFloat = 100.0 / screenWidth
        static let largeCircleMaxHeight: CGFloat = Self.largeCircleHeightMultiplier * screenWidth * maxScaleFactor
        
        // MARK: Mini Circle Button
        static let circleHeightMultiplier: CGFloat = 55.0 / screenWidth
        static let circleMaxHeight: CGFloat = Self.circleHeightMultiplier * screenWidth * maxScaleFactor
        
        // MARK: Tiny Button
        static let tinyHeightMultiplier: CGFloat = 18.75 / screenWidth
        static let tinyMaxHeight: CGFloat = Self.tinyHeightMultiplier * screenWidth * maxScaleFactor
        
        // MARK: Screen Width Circle Button
        static let wideHeightMultiplier: CGFloat = 60.0 / screenWidth
        static let wideMaxHeight: CGFloat = Self.wideHeightMultiplier * screenWidth * maxScaleFactor
        
        // MARK: Chevron Button
        static let chevronAspectRatio: CGFloat = 65.0 / 100.0
        static let chevronHeightMultiplier: CGFloat = 27.5 / screenWidth
        static let chevronMaxHeight: CGFloat = Self.chevronHeightMultiplier * screenWidth * maxScaleFactor
    }
    enum Input {
        // MARK: Text Input Field
        static let textFieldHeightMultiplier: CGFloat = 45.0 / screenWidth
        static let textFieldMaxHeight: CGFloat = Self.textFieldHeightMultiplier * screenWidth * maxScaleFactor
        
        // MARK: Text Input Field
        static let textViewHeightMultiplier: CGFloat = 135.0 / screenWidth
        static let textViewMaxHeight: CGFloat = Self.textViewHeightMultiplier * screenWidth * maxScaleFactor
        
        // MARK: Segmented Input Field
        static let segmentedHeightMultiplier: CGFloat = 37.5 / screenWidth
        static let segmentedMaxHeight: CGFloat = Self.segmentedHeightMultiplier * screenWidth * maxScaleFactor
        
        // MARK: Date Picker Field
        static let datePickerHeightMultiplier: CGFloat = 120.0 / screenWidth
        static let datePickerMaxHeight: CGFloat = Self.datePickerHeightMultiplier * screenWidth * maxScaleFactor
        
        static let megaDatePickerHeightMultiplier: CGFloat = datePickerHeightMultiplier * 2.25
        static let megaDatePickerMaxHeight: CGFloat = datePickerMaxHeight * 2.25
    }
}
//
//  Key Constants.swift
//  Hound
//
//  Created by Jonathan Xakellis on 9/21/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

public enum KeyConstant: String {

    // MARK: API Response Body

    // client and server
    case result
    case message
    case code
    case name
    case requestId
    case responseId

    // MARK: Family Information

    // client and server
    case familyHeadUserId
    case familyId
    case familyCode
    case familyIsLocked
    case familyKickUserId
    case familyActiveSubscription
    case familyMembers
    case familyHeadIsUser
    case previousFamilyMembers

    // MARK: User Information

    // client
    case userMiddleName
    case userNamePrefix
    case userNameSuffix
    case userNickname

    // client and server
    case userId
    case userIdentifier
    case userAppAccountToken
    case userEmail
    case userFirstName
    case userLastName
    case userNotificationToken

    // MARK: User Configuration
    
    // client
    case previousDogManagerSynchronization

    // client and server
    case userConfigurationInterfaceStyle
    case userConfigurationIsHapticsEnabled
    case userConfigurationMeasurementSystem
    
    case userConfigurationUsesDeviceTimeZone
    case userConfigurationUserTimeZone
    case userConfigurationDeviceTimeZone
    
    case userConfigurationSnoozeLength
    
    case userConfigurationIsNotificationEnabled
    case userConfigurationIsLoudNotificationEnabled
    case userConfigurationIsLogNotificationEnabled
    case userConfigurationIsReminderNotificationEnabled
    case userConfigurationNotificationSound
    
    case userConfigurationIsSilentModeEnabled
    case userConfigurationSilentModeStartHour
    case userConfigurationSilentModeEndHour
    case userConfigurationSilentModeStartMinute
    case userConfigurationSilentModeEndMinute

    // MARK: App Store Purchase

    // client
    case userPurchasedProduct
    case userPurchasedProductFromSubscriptionGroup20965379

    // client and server
    case appStoreReceiptURL
    case transactionId
    case productId
    case purchaseDate
    case expiresDate
    case numberOfFamilyMembers
    case isActive
    case autoRenewStatus
    case autoRenewProductId
    
    // MARK: Offline Sync Components
    
    case offlineModeComponents
    case offlineModeComponentsInitialAttemptedSyncDate
    case offlineModeComponentsInitialCreationDate
    
    case offlineModeDeletedObjectDeletedDate
    
    case offlineModeManagerShared
    case offlineModeManagerShouldUpdateUser
    case offlineModeManagerShouldGetUser
    case offlineModeManagerShouldGetFamily
    case offlineModeManagerShouldGetDogManager
    case offlineModeManagerOfflineModeDeletedObjects
    
    // MARK: Dog Manager

    // client
    case dogManager
    case dogs

    // MARK: Dog

    // client
    case dogIcon
    case dogLogs
    case dogReminders
    case dogTriggers

    // client and server
    case dogId
    case dogUUID
    case dogName
    case dogCreated
    case dogCreatedBy
    case dogLastModified
    case dogLastModifiedBy
    case dogIsDeleted

    // MARK: Log

    // client and server
    case logId
    case logUUID
    case logActionTypeId
    case logCustomActionName
    case logStartDate
    case logEndDate
    case logNote
    case logUnitTypeId
    case logNumberOfLogUnits
    case logCreatedByReminderUUID
    case logCreated
    case logCreatedBy
    case logLastModified
    case logLastModifiedBy
    case logLikedByUserIds
    case logIsDeleted

    // MARK: Reminder

    // client and server
    case reminderId
    case reminderUUID
    case reminderActionTypeId // also used for ReminderActionType
    case reminderCustomActionName
    case reminderType
    case reminderExecutionBasis
    case reminderExecutionDate
    case reminderIsTriggerResult
    case reminderIsEnabled
    case reminderRecipientUserIds
    case reminderTimeZone
    case reminderCreated
    case reminderCreatedBy
    case reminderLastModified
    case reminderLastModifiedBy
    case reminderIsDeleted
    
    // MARK: GlobalTypes
    
    case globalTypes
    case logActionType
    case reminderActionType
    case mappingLogActionTypeReminderActionType
    case logUnitType
    case mappingLogActionTypeLogUnitType
    
    // MARK: LogUnitType
    
    case unitSymbol
    case isImperial
    case isMetric
    case isUnitMass
    case isUnitVolume
    case isUnitLength
    
    // MARK: ReminderActionType/LogActionType/MappingLogActionTypeReminderActionType
    
    case mappingId
    case internalValue
    case readableValue // also LogUnitType
    case emoji
    case sortOrder
    case isDefault
    case allowsCustom
    
    // MARK: Reminder Trigger
    case triggerId
    case triggerUUID
    case triggerLogReactions
    case triggerReminderResult
    case triggerType
    case triggerTimeDelayComponents
    case triggerTimeDelay
    case triggerFixedTimeComponents
    case triggerFixedTimeType
    case triggerFixedTimeTypeAmount
    case triggerFixedTimeHour
    case triggerFixedTimeMinute
    case triggerManualCondition
    case triggerAlarmCreatedCondition
    case triggerCreated
    case triggerCreatedBy
    case triggerLastModified
    case triggerLastModifiedBy
    case triggerIsDeleted
    
    // MARK: Snooze Components

    // client
    case snoozeComponents
    // client and server
    case snoozeExecutionInterval

    // MARK: Countdown Components

    // client
    case countdownComponents
    // client and server
    case countdownExecutionInterval

    // MARK: Weekly Components

    // client
    case weeklyComponents
    // client and server
    case weeklyZonedHour
    case weeklyZonedMinute
    case weeklyZonedSunday
    case weeklyZonedMonday
    case weeklyZonedTuesday
    case weeklyZonedWednesday
    case weeklyZonedThursday
    case weeklyZonedFriday
    case weeklyZonedSaturday
    case weeklySkippedDate

    // MARK: Monthly Components

    // client
    case monthlyComponents
    // client and server
    case monthlyZonedDay
    case monthlyZonedHour
    case monthlyZonedMinute
    case monthlySkippedDate

    // MARK: One Time Components

    // client
    case oneTimeComponents
    // client and server
    case oneTimeDate
    
    // MARK: Survey Feedback
    
    case surveyFeedback
    case surveyFeedbackType
    case surveyFeedbackDeviceMetricModel
    case surveyFeedbackDeviceMetricSystemVersion
    case surveyFeedbackDeviceMetricAppVersion
    case surveyFeedbackDeviceMetricLocale
    case surveyFeedbackUserCancellationReason
    case surveyFeedbackUserCancellationFeedback
    case surveyFeedbackAppExperienceNumberOfStars
    case surveyFeedbackAppExperienceFeedback

    // MARK: Local

    // client
    case localIsNotificationAuthorized

    case localPreviousLogCustomActionNames
    case localPreviousReminderCustomActionNames

    case localPreviousDatesUserSurveyFeedbackAppExperienceRequested
    case localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted
    case localPreviousDatesUserReviewRequested

    case localAppVersionsWithReleaseNotesShown

    case localHasCompletedFirstTimeSetup
    case localHasCompletedHoundIntroductionViewController
    case localHasCompletedRemindersIntroductionViewController
    case localHasCompletedFamilyUpgradeIntroductionViewController

    case localAppVersion
    case localHasIncompatibleData
}
//
//  Notification Sound.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/6/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum NotificationSound: String, CaseIterable {
    init?(rawValue: String) {
        for sound in NotificationSound.allCases where sound.rawValue == rawValue {
            self = sound
            return
        }

        return nil
    }
    
    case radar = "Radar"
    // case apex = "Apex"
    // case beacon = "Beacon"
    // case bulletin = "Bulletin"
    // case byTheSeaside = "By The Seaside"
    // case chimes  = "Chimes"
    case circuit = "Circuit"
    // case constellation = "Constellation"
    // case cosmic = "Cosmic"
    // case crystals = "Crystals"
    // case hillside = "Hillside"
    case illuminate = "Illuminate"
    // case nightOwl = "Night Owl"
    // case opening = "Opening"
    // case playtime = "Playtime"
    case presto = "Presto"
    // case radiate = "Radiate"
    // case reflection = "Reflection"
    // case ripples = "Ripples"
    case sencha = "Sencha"
    case signal = "Signal"
    case silk = "Silk"
    // case slowRise = "Slow Rise"
    case stargaze = "Stargaze"
    // case summit = "Summit"
    case twinkle = "Twinkle"
    // case uplift = "Uplift"
    case waves = "Waves"
}
//
//  Unit Converter.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum LogUnitTypeConverter {
    
    /// For a given logUnit and its numberOfLogUnits, converts to the targetSystem. If the targetSystem is .both, then nothing is done as all units are acceptable. Otherwise, converts between imperial and metric. For example: 1 oz -> 28.3495 grams
    static func convert(forLogUnit logUnit: LogUnitType, forNumberOfLogUnits numberOfLogUnits: Double, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        guard targetSystem != .both else {
            // A system that supports both measurement types doesn't need to convert any units
            return (logUnit, numberOfLogUnits)
        }
        
        if logUnit.isUnitMass {
            return convertUnitMass(forMeasurement: Measurement(value: numberOfLogUnits, unit: UnitMass(symbol: logUnit.unitSymbol)), toTargetSystem: targetSystem)
        }
        else if logUnit.isUnitVolume {
            return convertUnitVolume(forMeasurement: Measurement(value: numberOfLogUnits, unit: UnitVolume(symbol: logUnit.unitSymbol)), toTargetSystem: targetSystem)
        }
        else if logUnit.isUnitLength {
            return convertUnitLength(forMeasurement: Measurement(value: numberOfLogUnits, unit: UnitLength(symbol: logUnit.unitSymbol)), toTargetSystem: targetSystem)
        }
        
        // Some units can't be converted, e.g. treats
        return (logUnit, numberOfLogUnits)
    }
    
    /// For a given Measurement<UnitMass>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than conversionThreshholdToNextUnit. For example: 4.5 kg is too small, so 450 grams is chosen. 5.5 kg is great enough (> threshhold), so 5.5 kg is chosen.
    private static func convertUnitMass(forMeasurement measurement: Measurement<UnitMass>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        let gt = GlobalTypes.shared else {
            return nil
        }
        let conversionTypes =
        switch targetSystem {
        case .imperial:
            let lbConversion = measurement.converted(to: UnitMass.pounds)
            let ozConversion = measurement.converted(to: UnitMass.ounces)
            if lbConversion.value > 1.0 {
                return (.lb, lbConversion.value)
            }
            else {
                return (.oz, ozConversion.value)
            }
        case .metric, .both:
            // .both should never happen, but if it does, fall through to metric
            let kgConversion = measurement.converted(to: UnitMass.kilograms)
            let gConversion = measurement.converted(to: UnitMass.grams)
            let mgConversion = measurement.converted(to: UnitMass.milligrams)
            
            if kgConversion.value > conversionThreshholdToNextUnit {
                return (.kg, kgConversion.value)
            }
            else if gConversion.value > conversionThreshholdToNextUnit {
                return (.g, gConversion.value)
            }
            else {
                return (.mg, mgConversion.value)
            }
        }
    }
    
    /// For a given Measurement<UnitVolume>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than 1.0. For example: 4.5 kg is too small, so 450 grams is chosen. 5.5 kg is great enough (> threshhold), so 5.5 kg is chosen.
    private static func convertUnitVolume(forMeasurement measurement: Measurement<UnitVolume>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnit, Double) {
        switch targetSystem {
        case .imperial:
            let cupsConversion = measurement.converted(to: UnitVolume.cups)
            let flOzConversion = measurement.converted(to: UnitVolume.fluidOunces)
            let tbspConversion = measurement.converted(to: UnitVolume.tablespoons)
            let tspConversion = measurement.converted(to: UnitVolume.teaspoons)
            
            if cupsConversion.value > 1.0 {
                return (.cup, cupsConversion.value)
            }
            else if flOzConversion.value > 1.0 {
                return (.flOz, flOzConversion.value)
            }
            else if tbspConversion.value > 1.0 {
                return (.tbsp, tbspConversion.value)
            }
            else {
                return (.tsp, tspConversion.value)
            }
        case .metric, .both:
            // .both should never happen, but if it does, fall through to metric
            let lConversion = measurement.converted(to: UnitVolume.liters)
            let mlConversion = measurement.converted(to: UnitVolume.milliliters)
            
            if lConversion.value > 1.0 {
                return (.l, lConversion.value)
            }
            else {
                return (.ml, mlConversion.value)
            }
        }
    }
    
    /// For a given Measurement<UnitLength>, converts it into the units for the targetSystem.Then selects the highest conversion unit where its value is greater than conversionThreshholdToNextUnit. For example: 4.5 kg is too small, so 450 grams is chosen. 5.5 kg is great enough (> threshhold), so 5.5 kg is chosen.
    private static func convertUnitLength(forMeasurement measurement: Measurement<UnitLength>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnit, Double) {
        switch targetSystem {
        case .imperial:
            let milesConversion = measurement.converted(to: UnitLength.miles)
            
            return (.mi, milesConversion.value)
        case .metric, .both:
            // .both should never happen, but if it does, fall through to metric
            let kmConversion = measurement.converted(to: UnitLength.kilometers)
            
            return (.km, kmConversion.value)
        }
    }
    
}
//
//  SurveyFeedbackType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/31/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum SurveyFeedbackType: String, CaseIterable {
    case cancelSubscription
    case appExperience
}
//
//  Unit Converter.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum LogUnitTypeConverter {
    
    /// For a given logUnitType and its numberOfLogUnits, converts to the targetSystem. If the targetSystem is .both, then nothing is done as all units are acceptable. Otherwise, converts between imperial and metric. For example: 1 oz -> 28.3495 grams
    static func convert(logUnitType: LogUnitType, numberOfLogUnits: Double, toTargetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        
        // If the target system accepts both measurement systems, no conversion is needed
        guard toTargetSystem != .both else {
            return (logUnitType, numberOfLogUnits)
        }
        
        // If the log unit already belongs to the target system, leave it as is
        if (toTargetSystem == .imperial && logUnitType.isImperial) ||
            (toTargetSystem == .metric && logUnitType.isMetric) {
            return (logUnitType, numberOfLogUnits)
        }
        
        if logUnitType.isUnitMass, let unit = UnitMass.from(symbol: logUnitType.unitSymbol) {
            return convertUnitMass(measurement: Measurement(value: numberOfLogUnits, unit: unit), toTargetSystem: toTargetSystem)
        }
        else if logUnitType.isUnitVolume, let unit = UnitVolume.from(symbol: logUnitType.unitSymbol) {
            return convertUnitVolume(measurement: Measurement(value: numberOfLogUnits, unit: unit), toTargetSystem: toTargetSystem)
        }
        else if logUnitType.isUnitLength, let unit = UnitLength.from(symbol: logUnitType.unitSymbol) {
            return convertUnitLength(measurement: Measurement(value: numberOfLogUnits, unit: unit), toTargetSystem: toTargetSystem)
        }
        
        // Some units can't be converted, e.g. treats
        return (logUnitType, numberOfLogUnits)
    }
    
    /// For a given Measurement<UnitVolume>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than 1.0. For example: .5 kg is too small, so 500 grams is chosen. 1.0 kg is great enough (> threshhold), so 1.0 kg is chosen.
    private static func convertUnitMass(measurement: Measurement<UnitMass>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        let conversions = GlobalTypes.shared.logUnitTypes.filter { logUnitType in
            return logUnitType.isUnitMass && UnitMass.from(symbol: logUnitType.unitSymbol) != nil
        }
            .filter { logUnitType in
                switch targetSystem {
                case .imperial: return logUnitType.isImperial
                case .metric: return logUnitType.isMetric
                case .both: return logUnitType.isMetric || logUnitType.isImperial
                }
            }
            .compactMap { lut in
                let unit = UnitMass.from(symbol: lut.unitSymbol)! // swiftlint:disable:this force_unwrapping
                let converted = measurement.converted(to: unit).value
                return (lut, converted)
            }
        
        // We want to return the conversion with the greatest type and a value above 1.0
        // e.g. if we have 24 oz and 1.5 lbs, we want 1.5 lbs since that is a greater unit, but if 8 oz and 0.5 lbs, then return oz
        
        // Sort ascending by the converted value
        let sortedByValue = conversions.sorted { $0.1 < $1.1 }
        
        // Find all with value > 1.0
        let aboveOne = sortedByValue.filter { $0.1 > 1.0 }
        
        // 4) If any > 1.0, pick the last (largest); otherwise pick the final entry in sorted list
        if let best = aboveOne.first {
            return (best.0, best.1)
        }
        
        let fallback = sortedByValue.first! // swiftlint:disable:this force_unwrapping
        return (fallback.0, fallback.1)
    }
    
    /// For a given Measurement<UnitVolume>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than 1.0. For example: .5 kg is too small, so 500 grams is chosen. 1.0 kg is great enough (> threshhold), so 1.0 kg is chosen.
    private static func convertUnitVolume(measurement: Measurement<UnitVolume>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        let conversions = GlobalTypes.shared.logUnitTypes.filter { lut in
            return lut.isUnitVolume && UnitVolume.from(symbol: lut.unitSymbol) != nil
        }
            .filter { logUnitType in
                switch targetSystem {
                case .imperial: return logUnitType.isImperial
                case .metric: return logUnitType.isMetric
                case .both: return logUnitType.isMetric || logUnitType.isImperial
                }
            }
            .compactMap { lut in
                let unit = UnitVolume.from(symbol: lut.unitSymbol)! // swiftlint:disable:this force_unwrapping
                let converted = measurement.converted(to: unit).value
                return (lut, converted)
            }
        
        // We want to return the conversion with the greatest type and a value above 1.0
        // e.g. if we have 24 oz and 1.5 lbs, we want 1.5 lbs since that is a greater unit, but if 8 oz and 0.5 lbs, then return oz
        
        // Sort ascending by the converted value
        let sortedByValue = conversions.sorted { $0.1 < $1.1 }
        
        // Find all with value > 1.0
        let aboveOne = sortedByValue.filter { $0.1 > 1.0 }
        
        // 4) If any > 1.0, pick the last (largest); otherwise pick the final entry in sorted list
        if let best = aboveOne.first {
            return (best.0, best.1)
        }
        
        let fallback = sortedByValue.first! // swiftlint:disable:this force_unwrapping
        return (fallback.0, fallback.1)
    }
    
    /// For a given Measurement<UnitVolume>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than 1.0. For example: .5 kg is too small, so 500 grams is chosen. 1.0 kg is great enough (> threshhold), so 1.0 kg is chosen.
    private static func convertUnitLength(measurement: Measurement<UnitLength>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        let conversions = GlobalTypes.shared.logUnitTypes.filter { lut in
            return lut.isUnitLength && UnitLength.from(symbol: lut.unitSymbol) != nil
        }
            .filter { logUnitType in
                switch targetSystem {
                case .imperial: return logUnitType.isImperial
                case .metric: return logUnitType.isMetric
                case .both: return logUnitType.isMetric || logUnitType.isImperial
                }
            }
            .compactMap { lut in
                let unit = UnitLength.from(symbol: lut.unitSymbol)! // swiftlint:disable:this force_unwrapping
                let converted = measurement.converted(to: unit).value
                return (lut, converted)
            }
        
        // We want to return the conversion with the greatest type and a value above 1.0
        // e.g. if we have 24 oz and 1.5 lbs, we want 1.5 lbs since that is a greater unit, but if 8 oz and 0.5 lbs, then return oz
        
        // Sort ascending by the converted value
        let sortedByValue = conversions.sorted { $0.1 < $1.1 }
        
        // Find all with value > 1.0
        let aboveOne = sortedByValue.filter { $0.1 > 1.0 }
        
        // 4) If any > 1.0, pick the last (largest); otherwise pick the final entry in sorted list
        if let best = aboveOne.first {
            return (best.0, best.1)
        }
        
        let fallback = sortedByValue.first! // swiftlint:disable:this force_unwrapping
        return (fallback.0, fallback.1)
    }
    
}
//
//  NSLayoutConstraintExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/17/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension NSLayoutConstraint {
    @discardableResult
    func constraintWithMultiplier(_ multiplier: CGFloat) -> NSLayoutConstraint {
        // Deactivate the original constraint before creating the new one
        self.isActive = false

        // Create new constraint copying all the parameters but changing the multiplier
        let newConstraint = NSLayoutConstraint(
            item: self.firstItem as Any,
            attribute: self.firstAttribute,
            relatedBy: self.relation,
            toItem: self.secondItem,
            attribute: self.secondAttribute,
            multiplier: multiplier,
            constant: self.constant
        )
        // Copy priority and identifier
        newConstraint.priority = self.priority
        newConstraint.identifier = self.identifier

        // Activate the new constraint
        newConstraint.isActive = true

        return newConstraint
    }
    
    func withPriority(_ priority: UILayoutPriority) -> NSLayoutConstraint {
        self.priority = priority
        return self
    }
}
//
//  CalendarExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/23/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension Calendar {
    func range(of component: Calendar.Component, in larger: Calendar.Component, for date: Date, in timeZone: TimeZone) -> Range<Int>? {
        var calendar = self
        calendar.timeZone = timeZone
        return calendar.range(of: component, in: larger, for: date)
    }
    
    static func fromZone(_ timeZone: TimeZone) -> Calendar {
        var calendar = Calendar(identifier: .gregorian)
        calendar.timeZone = timeZone
        return calendar
    }
    
    static var user: Calendar {
        return Calendar.fromZone(UserConfiguration.timeZone)
    }
}
//
//  UIColorExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/8/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIColor {
    static let houndYellow: UIColor = {
        return UIColor { traitCollection in
            //            if traitCollection.userInterfaceStyle == .dark {
            //                // Softer, richer yellow for dark backgrounds
            //                return UIColor(red: 235.0 / 255, green: 205.0 / 255, blue: 15.0 / 255, alpha: 1.0)
            //            }
            //            else {
            //                // Gentle, pastel yellow for light backgrounds
            //                return UIColor(red: 250.0 / 255, green: 220.0 / 255, blue: 30.0 / 255, alpha: 1.0)
            //            }
            if traitCollection.userInterfaceStyle == .dark {
                // Deeper yellow for dark mode
                return UIColor(red: 255.0 / 255.0, green: 193.0 / 255.0, blue: 7.0 / 255.0, alpha: 1.0)
            }
            else {
                // Brighter yellow for light mode
                return UIColor(red: 255.0 / 255.0, green: 215.0 / 255.0, blue: 0.0 / 255.0, alpha: 1.0)
            }
        }
    }()
}
//
//  NotificationNameExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension Notification.Name {
    static let didUpdateUserInterfaceStyle = Notification.Name("didUpdateUserInterfaceStyle")
    /// Posted when the user's time zone changes. Views observing this should
    /// refresh any displayed times. The `TimeZoneMonitor` automatically posts
    /// this notification when the system time zone updates, including daylight
    /// savings transitions
    static let didUpdateUserTimeZone = Notification.Name("didUpdateUserTimeZone")
}
//
//  ArrayExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 10/18/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension Array {
    subscript(safe index: Index) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}

extension Array where Element: CustomStringConvertible {
    func joined(separator: String, endingSeparator: String) -> String {
        switch count {
        case 0: return ""
        case 1: return self[0].description
        case 2: return self.map { $0.description }.joined(separator: endingSeparator)
        default:
            let allButLast = self.dropLast().map { $0.description }.joined(separator: separator)
            return "\(allButLast)\(endingSeparator)\(self.last!.description)" // swiftlint:disable:this force_unwrapping
        }
    }
}
//
//  IntExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/24/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension Int {
    /// Takes the given day of month and appends an appropiate suffix of st, nd, rd, or th, e.g. 31 returns st, 20 returns th, 2 returns nd
    func daySuffix() -> String {
        switch self {
        case 1, 21, 31:
            return "st"
        case 2, 22:
            return "nd"
        case 3, 23:
            return "rd"
        default:
            return "th"
        }
    }
    
    /**
     Converts a `TimeInterval` to a human-readable string.
     
     - Parameters:
       - capitalizeWords: If `true`, capitalizes the first letter of each time component.
       - abbreviationLevel: The abbreviation level to use (`.short`, `.medium`, or `.long`).
       - maxComponents: The maximum number of time components to display.
       - enforceSequentialComponents: If `true`, only display adjacent nonzero time units (e.g., "2h 5m", never "2h 0m").
     */
    func readable(
        capitalizeWords: Bool = false,
        abbreviationLevel: AbbreviationLevel = .medium,
        maxComponents: Int? = nil,
        enforceSequentialComponents: Bool = false
    ) -> String {
        return Double(self).readable(capitalizeWords: capitalizeWords, abbreviationLevel: abbreviationLevel, maxComponents: maxComponents, enforceSequentialComponents: enforceSequentialComponents)
    }
}
//
//  NSCoderExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/22/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension NSCoder {
    func decodeOptionalInteger(forKey key: String) -> Int? {
        return containsValue(forKey: key) ? decodeInteger(forKey: key) : nil
    }
    
    func decodeOptionalBool(forKey key: String) -> Bool? {
        return containsValue(forKey: key) ? decodeBool(forKey: key) : nil
    }
    
    func decodeOptionalDouble(forKey key: String) -> Double? {
        return containsValue(forKey: key) ? decodeDouble(forKey: key) : nil
    }
    
    func decodeOptionalFloat(forKey key: String) -> Float? {
        return containsValue(forKey: key) ? decodeFloat(forKey: key) : nil
    }
    
    func decodeOptionalString(forKey key: String) -> String? {
        return decodeOptionalObject(forKey: key)
    }
    
    func decodeOptionalObject<T>(forKey key: String) -> T? {
        return containsValue(forKey: key) ? decodeObject(forKey: key) as? T : nil
    }
}
//
//  UUIDExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/10/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension UUID {
    static func fromString(UUIDString: String?) -> UUID? {
        guard let UUIDString = UUIDString else {
            return nil
        }
        
        return UUID(uuidString: UUIDString)
    }
}
//
//  TimeIntervalExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/18/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum AbbreviationLevel {
    case short   // e.g. "5s"
    case medium  // e.g. "5 sec"
    case long    // e.g. "5 seconds"
}

extension Double {
    /**
     Converts a `Double` to a human-readable string.
     
     - Parameters:
       - capitalizeWords: If `true`, capitalizes the first letter of each time component.
       - abbreviationLevel: The abbreviation level to use (`.short`, `.medium`, or `.long`).
       - maxComponents: The maximum number of time components to display.
       - enforceSequentialComponents: If `true`, only display adjacent nonzero time units (e.g., "2h 5m", never "2h 0m").
     */
    func readable(
        capitalizeWords: Bool = false,
        abbreviationLevel: AbbreviationLevel = .medium,
        maxComponents: Int? = nil,
        enforceSequentialComponents: Bool = false
    ) -> String {
        
        // Convert total seconds to absolute integer value for easier processing
        let totalSeconds = abs(Int(self.rounded()))
        
        // Split into time units (weeks, days, hours, minutes, seconds)
        let units: [(value: Int, short: String, medium: String, long: String)] = [
            (totalSeconds / 604800, "w", "wk", "week"),                         // weeks
            ((totalSeconds % 604800) / 86400, "d", "day", "day"),               // days
            ((totalSeconds % 86400) / 3600, "h", "hr", "hour"),                 // hours
            ((totalSeconds % 3600) / 60, "m", "min", "minute"),                 // minutes
            (totalSeconds % 60, "s", "sec", "second")                           // seconds
        ]
        
        // Helper function to format a single unit string according to abbreviation style
        func formattedUnit(value: Int, short: String, medium: String, long: String) -> String {
            switch abbreviationLevel {
            case .short:
                return "\(value)\(short)"
            case .medium:
                return "\(value) \(value == 1 ? medium : "\(medium)s")"
            case .long:
                return "\(value) \(value == 1 ? long : "\(long)s")"
            }
        }
        
        var components: [String] = []
        
        if enforceSequentialComponents {
            // Find the first nonzero unit (e.g., first is hours for 1h 5m)
            guard let firstNonzeroIndex = units.firstIndex(where: { $0.value > 0 }) else {
                // All components are zero, show "0 seconds" in selected abbreviation style
                return formattedUnit(value: 0, short: "s", medium: "sec", long: "second")
            }
            
            let maxSequential = maxComponents ?? units.count
            var sequentialCount = 0
            
            // Only add consecutive nonzero units after the first, stop if a zero is found
            for i in firstNonzeroIndex..<units.count {
                let (value, short, medium, long) = units[i]
                if value == 0 { break }
                components.append(formattedUnit(value: value, short: short, medium: medium, long: long))
                sequentialCount += 1
                if sequentialCount >= maxSequential { break }
            }
        }
        else {
            // Collect up to maxComponents nonzero units, regardless of adjacency
            var nonzeroCount = 0
            for (value, short, medium, long) in units {
                guard value > 0 else { continue }
                if let maxComponents, nonzeroCount >= maxComponents { break }
                components.append(formattedUnit(value: value, short: short, medium: medium, long: long))
                nonzeroCount += 1
            }
            // If all components are zero, return "0 seconds" (or the equivalent)
            if components.isEmpty {
                return formattedUnit(value: 0, short: "s", medium: "sec", long: "second")
            }
        }
        
        // Apply capitalization if needed, then join with spaces
        return components
            .map { capitalizeWords ? $0.capitalized : $0.lowercased() }
            .joined(separator: " ")
    }
}
//
//  UIPasteboardExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/3/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIPasteboard {
    /// Assigns UIPasteboard.general.string to string then shows a banner to confirm to the user that the specified information was copied.
    func setPasteboard(string: String) {
        UIPasteboard.general.string = string

        PresentationManager.enqueueBanner(title: Constant.Visual.BannerText.copiedToClipboardTitle, subtitle: Constant.Visual.BannerText.copiedToClipboardSubtitle, style: .success)
    }
}
//
//  StringExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/5/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension String {
    
    static func convert(hour: Int, minute: Int) -> String {
        // Build a date with the hour/minute (date is arbitrary, e.g., Jan 1, 2000)
        var components = DateComponents()
        components.year = 2000
        components.month = 1
        components.day = 1
        components.hour = hour
        components.minute = minute
        // leave as Calendar.curent. we already have the hour and minute, just need it in a readable time
        guard let date = Calendar.current.date(from: components) else {
            return "\(hour):\(String(format: "%02d", minute))"
        }

        return date.formatted(date: .omitted, time: .shortened)
    }

    /// Only works if the label it is being used on has a single line of text OR has its paragraphs predefined with \n (s).
    func bounding(font: UIFont, height: CGFloat? = nil, width: CGFloat? = nil) -> CGSize {
        let attributedString = NSAttributedString(string: self, attributes: [.font: font])

        let greatestFiniteMagnitudeBounding = attributedString.boundingRect(with:
                                                                    CGSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude), options: .usesLineFragmentOrigin, context: nil)
        let boundHeight = height ?? greatestFiniteMagnitudeBounding.height
        let boundWidth = width ?? greatestFiniteMagnitudeBounding.width

        return CGSize(width: boundWidth, height: boundHeight)

    }

    /// Takes an ISO8601 string from the Hound server then attempts to create a Date
    func formatISO8601IntoDate() -> Date? {
        // from client
        // 2023-04-06T21:03:15Z
        // from server
        // 2023-04-12T20:40:00.000Z
        let formatterWithMilliseconds = Foundation.ISO8601DateFormatter()
        formatterWithMilliseconds.formatOptions = [.withFractionalSeconds, .withDashSeparatorInDate, .withColonSeparatorInTime, .withFullDate, .withTime]

        let formatterWithoutMilliseconds = Foundation.ISO8601DateFormatter()
        formatterWithoutMilliseconds.formatOptions = [.withDashSeparatorInDate, .withColonSeparatorInTime, .withFullDate, .withTime]

        return formatterWithMilliseconds.date(from: self) ?? formatterWithoutMilliseconds.date(from: self)

    }

    /// If string contains a , or a ",  replaces all occurances of double-quotes with a pair of double quotes then encloses field in double quotes
    func formatIntoCSV() -> String {
        var string = self

        // The string only needs to be modified if it contains double-quotes or commas
        guard string.contains("\"") || string.contains(",") else {
            return string
        }

        // Literal double-quote characters in a CSV are typically represented by a pair of double-quotes.
        string = string.replacingOccurrences(of: "\"", with: "\"\"")

        // To encode a field containing a comma or double-quotes, we must enclose the field in double quotes.
        string = "\"" + string + "\""

        return string
    }
    
    func hasText() -> Bool {
        return self.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false
    }
    
    /// Helper to replace all kinds of non-breaking/narrow spaces with regular spaces
    func normalizeSpaces() -> String {
        self.replacingOccurrences(of: "\u{202F}", with: " ").replacingOccurrences(of: "\u{00A0}", with: " ")
    }
}
//
//  TimeZoneExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/24/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension TimeZone {
    
    // Prevent repetitive recalculation of these static properties by caching them
    private struct Cache {
        static let houndTimeZones: [TimeZone] = {
            TimeZone.knownTimeZoneIdentifiers
                .compactMap { TimeZone(identifier: $0) }
                .sorted {
                    let gmtA = $0.secondsFromGMT()
                    let gmtB = $1.secondsFromGMT()
                    if gmtA != gmtB {
                        return gmtA < gmtB
                    }
                    else {
                        return $0.displayName().localizedCaseInsensitiveCompare($1.displayName()) == .orderedAscending
                    }
                }
        }()
        
        static let genericNameCounts: [String: Int] = {
            var counts = [String: Int]()
            for id in TimeZone.knownTimeZoneIdentifiers {
                if let tz = TimeZone(identifier: id) {
                    let name = tz.localizedName(for: .generic, locale: .current) ?? tz.identifier
                    counts[name, default: 0] += 1
                }
            }
            return counts
        }()
    }
    
    static var houndTimeZones: [TimeZone] {
        return Cache.houndTimeZones
    }
    
    func displayName(currentTimeZone: TimeZone? = nil) -> String {
        let genericName = self.localizedName(for: .generic, locale: .current) ?? ""
        let cityName = self.identifier.components(separatedBy: "/").last?.replacingOccurrences(of: "_", with: " ") ?? self.identifier
        
        let seconds = self.secondsFromGMT()
        let hours = abs(seconds) / 3600
        let minutes = (abs(seconds) % 3600) / 60
        let sign = seconds >= 0 ? "+" : "-"
        let offsetString = String(format: "%@%02d:%02d", sign, hours, minutes)
        
        let currentSuffix = (self.identifier == currentTimeZone?.identifier) ? " (Current)" : ""
        // Example: "Pacific Time (Los Angeles) -08:00"
        // Only show city if genericName is not unique
        let needsCity = (Cache.genericNameCounts[genericName] ?? 0) > 1
        
        if needsCity {
            return "\(genericName) (\(cityName)) \(offsetString)\(currentSuffix)"
        }
        else {
            return "\(genericName) \(offsetString)\(currentSuffix)"
        }
    }
    
    // MARK: - Time Zone Constructions
    
    /// Creates a TimeZone from an identifier string, or returns nil if the string is invalid or nil.
    static func from(_ str: String?) -> TimeZone? {
        guard let str = str else { return nil }
        return TimeZone(identifier: str)
    }
    
    // MARK: - Conversions
    
    /// Converts a (hour, minute) in this time zone to the same wall time in a target time zone, for display.
    /// Always uses a fixed reference date (2000-01-01) to avoid DST edge cases.
    func convert(hour: Int, minute: Int, to destinationTimeZone: TimeZone, referenceDate: Date) -> (hour: Int, minute: Int) {
        guard self != destinationTimeZone else {
            return (hour, minute)
        }
        let sourceCalendar = Calendar.fromZone(self)
        var components = sourceCalendar.dateComponents([.year, .month, .day], from: referenceDate)
        components.hour = hour
        components.minute = minute
        components.second = 0
        
        guard let dateInSource = sourceCalendar.date(from: components) else {
            return (hour, minute)
        }
        
        let destCalendar = Calendar.fromZone(destinationTimeZone)
        let targetComponents = destCalendar.dateComponents([.hour, .minute], from: dateInSource)
        return (targetComponents.hour ?? hour, targetComponents.minute ?? minute)
    }
    
    /// Converts a list of weekdays (from this time zone) to their equivalents in the target time zone, for a given hour/minute.
    /// Always uses a fixed reference week (starting 2000-01-02) to ensure the weekday value is deterministic.
    func convert(weekdays: [Weekday], hour: Int, minute: Int, to destinationTimeZone: TimeZone, referenceDate: Date) -> [Weekday] {
        guard self != destinationTimeZone else {
            return weekdays // No conversion needed
        }
        var targetWeekdays = Set<Weekday>()
        let sourceCalendar = Calendar.fromZone(self)
        let destCalendar = Calendar.fromZone(destinationTimeZone)
        
        let referenceSunday = sourceCalendar.nextDate(
                after: referenceDate,
                matching: DateComponents(weekday: 1), // 1 = Sunday in Foundation
                matchingPolicy: .nextTime,
                direction: .backward
            ) ?? referenceDate
        
        for weekday in weekdays {
            // Compute the offset from Sunday to the target weekday
            let offset = (weekday.rawValue - 1) // 1=Sunday, 2=Monday, etc.
            guard let dateForWeekday = sourceCalendar.date(byAdding: .day, value: offset, to: referenceSunday) else { continue }
            
            var components = sourceCalendar.dateComponents([.year, .month, .day], from: dateForWeekday)
            components.hour = hour
            components.minute = minute
            components.second = 0
            
            guard let dateInSource = sourceCalendar.date(from: components) else { continue }
            let targetComponents = destCalendar.dateComponents([.weekday], from: dateInSource)
            if let targetWeekdayValue = targetComponents.weekday,
               let targetWeekday = Weekday(rawValue: targetWeekdayValue) {
                targetWeekdays.insert(targetWeekday)
            }
        }
        return Array(targetWeekdays).sorted()
    }
    
    /// Converts a day-of-month/hour/minute from this (zoned/source) time zone into the destination time zone,
    /// including roll-under for months with fewer days, and proper handling of DST/cross-midnight transitions.
    /// - Parameters:
    ///   - day: The user-selected day of the month in the source time zone (1-31)
    ///   - hour: User-selected hour in source time zone
    ///   - minute: User-selected minute in source time zone
    ///   - destinationTimeZone: The tz to display for the user
    ///   - referenceDate: Any date in the desired month (typically next execution date or today)
    /// - Returns: (day, hour, minute) in the destination time zone, after all corrections.
    func convert(
        day: Int,
        hour: Int,
        minute: Int,
        to destinationTimeZone: TimeZone,
        referenceDate: Date
    ) -> (day: Int, hour: Int, minute: Int) {
        guard self != destinationTimeZone else {
            return (day, hour, minute) // No conversion needed
        }
        let sourceCalendar = Calendar.fromZone(self)
        
        // Clamp day to last valid day in zoned (source) time zone for month of referenceDate
        let daysInMonthSource = sourceCalendar.range(of: .day, in: .month, for: referenceDate, in: self)?.count ?? day
        let clampedDay = min(day, daysInMonthSource)
        
        // Build the source (zoned) date
        var components = sourceCalendar.dateComponents([.year, .month], from: referenceDate)
        components.day = clampedDay
        components.hour = hour
        components.minute = minute
        components.second = 0
        
        guard let sourceDate = sourceCalendar.date(from: components) else {
            // Defensive: fallback if we can't create a date
            return (clampedDay, hour, minute)
        }
        
        let destinationCalendar = Calendar.fromZone(destinationTimeZone)
        
        // Convert date to destination tz and get day/hour/minute in target tz
        let destComponents = destinationCalendar.dateComponents([.day, .hour, .minute], from: sourceDate)
        
        // Clamp day to last day of month in dest time zone
        let daysInDestMonth = destinationCalendar.range(of: .day, in: .month, for: sourceDate)?.count ?? (destComponents.day ?? clampedDay)
        
        let destDay = min(destComponents.day ?? clampedDay, daysInDestMonth)
        let destHour = destComponents.hour ?? hour
        let destMinute = destComponents.minute ?? minute
        return (destDay, destHour, destMinute)
    }
}
//
//  SKProductExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/14/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import StoreKit

extension SKProduct {
    // Attempts to use subscriptionPeriod unit and numberOfUnits to calculate an approximate monthly price, assuming 30 days / month.
    var monthlySubscriptionPrice: Double? {
        // what unit we are using: day, week, month, year
        let periodUnit = self.subscriptionPeriod?.unit
        // how many of the unit: x days, x weeks, x months, x years
        let numberOfUnits = self.subscriptionPeriod?.numberOfUnits

        guard let periodUnit = periodUnit, let numberOfUnits = numberOfUnits else {
            return nil
        }

        let numberOfMonths: Double? = {
            switch periodUnit {
            case .day:
                // days / 30 = months,
                return Double(numberOfUnits) / 30.0
            case .week:
                // weeks * 7 = days, days / 30 = months
                return (Double(numberOfUnits) * 7.0) / 30.0
            case .month:
                return Double(numberOfUnits)
            case .year:
                // years * 12 = months
                return Double(numberOfUnits) * 12.0
            default:
                return nil
            }
        }()

        guard let numberOfMonths = numberOfMonths else {
            return nil
        }

        var monthlySubscriptionPrice: Double = Double(truncating: self.price.dividing(by: NSDecimalNumber(value: numberOfMonths)))
        // truncate to 2 decimal places
        monthlySubscriptionPrice = floor(100 * monthlySubscriptionPrice) / 100
        return monthlySubscriptionPrice

    }

    /// Every SKProduct has a calculable monthlySubscriptionPrice. That means a certain SKProduct in subscriptionProducts will have the highest value of monthlySubscriptionPrice. If we take maximumMonthlySubscriptionPrice and apply it to the time frame of the subscription offered by this product, then we get the "full" price of this product. That is to say, we get the price that this product would cost if we use the highest possible price per time period. For example: 1 month $19.99 and 6 months $59.99. That would make the 1 month's fullPrice $19.99 and 6 month's fullPrice $119.99.
    var fullPrice: Double? {
        let maximumMonthlySubscriptionPrice: Double? = {
            // Find the SKProduct in subscriptionProducts with the highest value of monthlySubscriptionPrice
            var maximumMonthlySubscriptionPrice: Double?

            for product in InAppPurchaseManager.subscriptionProducts {
                guard let monthlySubscriptionPrice = product.monthlySubscriptionPrice else {
                    continue
                }

                maximumMonthlySubscriptionPrice = max(monthlySubscriptionPrice, maximumMonthlySubscriptionPrice ?? 0.0)
            }
            
            return maximumMonthlySubscriptionPrice
        }()
        
        guard let maximumMonthlySubscriptionPrice = maximumMonthlySubscriptionPrice else {
            return nil
        }

        // what unit we are using: day, week, month, year
        let periodUnit = self.subscriptionPeriod?.unit
        // how many of the unit: x days, x weeks, x months, x years
        let numberOfUnits = self.subscriptionPeriod?.numberOfUnits

        guard let periodUnit = periodUnit, let numberOfUnits = numberOfUnits else {
            return nil
        }

        let numberOfMonths: Double? = {
            switch periodUnit {
            case .day:
                // days / 30 = months,
                return Double(numberOfUnits) / 30.0
            case .week:
                // weeks * 7 = days, days / 30 = months
                return (Double(numberOfUnits) * 7.0) / 30.0
            case .month:
                return Double(numberOfUnits)
            case .year:
                // years * 12 = months
                return Double(numberOfUnits) * 12.0
            default:
                return nil
            }
        }()

        guard let numberOfMonths = numberOfMonths else {
            return nil
        }

        var fullPrice = numberOfMonths * maximumMonthlySubscriptionPrice
        
        // truncate to 2 decimal places
        fullPrice = floor(100 * fullPrice) / 100
        
        return fullPrice
    }
}
//
//  DateExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 12/8/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum HoundDateFormat {
    case formatStyle(date: Date.FormatStyle.DateStyle, time: Date.FormatStyle.TimeStyle)
    case template(String)
    
    /// Returns a formatted string for the supplied date based on the style, in the given time zone.
    func string(from date: Date, displayTimeZone: TimeZone) -> String {
        switch self {
        case let .formatStyle(dateStyle, timeStyle):
            let style = Date.FormatStyle(date: dateStyle, time: timeStyle, timeZone: displayTimeZone)
            return date.formatted(style)
        case let .template(template):
            let formatter = DateFormatter()
            formatter.setLocalizedDateFormatFromTemplate(template)
            formatter.timeZone = displayTimeZone
            return formatter.string(from: date)
        }
    }
}

extension Date {
    
    func ISO8601FormatWithFractionalSeconds() -> String {
        self.ISO8601Format(Date.ISO8601FormatStyle.init(dateSeparator: .dash, dateTimeSeparator: .standard, timeSeparator: .colon, includingFractionalSeconds: true))
    }
    
    func houndFormatted(_ format: HoundDateFormat, displayTimeZone: TimeZone) -> String {
        format.string(from: self, displayTimeZone: displayTimeZone)
    }
    
    /// Returns a rounded version of targetDate depending on roundingInterval, e.g. targetDate 18:41:51 -> rounded 18:42:00 for RI of 10 but for a RI of 5 rounded 18:41:50
    static func roundDate(targetDate: Date, roundingInterval: Double, roundingMethod: FloatingPointRoundingRule) -> Date {
        let rounded = Date(timeIntervalSinceReferenceDate: (targetDate.timeIntervalSinceReferenceDate / roundingInterval).rounded(roundingMethod) * roundingInterval)
        return rounded
    }
}
//
//  UnitFoundationExtensions.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/18/25.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension UnitMass {
    /// Returns the Foundation UnitMass for a given symbol string (e.g. "mg", "oz"), or nil if not recognized.
    static func from(symbol: String) -> UnitMass? {
        switch symbol {
        case "kg": return .kilograms
        case "g": return .grams
        case "dg": return .decigrams
        case "cg": return .centigrams
        case "mg": return .milligrams
        case "μg": return .micrograms
        case "ng": return .nanograms
        case "pg": return .picograms
        case "oz": return .ounces
        case "lb": return .pounds
        case "st": return .stones
        case "t": return .metricTons
        case "tn": return .shortTons
        case "ct": return .carats
        case "oz t": return .ouncesTroy
        case "slug": return .slugs
        default: return nil
        }
    }
}

// MARK: - UnitLength Symbol Mapping

extension UnitLength {
    /// Returns the Foundation UnitLength for a given symbol string (e.g. "cm", "ft"), or nil if not recognized.
    static func from(symbol: String) -> UnitLength? {
        switch symbol {
        case "Mm": return .megameters
        case "km": return .kilometers
        case "hm": return .hectometers
        case "dam": return .decameters
        case "m": return .meters
        case "dm": return .decimeters
        case "cm": return .centimeters
        case "mm": return .millimeters
        case "μm": return .micrometers
        case "nm": return .nanometers
        case "pm": return .picometers
        case "in": return .inches
        case "ft": return .feet
        case "yd": return .yards
        case "mi": return .miles
        case "smi": return .scandinavianMiles
        case "ly": return .lightyears
        case "nmi": return .nauticalMiles
        case "fathom": return .fathoms
        case "fur": return .furlongs
        case "au": return .astronomicalUnits
        case "pc": return .parsecs
        default: return nil
        }
    }
}

// MARK: - UnitVolume Symbol Mapping

extension UnitVolume {
    /// Returns the Foundation UnitVolume for a given symbol string (e.g. "L", "gal", "mL"), or nil if not recognized.
    static func from(symbol: String) -> UnitVolume? {
        switch symbol {
        case "ML": return .megaliters
        case "kL": return .kiloliters
        case "L": return .liters
        case "dL": return .deciliters
        case "cL": return .centiliters
        case "mL": return .milliliters
        case "km³": return .cubicKilometers
        case "m³": return .cubicMeters
        case "dm³": return .cubicDecimeters
        case "cm³": return .cubicCentimeters
        case "mm³": return .cubicMillimeters
        case "in³": return .cubicInches
        case "ft³": return .cubicFeet
        case "yd³": return .cubicYards
        case "mi³": return .cubicMiles
        case "ac ft": return .acreFeet
        case "bu": return .bushels
        case "tsp": return .teaspoons
        case "tbsp": return .tablespoons
        case "fl oz": return .fluidOunces
        case "cup": return .cups
        case "pt": return .pints
        case "qt": return .quarts
        case "gal": return .gallons
        case "imp tsp": return .imperialTeaspoons
        case "imp tbsp": return .imperialTablespoons
        case "imp fl oz": return .imperialFluidOunces
        case "imp pt": return .imperialPints
        case "imp qt": return .imperialQuarts
        case "imp gal": return .imperialGallons
        case "mcup": return .metricCups
        default: return nil
        }
    }
}
//
//  RemindersRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/1/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum RemindersRequest {
    
    static var baseURL: URL { DogsRequest.baseURL.appendingPathComponent("/reminders") }
    
    /// Returns an array of reminder bodies under the key "reminders". E.g. { reminders : [{reminder1}, {reminder2}] }
    private static func createBody(dogUUID: UUID, reminders: [Reminder]) -> JSONRequestBody {
        let reminderBodies = reminders.map { $0.createBody(dogUUID: dogUUID) }
        
        let body: JSONRequestBody = [Constant.Key.dogReminders.rawValue: .array(
            reminderBodies.map { .object($0.compactMapValues { $0 }) }
        )]
        return body
    }
    
}

extension RemindersRequest {
    
    // MARK: - Public Functions
    
    /**
     If query is successful, automatically combines client-side and server-side reminders and returns (reminder, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func get(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        reminder: Reminder,
        completionHandler: @escaping (Reminder?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body: JSONRequestBody = reminder.createBody(dogUUID: dogUUID)
        
        return RequestUtils.genericGetRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(nil, responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                let remindersBody: [JSONResponseBody]? = {
                    if let remindersBody = responseBody?[Constant.Key.result.rawValue] as? [JSONResponseBody] {
                        return remindersBody
                    }
                    else if let reminderBody = responseBody?[Constant.Key.result.rawValue] as? JSONResponseBody {
                        return [reminderBody]
                    }
                    else {
                        return nil
                    }
                }()
                
                if responseStatus == .noResponse {
                    // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                    OfflineModeManager.shared.didGetNoResponse(type: .dogManagerGet)
                }
                else if let reminderBody = remindersBody?.first {
                    // If we got a reminderBody, use it. This can only happen if responseStatus != .noResponse.
                    completionHandler(Reminder(fromBody: reminderBody, reminderToOverride: reminder.copy() as? Reminder), responseStatus, error)
                    return
                }
                
                // Either no response or no new, updated information from the Hound server
                completionHandler(reminder, responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically client-side and server-side reminders and returns (reminders, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        reminders: [Reminder],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // There should be reminders to actually create
        guard reminders.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body = createBody(dogUUID: dogUUID, reminders: reminders)
        
        return RequestUtils.genericPostRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { responseBody, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    reminders.forEach { reminder in
                        reminder.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: nil)
                    }
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                let remindersBody: [JSONResponseBody]? = {
                    if let remindersBody = responseBody?[Constant.Key.result.rawValue] as? [JSONResponseBody] {
                        return remindersBody
                    }
                    else if let reminderBody = responseBody?[Constant.Key.result.rawValue] as? JSONResponseBody {
                        return [reminderBody]
                    }
                    else {
                        return nil
                    }
                }()
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the reminders to be updated later
                    reminders.forEach { reminder in
                        reminder.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: Date())
                    }
                }
                else if let remindersBody = remindersBody {
                    remindersBody.forEach { reminderBody in
                        // For each reminderBody, get the reminderUUID and reminderId. We use the reminderUUID to locate the reminder so we can assign it its reminderId
                        guard let reminderId = reminderBody[Constant.Key.reminderId.rawValue] as? Int, let reminderUUID = UUID.fromString(UUIDString: reminderBody[Constant.Key.reminderUUID.rawValue] as? String) else {
                            return
                        }
                        
                        let reminder = reminders.first { reminder in
                            return reminder.reminderUUID == reminderUUID
                        }
                        
                        reminder?.reminderId = reminderId
                    }
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    @discardableResult static func update(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        reminders: [Reminder],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // There should be reminders to actually update
        guard reminders.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body = createBody(dogUUID: dogUUID, reminders: reminders)
        
        return RequestUtils.genericPutRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    reminders.forEach { reminder in
                        reminder.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: nil)
                    }
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the reminders to be updated later
                    reminders.forEach { reminder in
                        reminder.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: Date())
                    }
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    @discardableResult static func delete(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        reminderUUIDs: [UUID],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // There should be reminders to actually delete
        guard reminderUUIDs.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body: JSONRequestBody = {
            var reminderBodies: [JSONRequestBody] = []
            
            for reminderUUID in reminderUUIDs {
                var reminderBody: JSONRequestBody = [:]
                reminderBody[Constant.Key.dogUUID.rawValue] = .string(dogUUID.uuidString)
                reminderBody[Constant.Key.reminderUUID.rawValue] = .string(reminderUUID.uuidString)
                reminderBodies.append(reminderBody)
            }
        
            return [Constant.Key.dogReminders.rawValue: .array(reminderBodies.map { .object($0.compactMapValues { $0 }) })]
        }()
        
        return RequestUtils.genericDeleteRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the reminder to be deleted later
                    reminderUUIDs.forEach { reminderUUID in
                        OfflineModeManager.shared.addDeletedObjectToQueue(object: OfflineModeDeletedReminder(dogUUID: dogUUID, reminderUUID: reminderUUID, deletedDate: Date()))
                    }
                }
                
                completionHandler(responseStatus, error)
        }
    }
}
//
//  RequestUtils.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/6/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ResponseAutomaticErrorAlertTypes {
    /// If a HoundError is generated by a success, failure, or no response to a request, is it automatically alerted to
    case automaticallyAlertForAll
    /// If a HoundError is generated by a failure response to a request, is it automatically alerted to
    case automaticallyAlertOnlyForFailure
    /// If a HoundError is generated by a success, failure, or no response to a request, is it not automatically alerted to
    case automaticallyAlertForNone
}

enum RequestSourceFunctionTypes {
    /// The request function was invoked through normal means from somewhere in the Hound app
    case normal
    /// The request function was invoked from the OfflineModeManager to re-sync data
    case offlineModeManager
}

enum ResponseStatus {
    /// 200...299
    case successResponse
    /// != 200...299, e.g. 400, 404, 500
    case failureResponse
    /// Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
    case noResponse
}

/// abstractions used by other endpoint classes to make their request to the server, not used anywhere else in hound so therefore internal to endpoints and api requests.
enum RequestUtils {
    static var baseURL: URL { URL(string: Constant.Development.url) ?? URL(fileURLWithPath: "foo") }
    
    private static let session = URLSession(configuration: {
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.timeoutIntervalForRequest = 15.0
        sessionConfig.timeoutIntervalForResource = 30.0
        sessionConfig.waitsForConnectivity = false
        return sessionConfig
    }())
    
    /// Takes an already constructed URLRequest and executes it, returning it in a compeltion handler. This is the basis to all URL requests
    private static func genericRequest(
        request originalRequest: URLRequest,
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // If there is no internet connection, return noResponse and invoke OfflineModeManager to start attempting to re-sync data once a connection is restored
        // If sourceFunction is normal and OfflineModeManager is actively syncing, return noResponse as we want OfflineModeManager to finish syncing before trying to perform any more requests
        guard (NetworkManager.shared.isConnected) && (sourceFunction != .normal || OfflineModeManager.shared.isSyncInProgress == false) else {
            // Any completionHandlers or UI element changes must be done on the main thread
            DispatchQueue.main.async {
                let houndError = Constant.Error.GeneralRequestError.noInternetConnection()
                if errorAlert == .automaticallyAlertForAll {
                    houndError.alert()
                }
                
                completionHandler(nil, ResponseStatus.noResponse, houndError)
                
                // We can't perform the request because there is no internet connection. Have offline sync manager start monitoring for when connectivity is restored. This has to be after completionHandler, otherwise there will be nothing to sync so OfflineModeManager won't monitor anything
                OfflineModeManager.shared.startMonitoring()
            }
            return nil
        }
        
        var request = originalRequest
        if let userIdentifier = UserInformation.userIdentifier {
            request.setValue(userIdentifier, forHTTPHeaderField: "houndheader-useridentifier")
        }
        request.setValue(AppVersion.current.rawValue, forHTTPHeaderField: "houndheader-appversion")
        
        HoundLogger.apiRequest.notice("\(request.httpMethod ?? Constant.Visual.Text.unknownText) Request for \(request.url?.description ?? Constant.Visual.Text.unknownText)")
        //        HoundLogger.apiRequest.debug("\tRequest Body: \(String(data: request.httpBody ?? Data(), encoding: .utf8) ?? Constant.Visual.Text.unknownText)")
        
        // Create the task that will send the request
        let task = session.dataTask(with: request) { data, response, error in
            genericRequestResponse(request: request, errorAlert: errorAlert, completionHandler: completionHandler, data: data, URLResponse: response, error: error)
        }
        
        // Pass off the task to be executed when its time for it. Handles lots of requests coming in at once
        DataTaskManager.enqueueTask(dataTask: task)
        
        return task.progress
    }
    
    /// Parses the response from session.dataTask(with: request). Depending on if the response was a success, failure, or no response, invokes a futher helper function
    private static func genericRequestResponse(
        request: URLRequest,
        errorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void,
        data: Data?,
        URLResponse: URLResponse?,
        error: Error?
    ) {
        // extract status code from URLResponse
        let responseStatusCode: Int? = (URLResponse as? HTTPURLResponse)?.statusCode
        
        // parse response from json
        let responseBody: JSONResponseBody? = {
            // if no data or if no status code, then request failed
            guard let data = data else {
                return nil
            }
            
            // try to serialize data as "result" form with array of info first, if that fails, revert to regular "message" and "error" format
            return try?
            JSONSerialization.jsonObject(with: data, options: .fragmentsAllowed) as? [String: [JSONResponseBody]]
            ?? JSONSerialization.jsonObject(with: data, options: .fragmentsAllowed) as? JSONResponseBody
        }()
        
        //        HoundLogger.apiResponse.debug("\tResponse Body: \(responseBody)")
        
        guard error == nil, let responseBody = responseBody, let responseStatusCode = responseStatusCode else {
            genericRequestNoResponse(
                request: request,
                errorAlert: errorAlert,
                completionHandler: completionHandler,
                responseBody: responseBody,
                error: error
            )
            return
        }
        
        guard 200...299 ~= responseStatusCode else {
            genericRequestFailureResponse(
                request: request,
                errorAlert: errorAlert,
                completionHandler: completionHandler,
                responseBody: responseBody
            )
            return
        }
        
        genericRequestSuccessResponse(
            request: request,
            completionHandler: completionHandler,
            responseBody: responseBody
        )
    }
    
    /// Handles a case of a no response from a data task query
    private static func genericRequestNoResponse(
        request: URLRequest,
        errorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void,
        responseBody: JSONResponseBody?,
        error: Error?
    ) {
        // assume an error is no response as that implies request/response failure, meaning the end result of no response is the same
        HoundLogger.apiResponse.warning(
            "No \(request.httpMethod ?? Constant.Visual.Text.unknownText) Response for \(request.url?.description ?? Constant.Visual.Text.unknownText)\nData Task Error: \(error?.localizedDescription ?? Constant.Visual.Text.unknownText)")
        
        let responseError: HoundError = {
            switch request.httpMethod {
            case "PATCH":
                return Constant.Error.GeneralResponseError.getNoResponse()
            case "POST":
                return Constant.Error.GeneralResponseError.postNoResponse()
            case "PUT":
                return Constant.Error.GeneralResponseError.putNoResponse()
            case "DELETE":
                return Constant.Error.GeneralResponseError.deleteNoResponse()
            default:
                return Constant.Error.GeneralResponseError.getNoResponse()
            }
        }()
        
        // Any completionHandlers or UI element changes must be done on the main thread
        DispatchQueue.main.async {
            if errorAlert == .automaticallyAlertForAll {
                responseError.alert()
            }
            
            completionHandler(responseBody, .noResponse, responseError)
            
            // We can't perform the request because there is no internet connection. Have offline sync manager start monitoring for when connectivity is restored. This has to be after completionHandler, otherwise there will be nothing to sync so OfflineModeManager won't monitor anything
            OfflineModeManager.shared.startMonitoring()
        }
    }
    
    /// Handles a case of a failure response from a data task query
    private static func genericRequestFailureResponse(
        request: URLRequest,
        errorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void,
        responseBody: JSONResponseBody
    ) {
        // Our request went through but was invalid
        HoundLogger.apiResponse.warning(
            "Failure \(request.httpMethod ?? Constant.Visual.Text.unknownText) Response for \(request.url?.description ?? Constant.Visual.Text.unknownText)\n Message: \(responseBody[Constant.Key.message.rawValue] as? String ?? Constant.Visual.Text.unknownText)\n Code: \(responseBody[Constant.Key.code.rawValue] as? String ?? Constant.Visual.Text.unknownText)\n Type:\(responseBody[Constant.Key.name.rawValue] as? String ?? Constant.Visual.Text.unknownText)")
        
        let responseErrorCode: String? = responseBody[Constant.Key.code.rawValue] as? String
        let requestId: Int = responseBody[Constant.Key.requestId.rawValue] as? Int ?? -1
        let responseId: Int = responseBody[Constant.Key.responseId.rawValue] as? Int ?? -1
        
        let responseError: HoundError = {
            // attempt to construct an error from responseErrorCode
            if let responseErrorCode = responseErrorCode, let error = Constant.Error.serverError(errorCode: responseErrorCode, requestId: requestId, responseId: responseId) {
                return error
            }
            
            // could not construct an error, use a default error message based upon the http method
            switch request.httpMethod {
            case "PATCH":
                return Constant.Error.GeneralResponseError.getFailureResponse(requestId: requestId, responseId: responseId)
            case "POST":
                return Constant.Error.GeneralResponseError.postFailureResponse(requestId: requestId, responseId: responseId)
            case "PUT":
                return Constant.Error.GeneralResponseError.putFailureResponse(requestId: requestId, responseId: responseId)
            case "DELETE":
                return Constant.Error.GeneralResponseError.deleteFailureResponse(requestId: requestId, responseId: responseId)
            default:
                return Constant.Error.GeneralResponseError.getFailureResponse(requestId: requestId, responseId: responseId)
            }
        }()
        
        // Any completionHandlers or UI element changes must be done on the main thread
        DispatchQueue.main.async {
            
            guard responseError.name != Constant.Error.GeneralResponseError.appVersionOutdated(requestId: -1, responseId: -1).name else {
                // If the user's app is outdated, it no longer works for hound. Therefore, prevent them from doing anything until they update.
                // Ignore errorAlert
                responseError.alert()
                return
            }
            
            if errorAlert == .automaticallyAlertForAll || errorAlert == .automaticallyAlertOnlyForFailure {
                responseError.alert()
            }
            
            // if the error happened to be about the user's account or family disappearing or them losing access, then revert them to the login page
            if responseError.name == Constant.Error.PermissionResponseError.noUser(requestId: -1, responseId: -1).name {
                PersistenceManager.clearStorageToReloginToAccount()
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncVC.self, completionHandler: nil)
            }
            else if responseError.name == Constant.Error.PermissionResponseError.noFamily(requestId: -1, responseId: -1).name {
                PersistenceManager.clearStorageToRejoinFamily()
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncVC.self, completionHandler: nil)
            }
            // if the error happens to be because a dog, log, or reminder was deleted, then invoke a low level refresh to update the user's data.
            else if responseError.name == Constant.Error.FamilyResponseError.deletedDog(requestId: -1, responseId: -1).name ||
                        responseError.name == Constant.Error.FamilyResponseError.deletedLog(requestId: -1, responseId: -1).name ||
                        responseError.name == Constant.Error.FamilyResponseError.deletedReminder(requestId: -1, responseId: -1).name ||
                        responseError.name == Constant.Error.FamilyResponseError.deletedTrigger(requestId: -1, responseId: -1).name {
                MainTabBarController.shouldSilentlyRefreshDogManager = true
            }
            else if responseError.name == Constant.Error.GeneralResponseError.rateLimitExceeded(requestId: -1, responseId: -1).name {
                DataTaskManager.lastDateRateLimitReceived = Date()
            }
            
            completionHandler(responseBody, .failureResponse, responseError)
        }
    }
    
    /// Handles a case of a success response from a data task query
    private static func genericRequestSuccessResponse(
        request: URLRequest,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void,
        responseBody: JSONResponseBody
    ) {
        // Our request was valid and successful
        HoundLogger.apiResponse.notice("Success \(request.httpMethod ?? Constant.Visual.Text.unknownText) Response for \(request.url?.description ?? Constant.Visual.Text.unknownText)")
        
        // Any completionHandlers or UI element changes must be done on the main thread
        DispatchQueue.main.async {
            completionHandler(responseBody, .successResponse, nil)
        }
    }
}

extension RequestUtils {
    
    // MARK: - Generic GET, POST, PUT, and DELETE requests
    
    /// Perform a generic get request at the specified url with NO body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericGetRequest(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes,
        url: URL,
        body: JSONRequestBody,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: url)
        
        // specify http method
        request.httpMethod = "PATCH"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        let serializableBody = body.toAnyDictionary()
        request.httpBody = try? JSONSerialization.data(withJSONObject: serializableBody)
        
        return genericRequest(
            request: request,
            errorAlert: errorAlert,
            sourceFunction: sourceFunction
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
    }
    
    /// Perform a generic get request at the specified url with provided body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericPostRequest(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes,
        url: URL,
        body: JSONRequestBody,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: url)
        
        // specify http method
        request.httpMethod = "POST"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        let serializableBody = body.toAnyDictionary()
        request.httpBody = try? JSONSerialization.data(withJSONObject: serializableBody)
        
        return genericRequest(
            request: request,
            errorAlert: errorAlert,
            sourceFunction: sourceFunction
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
        
    }
    
    /// Perform a generic get request at the specified url with provided body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericPutRequest(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes,
        url: URL,
        body: JSONRequestBody,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: url)
        
        // specify http method
        request.httpMethod = "PUT"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        let serializableBody = body.toAnyDictionary()
        request.httpBody = try? JSONSerialization.data(withJSONObject: serializableBody)
        
        return genericRequest(
            request: request,
            errorAlert: errorAlert,
            sourceFunction: sourceFunction
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
        
    }
    
    /// Perform a generic get request at the specified url with NO body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericDeleteRequest(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes,
        url: URL,
        body: JSONRequestBody,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: url)
        
        // specify http method
        request.httpMethod = "DELETE"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        let serializableBody = body.toAnyDictionary()
        request.httpBody = try? JSONSerialization.data(withJSONObject: serializableBody)
        
        return genericRequest(
            request: request,
            errorAlert: errorAlert,
            sourceFunction: sourceFunction
        ) { responseBody, responseStatus, error  in
            completionHandler(responseBody, responseStatus, error)
        }
    }
    
}
//
//  LogsRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/1/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum LogsRequest {
    
    static var baseURL: URL { DogsRequest.baseURL.appendingPathComponent("/logs") }
    static var baseURLForLike: URL { baseURL.appendingPathComponent("/like") }
    
    /**
     If query is successful, automatically combines client-side and server-side logs and returns (log, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func get(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        log: Log,
        completionHandler: @escaping (Log?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body: JSONRequestBody = log.createBody(dogUUID: dogUUID)
        
        return RequestUtils.genericGetRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(nil, responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                    OfflineModeManager.shared.didGetNoResponse(type: .dogManagerGet)
                }
                else if let logBody = responseBody?[Constant.Key.result.rawValue] as? JSONResponseBody {
                    // If we got a logBody, use it. This can only happen if responseStatus != .noResponse.
                    completionHandler(Log(fromBody: logBody, logToOverride: log.copy() as? Log), responseStatus, error)
                    return
                }
                
                // Either no response or no new, updated information from the Hound server
                completionHandler(log, responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically assigns logId to log and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        log: Log,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body = log.createBody(dogUUID: dogUUID)
        
        return RequestUtils.genericPostRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { responseBody, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    log.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: nil)
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the log to be updated later
                    log.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: Date())
                }
                else if let logId = responseBody?[Constant.Key.result.rawValue] as? Int {
                    // If we got a logId, use it. This can only happen if responseStatus != .noResponse.
                    log.logId = logId
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func update(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        log: Log,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body = log.createBody(dogUUID: dogUUID)
        
        // make put request, assume body valid as constructed with function
        return RequestUtils.genericPutRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    log.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: nil)
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the log to be updated later
                    log.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: Date())
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func delete(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        logUUID: UUID,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        var body: JSONRequestBody = [:]
        body[Constant.Key.dogUUID.rawValue] = .string(dogUUID.uuidString)
        body[Constant.Key.logUUID.rawValue] = .string(logUUID.uuidString)
        
        return RequestUtils.genericDeleteRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the log to be deleted later
                    OfflineModeManager.shared.addDeletedObjectToQueue(object: OfflineModeDeletedLog(dogUUID: dogUUID, logUUID: logUUID, deletedDate: Date()))
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
}
//
//  DogsRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/28/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum DogsRequest {
    static var baseURL: URL { FamilyRequest.baseURL.appendingPathComponent("/dogs") }
    
    /**
     If query is successful, automatically combines client-side and server-side dogs and returns (dog, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func get(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dog: Dog,
        completionHandler: @escaping (Dog?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        guard var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: false) else {
            completionHandler(nil, .failureResponse, nil)
            return nil
        }
        
        if let previousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization {
            components.queryItems = components.queryItems ?? []
            // if we have a previousDogManagerSynchronization that isn't equal to 1970 (the default value), then provide it as that means we have a custom value.
            components.queryItems?.append(
                URLQueryItem(
                    name: Constant.Key.previousDogManagerSynchronization.rawValue,
                    value: previousDogManagerSynchronization.ISO8601FormatWithFractionalSeconds()
                ))
        }
        
        guard let url = components.url else {
            completionHandler(nil, .failureResponse, nil)
            return nil
        }
        
        let body: JSONRequestBody = [Constant.Key.dogUUID.rawValue: .string(dog.dogUUID.uuidString)]
        
        return RequestUtils.genericGetRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: url,
            body: body) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(nil, responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                    OfflineModeManager.shared.didGetNoResponse(type: .dogManagerGet)
                }
                else if let newDogBody = responseBody?[Constant.Key.result.rawValue] as? [String: Any] {
                    // If we got a dogBody, use it. This can only happen if responseStatus != .noResponse.
                    completionHandler(Dog(fromBody: newDogBody, dogToOverride: dog.copy() as? Dog), responseStatus, error)
                    return
                }
                
                // Either no response or no new, updated information from the Hound server
                completionHandler(dog, responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically combines client-side and server-side dogManagers and returns (dogManager, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func get(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogManager: DogManager,
        completionHandler: @escaping (DogManager?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        guard var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: false) else {
            completionHandler(nil, .failureResponse, nil)
            return nil
        }
        
        if let previousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization {
            components.queryItems = components.queryItems ?? []
            // if we have a previousDogManagerSynchronization that isn't equal to 1970 (the default value), then provide it as that means we have a custom value.
            components.queryItems?.append(
                URLQueryItem(
                    name: Constant.Key.previousDogManagerSynchronization.rawValue,
                    value: previousDogManagerSynchronization.ISO8601FormatWithFractionalSeconds()
                ))
        }
        
        guard let url = components.url else {
            completionHandler(nil, .failureResponse, nil)
            return nil
        }
        
        // If the query is successful, we want new previousDogManagerSynchronization to be before the query took place. This ensures that any changes that might have occured DURING our query will be synced at a future date.
        let previousDogManagerSynchronization = Date()
        
        return RequestUtils.genericGetRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: url,
            body: [:]) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(nil, responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                    OfflineModeManager.shared.didGetNoResponse(type: .dogManagerGet)
                }
                else if let dogBodies = responseBody?[Constant.Key.result.rawValue] as? [[String: Any]] {
                    // If we got dogBodies, use them. This can only happen if responseStatus != .noResponse.
                    LocalConfiguration.previousDogManagerSynchronization = previousDogManagerSynchronization
                    
                    completionHandler(DogManager(fromDogBodies: dogBodies, dogManagerToOverride: dogManager.copy() as? DogManager), responseStatus, error)
                    return
                }
                
                // Either no response or no new, updated information from the Hound server
                completionHandler(dogManager, responseStatus, error)
        }
        
    }
    
    /**
     If query is successful, automatically assigns dogId to the dog and manages local storage of dogIcon and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dog: Dog,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body = dog.createBody()
        
        return RequestUtils.genericPostRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { responseBody, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    dog.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: nil)
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                if let dogIcon = dog.dogIcon {
                    DogIconManager.addIcon(dogUUID: dog.dogUUID, dogIcon: dogIcon)
                }
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the dog to be updated later
                    dog.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: Date())
                }
                else if let dogId = responseBody?[Constant.Key.result.rawValue] as? Int {
                    // If we got a dogId, use it. This can only happen if responseStatus != .noResponse.
                    dog.dogId = dogId
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically manages local storage of dogIcon and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func update(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dog: Dog,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body = dog.createBody()
        
        return RequestUtils.genericPutRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    dog.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: nil)
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                if let dogIcon = dog.dogIcon {
                    DogIconManager.addIcon(dogUUID: dog.dogUUID, dogIcon: dogIcon)
                }
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the dog to be updated later
                    dog.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: Date())
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically manages local storage of dogIcon and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func delete(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body: JSONRequestBody = [Constant.Key.dogUUID.rawValue: .string(dogUUID.uuidString)]
        
        return RequestUtils.genericDeleteRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                DogIconManager.removeIcon(dogUUID: dogUUID)
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the dog to be deleted later
                    OfflineModeManager.shared.addDeletedObjectToQueue(object: OfflineModeDeletedDog(dogUUID: dogUUID, deletedDate: Date()))
                }
                
                completionHandler(responseStatus, error)
        }
    }
}
//
//  SurveyFeedbackRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/31/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation
import UIKit

enum SurveyFeedbackRequest {
    static var baseURL: URL { FamilyRequest.baseURL.appendingPathComponent("/surveyFeedback")}
    
    /**
     Invoke function when user fills out the feedback survey for why they are cancelling their Hound+ subscription.
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
   */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        userCancellationReason: SubscriptionCancellationReason?,
        userCancellationFeedback: String,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        var body: JSONRequestBody = [:]
        body[Constant.Key.surveyFeedbackType.rawValue] = .string(SurveyFeedbackType.cancelSubscription.rawValue)
        body[Constant.Key.surveyFeedbackUserCancellationReason.rawValue] = .string(userCancellationReason?.internalValue)
        body[Constant.Key.surveyFeedbackUserCancellationFeedback.rawValue] = .string(userCancellationFeedback)
        
        return create(errorAlert: errorAlert, sourceFunction: sourceFunction, body: body, completionHandler: completionHandler)
    }
    
    /**
     Invoke function when user fills out the feedback survey for their experience with Hound
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
   */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        numberOfStars: Int,
        appExperienceFeedback: String,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body: JSONRequestBody = [
            Constant.Key.surveyFeedbackType.rawValue: .string(SurveyFeedbackType.appExperience.rawValue),
            Constant.Key.surveyFeedbackAppExperienceNumberOfStars.rawValue: .int(numberOfStars),
            Constant.Key.surveyFeedbackAppExperienceFeedback.rawValue: .string(appExperienceFeedback)
        ]
        
        return create(errorAlert: errorAlert, sourceFunction: sourceFunction, body: body) { responseStatus, houndError in
            guard responseStatus != .failureResponse else {
                completionHandler(responseStatus, houndError)
                return
            }
            
            // We successfully submitted the survey for app experience, so track that
            if responseStatus == .successResponse {
                LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted.append(Date())
            }
            
            completionHandler(responseStatus, houndError)
        }
    }

    /**
     Sends a generic surveyFeedback request to the Hound server, appending a variety of device metrics to the passed body
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
   */
    @discardableResult private static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        body: JSONRequestBody,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
       
        var bodyWithDeviceMetrics = body
        bodyWithDeviceMetrics[Constant.Key.surveyFeedbackDeviceMetricModel.rawValue] = .string(UIDevice.current.model)
        bodyWithDeviceMetrics[Constant.Key.surveyFeedbackDeviceMetricSystemVersion.rawValue] = .string(UIDevice.current.systemVersion)
        bodyWithDeviceMetrics[Constant.Key.surveyFeedbackDeviceMetricAppVersion.rawValue] = .string(AppVersion.current.rawValue)
        bodyWithDeviceMetrics[Constant.Key.surveyFeedbackDeviceMetricLocale.rawValue] = .string(Locale.current.identifier)
        
        // All of the previous body should be encapsulated inside a surveyFeedback body
        var body: JSONRequestBody = [:]
        body[Constant.Key.surveyFeedback.rawValue] = .object(bodyWithDeviceMetrics)
        
        return RequestUtils.genericPostRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
                completionHandler(responseStatus, error)
        }
    }
}
//
//  TransactionsRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/23/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum TransactionsRequest {

    static var baseURLWithoutParams: URL { FamilyRequest.baseURL.appendingPathComponent("/transactions") }

    /**
     If query is successful, automatically manages FamilyInformation.familySubscriptions and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
    */
    @discardableResult static func get(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {

        RequestUtils.genericGetRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURLWithoutParams,
            body: [:]) { responseBody, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                if let result = responseBody?[Constant.Key.result.rawValue] as? [JSONResponseBody] {

                    FamilyInformation.clearAllFamilySubscriptions()
                    for subscription in result {
                        FamilyInformation.addFamilySubscription(subscription: Subscription(fromBody: subscription))
                    }

                    completionHandler(.successResponse, error)
                }
                else {
                    completionHandler(.failureResponse, error)
                }
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }

    /**
     Sends a request with the user's base64 encoded appStoreRecieptURL for the user to create a subscription.
     If query is successful, automatically manages FamilyInformation.familySubscriptions and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
    */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // Get the receipt if it's available. If the receipt isn't available, we sent through an invalid base64EncodedString, then the server will return us an error
        let base64EncodedReceiptString: String? = {
            guard let appStoreReceiptURL = Bundle.main.appStoreReceiptURL, FileManager.default.fileExists(atPath: appStoreReceiptURL.path), let receiptData = try? Data(contentsOf: appStoreReceiptURL, options: .alwaysMapped) else {
                // Experienced an error, so no base64 encoded string
                return nil
            }

            return receiptData.base64EncodedString(options: [])
        }()

        guard let base64EncodedReceiptString = base64EncodedReceiptString else {
            completionHandler(.failureResponse, nil)
            return nil
        }

        let body: JSONRequestBody = [Constant.Key.appStoreReceiptURL.rawValue: .string(base64EncodedReceiptString)]

        return RequestUtils.genericPostRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURLWithoutParams,
            body: body) { responseBody, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                if let result = responseBody?[Constant.Key.result.rawValue] as? JSONResponseBody {
                    let familyActiveSubscription = Subscription(fromBody: result)
                    FamilyInformation.addFamilySubscription(subscription: familyActiveSubscription)

                    completionHandler(.successResponse, error)
                }
                else {
                    completionHandler(.failureResponse, error)
                }
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }
}
//
//  ResponseStatus.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/16/22.
//  Copyright © 2022 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum ResponseStatus {
    /// 200...299
    case successResponse
    /// != 200...299, e.g. 400, 404, 500
    case failureResponse
    /// Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
    case noResponse
}
//
//  UserRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/28/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum UserRequest {

    static var baseURL: URL { RequestUtils.baseURL.appendingPathComponent("/user")}
    /**
     If query is successful, automatically sets up UserInformation and UserConfiguration and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func get(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericGetRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: [:]) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    OfflineModeManager.shared.didGetNoResponse(type: .userRequestGet)
                }
                else if let result = responseBody?[Constant.Key.result.rawValue] as? JSONResponseBody {
                    UserInformation.setup(fromBody: result)
                    UserConfiguration.setup(fromBody: result)
                }
                
                completionHandler(responseStatus, error)
        }
    }

    /**
     Creates a user's account on the server
     If query is successful, automatically sets up UserInformation.userId and returns (true, .successResponse, requestId, responseId)
     If query isn't successful, returns (false, .failureResponse, requestId, responseId) or (false, .noResponse, requestId, responseId)
     */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericPostRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: UserConfiguration.createBody(addingOntoBody: UserInformation.createBody(addingOntoBody: nil))) { responseBody, responseStatus, error in

            switch responseStatus {
            case .successResponse:
                if let userId = responseBody?[Constant.Key.result.rawValue] as? String {
                    UserInformation.userId = userId
                    completionHandler(.successResponse, error)
                }
                else {
                    completionHandler(.failureResponse, error)
                }
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }

    /**
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func update(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        body: JSONRequestBody,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericPutRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    OfflineModeManager.shared.didGetNoResponse(type: .userRequestUpdate)
                }
                
                completionHandler(responseStatus, error)
        }
    }

    /**
     If query is successful, automatically invokes PersistenceManager.clearStorageToReloginToAccount() and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func delete(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        body: JSONRequestBody = [:],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericDeleteRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                PersistenceManager.clearStorageToReloginToAccount()
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }
}
//
//  FamilyRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/3/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum FamilyRequest {
    
    static var baseURL: URL { UserRequest.baseURL.appendingPathComponent("/family") }

    /**
     If query is successful, automatically sets up FamilyInformation and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func get(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        return RequestUtils.genericGetRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: [:]) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    OfflineModeManager.shared.didGetNoResponse(type: .familyRequestGet)
                }
                else if let result = responseBody?[Constant.Key.result.rawValue] as? JSONResponseBody {
                    FamilyInformation.setup(fromBody: result)
                }
                
                completionHandler(responseStatus, error)
        }
    }

    /**
     Sends a request for the user to create their own family.
     If query is successful, automatically invokes PersistenceManager.clearStorageToRejoinFamily() and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericPostRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: [:]) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                PersistenceManager.clearStorageToRejoinFamily()
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }

    /**
     Update specific piece(s) of the family
     If query is successful, automatically invokes PersistenceManager.clearStorageToRejoinFamily() and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func update(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        body: JSONRequestBody,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let attemptingToJoinFamily = body[Constant.Key.familyCode.rawValue] != nil
        
        return RequestUtils.genericPutRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                if attemptingToJoinFamily {
                    // User successfully joined a new family
                    PersistenceManager.clearStorageToRejoinFamily()
                }
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }

    /**
     If the user is a familyMember, lets the user leave the family.
     If the user is a familyHead and are the only member, deletes the family.
     If query is successful, automatically invokes PersistenceManager.clearStorageToRejoinFamily() and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func delete(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        body: JSONRequestBody = [:],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericDeleteRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                PersistenceManager.clearStorageToRejoinFamily()
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }
}
//
//  AlertRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/18/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum AlertRequest {
    static var baseURL: URL { UserRequest.baseURL.appendingPathComponent("/alert")}

    /**
     Invoke function when user is terminating Hound. Sends query to Hound server that sends APN to user, warning against terminating the app
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
   */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        return RequestUtils.genericPostRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: [:]) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }
}
//
//  TypesRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/1/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum GlobalTypesRequest {

    static var baseURL: URL { RequestUtils.baseURL.appendingPathComponent("/globalTypes")}
    /**
     If query is successful, automatically sets up UserInformation and UserConfiguration and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func get(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericGetRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: [:]) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    completionHandler(responseStatus, error)
                    return
                }
                
                if let result = responseBody?[Constant.Key.result.rawValue] as? JSONResponseBody {
                    GlobalTypes.shared = GlobalTypes(fromBody: result)
                }
                
                guard GlobalTypes.shared != nil else {
                    completionHandler(.failureResponse, error)
                    return
                }
                
                completionHandler(responseStatus, error)
        }
    }
}
//
//  TriggersRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/14/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum TriggersRequest {
    
    static var baseURL: URL { DogsRequest.baseURL.appendingPathComponent("/dogTriggers") }
    
    /// Returns an array of reminder trigger bodies under the key "dogTriggers".
    private static func createBody(
        dogUUID: UUID,
        dogTriggers: [Trigger]
    ) -> JSONRequestBody {
        let triggerBodies = dogTriggers.map { $0.createBody(dogUUID: dogUUID) }
        
        let body: JSONRequestBody = [Constant.Key.dogTriggers.rawValue: .array(
            triggerBodies.map { .object($0.compactMapValues { $0 }) }
        )]
        return body
    }
    
}

extension TriggersRequest {
    
    // MARK: - Public Functions
    
    /**
     If query is successful, combines client-side and server-side dogTriggers and returns (trigger, .successResponse).
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse).
     */
    @discardableResult static func get(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        trigger: Trigger,
        completionHandler: @escaping (
            Trigger?,
            ResponseStatus,
            HoundError?
        ) -> Void
    ) -> Progress? {
        let body: JSONRequestBody = trigger.createBody(dogUUID: dogUUID)
        
        return RequestUtils.genericGetRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body
        ) { responseBody, responseStatus, error in
            guard responseStatus != .failureResponse else {
                // If there was a failureResponse, there was something purposefully wrong with the request
                completionHandler(nil, responseStatus, error)
                return
            }
            
            // Either completed successfully or no response from the server, we can proceed as usual
            let triggersBody: [JSONResponseBody]? = {
                if let array = responseBody?[Constant.Key.result.rawValue] as? [JSONResponseBody] {
                    return array
                }
                else if let single = responseBody?[Constant.Key.result.rawValue] as? JSONResponseBody {
                    return [single]
                }
                else {
                    return nil
                }
            }()
            
            if responseStatus == .noResponse {
                // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                OfflineModeManager.shared.didGetNoResponse(
                    type: .dogManagerGet
                )
            }
            else if let triggerBody = triggersBody?.first {
                // If we got a triggerBody, use it. This can only happen if responseStatus != .noResponse.
                let override = trigger.copy() as? Trigger
                completionHandler(
                    Trigger(
                        fromBody: triggerBody,
                        triggerToOverride: override
                    ),
                    responseStatus,
                    error
                )
                return
            }
            
            // Either no response or no new, updated information from the Hound server
            completionHandler(
                trigger,
                responseStatus,
                error
            )
        }
    }
    
    /**
     If query is successful, creates triggers and returns (.successResponse).
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse).
     */
    @discardableResult static func create(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        dogTriggers: [Trigger],
        completionHandler: @escaping (
            ResponseStatus,
            HoundError?
        ) -> Void
    ) -> Progress? {
        // There should be triggers to actually create
        guard dogTriggers.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body = createBody(
            dogUUID: dogUUID,
            dogTriggers: dogTriggers
        )
        
        return RequestUtils.genericPostRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body
        ) { responseBody, responseStatus, error in
            // As long as we got a response from the server, it no longers needs synced. Success or failure
            if responseStatus != .noResponse {
                dogTriggers.forEach { trigger in
                    trigger.offlineModeComponents
                        .updateInitialAttemptedSyncDate(
                            initialAttemptedSyncDate: nil
                        )
                }
            }
            
            guard responseStatus != .failureResponse else {
                // If there was a failureResponse, there was something purposefully wrong with the request
                completionHandler(responseStatus, error)
                return
            }
            
            // Either completed successfully or no response from the server, we can proceed as usual
            let triggersBody: [JSONResponseBody]? = {
                if let array = responseBody?[Constant.Key.result.rawValue] as? [JSONResponseBody] {
                    return array
                }
                else if let single = responseBody?[Constant.Key.result.rawValue] as? JSONResponseBody {
                    return [single]
                }
                else {
                    return nil
                }
            }()
            
            if responseStatus == .noResponse {
                // If we got no response, then mark the triggers to be updated later
                dogTriggers.forEach { trigger in
                    trigger.offlineModeComponents
                        .updateInitialAttemptedSyncDate(
                            initialAttemptedSyncDate: Date()
                        )
                }
            }
            else if let bodies = triggersBody {
                // For each body, get the UUID and id. We use the uuid to locate the reminder so we can assign it its id
                bodies.forEach { body in
                    guard let id = body[Constant.Key.triggerId.rawValue] as? Int,
                          let uuidString = body[Constant.Key.triggerUUID.rawValue] as? String,
                          let uuid = UUID.fromString(UUIDString: uuidString)
                    else {
                        return
                    }
                    
                    dogTriggers.first(where: { $0.triggerUUID == uuid })?.triggerId = id
                }
            }
            
            completionHandler(responseStatus, error)
        }
    }
    
    @discardableResult static func update(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        dogTriggers: [Trigger],
        completionHandler: @escaping (
            ResponseStatus,
            HoundError?
        ) -> Void
    ) -> Progress? {
        // There should be reminders to actually update
        guard dogTriggers.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body = createBody(dogUUID: dogUUID, dogTriggers: dogTriggers)
        
        return RequestUtils.genericPutRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body
        ) { _, responseStatus, error in
            // As long as we got a response from the server, it no longers needs synced. Success or failure
            if responseStatus != .noResponse {
                dogTriggers.forEach { trigger in
                    trigger.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: nil)
                }
            }
            
            guard responseStatus != .failureResponse else {
                // If there was a failureResponse, there was something purposefully wrong with the request
                completionHandler(responseStatus, error)
                return
            }
            
            if responseStatus == .noResponse {
                // If we got no response, then mark the reminders to be updated later
                dogTriggers.forEach { trigger in
                    trigger.offlineModeComponents.updateInitialAttemptedSyncDate(initialAttemptedSyncDate: Date())
                }
            }
            
            completionHandler(responseStatus, error)
        }
    }
    
    @discardableResult static func delete(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        sourceFunction: RequestSourceFunctionTypes = .normal,
        dogUUID: UUID,
        triggerUUIDs: [UUID],
        completionHandler: @escaping (
            ResponseStatus,
            HoundError?
        ) -> Void
    ) -> Progress? {
        // There should be reminders to actually delete
        guard triggerUUIDs.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body: JSONRequestBody = {
            var triggerBodies: [JSONRequestBody] = []
            for UUID in triggerUUIDs {
                var entry: JSONRequestBody = [:]
                entry[Constant.Key.dogUUID.rawValue] = .string(dogUUID.uuidString)
                entry[Constant.Key.triggerUUID.rawValue] = .string(UUID.uuidString)
                triggerBodies.append(entry)
            }
            return [Constant.Key.dogTriggers.rawValue: .array(
                triggerBodies.map { .object($0.compactMapValues { $0 }) }
            )]
        }()
        
        return RequestUtils.genericDeleteRequest(
            errorAlert: errorAlert,
            sourceFunction: sourceFunction,
            url: baseURL,
            body: body
        ) { _, responseStatus, error in
            guard responseStatus != .failureResponse else {
                // If there was a failureResponse, there was something purposefully wrong with the request
                completionHandler(responseStatus, error)
                return
            }
            
            // Either completed successfully or no response from the server, we can proceed as usual
            
            if responseStatus == .noResponse {
                triggerUUIDs.forEach { uuid in
                    OfflineModeManager.shared
                        .addDeletedObjectToQueue(object:
                                                    OfflineModeDeletedTrigger(
                                                        dogUUID: dogUUID,
                                                        triggerUUID: uuid,
                                                        deletedDate: Date()))
                }
            }
            
            completionHandler(responseStatus, error)
        }
    }
}
//
//  UserConfiguration.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/7/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

/// Configuration that is local to the app only. If the app is reinstalled then this data should be pulled down from the cloud
final class UserConfiguration: UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    static func persist(toUserDefaults: UserDefaults) {
        toUserDefaults.set(UserConfiguration.interfaceStyle.rawValue, forKey: Constant.Key.userConfigurationInterfaceStyle.rawValue)
        toUserDefaults.set(UserConfiguration.measurementSystem.rawValue, forKey: Constant.Key.userConfigurationMeasurementSystem.rawValue)
        toUserDefaults.set(UserConfiguration.isHapticsEnabled, forKey: Constant.Key.userConfigurationIsHapticsEnabled.rawValue)
        toUserDefaults.set(UserConfiguration.usesDeviceTimeZone, forKey: Constant.Key.userConfigurationUsesDeviceTimeZone.rawValue)
        toUserDefaults.set(UserConfiguration.userTimeZone?.identifier, forKey: Constant.Key.userConfigurationUserTimeZone.rawValue)
        
        toUserDefaults.set(UserConfiguration.notificationSound.rawValue, forKey: Constant.Key.userConfigurationNotificationSound.rawValue)
        
        toUserDefaults.set(UserConfiguration.isNotificationEnabled, forKey: Constant.Key.userConfigurationIsNotificationEnabled.rawValue)
        toUserDefaults.set(UserConfiguration.isLoudNotificationEnabled, forKey: Constant.Key.userConfigurationIsLoudNotificationEnabled.rawValue)
        toUserDefaults.set(UserConfiguration.isLogNotificationEnabled, forKey: Constant.Key.userConfigurationIsLogNotificationEnabled.rawValue)
        toUserDefaults.set(UserConfiguration.isReminderNotificationEnabled, forKey: Constant.Key.userConfigurationIsReminderNotificationEnabled.rawValue)
        
        toUserDefaults.set(UserConfiguration.isSilentModeEnabled, forKey: Constant.Key.userConfigurationIsSilentModeEnabled.rawValue)
        toUserDefaults.set(UserConfiguration.silentModeStartHour, forKey: Constant.Key.userConfigurationSilentModeStartHour.rawValue)
        toUserDefaults.set(UserConfiguration.silentModeEndHour, forKey: Constant.Key.userConfigurationSilentModeEndHour.rawValue)
        toUserDefaults.set(UserConfiguration.silentModeStartMinute, forKey: Constant.Key.userConfigurationSilentModeStartMinute.rawValue)
        toUserDefaults.set(UserConfiguration.silentModeEndMinute, forKey: Constant.Key.userConfigurationSilentModeEndMinute.rawValue)
    }
    
    static func load(fromUserDefaults: UserDefaults) {
        // NOTE: User Configuration is stored on the Hound server and retrieved synced. However, if the user is in offline mode, they will need these values. Therefore, use local storage as a second backup for these values
        
        if let interfaceStyleInt = fromUserDefaults.value(forKey: Constant.Key.userConfigurationInterfaceStyle.rawValue) as? Int {
            UserConfiguration.interfaceStyle = UIUserInterfaceStyle(rawValue: interfaceStyleInt) ?? UserConfiguration.interfaceStyle
        }
        if let measurementSystemInt = fromUserDefaults.value(forKey: Constant.Key.userConfigurationMeasurementSystem.rawValue) as? Int {
            UserConfiguration.measurementSystem = MeasurementSystem(rawValue: measurementSystemInt) ?? UserConfiguration.measurementSystem
        }
        UserConfiguration.isHapticsEnabled = fromUserDefaults.value(forKey: Constant.Key.userConfigurationIsHapticsEnabled.rawValue) as? Bool ?? UserConfiguration.isHapticsEnabled
        UserConfiguration.usesDeviceTimeZone = fromUserDefaults.value(forKey: Constant.Key.userConfigurationUsesDeviceTimeZone.rawValue) as? Bool ?? UserConfiguration.usesDeviceTimeZone
        UserConfiguration.userTimeZone = {
            if let str = fromUserDefaults.value(forKey: Constant.Key.userConfigurationUserTimeZone.rawValue) as? String {
                return TimeZone(identifier: str)
            }
            return nil
        }() ?? UserConfiguration.userTimeZone
        
        UserConfiguration.snoozeLength = fromUserDefaults.value(forKey: Constant.Key.userConfigurationSnoozeLength.rawValue) as? Double ?? UserConfiguration.snoozeLength
        
        UserConfiguration.isNotificationEnabled = fromUserDefaults.value(forKey: Constant.Key.userConfigurationIsNotificationEnabled.rawValue) as? Bool ?? UserConfiguration.isNotificationEnabled
        UserConfiguration.isLoudNotificationEnabled = fromUserDefaults.value(forKey: Constant.Key.userConfigurationIsLoudNotificationEnabled.rawValue) as? Bool ?? UserConfiguration.isLoudNotificationEnabled
        UserConfiguration.isLogNotificationEnabled = fromUserDefaults.value(forKey: Constant.Key.userConfigurationIsLogNotificationEnabled.rawValue) as? Bool ?? UserConfiguration.isLogNotificationEnabled
        UserConfiguration.isReminderNotificationEnabled = fromUserDefaults.value(forKey: Constant.Key.userConfigurationIsReminderNotificationEnabled.rawValue) as? Bool ?? UserConfiguration.isReminderNotificationEnabled
        if let notificationSoundString = fromUserDefaults.value(forKey: Constant.Key.userConfigurationNotificationSound.rawValue) as? String {
            UserConfiguration.notificationSound = NotificationSound(rawValue: notificationSoundString) ?? UserConfiguration.notificationSound
        }
        
        UserConfiguration.isSilentModeEnabled = fromUserDefaults.value(forKey: Constant.Key.userConfigurationIsSilentModeEnabled.rawValue) as? Bool ?? UserConfiguration.isSilentModeEnabled
        UserConfiguration.silentModeStartHour = fromUserDefaults.value(forKey: Constant.Key.userConfigurationSilentModeStartHour.rawValue) as? Int ?? UserConfiguration.silentModeStartHour
        UserConfiguration.silentModeEndHour = fromUserDefaults.value(forKey: Constant.Key.userConfigurationSilentModeEndHour.rawValue) as? Int ?? UserConfiguration.silentModeEndHour
        UserConfiguration.silentModeStartMinute = fromUserDefaults.value(forKey: Constant.Key.userConfigurationSilentModeStartMinute.rawValue) as? Int ?? UserConfiguration.silentModeStartMinute
        UserConfiguration.silentModeEndMinute = fromUserDefaults.value(forKey: Constant.Key.userConfigurationSilentModeEndMinute.rawValue) as? Int ?? UserConfiguration.silentModeEndMinute
    }
    
    // MARK: - Main
    
    /// If OfflineModeManager.shared.shouldUpdateUser is false, sets the UserConfiguration values equal to all the values found in the body.
    static func setup(fromBody body: JSONResponseBody) {
        // This is a unique edge case. If the user updated their UserConfiguration (while offline), then terminates Hound, then re-opens Hound, the first thing the app will do is a get request to the Hound server. This would overwrite the user's local changes. Therefore, don't overwrite these changes.
        guard OfflineModeManager.shared.shouldUpdateUser == false else { return }
        
        if let interfaceStyleInt = body[Constant.Key.userConfigurationInterfaceStyle.rawValue] as? Int, let interfaceStyle = UIUserInterfaceStyle(rawValue: interfaceStyleInt) {
            self.interfaceStyle = interfaceStyle
        }
        if let measurementSystemInt = body[Constant.Key.userConfigurationMeasurementSystem.rawValue] as? Int, let measurementSystem = MeasurementSystem(rawValue: measurementSystemInt) {
            self.measurementSystem = measurementSystem
        }
        if let isHapticsEnabled = body[Constant.Key.userConfigurationIsHapticsEnabled.rawValue] as? Bool {
            self.isHapticsEnabled = isHapticsEnabled
        }
        if let usesDeviceTimeZone = body[Constant.Key.userConfigurationUsesDeviceTimeZone.rawValue] as? Bool {
            self.usesDeviceTimeZone = usesDeviceTimeZone
        }
        if let userTimeZone = body[Constant.Key.userConfigurationUserTimeZone.rawValue] as? String {
            self.userTimeZone = TimeZone(identifier: userTimeZone)
        }
        
        if let snoozeLength = body[Constant.Key.userConfigurationSnoozeLength.rawValue] as? Double {
            self.snoozeLength = snoozeLength
        }
        
        if let isNotificationEnabled = body[Constant.Key.userConfigurationIsNotificationEnabled.rawValue] as? Bool {
            self.isNotificationEnabled = isNotificationEnabled
        }
        if let isLoudNotificationEnabled = body[Constant.Key.userConfigurationIsLoudNotificationEnabled.rawValue] as? Bool {
            self.isLoudNotificationEnabled = isLoudNotificationEnabled
        }
        if let isLogNotificationEnabled = body[Constant.Key.userConfigurationIsLogNotificationEnabled.rawValue] as? Bool {
            self.isLogNotificationEnabled = isLogNotificationEnabled
        }
        if let isReminderNotificationEnabled = body[Constant.Key.userConfigurationIsReminderNotificationEnabled.rawValue] as? Bool {
            self.isReminderNotificationEnabled = isReminderNotificationEnabled
        }
        if let notificationSoundString = body[Constant.Key.userConfigurationNotificationSound.rawValue] as? String, let notificationSound = NotificationSound(rawValue: notificationSoundString) {
            self.notificationSound = notificationSound
        }
        
        if let isSilentModeEnabled = body[Constant.Key.userConfigurationIsSilentModeEnabled.rawValue] as? Bool {
            self.isSilentModeEnabled = isSilentModeEnabled
        }
        if let silentModeStartHour = body[Constant.Key.userConfigurationSilentModeStartHour.rawValue] as? Int {
            self.silentModeStartHour = silentModeStartHour
        }
        if let silentModeEndHour = body[Constant.Key.userConfigurationSilentModeEndHour.rawValue] as? Int {
            self.silentModeEndHour = silentModeEndHour
        }
        if let silentModeStartMinute = body[Constant.Key.userConfigurationSilentModeStartMinute.rawValue] as? Int {
            self.silentModeStartMinute = silentModeStartMinute
        }
        if let silentModeEndMinute = body[Constant.Key.userConfigurationSilentModeEndMinute.rawValue] as? Int {
            self.silentModeEndMinute = silentModeEndMinute
        }
    }
    
    // MARK: - In-App Appearance Related
    
    private static var storedInterfaceStyle: UIUserInterfaceStyle = .unspecified
    static var interfaceStyle: UIUserInterfaceStyle {
        get {
            storedInterfaceStyle
        }
        set {
            storedInterfaceStyle = newValue
            NotificationCenter.default.post(name: .didUpdateUserInterfaceStyle, object: nil)
        }
    }
    
    static var measurementSystem: MeasurementSystem = {
        if #available(iOS 16, *) {
            switch Locale.current.measurementSystem {
            case .metric:
                return .metric
            case .us:
                return .imperial
            case .uk:
                return .metric
            default:
                return .metric
            }
        }
        else {
            return Locale.current.usesMetricSystem ? .metric : .imperial
        }
    }()
    
    static var isHapticsEnabled: Bool = true
    
    static var usesDeviceTimeZone: Bool = true {
        didSet {
            if oldValue != usesDeviceTimeZone {
                NotificationCenter.default.post(name: .didUpdateUserTimeZone, object: nil)
            }
        }
    }
    
    static var userTimeZone: TimeZone? {
        didSet {
            if oldValue != userTimeZone {
                NotificationCenter.default.post(name: .didUpdateUserTimeZone, object: nil)
            }
        }
    }
    
    static var deviceTimeZone: TimeZone {
        TimeZone.autoupdatingCurrent
    }
    /// If usesTimeZone is true, this simply returns the device timeZone. Otherwise, it attempts to use the userTimeZone (possibly configured) to load the TZ
    static var timeZone: TimeZone {
        return usesDeviceTimeZone ? deviceTimeZone : userTimeZone ?? deviceTimeZone
    }
    
    // MARK: - Alarm Timing Related
    
    static var snoozeLength: Double = Double(60 * 5)
    
    // MARK: - iOS Notification Related
    
    /// This should be stored on the server as it is important to only send notifications to devices that can use them. This will always be overriden by the user upon reinstall if its state is different in that new install.
    static var isNotificationEnabled: Bool = false
    
    /// Determines if the app should send the user loud notifications. Loud notification bypass most iPhone settings to play at max volume (Do Not Disturb, ringer off, volume off...)
    static var isLoudNotificationEnabled: Bool = false
    
    /// Determines if the server should send the user notifications when a log is created (or other similar actions)
    static var isLogNotificationEnabled: Bool = true
    
    /// Determines if the server should send the user notifications when a reminder's alarm triggers (or other similar actions)
    static var isReminderNotificationEnabled: Bool = true
    
    /// Sound a notification will play
    static var notificationSound: NotificationSound = NotificationSound.radar
    
    static var isSilentModeEnabled: Bool = false
    
    /// Hour of the day, in UTC, that silent mode will start. During silent mode, no notifications will be sent to the user. Default 10 PM
    static var silentModeStartHour: Int = 22
    
    /// Hour of the day, in UTC, that silent mode will end. During silent mode, no notifications will be sent to the user. Default 5 AM
    static var silentModeEndHour: Int = 5
    
    static var silentModeStartMinute: Int = 0
    
    static var silentModeEndMinute: Int = 0
}

extension UserConfiguration {
    // MARK: - Request
    
    /// Returns an array literal of the user configurations's properties. This is suitable to be used as the JSON body for a HTTP request
    static func createBody(addingOntoBody: JSONRequestBody?) -> JSONRequestBody {
        var body: JSONRequestBody = addingOntoBody ?? [:]
        
        body[Constant.Key.userConfigurationInterfaceStyle.rawValue] = .int(UserConfiguration.interfaceStyle.rawValue)
        body[Constant.Key.userConfigurationMeasurementSystem.rawValue] = .int(UserConfiguration.measurementSystem.rawValue)
        body[Constant.Key.userConfigurationIsHapticsEnabled.rawValue] = .bool(UserConfiguration.isHapticsEnabled)
        body[Constant.Key.userConfigurationUsesDeviceTimeZone.rawValue] = .bool(UserConfiguration.usesDeviceTimeZone)
        body[Constant.Key.userConfigurationUserTimeZone.rawValue] = .string(UserConfiguration.userTimeZone?.identifier)
        body[Constant.Key.userConfigurationDeviceTimeZone.rawValue] = .string(UserConfiguration.deviceTimeZone.identifier)
        
        body[Constant.Key.userConfigurationSnoozeLength.rawValue] = .double(UserConfiguration.snoozeLength)
        
        body[Constant.Key.userConfigurationIsNotificationEnabled.rawValue] = .bool(UserConfiguration.isNotificationEnabled)
        body[Constant.Key.userConfigurationIsLoudNotificationEnabled.rawValue] = .bool(UserConfiguration.isLoudNotificationEnabled)
        body[Constant.Key.userConfigurationIsLogNotificationEnabled.rawValue] = .bool(UserConfiguration.isLogNotificationEnabled)
        body[Constant.Key.userConfigurationIsReminderNotificationEnabled.rawValue] = .bool(UserConfiguration.isReminderNotificationEnabled)
        body[Constant.Key.userConfigurationNotificationSound.rawValue] = .string(UserConfiguration.notificationSound.rawValue)
        
        body[Constant.Key.userConfigurationIsSilentModeEnabled.rawValue] = .bool(UserConfiguration.isSilentModeEnabled)
        body[Constant.Key.userConfigurationSilentModeStartHour.rawValue] = .int(UserConfiguration.silentModeStartHour)
        body[Constant.Key.userConfigurationSilentModeEndHour.rawValue] = .int(UserConfiguration.silentModeEndHour)
        body[Constant.Key.userConfigurationSilentModeStartMinute.rawValue] = .int(UserConfiguration.silentModeStartMinute)
        body[Constant.Key.userConfigurationSilentModeEndMinute.rawValue] = .int(UserConfiguration.silentModeEndMinute)
        
        // userNotificationToken is synced through UserRequest.update. Therefore, include it in the UserConfiguration body with the rest of the information that is updated. This is especially important for offline mode, which, if it detects a noResponse in UserRequest.update, re-syncs all of the UserConfiguration.
        body[Constant.Key.userNotificationToken.rawValue] = .string(UserInformation.userNotificationToken)
        return body
    }
}
//
//  FamilyInformation.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/5/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Configuration that is local to the app only. If the app is reinstalled then this data should be pulled down from the cloud
final class FamilyInformation: UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    static func persist(toUserDefaults: UserDefaults) {
        toUserDefaults.set(familyHeadUserId, forKey: Constant.Key.familyHeadUserId.rawValue)
        toUserDefaults.set(familyCode, forKey: Constant.Key.familyCode.rawValue)
        toUserDefaults.set(familyIsLocked, forKey: Constant.Key.familyIsLocked.rawValue)
        
        if let dataPreviousFamilyMembers = try? NSKeyedArchiver.archivedData(withRootObject: previousFamilyMembers, requiringSecureCoding: false) {
            toUserDefaults.set(dataPreviousFamilyMembers, forKey: Constant.Key.previousFamilyMembers.rawValue)
        }
        if let dataFamilyMembers = try? NSKeyedArchiver.archivedData(withRootObject: familyMembers, requiringSecureCoding: false) {
            toUserDefaults.set(dataFamilyMembers, forKey: Constant.Key.familyMembers.rawValue)
        }
        if let dataActiveFamilySubscription = try? NSKeyedArchiver.archivedData(withRootObject: familyActiveSubscription, requiringSecureCoding: false) {
            toUserDefaults.set(dataActiveFamilySubscription, forKey: Constant.Key.familyActiveSubscription.rawValue)
        }
    }
    
    static func load(fromUserDefaults: UserDefaults) {
        FamilyInformation.familyHeadUserId = fromUserDefaults.value(forKey: Constant.Key.familyHeadUserId.rawValue) as? String
        FamilyInformation.familyCode = fromUserDefaults.value(forKey: Constant.Key.familyCode.rawValue) as? String
        FamilyInformation.familyIsLocked = fromUserDefaults.value(forKey: Constant.Key.familyIsLocked.rawValue) as? Bool ?? FamilyInformation.familyIsLocked
       
        if let dataPreviousFamilyMembers: Data = UserDefaults.standard.data(forKey: Constant.Key.previousFamilyMembers.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataPreviousFamilyMembers) {
            unarchiver.requiresSecureCoding = false
            
            if let previousFamilyMembers = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? [FamilyMember] {
                FamilyInformation.previousFamilyMembers = previousFamilyMembers
            }
            else {
                HoundLogger.general.error("FamilyInformation.load: Failed to decode previousFamilyMembers with unarchiver")
            }
        }
        else {
            HoundLogger.general.error("FamilyInformation.load: Failed to construct dataPreviousFamilyMembers or construct unarchiver for dataPreviousFamilyMembers")
        }
        
        if let dataFamilyMembers: Data = UserDefaults.standard.data(forKey: Constant.Key.familyMembers.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataFamilyMembers) {
            unarchiver.requiresSecureCoding = false
            
            if let familyMembers = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? [FamilyMember] {
                FamilyInformation.familyMembers = familyMembers
            }
            else {
                HoundLogger.general.error("FamilyInformation.load: Failed to decode familyMembers with unarchiver")
            }
        }
        else {
            HoundLogger.general.error("FamilyInformation.load: Failed to construct dataFamilyMembers or construct unarchiver for dataFamilyMembers")
        }
        
        if let dataFamilyActiveSubscription: Data = UserDefaults.standard.data(forKey: Constant.Key.familyActiveSubscription.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataFamilyActiveSubscription) {
            unarchiver.requiresSecureCoding = false
            
            if let familyActiveSubscription = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? Subscription {
                // The familyActiveSubscription should always have isActive true. However, decodeBool might decode it as false if no key exists for that value.
                familyActiveSubscription.isActive = true
                FamilyInformation.addFamilySubscription(subscription: familyActiveSubscription)
            }
            else {
                HoundLogger.general.error("FamilyInformation.load: Failed to decode familyActiveSubscription with unarchiver")
            }
        }
        else {
            HoundLogger.general.error("FamilyInformation.load: Failed to construct dataFamilyActiveSubscription or construct unarchiver for dataFamilyActiveSubscription")
        }
    }
    
    // MARK: - Properties
    
    private(set) static var familyHeadUserId: String?

    /// The code used by new users to join the family
    private(set) static var familyCode: String?

    /// If a family is locked, then no new members can join. Only the family head can lock and unlock the family.
    static var familyIsLocked: Bool = false

    /// Users that used to be in the family
    private(set) static var previousFamilyMembers: [FamilyMember] = []

    /// Users that are currently in the family
    private(set) static var familyMembers: [FamilyMember] = []

    private(set) static var familySubscriptions: [Subscription] = []

    // MARK: - Main
    
    /// Sets the FamilyInformation values equal to all the values found in the fromBody. The key for the each fromBody value must match the name of the FamilyInformation property exactly in order to be used. The value must also be able to be converted into the proper data type.
    static func setup(fromBody: JSONResponseBody) {
        let oldUserIds = Set(familyMembers.map { $0.userId })
        if let familyHeadUserId = fromBody[Constant.Key.familyHeadUserId.rawValue] as? String {
            self.familyHeadUserId = familyHeadUserId
        }
        if let familyIsLocked = fromBody[Constant.Key.familyIsLocked.rawValue] as? Bool {
            self.familyIsLocked = familyIsLocked
        }
        if let familyCode = fromBody[Constant.Key.familyCode.rawValue] as? String {
            self.familyCode = familyCode
        }
        if let familyMembersBody = fromBody[Constant.Key.familyMembers.rawValue] as? [JSONResponseBody] {
            familyMembers.removeAll()
            // get individual bodies for members
            for familyMemberBody in familyMembersBody {
                // convert fromBody into family member
                familyMembers.append(FamilyMember(fromBody: familyMemberBody))
            }

            familyMembers.sort(by: { $0 <= $1 })
        }
        if let previousFamilyMembersBody = fromBody[Constant.Key.previousFamilyMembers.rawValue] as? [JSONResponseBody] {
            previousFamilyMembers.removeAll()

            // get individual bodies for previous family members
            for previousFamilyMemberBody in previousFamilyMembersBody {
                // convert fromBody into family member; a previousFamilyMember can't be a family head so pass nil
                previousFamilyMembers.append(FamilyMember(fromBody: previousFamilyMemberBody))
            }

            previousFamilyMembers.sort(by: { $0 <= $1 })

        }
        if let familyActiveSubscriptionBody = fromBody[Constant.Key.familyActiveSubscription.rawValue] as? JSONResponseBody {
            let familyActiveSubscription = Subscription(fromBody: familyActiveSubscriptionBody)
            addFamilySubscription(subscription: familyActiveSubscription)
        }
        
        let newUserIds = Set(familyMembers.map { $0.userId })
                   let added = newUserIds.subtracting(oldUserIds)
                   let removed = oldUserIds.subtracting(newUserIds)
                   updateRemindersForFamilyMemberChanges(addedUserIds: added, removedUserIds: removed)
    }
    
    // MARK: - Computed Properties
    
    static var familyActiveSubscription: Subscription {
        let potentialSubscription = familySubscriptions.first { subscription in
            subscription.isActive
        }

        return potentialSubscription ?? Constant.Class.Subscription.defaultSubscription
    }
    
    // MARK: - Functions
    
    static func findFamilyMember(userId: String?) -> FamilyMember? {
        guard let userId = userId else {
            return nil
        }

        let matchingFamilyMember: FamilyMember? = FamilyInformation.familyMembers.first { familyMember in
            familyMember.userId == userId
        } ?? FamilyInformation.previousFamilyMembers.first(where: { previousFamilyMember in
            previousFamilyMember.userId == userId
        })

        return matchingFamilyMember
    }

    static func addFamilySubscription(subscription: Subscription) {
        // Remove any transactions that match the transactionId
        familySubscriptions.removeAll { existingSubscription in
            existingSubscription.transactionId == subscription.transactionId
        }

        if subscription.isActive {
            // There can only be one active subscription, so remove tag from others
            familySubscriptions.forEach { existingSubscription in
                existingSubscription.isActive = false
            }
            // Active subscription goes at the beginning
            familySubscriptions.insert(subscription, at: 0)
        }
        else {
            // Other subscriptions go at the end
            familySubscriptions.append(subscription)
        }
    }

    static func clearAllFamilySubscriptions() {
        familySubscriptions.removeAll()
    }
    
    private static func updateRemindersForFamilyMemberChanges(addedUserIds: Set<String>, removedUserIds: Set<String>) {
            guard let dogManager = DogManager.globalDogManager else { return }
            for dog in dogManager.dogs {
                for reminder in dog.dogReminders.dogReminders {
                    var recipients = Set(reminder.reminderRecipientUserIds)
                    recipients.formUnion(addedUserIds)
                    recipients.subtract(removedUserIds)
                    reminder.reminderRecipientUserIds = Array(recipients)
                }
            }
        }

}
//
//  UserInformation.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/7/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import KeychainSwift

/// Information specific to the user.
final class UserInformation: UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    /// Persists all of the UserInformation variables to the specified UserDefaults and, selectively, some to KeychainSwift
    static func persist(toUserDefaults: UserDefaults) {
        let keychain = KeychainSwift()
        
        if let userIdentifier = UserInformation.userIdentifier {
            keychain.set(userIdentifier, forKey: Constant.Key.userIdentifier.rawValue)
            UserDefaults.standard.set(userIdentifier, forKey: Constant.Key.userIdentifier.rawValue)
        }

        if let email = UserInformation.userEmail {
            keychain.set(email, forKey: Constant.Key.userEmail.rawValue)
            UserDefaults.standard.set(email, forKey: Constant.Key.userEmail.rawValue)
        }

        if let firstName = UserInformation.userFirstName {
            keychain.set(firstName, forKey: Constant.Key.userFirstName.rawValue)
            UserDefaults.standard.set(firstName, forKey: Constant.Key.userFirstName.rawValue)
        }

        if let lastName = UserInformation.userLastName {
            keychain.set(lastName, forKey: Constant.Key.userLastName.rawValue)
            UserDefaults.standard.set(lastName, forKey: Constant.Key.userLastName.rawValue)
        }
        
        // The important
        toUserDefaults.set(UserInformation.userId, forKey: Constant.Key.userId.rawValue)
        toUserDefaults.set(UserInformation.familyId, forKey: Constant.Key.familyId.rawValue)
        toUserDefaults.set(UserInformation.userAppAccountToken, forKey: Constant.Key.userAppAccountToken.rawValue)
        toUserDefaults.set(UserInformation.userNotificationToken, forKey: Constant.Key.userNotificationToken.rawValue)
    }
    
    /// Loads all of the UserInformation variables from the specified UserDefaults and, selectively, some from KeychainSwift
    static func load(fromUserDefaults: UserDefaults) {
        // These values are retrieved from Sign In With Apple so therefore need to be persisted specially. All other values can be retrieved using these values.
        let keychain = KeychainSwift()
        
        UserInformation.userIdentifier =
        keychain.get(Constant.Key.userIdentifier.rawValue)
        ?? fromUserDefaults.value(forKey: Constant.Key.userIdentifier.rawValue) as? String
        ?? Constant.Development.developmentDatabaseTestUserIdentifier
        ?? UserInformation.userIdentifier
        
        UserInformation.userEmail =
        keychain.get(Constant.Key.userEmail.rawValue)
        ?? fromUserDefaults.value(forKey: Constant.Key.userEmail.rawValue) as? String
        ?? UserInformation.userEmail
        
        UserInformation.userFirstName =
        keychain.get(Constant.Key.userFirstName.rawValue)
        ?? fromUserDefaults.value(forKey: Constant.Key.userFirstName.rawValue) as? String
        ?? UserInformation.userFirstName
        
        UserInformation.userLastName =
        keychain.get(Constant.Key.userLastName.rawValue)
        ?? fromUserDefaults.value(forKey: Constant.Key.userLastName.rawValue) as? String
        ?? UserInformation.userLastName
        
        // MARK: Load Rest of User Information (excluding that which was loaded from the keychain)
        
        UserInformation.userId = fromUserDefaults.value(forKey: Constant.Key.userId.rawValue) as? String ?? UserInformation.userId ?? Constant.Development.developmentDatabaseTestUserId
        
        UserInformation.familyId = fromUserDefaults.value(forKey: Constant.Key.familyId.rawValue) as? String ?? UserInformation.familyId
        
        UserInformation.userAppAccountToken = fromUserDefaults.value(forKey: Constant.Key.userAppAccountToken.rawValue) as? String ?? UserInformation.userAppAccountToken
        
        UserInformation.userNotificationToken = fromUserDefaults.value(forKey: Constant.Key.userNotificationToken.rawValue) as? String ?? UserInformation.userNotificationToken
    }
    
    // MARK: - Properties
    
    static var userId: String?

    static var userIdentifier: String?
    
    static var familyId: String?

    static var userAppAccountToken: String?

    static var userNotificationToken: String?

    static var userEmail: String?

    static var userFirstName: String?

    static var userLastName: String?
    
    // MARK: - Main
    /// Sets the UserInformation values equal to all the values found in the body. The key for the each body value must match the name of the UserConfiguration property exactly in order to be used. The value must also be able to be converted into the proper data type.
    static func setup(fromBody body: JSONResponseBody) {
        if let userId = body[Constant.Key.userId.rawValue] as? String {
            self.userId = userId
        }
        if let familyId = body[Constant.Key.familyId.rawValue] as? String {
            self.familyId = familyId
        }
        if let userAppAccountToken = body[Constant.Key.userAppAccountToken.rawValue] as? String {
            self.userAppAccountToken = userAppAccountToken
        }
        if let userNotificationToken = body[Constant.Key.userNotificationToken.rawValue] as? String {
            self.userNotificationToken = userNotificationToken
        }
        if let userEmail = body[Constant.Key.userEmail.rawValue] as? String {
            self.userEmail = userEmail
        }
        if let userFirstName = body[Constant.Key.userFirstName.rawValue] as? String {
            self.userFirstName = userFirstName
        }
        if let userLastName = body[Constant.Key.userLastName.rawValue] as? String {
            self.userLastName = userLastName
        }
    }
    
    // MARK: - Computed Properties
    
    /// The users member's full name. Handles cases where the first name and/or last name may be ""
    static var displayFullName: String {
        let trimmedFirstName = userFirstName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        let trimmedLastName = userLastName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""

        // check to see if anything is blank
        if trimmedFirstName.isEmpty && trimmedLastName.isEmpty {
            return Constant.Visual.Text.unknownName
        }
        // we know one of OR both of the trimmedFirstName and trimmedLast name are != nil &&.isEmpty == false
        else if trimmedFirstName.isEmpty {
            // no first name but has last name
            return trimmedLastName
        }
        else if trimmedLastName.isEmpty {
            // no last name but has first name
            return trimmedFirstName
        }
        else {
            return "\(trimmedFirstName) \(trimmedLastName)"
        }
    }
    
    static var isUserFamilyHead: Bool {
        return FamilyInformation.findFamilyMember(userId: UserInformation.userId)?.isUserFamilyHead ?? false
    }
    
    // MARK: - Function
    
    /// Returns an array literal of the user information's properties. This is suitable to be used as the JSON body for a HTTP request
    static func createBody(addingOntoBody: JSONRequestBody?) -> JSONRequestBody {
        var body: JSONRequestBody = addingOntoBody ?? [:]
        body[Constant.Key.userEmail.rawValue] = .string(UserInformation.userEmail)
        body[Constant.Key.userFirstName.rawValue] = .string(UserInformation.userFirstName)
        body[Constant.Key.userLastName.rawValue] = .string(UserInformation.userLastName)
        return body
    }
}
//
//  LocalConfiguration.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/7/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import StoreKit
import UIKit

/// Configuration that is local to the app only. If the app is reinstalled then this data should be fresh
final class LocalConfiguration: UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    /// Persists all of the LocalConfiguration variables and the globalDogManager to the specified UserDefaults
    static func persist(toUserDefaults: UserDefaults) {
        toUserDefaults.set(LocalConfiguration.previousDogManagerSynchronization, forKey: Constant.Key.previousDogManagerSynchronization.rawValue)
        
        if let dogManager = DogManager.globalDogManager, let dataDogManager = try? NSKeyedArchiver.archivedData(withRootObject: dogManager, requiringSecureCoding: false) {
            toUserDefaults.set(dataDogManager, forKey: Constant.Key.dogManager.rawValue)
        }
        
        if let dataLocalPreviousLogCustomActionNames = try? NSKeyedArchiver.archivedData(withRootObject: LocalConfiguration.localPreviousLogCustomActionNames, requiringSecureCoding: false) {
            toUserDefaults.set(dataLocalPreviousLogCustomActionNames, forKey: Constant.Key.localPreviousLogCustomActionNames.rawValue)
        }
        if let dataLocalPreviousReminderCustomActionNames = try? NSKeyedArchiver.archivedData(withRootObject: LocalConfiguration.localPreviousReminderCustomActionNames, requiringSecureCoding: false) {
            toUserDefaults.set(dataLocalPreviousReminderCustomActionNames, forKey: Constant.Key.localPreviousReminderCustomActionNames.rawValue)
        }
        
        toUserDefaults.set(LocalConfiguration.localIsNotificationAuthorized, forKey: Constant.Key.localIsNotificationAuthorized.rawValue)
        
        toUserDefaults.set(LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested, forKey: Constant.Key.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.rawValue)
        
        toUserDefaults.set(LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted, forKey: Constant.Key.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted.rawValue)
        
        let versionsRaw = LocalConfiguration.localAppVersionsWithReleaseNotesShown.map { $0.rawValue }
        toUserDefaults.set(versionsRaw, forKey: Constant.Key.localAppVersionsWithReleaseNotesShown.rawValue)
        
        toUserDefaults.set(LocalConfiguration.localHasCompletedHoundIntroductionViewController, forKey: Constant.Key.localHasCompletedHoundIntroductionViewController.rawValue)
        toUserDefaults.set(LocalConfiguration.localHasCompletedRemindersIntroductionViewController, forKey: Constant.Key.localHasCompletedRemindersIntroductionViewController.rawValue)
        toUserDefaults.set(LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController, forKey: Constant.Key.localHasCompletedFamilyUpgradeIntroductionViewController.rawValue)
        
        // Don't persist value. This is purposefully reset everytime the app reopens
        LocalConfiguration.localDateWhenAppLastEnteredBackground = Date()
    }
    
    /// Load all of the LocalConfiguration variables and the globalDogManager from the specified UserDefaults
    static func load(fromUserDefaults: UserDefaults) {
        LocalConfiguration.previousDogManagerSynchronization = fromUserDefaults.value(forKey: Constant.Key.previousDogManagerSynchronization.rawValue) as? Date ?? LocalConfiguration.previousDogManagerSynchronization
        
        if let dataDogManager: Data = UserDefaults.standard.data(forKey: Constant.Key.dogManager.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataDogManager) {
            unarchiver.requiresSecureCoding = false
            
            if let dogManager = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? DogManager {
                DogManager.globalDogManager = dogManager
            }
            else {
                // if nil, then decode failed or there was an issue. therefore, set the interval back to past so we can refresh from the server
                HoundLogger.general.error("Failed to decode dogManager with unarchiver")
                PersistenceManager.clearDogManagerStorage()
            }
        }
        else {
            // if nil, then decode failed or there was an issue. therefore, set the interval back to past so we can refresh from the server
            HoundLogger.general.error("Failed to construct dataDogManager or construct unarchiver for dogManager")
            PersistenceManager.clearDogManagerStorage()
        }
        
        if let dataLocalPreviousLogCustomActionNames: Data = fromUserDefaults.data(forKey: Constant.Key.localPreviousLogCustomActionNames.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataLocalPreviousLogCustomActionNames) {
            unarchiver.requiresSecureCoding = false
            
            LocalConfiguration.localPreviousLogCustomActionNames = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? [PreviousLogCustomActionName] ?? LocalConfiguration.localPreviousLogCustomActionNames
        }
        
        if let dataLocalPreviousReminderCustomActionNames: Data = fromUserDefaults.data(forKey: Constant.Key.localPreviousReminderCustomActionNames.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataLocalPreviousReminderCustomActionNames) {
            unarchiver.requiresSecureCoding = false
            
            LocalConfiguration.localPreviousReminderCustomActionNames = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? [PreviousReminderCustomActionName] ?? LocalConfiguration.localPreviousReminderCustomActionNames
        }
        
        LocalConfiguration.localIsNotificationAuthorized =
        fromUserDefaults.value(forKey: Constant.Key.localIsNotificationAuthorized.rawValue) as? Bool
        ?? LocalConfiguration.localIsNotificationAuthorized
        
        LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested =
        fromUserDefaults.value(forKey: Constant.Key.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.rawValue) as? [Date]
        ?? LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested
        
        LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted =
        fromUserDefaults.value(forKey: Constant.Key.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted.rawValue) as? [Date]
        ?? LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted
        
        LocalConfiguration.localPreviousDatesUserReviewRequested =
        fromUserDefaults.value(forKey: Constant.Key.localPreviousDatesUserReviewRequested.rawValue) as? [Date] ?? LocalConfiguration.localPreviousDatesUserReviewRequested
        
        if let rawStrings = fromUserDefaults.value(forKey: Constant.Key.localAppVersionsWithReleaseNotesShown.rawValue) as? [String] {
            LocalConfiguration.localAppVersionsWithReleaseNotesShown = rawStrings.map { AppVersion(from: $0) }.compactMap({ v in
                return v
            })
        }
        
        LocalConfiguration.localHasCompletedHoundIntroductionViewController =
        fromUserDefaults.value(forKey: Constant.Key.localHasCompletedHoundIntroductionViewController.rawValue) as? Bool
        ?? LocalConfiguration.localHasCompletedHoundIntroductionViewController
        
        LocalConfiguration.localHasCompletedRemindersIntroductionViewController =
        fromUserDefaults.value(forKey: Constant.Key.localHasCompletedRemindersIntroductionViewController.rawValue) as? Bool
        ?? LocalConfiguration.localHasCompletedRemindersIntroductionViewController
        
        // Before 4.0.0 "localHasCompletedFamilyUpgradeIntroductionViewController" was "localHasCompletedSettingsFamilyIntroductionViewController"
        if let legacyValue = fromUserDefaults.value(forKey: "localHasCompletedSettingsFamilyIntroductionViewController") as? Bool {
            fromUserDefaults.set(legacyValue, forKey: Constant.Key.localHasCompletedFamilyUpgradeIntroductionViewController.rawValue)
            fromUserDefaults.removeObject(forKey: "localHasCompletedSettingsFamilyIntroductionViewController")
        }
        LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController =
        fromUserDefaults.value(forKey: Constant.Key.localHasCompletedFamilyUpgradeIntroductionViewController.rawValue) as? Bool ?? LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController
    }
    
    // MARK: Sync Related
    
    /// For our first every dogManager sync, we want to retrieve ever dog, reminder, and log (which can be a LOT of data as accounts accumlate logs over the years). To get everything the family has ever added, we set our last sync as far back in time as it will go. This will retrieve everything
    static var previousDogManagerSynchronization: Date?
    
    // MARK: Log Related
    
    /// An array storing the logCustomActionName input by the user. If the user selects a log as 'Custom' then puts in a custom name, it will be tracked here.
    static var localPreviousLogCustomActionNames: [PreviousLogCustomActionName] = []
    
    /// Add the custom log action name to the stored array of localPreviousLogCustomActionNames. If it is already present, then nothing changes, otherwise override the oldest one
    static func addLogCustomAction(logActionType: LogActionType, logCustomActionName: String) {
        // make sure its a valid custom type
        guard logActionType.allowsCustom else { return }
        
        // make sure the name actually contains something
        guard logCustomActionName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false else { return }
        
        // Remove any identical records to this, as we want these to all be unique
        localPreviousLogCustomActionNames.removeAll { previousLogCustomActionName in
            return previousLogCustomActionName.logActionTypeId == logActionType.logActionTypeId && previousLogCustomActionName.logCustomActionName == logCustomActionName
        }
        
        // Re-add at beginning of array
        localPreviousLogCustomActionNames.insert(
            PreviousLogCustomActionName(
                logActionTypeId: logActionType.logActionTypeId,
                logCustomActionName: logCustomActionName
            ),
            at: 0
        )
        
        // check to see if we are over capacity for this specific action type
        var countForType = 0
        for (index, element) in localPreviousLogCustomActionNames.enumerated().reversed() where element.logActionTypeId == logActionType.logActionTypeId {
            countForType += 1
            if countForType > PreviousLogCustomActionName.maxStored {
                localPreviousLogCustomActionNames.remove(at: index)
            }
            
        }
    }
    
    // MARK: Reminder Related
    
    /// An array storing the localPreviousReminderCustomActionNames input by the user. If the user selects a reminder as 'Custom' then puts in a custom name, it will be tracked here.
    static var localPreviousReminderCustomActionNames: [PreviousReminderCustomActionName] = []
    
    /// Add the custom reminder action name to the stored array of localPreviousReminderCustomActionNames. If it is already present, then nothing changes, otherwise override the oldest one
    static func addReminderCustomAction(reminderActionType: ReminderActionType, reminderCustomActionName: String) {
        // make sure its a valid custom type
        guard reminderActionType.allowsCustom else { return }
        
        // make sure the name actually contains something
        guard reminderCustomActionName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false else { return }
        
        // Remove any identical records to this, as we want these to all be unique
        localPreviousReminderCustomActionNames.removeAll { previousReminderCustomActionName in
            return previousReminderCustomActionName.reminderActionTypeId == reminderActionType.reminderActionTypeId && previousReminderCustomActionName.reminderCustomActionName == reminderCustomActionName
        }
        
        // Re-add at beginning of array
        localPreviousReminderCustomActionNames.insert(
            PreviousReminderCustomActionName(
                reminderActionTypeId: reminderActionType.reminderActionTypeId,
                reminderCustomActionName: reminderCustomActionName
            ),
            at: 0
        )
        
        // check to see if we are over capacity for this specific action type
        var countForType = 0
        for (index, element) in localPreviousReminderCustomActionNames.enumerated().reversed() where element.reminderActionTypeId == reminderActionType.reminderActionTypeId {
            countForType += 1
            if countForType > PreviousReminderCustomActionName.maxStored {
                localPreviousReminderCustomActionNames.remove(at: index)
            }
        }
    }
    
    // MARK: iOS Notification Related
    
    static var localIsNotificationAuthorized: Bool = false
    
    // MARK: Alert Related
    
    /// Used to track when the user was last asked to give survey feedback on their experience with Hound. We add a Date() to the array by default to signify when the app was installed (or the update for this feature was installed)
    static var localPreviousDatesUserSurveyFeedbackAppExperienceRequested: [Date] = []
    
    /// Used to track when the user last provided the survey feedback on their experience with Hound
    static var localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted: [Date] = []
    
    /// Used to track when the user was shown Apple's request review pop-up that allows the user to one to five star Hound
    static var localPreviousDatesUserReviewRequested: [Date] = []
    
    /// Keeps track of what Hound versions the release notes have been shown for. For example, if we show the release notes for Hound 2.0.0, then we will store 2.0.0 in the array. This makes sure the release notes are only shown once for a given update
    static var localAppVersionsWithReleaseNotesShown: [AppVersion] = []
    
    /// Keeps track of if the user has viewed AND completed the family introduction view controller (which helps the user setup their first dog)
    static var localHasCompletedHoundIntroductionViewController: Bool = false
    
    /// Keeps track of if the user has viewed AND completed the reminders introduction view controller (which helps the user setup their first reminders)
    static var localHasCompletedRemindersIntroductionViewController: Bool = false
    
    /// Keeps track of if the user has viewed AND completed the settings family introduction view controller (which helps notify the user of their family limits)
    static var localHasCompletedFamilyUpgradeIntroductionViewController: Bool = false
    
    /// Everytime Hound is restarted and entering from a terminated state, this value is set to Date(). Then when the app closes, it is set to Date() again. If Hound is closed for more than a certain time frame, using this variable to track how long it was closed, then we do certain actions, e.g. refresh the dog manager for new updates.
    static var localDateWhenAppLastEnteredBackground: Date = Date()
}
//
//  CompatibleDataTypeForJSON.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/10/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

typealias JSONRequestBody = [String: JSONValue?]
typealias JSONResponseBody = [String: Any?]

enum JSONValue {
    case string(String?)
    case int(Int?)
    case double(Double?)
    case bool(Bool?)
    case array([JSONValue?])
    case object([String: JSONValue?])
    
    func toAny() -> Any? {
        switch self {
        case .string(let str): return str
        case .int(let int): return int
        case .double(let dbl): return dbl
        case .bool(let bool): return bool
        case .array(let arr):
            // For JSON, NSNull represents nil elements in arrays
            return arr.map { $0?.toAny() ?? NSNull() }
        case .object(let obj):
            // Remove any nil values if needed, or keep as NSNull
            var dict = [String: Any]()
            for (key, value) in obj {
                dict[key] = value?.toAny() ?? NSNull()
            }
            return dict
        }
    }
}

extension Dictionary where Key == String, Value == JSONValue? {
    func toAnyDictionary() -> [String: Any] {
        var out = [String: Any]()
        for (k, v) in self {
            if let val = v?.toAny() {
                out[k] = val
            }
            else {
                out[k] = NSNull() // or skip if you prefer to omit null keys
            }
        }
        return out
    }
}
//
//  HoundUIProtocol.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/10/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

protocol HoundUIProtocol {
    /// Open ended field to be used for extra information if needed in certain use cases
    var properties: JSONRequestBody { get set }
}

protocol HoundUIKitProtocol {
    func setupGeneratedViews()
    func addSubViews()
    func setupConstraints()
}
//
//  UserDefaultPersistable.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/14/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

protocol UserDefaultPersistable {
    static func persist(toUserDefaults: UserDefaults)
    static func load(fromUserDefaults: UserDefaults)
}
//
//  TriggerTests.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import XCTest
@testable import Hound

final class TriggerTests: XCTestCase {
    
    func testTimeDelayInitializationAndChanges() {
        let reaction = TriggerLogReaction(forLogActionTypeId: 2, forLogCustomActionName: "walk")
        let reminderResult = TriggerReminderResult(forReminderActionTypeId: 4, forReminderCustomActionName: nil)
        let trig = Trigger(triggerLogReactions: [reaction],
                           triggerReminderResult: reminderResult,
                           triggerType: .timeDelay,
                           triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 120),
                           triggerManualCondition: true,
                           triggerAlarmCreatedCondition: false)
        XCTAssertEqual(trig.triggerType, .timeDelay)
        XCTAssertEqual(trig.timeDelayComponents.triggerTimeDelay, 120)
        XCTAssertTrue(trig.triggerManualCondition)
        XCTAssertFalse(trig.triggerAlarmCreatedCondition)
        XCTAssertTrue(trig.timeDelayComponents.changeTriggerTimeDelay(300))
        XCTAssertEqual(trig.timeDelayComponents.triggerTimeDelay, 300)
        XCTAssertFalse(trig.timeDelayComponents.changeTriggerTimeDelay(-10))
        XCTAssertEqual(trig.timeDelayComponents.triggerTimeDelay, 300)
    }
    
    func testFixedTimeInitializationAndChanges() {
        let reaction = TriggerLogReaction(forLogActionTypeId: 1, forLogCustomActionName: nil)
        let reminderResult = TriggerReminderResult(forReminderActionTypeId: 3, forReminderCustomActionName: "potty")
        let trig = Trigger(triggerLogReactions: [reaction],
                           triggerReminderResult: reminderResult,
                           triggerType: .fixedTime,
                           triggerFixedTimeComponents: TriggerFixedTimeComponents(
                            triggerFixedTimeTypeAmount: 1,
                            triggerFixedTimeHour: 6,
                            triggerFixedTimeMinute: 30))
        XCTAssertEqual(trig.triggerType, .fixedTime)
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeTypeAmount, 1)
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeHour, 6)
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeMinute, 30)
        XCTAssertTrue(trig.fixedTimeComponents.changeTriggerFixedTimeTypeAmount(2))
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeTypeAmount, 2)
        XCTAssertFalse(trig.fixedTimeComponents.changeTriggerFixedTimeTypeAmount(-1))
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeTypeAmount, 2)
        XCTAssertTrue(trig.fixedTimeComponents.changeFixedTimeHour(23))
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeHour, 23)
        XCTAssertFalse(trig.fixedTimeComponents.changeFixedTimeHour(25))
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeHour, 23)
        XCTAssertTrue(trig.fixedTimeComponents.changeFixedTimeMinute(45))
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeMinute, 45)
        XCTAssertFalse(trig.fixedTimeComponents.changeFixedTimeMinute(61))
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeMinute, 45)
    }
    
    func testShouldActivateTrigger() {
        let reaction1 = TriggerLogReaction(forLogActionTypeId: 1, forLogCustomActionName: nil)
        let reaction2 = TriggerLogReaction(forLogActionTypeId: 2, forLogCustomActionName: "play")
        let trig = Trigger(triggerLogReactions: [reaction1, reaction2])
        var log = Log(forLogActionTypeId: 1, forLogCustomActionName: nil)
        XCTAssertTrue(trig.shouldActivateTrigger(forLog: log))
        log = Log(forLogActionTypeId: 2, forLogCustomActionName: "play")
        XCTAssertTrue(trig.shouldActivateTrigger(forLog: log))
        log = Log(forLogActionTypeId: 2, forLogCustomActionName: "foo")
        XCTAssertFalse(trig.shouldActivateTrigger(forLog: log))
        trig.triggerManualCondition = false
        log = Log(forLogActionTypeId: 1, forLogCustomActionName: nil)
        XCTAssertFalse(trig.shouldActivateTrigger(forLog: log))
        trig.triggerManualCondition = true
        trig.triggerAlarmCreatedCondition = false
        log = Log(forLogActionTypeId: 1, forLogCustomActionName: nil, forCreatedByReminderUUID: UUID())
        XCTAssertFalse(trig.shouldActivateTrigger(forLog: log))
    }
    
    func testNextReminderDateTimeDelay() {
        let trig = Trigger(triggerType: .timeDelay,
                           triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 60))
        let basis = TestHelper.date("2024-01-01T00:00:00Z")
        let next = trig.nextReminderDate(afterDate: basis, in: TestHelper.utc)
        XCTAssertEqual(next, basis.addingTimeInterval(60))
    }
    
    func testNextReminderDateFixedTime() {
        let trig = Trigger(triggerType: .fixedTime,
                           triggerFixedTimeComponents: TriggerFixedTimeComponents(
                            triggerFixedTimeTypeAmount: 0,
                            triggerFixedTimeHour: 15,
                            triggerFixedTimeMinute: 0))
        let basis = TestHelper.date("2024-05-10T14:00:00Z")
        let tz = TimeZone(identifier: "UTC")!
        let next = trig.nextReminderDate(afterDate: basis, in: tz)!
        var cal = Calendar(identifier: .gregorian)
        cal.timeZone = tz
        var comps = cal.dateComponents(in: tz, from: basis)
        comps.hour = 15; comps.minute = 0; comps.second = 0
        let expected = cal.date(from: comps)!
        XCTAssertEqual(next, expected)
        // when past time, roll over next day
        let pastBasis = TestHelper.date("2024-05-10T16:00:00Z")
        let rollover = trig.nextReminderDate(afterDate: pastBasis, in: tz)!
        let expectedRoll = cal.date(byAdding: .day, value: 1, to: expected)!
        XCTAssertEqual(rollover, expectedRoll)
    }
    
    func testCreateTriggerResultReminder() {
        let trig = Trigger(triggerType: .timeDelay,
                           triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 60))
        let log = Log(forLogActionTypeId: 1)
        guard let rem = trig.createTriggerResultReminder(afterLog: log, in: TestHelper.utc) else { return XCTFail("nil") }
        XCTAssertEqual(rem.reminderActionTypeId, trig.triggerReminderResult.reminderActionTypeId)
        XCTAssertTrue(rem.reminderIsTriggerResult)
        XCTAssertEqual(rem.oneTimeComponents.oneTimeDate, log.logStartDate.addingTimeInterval(60))
    }
    
    func testSetTriggerLogReactionsRemovesDuplicates() {
        let r1 = TriggerLogReaction(forLogActionTypeId: 1, forLogCustomActionName: nil)
        let dup = TriggerLogReaction(forLogActionTypeId: 1, forLogCustomActionName: nil)
        let trig = Trigger(triggerLogReactions: [r1])
        XCTAssertTrue(trig.setTriggerLogReactions([r1, dup]))
        XCTAssertEqual(trig.triggerLogReactions.count, 1)
        XCTAssertFalse(trig.setTriggerLogReactions([]))
    }
    
    func testTimeDelayChangeRejectsZero() {
        let trig = Trigger(triggerType: .timeDelay,
                           triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 60))
        XCTAssertFalse(trig.timeDelayComponents.changeTriggerTimeDelay(0))
        XCTAssertEqual(trig.timeDelayComponents.triggerTimeDelay, 60)
    }
    
    func testFixedTimeChangeRejectsNegative() {
        let trig = Trigger(triggerType: .fixedTime,
                           triggerFixedTimeComponents: TriggerFixedTimeComponents(
                            triggerFixedTimeTypeAmount: 0,
                            triggerFixedTimeHour: 10,
                            triggerFixedTimeMinute: 0))
        XCTAssertFalse(trig.fixedTimeComponents.changeFixedTimeHour(-1))
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeHour, 10)
        XCTAssertFalse(trig.fixedTimeComponents.changeFixedTimeMinute(-5))
        XCTAssertEqual(trig.fixedTimeComponents.triggerFixedTimeMinute, 0)
    }
    
    func testNextReminderDateTimeDelayUsesEndDate() {
        let trig = Trigger(triggerType: .timeDelay,
                           triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 120))
        let start = TestHelper.date("2024-01-01T10:00:00Z")
        let end = TestHelper.date("2024-01-01T11:00:00Z")
        let log = Log(forLogActionTypeId: 1, forLogStartDate: start, forLogEndDate: end)
        let next = trig.nextReminderDate(afterLog: log, in: TestHelper.utc)
        XCTAssertEqual(next, end.addingTimeInterval(120))
    }
    
    func testDogTriggerManagerMatching() {
        let trig1 = Trigger(triggerLogReactions: [TriggerLogReaction(forLogActionTypeId: 1, forLogCustomActionName: nil)],
                            triggerType: .timeDelay,
                            triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 60))
        let trig2 = Trigger(triggerLogReactions: [TriggerLogReaction(forLogActionTypeId: 2, forLogCustomActionName: "play")],
                            triggerType: .timeDelay,
                            triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 120))
        let manager = DogTriggerManager(forDogTriggers: [trig1, trig2])
        let m1 = manager.matchingActivatedTriggers(forLog: Log(forLogActionTypeId: 1))
        XCTAssertEqual(m1.map { $0.triggerUUID }, [trig1.triggerUUID])
        let m2 = manager.matchingActivatedTriggers(forLog: Log(forLogActionTypeId: 2, forLogCustomActionName: "play"))
        XCTAssertEqual(m2.map { $0.triggerUUID }, [trig2.triggerUUID])
        XCTAssertTrue(manager.matchingActivatedTriggers(forLog: Log(forLogActionTypeId: 3)).isEmpty)
    }
    
    func testTriggerComparisonSorting() {
        let t1 = Trigger(triggerType: .timeDelay,
                         triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 30))
        let t2 = Trigger(triggerType: .timeDelay,
                         triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 60))
        let t3 = Trigger(triggerType: .fixedTime,
                         triggerFixedTimeComponents: TriggerFixedTimeComponents(
                            triggerFixedTimeTypeAmount: 0,
                            triggerFixedTimeHour: 8,
                            triggerFixedTimeMinute: 0))
        var arr = [t3, t2, t1]
        arr.sort(by: { $0 < $1 })
        XCTAssertEqual(arr[0].timeDelayComponents.triggerTimeDelay, 30)
        XCTAssertEqual(arr[1].timeDelayComponents.triggerTimeDelay, 60)
        XCTAssertEqual(arr[2].triggerType, .fixedTime)
    }
    
    func testCreateTriggerResultReminderFixedTime() {
        let trig = Trigger(triggerType: .fixedTime,
                           triggerFixedTimeComponents: TriggerFixedTimeComponents(
                            triggerFixedTimeTypeAmount: 1,
                            triggerFixedTimeHour: 6,
                            triggerFixedTimeMinute: 0))
        let log = Log(forLogActionTypeId: 1, forLogStartDate: TestHelper.date("2024-05-01T00:00:00Z"))
        let rem = trig.createTriggerResultReminder(afterLog: log, in: TestHelper.utc, currentDate: TestHelper.date("2024-05-01T00:00:00Z"))
        XCTAssertNotNil(rem)
        guard let rem = rem else { return }
        let expected = trig.fixedTimeComponents.nextReminderDate(afterDate: log.logStartDate, in: TestHelper.utc)!
        XCTAssertEqual(rem.oneTimeComponents.oneTimeDate, expected)
    }
    
    func testFailCreateTriggerResultReminderFixedTime() {
        let trig = Trigger(triggerType: .fixedTime,
                           triggerFixedTimeComponents: TriggerFixedTimeComponents(
                            triggerFixedTimeTypeAmount: 1,
                            triggerFixedTimeHour: 6,
                            triggerFixedTimeMinute: 0))
        let log = Log(forLogActionTypeId: 1, forLogStartDate: TestHelper.date("2024-05-01T00:00:00Z"))
        let rem = trig.createTriggerResultReminder(afterLog: log, in: TestHelper.utc, currentDate: TestHelper.date("2024-05-04T00:00:00Z"))
        XCTAssertNil(rem)
    }
    
    func testReadableTimeOutputs() {
        let td = Trigger(triggerType: .timeDelay,
                         triggerTimeDelayComponents: TriggerTimeDelayComponents(triggerTimeDelay: 3600))
        XCTAssertEqual(td.readableTime(), "1h later")
        let ft = Trigger(triggerType: .fixedTime,
                         triggerFixedTimeComponents: TriggerFixedTimeComponents(
                            triggerFixedTimeTypeAmount: 1,
                            triggerFixedTimeHour: 7,
                            triggerFixedTimeMinute: 30))
        XCTAssertEqual(ft.readableTime().normalizeSpaces(), "next day @ 7:30 AM")
    }
}
//
//  SanityTest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import XCTest

final class SanityTests: XCTestCase {
    func testSanity() {
        XCTAssertTrue(true)
    }
}
//
//  TimeZoneExtensionTests.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/26/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import XCTest
@testable import Hound

final class TimeZoneExtensionTests: XCTestCase {
    
    func testHourMinuteConversion() {
        let est = TimeZone(identifier: "America/New_York")!
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let ref = TestHelper.date("2024-06-15T00:00:00Z")
        let result = est.convert(hour: 23, minute: 30, to: pst, referenceDate: ref)
        let calendar = Calendar(identifier: .gregorian)
        var comps = calendar.dateComponents(in: est, from: ref)
        comps.day = comps.day ?? 1
        comps.hour = 23; comps.minute = 30; comps.second = 0
        comps.timeZone = est
        let date = calendar.date(from: comps)!
        let expected = calendar.dateComponents(in: pst, from: date)
        XCTAssertEqual(result.hour, expected.hour)
        XCTAssertEqual(result.minute, expected.minute)
    }
    
    func testWeekdayConversion() {
        let gmt = TimeZone(identifier: "GMT")!
        let tokyo = TimeZone(identifier: "Asia/Tokyo")!
        let weekdays: [Weekday] = [.sunday, .tuesday]
        let ref = TestHelper.date("2024-06-15T00:00:00Z")
        let result = gmt.convert(weekdays: weekdays, hour: 23, minute: 0, to: tokyo, referenceDate: ref)
        var expected = Set<Weekday>()
        let calendar = Calendar(identifier: .gregorian)
        for day in weekdays {
            var comps = calendar.dateComponents([.year, .month], from: ref)
            comps.day = 2 + (day.rawValue - 1)
            comps.hour = 23; comps.minute = 0; comps.second = 0
            comps.timeZone = gmt
            let date = calendar.date(from: comps)!
            let out = calendar.dateComponents(in: tokyo, from: date)
            expected.insert(Weekday(rawValue: out.weekday!)!)
        }
        XCTAssertEqual(Set(result), expected)
    }
    
    func testDayHourMinuteConversion() {
        let est = TimeZone(identifier: "America/New_York")!
        let berlin = TimeZone(identifier: "Europe/Berlin")!
        let reference = TestHelper.date("2024-03-30T00:00:00Z")
        let (d,h,m) = est.convert(day: 31, hour: 1, minute: 45, to: berlin, referenceDate: reference)
        let cal = Calendar(identifier: .gregorian)
        var comps = cal.dateComponents(in: est, from: reference)
        let daysInMonth = cal.range(of: .day, in: .month, for: reference, in: est)!.count
        comps.day = min(31, daysInMonth)
        comps.hour = 1; comps.minute = 45; comps.second = 0
        let date = cal.date(from: comps)!
        let expComp = cal.dateComponents(in: berlin, from: date)
        let daysMonthBerlin = cal.range(of: .day, in: .month, for: date, in: berlin)!.count
        let expectedDay = min(expComp.day!, daysMonthBerlin)
        XCTAssertEqual(d, expectedDay)
        XCTAssertEqual(h, expComp.hour)
        XCTAssertEqual(m, expComp.minute)
    }
    
    func testHalfHourOffsetConversion() {
        let ist = TimeZone(identifier: "Asia/Kolkata")! // GMT+5:30
        let gmt = TimeZone(identifier: "GMT")!
        let ref = TestHelper.date("2024-06-15T00:00:00Z")
        let result = ist.convert(hour: 9, minute: 0, to: gmt, referenceDate: ref)
        var comps = Calendar(identifier: .gregorian).dateComponents(in: ist, from: ref)
        comps.day = comps.day ?? 1
        comps.hour = 9; comps.minute = 0; comps.second = 0
        comps.timeZone = ist
        let cal = Calendar(identifier: .gregorian)
        let date = cal.date(from: comps)!
        let expected = cal.dateComponents(in: gmt, from: date)
        XCTAssertEqual(result.hour, expected.hour)
        XCTAssertEqual(result.minute, expected.minute)
    }
    
    func testHourMinuteCrossMidnight() {
        let tokyo = TimeZone(identifier: "Asia/Tokyo")!
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let ref = TestHelper.date("2024-06-15T00:00:00Z")
        let result = tokyo.convert(hour: 0, minute: 30, to: pst, referenceDate: ref)
        XCTAssertEqual(result.hour, 8)
        XCTAssertEqual(result.minute, 30)
    }
    
    func testWeekdayNextDayConversion() {
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let utc = TestHelper.utc
        let ref = TestHelper.date("2024-06-15T00:00:00Z")
        let out = pst.convert(weekdays: [.saturday], hour: 23, minute: 0, to: utc, referenceDate: ref)
        XCTAssertEqual(out, [.sunday])
    }
    
    func testWeekdayPreviousDayConversion() {
        let tokyo = TimeZone(identifier: "Asia/Tokyo")!
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let ref = TestHelper.date("2024-06-15T00:00:00Z")
        let out = tokyo.convert(weekdays: [.monday], hour: 0, minute: 30, to: pst, referenceDate: ref)
        XCTAssertEqual(out, [.sunday])
    }
    
    func testDayHourMinuteDSTSpringForward() {
        let est = TimeZone(identifier: "America/New_York")!
        let utc = TestHelper.utc
        let ref = TestHelper.date("2024-03-01T00:00:00Z")
        let result = est.convert(day: 10, hour: 2, minute: 30, to: utc, referenceDate: ref)
        XCTAssertEqual(result.day, 10)
        XCTAssertEqual(result.hour, 7)
        XCTAssertEqual(result.minute, 30)
    }
    
    func testDayHourMinuteDSTFallBack() {
        let est = TimeZone(identifier: "America/New_York")!
        let utc = TestHelper.utc
        let ref = TestHelper.date("2024-11-01T00:00:00Z")
        let result = est.convert(day: 3, hour: 1, minute: 30, to: utc, referenceDate: ref)
        XCTAssertEqual(result.day, 3)
        XCTAssertEqual(result.hour, 5)
        XCTAssertEqual(result.minute, 30)
    }
    
    func testDayOverflowConversion() {
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let utc = TestHelper.utc
        let ref = TestHelper.date("2024-04-15T00:00:00Z")
        let result = pst.convert(day: 31, hour: 0, minute: 0, to: utc, referenceDate: ref)
        // april 31st doesnt exist, so we roll under to num days in ref month
        XCTAssertEqual(result.day, 30)
        XCTAssertEqual(result.hour, 7)
        XCTAssertEqual(result.minute, 0)
    }
    
    func testDayNoOverflowConversion() {
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let utc = TestHelper.utc
        let ref = TestHelper.date("2024-05-15T00:00:00Z")
        let result = pst.convert(day: 31, hour: 0, minute: 0, to: utc, referenceDate: ref)
        // may 31st does exist, so no roll under
        XCTAssertEqual(result.day, 31)
        XCTAssertEqual(result.hour, 7)
        XCTAssertEqual(result.minute, 0)
    }
    
    func testHourMinuteConversionCrossDayForward() {
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let tokyo = TimeZone(identifier: "Asia/Tokyo")!
        let ref = TestHelper.date("2024-01-15T00:00:00Z")
        let result = pst.convert(hour: 18, minute: 45, to: tokyo, referenceDate: ref)
        XCTAssertEqual(result.hour, 11)
        XCTAssertEqual(result.minute, 45)
    }
    
    func testHourMinuteConversionCrossDayBackward() {
        let ist = TimeZone(identifier: "Asia/Kolkata")!
        let est = TimeZone(identifier: "America/New_York")!
        let ref = TestHelper.date("2024-01-15T00:00:00Z")
        let result = ist.convert(hour: 5, minute: 15, to: est, referenceDate: ref)
        XCTAssertEqual(result.hour, 18)
        XCTAssertEqual(result.minute, 45)
    }
    
    func testReferenceDateAffectsHourMinuteConversion() {
        let ny = TimeZone(identifier: "America/New_York")!
        let syd = TimeZone(identifier: "Australia/Sydney")!
        let winter = TestHelper.date("2024-01-15T00:00:00Z")
        let summer = TestHelper.date("2024-07-15T00:00:00Z")
        let w = ny.convert(hour: 20, minute: 0, to: syd, referenceDate: winter)
        let s = ny.convert(hour: 20, minute: 0, to: syd, referenceDate: summer)
        XCTAssertEqual(w.hour, 12)
        XCTAssertEqual(s.hour, 10)
        XCTAssertNotEqual(w.hour, s.hour)
    }
    
    func testReferenceDateAffectsWeekdayConversion() {
        let la = TimeZone(identifier: "America/Los_Angeles")!
        let syd = TimeZone(identifier: "Australia/Sydney")!
        let winter = TestHelper.date("2024-01-15T00:00:00Z")
        let summer = TestHelper.date("2024-07-15T00:00:00Z")
        let w = la.convert(weekdays: [.monday], hour: 6, minute: 0, to: syd, referenceDate: winter)
        let s = la.convert(weekdays: [.monday], hour: 6, minute: 0, to: syd, referenceDate: summer)
        XCTAssertEqual(w, [.tuesday])
        XCTAssertEqual(s, [.monday])
    }
    
    func testWeekdayConversionCrossMidnightForward() {
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let utc = TimeZone(identifier: "UTC")!
        let ref = TestHelper.date("2024-06-15T00:00:00Z")
        let result = pst.convert(weekdays: [.saturday], hour: 23, minute: 30, to: utc, referenceDate: ref)
        XCTAssertEqual(result, [.sunday])
    }
    
    func testWeekdayConversionCrossMidnightBackward() {
        let tokyo = TimeZone(identifier: "Asia/Tokyo")!
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let ref = TestHelper.date("2024-06-15T00:00:00Z")
        let result = tokyo.convert(weekdays: [.monday, .wednesday], hour: 2, minute: 0, to: pst, referenceDate: ref)
        XCTAssertEqual(Set(result), Set([.sunday, .tuesday]))
    }
    
    func testDayHourMinuteConversionNextMonth() {
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let tokyo = TimeZone(identifier: "Asia/Tokyo")!
        let reference = TestHelper.date("2024-02-01T00:00:00Z")
        let (d, h, m) = pst.convert(day: 31, hour: 18, minute: 0, to: tokyo, referenceDate: reference)
        XCTAssertEqual(d, 1)
        XCTAssertEqual(h, 11)
        XCTAssertEqual(m, 0)
    }
    
    func testDayHourMinuteConversionPreviousMonth() {
        let berlin = TimeZone(identifier: "Europe/Berlin")!
        let est = TimeZone(identifier: "America/New_York")!
        let reference = TestHelper.date("2024-03-01T00:00:00Z")
        let (d, h, m) = berlin.convert(day: 1, hour: 0, minute: 30, to: est, referenceDate: reference)
        XCTAssertEqual(d, 29)
        XCTAssertEqual(h, 18)
        XCTAssertEqual(m, 30)
    }
    
    func testDayHourMinuteConversionDSTSpringForward() {
        let est = TimeZone(identifier: "America/New_York")!
        let utc = TimeZone(identifier: "UTC")!
        let reference = TestHelper.date("2024-03-01T12:00:00Z")
        let (d, h, m) = est.convert(day: 10, hour: 2, minute: 30, to: utc, referenceDate: reference)
        XCTAssertEqual(d, 10)
        XCTAssertEqual(h, 7)
        XCTAssertEqual(m, 30)
    }
    
    func testDayHourMinuteConversionDSTFallBack() {
        let est = TimeZone(identifier: "America/New_York")!
        let utc = TimeZone(identifier: "UTC")!
        let reference = TestHelper.date("2024-11-01T12:00:00Z")
        let (d, h, m) = est.convert(day: 3, hour: 1, minute: 30, to: utc, referenceDate: reference)
        XCTAssertEqual(d, 3)
        XCTAssertEqual(h, 5)
        XCTAssertEqual(m, 30)
    }
    
    func testHourMinuteReferenceDateDSTDifference() {
        let ny = TimeZone(identifier: "America/New_York")!
        let utc = TestHelper.utc
        let winter = TestHelper.date("2024-01-15T00:00:00Z")
        let summer = TestHelper.date("2024-07-15T00:00:00Z")
        let winterResult = ny.convert(hour: 9, minute: 0, to: utc, referenceDate: winter)
        let summerResult = ny.convert(hour: 9, minute: 0, to: utc, referenceDate: summer)
        XCTAssertEqual(winterResult.hour, 14)
        XCTAssertEqual(summerResult.hour, 13)
        XCTAssertNotEqual(winterResult.hour, summerResult.hour)
    }
    
    func testDayHourMinuteReferenceDateDSTDifference() {
        let ny = TimeZone(identifier: "America/New_York")!
        let utc = TestHelper.utc
        let winter = TestHelper.date("2024-01-15T00:00:00Z")
        let summer = TestHelper.date("2024-07-15T00:00:00Z")
        let winterResult = ny.convert(day: 10, hour: 2, minute: 30, to: utc, referenceDate: winter)
        let summerResult = ny.convert(day: 10, hour: 2, minute: 30, to: utc, referenceDate: summer)
        XCTAssertEqual(winterResult.hour, 7)
        XCTAssertEqual(summerResult.hour, 6)
        XCTAssertNotEqual(winterResult.hour, summerResult.hour)
    }
    
    func testReferenceDateAdjustsHourMinute() {
        let ny = TimeZone(identifier: "America/New_York")!
        let berlin = TimeZone(identifier: "Europe/Berlin")!
        let march = TestHelper.date("2024-03-15T00:00:00Z") // NY DST, Berlin not
        let april = TestHelper.date("2024-04-15T00:00:00Z") // Both DST
        
        let marchResult = ny.convert(hour: 12, minute: 0, to: berlin, referenceDate: march)
        let aprilResult = ny.convert(hour: 12, minute: 0, to: berlin, referenceDate: april)
        
        XCTAssertEqual(marchResult.hour, 17)
        XCTAssertEqual(aprilResult.hour, 18)
    }
}
//
//  HoundTests.swift
//  HoundTests
//
//  Created by Jonathan Xakellis on 7/26/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Testing

struct HoundTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}
//
//  TestHelper.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation
@testable import Hound

final class TestHelper {
    static var utc: TimeZone {
        return TimeZone(identifier: "UTC")!
    }
    
    static var utcCalendar: Calendar {
        var cal = Calendar(identifier: .gregorian)
        cal.timeZone = utc
        return cal
    }
    
    static func calendar(_ timeZone: TimeZone) -> Calendar {
        var cal = Calendar(identifier: .gregorian)
        cal.timeZone = timeZone
        return cal
    }
    
    static func date(_ string: String) -> Date {
        return string.formatISO8601IntoDate()!
    }
    
    static func countdown(_ interval: Double?) -> CountdownComponents {
        CountdownComponents(executionInterval: interval)
    }
    
    static func weekly(days: [Weekday], hour: Int, minute: Int, skipped: Date?) -> WeeklyComponents {
        let comp = WeeklyComponents()
        _ = comp.setZonedWeekdays(days)
        comp.zonedHour = hour
        comp.zonedMinute = minute
        comp.skippedDate = skipped
        return comp
    }
    
    static func monthly(day: Int, hour: Int, minute: Int, skipped: Date?) -> MonthlyComponents {
        MonthlyComponents(zonedDay: day, zonedHour: hour, zonedMinute: minute, skippedDate: skipped)
    }
    
    static func oneTime(date: Date) -> OneTimeComponents {
        OneTimeComponents(oneTimeDate: date)
    }
    
    static func snooze(_ interval: Double?) -> SnoozeComponents {
        SnoozeComponents(executionInterval: interval)
    }
}
//
//  Untitled.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/26/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import XCTest
@testable import Hound

final class MonthlyComponentsTests: XCTestCase {
    
    // MARK: - Next Execution Tests
    
    func testNextExecutionNormalMonth() {
        let tz = TestHelper.utc
        
        let comp = TestHelper.monthly(day: 15, hour: 10, minute: 15, skipped: nil)
        let basis = TestHelper.date("2024-01-10T00:00:00Z")
        
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        let expected = TestHelper.date("2024-01-15T10:15:00Z")
        
        XCTAssertEqual(next, expected)
    }
    
    func testNextExecutionFirstDay() {
        let tz = TestHelper.utc
        
        let comp = TestHelper.monthly(day: 1, hour: 10, minute: 15, skipped: nil)
        let basis = TestHelper.date("2024-01-10T00:00:00Z")
        
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        let expected = TestHelper.date("2024-02-01T10:15:00Z")
        
        XCTAssertEqual(next, expected)
    }
    
    func testNextExecutionDayUnderflowTo30() {
        let tz = TestHelper.utc
        
        let comp = TestHelper.monthly(day: 31, hour: 8, minute: 0, skipped: nil)
        let basis = TestHelper.date("2024-04-01T00:00:00Z")
        
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        let expected = TestHelper.date("2024-04-30T08:00:00Z")
        
        XCTAssertEqual(next, expected)
    }
    
    func testNextExecutionDayNoUnderflow() {
        let tz = TestHelper.utc
        
        let comp = TestHelper.monthly(day: 31, hour: 8, minute: 0, skipped: nil)
        let basis = TestHelper.date("2024-05-01T00:00:00Z")
        
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        let expected = TestHelper.date("2024-05-31T08:00:00Z")
        
        XCTAssertEqual(next, expected)
    }
    
    func testNextExecutionDSTSpringForward() {
        let comp = TestHelper.monthly(day: 10, hour: 2, minute: 30, skipped: nil)
        let noDSTBasis = TestHelper.date("2024-02-01T00:00:00Z")
        let basis = TestHelper.date("2024-03-01T00:00:00Z")
        let tz = TimeZone(identifier: "America/New_York")!
        
        // For February, 2:30 AM EST (UTC-5) = 07:30 UTC
        let noDSTNext = comp.nextExecutionDate(reminderExecutionBasis: noDSTBasis, reminderTimeZone: tz)
        let noDSTExpected = TestHelper.date("2024-02-10T07:30:00Z")
        XCTAssertEqual(noDSTNext, noDSTExpected)

        // For March 10, 2024, 2:30 AM does NOT exist, so it should jump to 3:30 AM EDT (UTC-4) = 07:30 UTC
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        let expected = TestHelper.date("2024-03-10T07:30:00Z") // 3:30 AM EDT
        XCTAssertEqual(next, expected)
    }
    
    // MARK: - Previous Execution Tests
    
    func testPreviousExecutionDST() {
        let comp = TestHelper.monthly(day: 14, hour: 2, minute: 30, skipped: nil)
        let basis = TestHelper.date("2024-03-15T12:00:00Z")
        let tz = TimeZone(identifier: "America/New_York")!
        let prev = comp.previousExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        let expected = "2024-03-14T06:30:00Z" // DST consideration
        XCTAssertEqual(prev, TestHelper.date(expected))
    }
    
    func testPreviousExecutionDayOverflow() {
        let comp = TestHelper.monthly(day: 31, hour: 9, minute: 0, skipped: nil)
        let basis = TestHelper.date("2024-04-15T00:00:00Z")
        let tz = TimeZone(identifier: "America/New_York")!
        let prev = comp.previousExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        let expected = TestHelper.date("2024-03-31T13:00:00Z") // previous month (March)
        XCTAssertEqual(prev, expected)
    }
    
    func testPreviousExecutionLeapYear() {
            let comp = TestHelper.monthly(day: 31, hour: 9, minute: 0, skipped: nil)
            let basis = TestHelper.date("2024-03-15T00:00:00Z")
            let prev = comp.previousExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: TestHelper.utc)
            let expected = "2024-02-29T09:00:00Z"
            XCTAssertEqual(prev, TestHelper.date(expected))
        }

    
    // MARK: - Skipping Behavior Tests
    
    func testSkippingBehavior() {
        let skipped = TestHelper.date("2024-06-05T12:00:00Z")
        let comp = TestHelper.monthly(day: 5, hour: 12, minute: 0, skipped: skipped)
        let basis = TestHelper.date("2024-06-01T00:00:00Z")
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: TestHelper.utc)
        let expected = TestHelper.date("2024-07-05T12:00:00Z")
        XCTAssertEqual(next, expected)
    }
    
    // MARK: - Readable Recurrence Tests
    
    func testLocalConversion() {
        let est = TimeZone(identifier: "America/New_York")!
        let gmt = TimeZone(identifier: "GMT")!
        // 2024-01-10 is always standard time (EST, UTC-5)
        let comp = TestHelper.monthly(day: 10, hour: 22, minute: 15, skipped: nil)
        let basis = TestHelper.date("2024-01-10T00:00:00-05:00")

        let estReadable = comp.readableRecurrence(reminderExecutionBasis: basis, reminderTimeZone: est, displayTimeZone: est)
        XCTAssertEqual(estReadable.normalizeSpaces(), "Every 10th at 10:15 PM")
        
        let local = comp.readableRecurrence(reminderExecutionBasis: basis, reminderTimeZone: est, displayTimeZone: gmt)
        // 10:15 PM EST converts to 3:15 AM GMT on the 11th
        XCTAssertEqual(local.normalizeSpaces(), "Every 11th at 3:15 AM")
    }
    
    func testNotSkippingExecutionAcrossTimeZones() {
        let expectations: [String: String] = [
            "UTC": "2024-01-15T10:00:00Z",
            "Pacific/Auckland": "2024-01-14T21:00:00Z",
            "Pacific/Honolulu": "2024-01-15T20:00:00Z",
            "Asia/Kolkata": "2024-01-15T04:30:00Z"
        ]
        let comp = TestHelper.monthly(day: 15, hour: 10, minute: 0, skipped: nil)
        let basis = TestHelper.date("2024-01-01T00:00:00Z")
        for (id, expected) in expectations {
            let tz = TimeZone(identifier: id)!
            let next = comp.notSkippingExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
            XCTAssertEqual(next, TestHelper.date(expected))
        }
    }
    
    func testNextExecutionWhileSkipping() {
        let date = TestHelper.date("2024-08-20T08:00:00Z")
        let comp = TestHelper.monthly(day: 20, hour: 8, minute: 0, skipped: date)
        let tz = TestHelper.utc
        let basis = TestHelper.date("2024-08-01T00:00:00Z")
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // first execution on 2024-08-20T08:00:00Z is skipped; next is 2024-09-20T08:00:00Z
        XCTAssertEqual(next, TestHelper.date("2024-09-20T08:00:00Z"))
    }
    
    func testPreviousExecutionLeapYearUTC() {
        let tz = TestHelper.utc
        let comp = TestHelper.monthly(day: 31, hour: 9, minute: 0, skipped: nil)
        let basis = TestHelper.date("2024-03-15T00:00:00Z") // leap year
        let prev = comp.previousExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // previous valid date is 2024-02-29 at 09:00 UTC
        XCTAssertEqual(prev, TestHelper.date("2024-02-29T09:00:00Z"))
    }
    
    func testDSTFallBackAmbiguousTime() {
        let tz = TimeZone(identifier: "America/New_York")!

        let comp = TestHelper.monthly(day: 3, hour: 1, minute: 30, skipped: nil)
        let basis = TestHelper.date("2024-10-20T00:00:00Z")
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // falls on DST change day: 2024-11-03 at 1:30 AM EDT -> 05:30 UTC
        XCTAssertEqual(next, TestHelper.date("2024-11-03T05:30:00Z"))
    }
    
    func testReadableRecurrenceDifferentTimeZone() {
        let comp = TestHelper.monthly(day: 15, hour: 22, minute: 45, skipped: nil)
        let est = TimeZone(identifier: "America/New_York")!
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let basis = TestHelper.date("2024-07-01T00:00:00Z")
        let next = comp.notSkippingExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: est)
        XCTAssertNotNil(next)
        guard let next = next else {
            return
        }
        let (d,h,m) = est.convert(day: 15, hour: 22, minute: 45, to: pst, referenceDate: next)
        let expected = "Every \(d)\(d.daySuffix()) at \(String.convert(hour: h, minute: m))"
        XCTAssertEqual(comp.readableRecurrence(reminderExecutionBasis: basis, reminderTimeZone: est, displayTimeZone: pst), expected)
    }
    
    func testConfigureFromDate() {
        let date = TestHelper.date("2024-07-04T18:30:00Z")
        let tz = TestHelper.utc
        let comp = TestHelper.monthly(day: 1, hour: 1, minute: 1, skipped: nil)
        comp.configure(from: date, timeZone: tz)
        XCTAssertEqual(comp.zonedDay, 4)
        XCTAssertEqual(comp.zonedHour, 18)
        XCTAssertEqual(comp.zonedMinute, 30)
    }
    
    func testApplyFromOtherComponent() {
        let base = TestHelper.monthly(day: 5, hour: 7, minute: 0, skipped: nil)
        let other = TestHelper.monthly(day: 10, hour: 20, minute: 45, skipped: nil)
        base.apply(from: other)
        XCTAssertEqual(base.zonedDay, 10)
        XCTAssertEqual(base.zonedHour, 20)
        XCTAssertEqual(base.zonedMinute, 45)
    }
    
    func testReminderIntegrationNextDate() {
        let rem = Reminder(reminderType: .monthly,
                           reminderExecutionBasis: TestHelper.date("2024-05-01T00:00:00Z"),
                           reminderTimeZone: TestHelper.utc,
                           monthlyComponents: TestHelper.monthly(day: 20, hour: 7, minute: 0, skipped: nil))
        let next = rem.reminderExecutionDate
        // next occurrence is 2024-05-20 at 07:00 UTC
        XCTAssertEqual(next, TestHelper.date("2024-05-20T07:00:00Z"))
    }
    
    func testReminderIntegrationSkipping() {
        let rem = Reminder(reminderType: .monthly,
                           reminderExecutionBasis: TestHelper.date("2024-06-01T00:00:00Z"),
                           reminderTimeZone: TestHelper.utc,
                           monthlyComponents: TestHelper.monthly(day: 10, hour: 7, minute: 0, skipped: TestHelper.date("2024-06-10T07:00:00Z")))
        let first = rem.reminderExecutionDate
        rem.disableIsSkipping()
        let second = rem.reminderExecutionDate
        XCTAssertNotEqual(first, second)
    }
}
//
//  SnoozeComponentTests.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import XCTest
@testable import Hound

final class SnoozeComponentsTests: XCTestCase {

    func testSnoozeAcrossDSTSpringForward() {
        let tz = TimeZone(identifier: "America/New_York")!
        let base = TestHelper.date("2024-03-10T06:30:00Z") // 1:30 EST before jump
        let rem = Reminder(
            reminderType: .oneTime,
            reminderExecutionBasis: base,
            reminderTimeZone: tz,
            oneTimeComponents: TestHelper.oneTime(date: base),
            snoozeComponents: TestHelper.snooze(3600)
        )
        // adding one hour crosses into DST resulting in 2024-03-10T07:30:00Z
        XCTAssertEqual(rem.reminderExecutionDate, TestHelper.date("2024-03-10T07:30:00Z"))
    }

    func testSnoozeAcrossDSTFallBack() {
        let tz = TimeZone(identifier: "America/New_York")!
        let base = TestHelper.date("2024-11-03T04:30:00Z") // 0:30 EDT before fall back
        let rem = Reminder(
            reminderType: .oneTime,
            reminderExecutionBasis: base,
            reminderTimeZone: tz,
            oneTimeComponents: TestHelper.oneTime(date: base),
            snoozeComponents: TestHelper.snooze(7200)
        )
        // adding two hours lands in repeated hour at 2024-11-03T06:30:00Z
        XCTAssertEqual(rem.reminderExecutionDate, TestHelper.date("2024-11-03T06:30:00Z"))
    }

    func testResetForNextAlarmClearsSnooze() {
        let base = TestHelper.date("2024-05-01T00:00:00Z")
        let rem = Reminder(
            reminderType: .countdown,
            reminderExecutionBasis: base,
            reminderTimeZone: TimeZone(identifier: "UTC"),
            countdownComponents: TestHelper.countdown(60),
            snoozeComponents: TestHelper.snooze(120)
        )
        XCTAssertNotNil(rem.snoozeComponents.executionInterval)
        rem.resetForNextAlarm()
        XCTAssertNil(rem.snoozeComponents.executionInterval)
    }
    
    func testChangeExecutionIntervalValidation() {
            let comp = SnoozeComponents(executionInterval: 60)
            XCTAssertTrue(comp.changeExecutionInterval(120))
            XCTAssertEqual(comp.executionInterval, 120)
            XCTAssertFalse(comp.changeExecutionInterval(0))
            XCTAssertEqual(comp.executionInterval, 120)
            XCTAssertFalse(comp.changeExecutionInterval(-5))
            XCTAssertEqual(comp.executionInterval, 120)
            XCTAssertTrue(comp.changeExecutionInterval(nil))
            XCTAssertNil(comp.executionInterval)
        }
}
//
//  CountdownComponentTests.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import XCTest
@testable import Hound

final class CountdownComponentsTests: XCTestCase {

    func testReminderIntegrationAcrossDST() {
        let base = TestHelper.date("2024-03-10T06:30:00Z")
        let tz = TimeZone(identifier: "America/New_York")!
        let rem = Reminder(reminderType: .countdown,
                           reminderExecutionBasis: base,
                           reminderTimeZone: tz,
                           countdownComponents: TestHelper.countdown(3600))
        // 1 hour countdown crosses DST start -> 2024-03-10T07:30:00Z
        XCTAssertEqual(rem.reminderExecutionDate, TestHelper.date("2024-03-10T07:30:00Z"))
    }

    func testReminderIntegrationDifferentTZ() {
        let base = TestHelper.date("2024-05-01T12:00:00Z")
        let tz = TimeZone(identifier: "Asia/Tokyo")!
        let rem = Reminder(reminderType: .countdown,
                           reminderExecutionBasis: base,
                           reminderTimeZone: tz,
                           countdownComponents: TestHelper.countdown(120))
        // 2 minute countdown results in 2024-05-01T12:02:00Z
        XCTAssertEqual(rem.reminderExecutionDate, TestHelper.date("2024-05-01T12:02:00Z"))
    }

}
//
//  OneTimeComponentTests.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import XCTest
@testable import Hound

final class OneTimeComponentsTests: XCTestCase {
    
    func withTimezone<T>(_ identifier: String, _ body: () throws -> T) rethrows -> T {
        let original = getenv("TZ").flatMap { String(cString: $0) }
        setenv("TZ", identifier, 1)
        NSTimeZone.resetSystemTimeZone()
        defer {
            if let orig = original { setenv("TZ", orig, 1) } else { unsetenv("TZ") }
            NSTimeZone.resetSystemTimeZone()
        }
        return try body()
    }
    
    func testReadablePropertiesVariousDates() throws {
        let sameYear = TestHelper.date("2025-01-02T05:06:07Z")
        let diffYear = TestHelper.date("2024-12-31T23:59:59Z")
        let compSame = OneTimeComponents(oneTimeDate: sameYear)
        let compDiff = OneTimeComponents(oneTimeDate: diffYear)
        XCTAssertEqual(
            compSame.readableDayOfYear(displayTimeZone: TestHelper.utc),
            sameYear.houndFormatted(
                .template("MMMMd"),
                displayTimeZone: TestHelper.utc
            )
        )
        XCTAssertEqual(
            compDiff.readableDayOfYear(displayTimeZone: TestHelper.utc),
            diffYear.houndFormatted(
                .template("MMMMdyyyy"),
                displayTimeZone: TestHelper.utc
            )
        )
        XCTAssertEqual(
            compSame.readableTimeOfDay(displayTimeZone: TestHelper.utc),
            sameYear.houndFormatted(
                .template("hma"),
                displayTimeZone: TestHelper.utc
            )
        )
    }
    
    func testDSTBoundaryHandling() throws {
        let newYork = TimeZone(identifier: "America/New_York")!
        let beforeDST = TestHelper.date("2024-03-10T06:59:00Z") // 1:59 AM EST
        let afterDST = TestHelper.date("2024-03-10T07:01:00Z")  // 3:01 AM EDT
        
        let compBefore = OneTimeComponents(oneTimeDate: beforeDST)
        let compAfter = OneTimeComponents(oneTimeDate: afterDST)
        
        XCTAssertLessThan(
            compBefore.readableTimeOfDay(displayTimeZone: newYork),
            compAfter.readableTimeOfDay(displayTimeZone: newYork)
        )
    }
    
    func testExtremeDateValues() throws {
        let early = Date.distantPast
        let late = Date.distantFuture
        let midnight = TestHelper.date("2024-01-01T00:00:00Z")
        let almostMidnight = TestHelper.date("2024-01-01T23:59:59Z")
        
        let comps = [OneTimeComponents(oneTimeDate: early),
                     OneTimeComponents(oneTimeDate: late),
                     OneTimeComponents(oneTimeDate: midnight),
                     OneTimeComponents(oneTimeDate: almostMidnight)]
        for c in comps {
            XCTAssertNotNil(c.oneTimeDate)
        }
    }
}
//
//  ReminderTests.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/26/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import XCTest
@testable import Hound

final class ReminderTests: XCTestCase {
    
    func testOneTimeReminderExecution() {
        let execDate = TestHelper.date("2024-10-05T12:30:00Z")
        let rem = Reminder(
            reminderType: .oneTime,
            reminderExecutionBasis: execDate,
            reminderTimeZone: TestHelper.utc,
            oneTimeComponents: TestHelper.oneTime(date: execDate)
        )
        XCTAssertEqual(rem.reminderExecutionDate, execDate)
    }
    
    func testCountdownReminderExecution() {
        let rem = Reminder(
            reminderType: .countdown,
            reminderExecutionBasis: TestHelper.date("2024-01-01T00:00:00Z"),
            reminderTimeZone: TestHelper.utc,
            countdownComponents: TestHelper.countdown(60)
        )
        XCTAssertEqual(rem.reminderExecutionDate, TestHelper.date("2024-01-01T00:01:00Z"))
    }
    
    func testWeeklyReminderExecutionInDifferentTZ() {
        let rem = Reminder(
            reminderType: .weekly,
            reminderExecutionBasis: TestHelper.date("2024-05-10T12:00:00Z"),
            reminderTimeZone: TimeZone(identifier: "America/New_York"),
            weeklyComponents: TestHelper.weekly(days: [.monday], hour: 9, minute: 0, skipped: nil)
        )
        let next = rem.reminderExecutionDate
        // basis 2024-05-10T12:00:00Z is Friday 08:00 in New York
        // next Monday at 09:00 EDT is 2024-05-13T13:00:00Z in UTC
        XCTAssertEqual(next, TestHelper.date("2024-05-13T13:00:00Z"))
    }
    
    func testMonthlyReminderExecutionSkipsAndDisables() {
        let rem = Reminder(
            reminderType: .monthly,
            reminderExecutionBasis: TestHelper.date("2024-05-01T00:00:00Z"),
            reminderTimeZone: TestHelper.utc,
            monthlyComponents: TestHelper.monthly(day: 20, hour: 7, minute: 0, skipped: TestHelper.date("2024-05-20T07:00:00Z"))
        )
        // should skip the first occurrence on 2024-05-20 and move to 2024-06-20
        let next = rem.reminderExecutionDate
        XCTAssertEqual(next, TestHelper.date("2024-06-20T07:00:00Z"))
        // disable skipping
        rem.disableIsSkipping()
        XCTAssertFalse(rem.monthlyComponents.isSkipping)
    }
    
    func testSnoozeOverridesReminder() {
        let rem = Reminder(
            reminderType: .weekly,
            reminderExecutionBasis: TestHelper.date("2024-06-01T00:00:00Z"),
            reminderTimeZone: TestHelper.utc,
            weeklyComponents: TestHelper.weekly(days: [.sunday], hour: 8, minute: 0, skipped: nil),
            snoozeComponents: TestHelper.snooze(3600)
        )
        // 1 hour snooze from 2024-06-01T00:00:00Z results in 2024-06-01T01:00:00Z
        XCTAssertEqual(rem.reminderExecutionDate, TestHelper.date("2024-06-01T01:00:00Z"))
    }
    
    func testWeeklyReminderDSTSpringForward() {
        let rem = Reminder(
            reminderType: .weekly,
            reminderExecutionBasis: TestHelper.date("2024-03-01T00:00:00Z"),
            reminderTimeZone: TimeZone(identifier: "America/New_York"),
            weeklyComponents: TestHelper.weekly(days: [.sunday], hour: 2, minute: 30, skipped: nil)
        )
        let next = rem.reminderExecutionDate
        // next Sunday 2:30 AM occurs on 2024-03-03 which is 07:30 UTC
        XCTAssertEqual(next, TestHelper.date("2024-03-03T07:30:00Z"))
    }
    
    func testWeeklyReminderDSTFallBack() {
        let rem = Reminder(
            reminderType: .weekly,
            reminderExecutionBasis: TestHelper.date("2024-10-20T00:00:00Z"),
            reminderTimeZone: TimeZone(identifier: "America/New_York"),
            weeklyComponents: TestHelper.weekly(days: [.sunday], hour: 1, minute: 30, skipped: nil)
        )
        let next = rem.reminderExecutionDate
        // next Sunday 1:30 AM before fall back is 2024-10-20 at 05:30 UTC
        XCTAssertEqual(next, TestHelper.date("2024-10-20T05:30:00Z"))
    }
    
    func testWeeklyMultipleDaysPreviousNext() {
        let rem = Reminder(
            reminderType: .weekly,
            reminderExecutionBasis: TestHelper.date("2024-05-15T12:00:00Z"),
            reminderTimeZone: TestHelper.utc,
            weeklyComponents: TestHelper.weekly(days: [.monday, .wednesday], hour: 9, minute: 0, skipped: nil)
        )
        let next = rem.reminderExecutionDate
        // next occurrence should be Monday 2024-05-20 at 09:00 UTC
        XCTAssertEqual(next, TestHelper.date("2024-05-20T09:00:00Z"))
        let prev = rem.weeklyComponents.previousExecutionDate(reminderExecutionBasis: rem.reminderExecutionBasis,
                                                              reminderTimeZone: rem.reminderTimeZone)
        // previous occurrence is Wednesday 2024-05-15 at 09:00 UTC
        XCTAssertEqual(prev, TestHelper.date("2024-05-15T09:00:00Z"))
    }
    
    func testMonthlyDayOverflowNextAndPrevious() {
        let rem = Reminder(
            reminderType: .monthly,
            reminderExecutionBasis: TestHelper.date("2024-04-01T00:00:00Z"),
            reminderTimeZone: TestHelper.utc,
            monthlyComponents: TestHelper.monthly(day: 31, hour: 8, minute: 0, skipped: nil)
        )
        let next = rem.reminderExecutionDate
        // April has only 30 days so next execution occurs on 2024-04-30 at 08:00 UTC
        XCTAssertEqual(next, TestHelper.date("2024-04-30T08:00:00Z"))
        let prev = rem.monthlyComponents.previousExecutionDate(reminderExecutionBasis: rem.reminderExecutionBasis,
                                                               reminderTimeZone: rem.reminderTimeZone)
        // previous execution was 2024-03-31 at 08:00 UTC
        XCTAssertEqual(prev, TestHelper.date("2024-03-31T08:00:00Z"))
    }
    
    func testDisableIsSkippingDateWeekly() {
        let rem = Reminder(
            reminderType: .weekly,
            reminderExecutionBasis: TestHelper.date("2024-07-01T00:00:00Z"),
            reminderTimeZone: TestHelper.utc,
            weeklyComponents: TestHelper.weekly(days: [.sunday], hour: 6, minute: 0, skipped: TestHelper.date("2024-07-07T06:00:00Z"))
        )
        // disabling skipping should return the first scheduled date 2024-07-07 at 06:00 UTC
        XCTAssertEqual(rem.disableIsSkippingDate, TestHelper.date("2024-07-07T06:00:00Z"))
    }
    
    func testDisableIsSkippingDateSnoozedReturnsNil() {
        let rem = Reminder(
            reminderType: .weekly,
            reminderExecutionBasis: TestHelper.date("2024-07-01T00:00:00Z"),
            reminderTimeZone: TestHelper.utc,
            weeklyComponents: TestHelper.weekly(days: [.sunday], hour: 6, minute: 0, skipped: TestHelper.date("2024-07-07T06:00:00Z")),
            snoozeComponents: TestHelper.snooze(600)
        )
        XCTAssertNil(rem.disableIsSkippingDate)
    }
    
    func testDisableIsSkippingDateMonthly() {
        let rem = Reminder(
            reminderType: .monthly,
            reminderExecutionBasis: TestHelper.date("2024-05-01T00:00:00Z"),
            reminderTimeZone: TestHelper.utc,
            monthlyComponents: TestHelper.monthly(day: 15, hour: 10, minute: 0, skipped: TestHelper.date("2024-05-15T10:00:00Z"))
        )
        XCTAssertEqual(rem.disableIsSkippingDate, TestHelper.date("2024-05-15T10:00:00Z"))
    }
    
    func makeFullReminder(type: ReminderType) -> Reminder {
        let basis = TestHelper.date("2024-01-01T00:00:00Z")
        let tz = TimeZone(identifier: "America/Los_Angeles")!
        let recipients = ["a", "b"]
        let countdown = TestHelper.countdown(120)
        let weekly = TestHelper.weekly(days: [.sunday], hour: 8, minute: 0, skipped: nil)
        let monthly = TestHelper.monthly(day: 15, hour: 9, minute: 0, skipped: nil)
        let oneTime = TestHelper.oneTime(date: TestHelper.date("2024-05-05T12:00:00Z"))
        let snooze = TestHelper.snooze(nil)
        let offline = OfflineModeComponents(forInitialAttemptedSyncDate: basis,
                                            forInitialCreationDate: basis)
        return Reminder(
            reminderId: 5,
            reminderUUID: UUID(uuidString: "00000000-0000-0000-0000-000000000555"),
            reminderActionTypeId: 2,
            reminderCustomActionName: "Walk",
            reminderType: type,
            reminderExecutionBasis: basis,
            reminderIsTriggerResult: false,
            reminderIsEnabled: true,
            reminderRecipientUserIds: recipients,
            reminderTimeZone: tz,
            countdownComponents: countdown,
            weeklyComponents: weekly,
            monthlyComponents: monthly,
            oneTimeComponents: oneTime,
            snoozeComponents: snooze,
            offlineModeComponents: offline
        )
    }
    
    func testCustomActionNameSanitization() {
        let rem = makeFullReminder(type: .countdown)
        rem.reminderCustomActionName = "   extremely long custom name that should be truncated to thirty two characters  "
        XCTAssertLessThanOrEqual(rem.reminderCustomActionName.count, Constant.Class.Reminder.reminderCustomActionNameCharacterLimit)
        XCTAssertFalse(rem.reminderCustomActionName.hasPrefix(" "))
    }
    
    func testChangeTypeResetsExecutionBasis() {
        let rem = makeFullReminder(type: .countdown)
        let before = rem.reminderExecutionBasis
        rem.changeReminderType(.weekly)
        XCTAssertEqual(rem.reminderType, .weekly)
        XCTAssertGreaterThan(rem.reminderExecutionBasis, before)
    }
    
    func testEnableDisableAndReset() {
        let rem = makeFullReminder(type: .weekly)
        rem.reminderIsEnabled = false
        XCTAssertNil(rem.reminderExecutionDate)
        rem.reminderIsEnabled = true
        XCTAssertNotNil(rem.reminderExecutionDate)
    }
    
    func testSkippingAndDisableIsSkippingDate() {
        let rem = makeFullReminder(type: .weekly)
        let skipDate = TestHelper.date("2024-05-05T15:00:00Z")
        rem.enableIsSkipping(skippedDate: skipDate)
        XCTAssertTrue(rem.weeklyComponents.isSkipping)
        XCTAssertEqual(rem.disableIsSkippingDate, rem.weeklyComponents.notSkippingExecutionDate(reminderExecutionBasis: rem.reminderExecutionBasis, reminderTimeZone: rem.reminderTimeZone))
        rem.disableIsSkipping()
        XCTAssertFalse(rem.weeklyComponents.isSkipping)
    }
    
    func testSnoozeOverridesExecution() {
        let rem = makeFullReminder(type: .countdown)
        rem.snoozeComponents.changeExecutionInterval(300)
        // 5 minute snooze from 2024-01-01T00:00:00Z results in 2024-01-01T00:05:00Z
        XCTAssertEqual(rem.reminderExecutionDate, TestHelper.date("2024-01-01T00:05:00Z"))
    }
    
    func testResetForNextAlarmResetsState() {
        let basis = TestHelper.date("2024-06-01T00:00:00Z")
        let rem = Reminder(reminderType: .weekly,
                           reminderExecutionBasis: basis,
                           reminderTimeZone: TestHelper.utc,
                           weeklyComponents: TestHelper.weekly(days: [.sunday], hour: 8, minute: 0, skipped: basis),
                           snoozeComponents: TestHelper.snooze(600))
        let oldBasis = rem.reminderExecutionBasis
        XCTAssertNotNil(rem.reminderExecutionDate)
        rem.resetForNextAlarm()
        XCTAssertFalse(rem.weeklyComponents.isSkipping)
        XCTAssertNil(rem.snoozeComponents.executionInterval)
        XCTAssertGreaterThan(rem.reminderExecutionBasis, oldBasis)
    }
    
    func testMonthlyNextExecutionCrossesYear() {
        let rem = Reminder(reminderType: .monthly,
                           reminderExecutionBasis: TestHelper.date("2024-12-20T00:00:00Z"),
                           reminderTimeZone: TestHelper.utc,
                           monthlyComponents: TestHelper.monthly(day: 15, hour: 9, minute: 0, skipped: nil))
        let next = rem.reminderExecutionDate
        XCTAssertEqual(next, TestHelper.date("2025-01-15T09:00:00Z"))
    }
    
    func testWeeklyComparisonUsesLocalTime() {
        let previousUsesDevice = UserConfiguration.usesDeviceTimeZone
        let previousTZ = UserConfiguration.userTimeZone
        UserConfiguration.usesDeviceTimeZone = false
        UserConfiguration.userTimeZone = TestHelper.utc
        defer {
            UserConfiguration.usesDeviceTimeZone = previousUsesDevice
            UserConfiguration.userTimeZone = previousTZ
        }
        
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let est = TimeZone(identifier: "America/New_York")!
        
        let lhs = Reminder(reminderId: 1,
                           reminderType: .weekly,
                           reminderTimeZone: pst,
                           weeklyComponents: TestHelper.weekly(days: [.monday], hour: 8, minute: 0, skipped: nil))
        let rhs = Reminder(reminderId: 2,
                           reminderType: .weekly,
                           reminderTimeZone: est,
                           weeklyComponents: TestHelper.weekly(days: [.monday], hour: 9, minute: 0, skipped: nil))
        
        XCTAssertTrue(rhs < lhs)
    }
}
//
//  WeeklyComponentTests.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/26/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import XCTest
@testable import Hound

final class WeeklyComponentsTests: XCTestCase {
    
    func testNextExecutionBasic() {
        let comp = TestHelper.weekly(days: [.monday], hour: 9, minute: 30, skipped: nil)
        let tz = TimeZone(identifier: "America/Los_Angeles")!
        let basis = TestHelper.date("2024-06-01T12:00:00Z")
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // next Monday 9:30 PDT is 2024-06-03T16:30:00Z
        XCTAssertEqual(next, TestHelper.date("2024-06-03T16:30:00Z"))
    }
    
    func testNextExecutionSkipping() {
        let comp = TestHelper.weekly(days: [.sunday], hour: 6, minute: 0, skipped: TestHelper.date("2024-06-02T06:00:00Z"))
        let tz = TestHelper.utc
        let basis = TestHelper.date("2024-06-01T00:00:00Z")
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // first occurrence 2024-06-02T06:00:00Z is skipped so next is 2024-06-09T06:00:00Z
        XCTAssertEqual(next, TestHelper.date("2024-06-09T06:00:00Z"))
    }
    
    func testPreviousExecutionDST() {
        let comp = TestHelper.weekly(days: [.monday], hour: 2, minute: 30, skipped: nil)
        let tz = TimeZone(identifier: "America/New_York")!
        let basis = TestHelper.date("2024-03-12T12:00:00Z") // after spring forward
        let prev = comp.previousExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // previous Monday 2:30 AM EDT is 2024-03-11T06:30:00Z
        XCTAssertEqual(prev, TestHelper.date("2024-03-11T06:30:00Z"))
    }
    
    func testLocalConversions() {
        let comp = TestHelper.weekly(days: [.sunday], hour: 23, minute: 0, skipped: nil)
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let utc = TestHelper.utc
        let basis = TestHelper.date("2024-05-12T00:00:00Z")
        let localTime = comp.localTimeOfDay(reminderExecutionBasis: basis, reminderTimeZone: pst, displayTimeZone: utc)
        let expected = pst.convert(hour: 23, minute: 0, to: utc, referenceDate: basis)
        XCTAssertEqual(localTime.hour, expected.hour)
        XCTAssertEqual(localTime.minute, expected.minute)
        let localWeekdays = comp.localWeekdays(reminderExecutionBasis: basis, reminderTimeZone: pst, displayTimeZone: utc)
        XCTAssertEqual(Set(localWeekdays), Set(pst.convert(weekdays: [.sunday], hour: 23, minute: 0, to: utc, referenceDate: basis)))
    }
    
    func testMultipleWeekdayNextAndPrevious() {
        let comp = TestHelper.weekly(days: [.monday, .wednesday], hour: 8, minute: 45, skipped: nil)
        let tz = TestHelper.utc
        let basis = TestHelper.date("2024-05-14T12:00:00Z")
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // next occurrence is Wednesday 2024-05-15 at 08:45 UTC
        XCTAssertEqual(next, TestHelper.date("2024-05-15T08:45:00Z"))
        let prev = comp.previousExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // previous occurrence is Monday 2024-05-13 at 08:45 UTC
        XCTAssertEqual(prev, TestHelper.date("2024-05-13T08:45:00Z"))
    }
    
    func testDSTFallBackNextExecution() {
        let comp = TestHelper.weekly(days: [.sunday], hour: 1, minute: 30, skipped: nil)
        let tz = TimeZone(identifier: "America/New_York")!
        let basis = TestHelper.date("2024-10-20T00:00:00Z")
        let next = comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // next Sunday 1:30 AM occurs on 2024-10-20T05:30:00Z
        XCTAssertEqual(next, TestHelper.date("2024-10-20T05:30:00Z"))
    }
    
    func testSetZonedWeekdaysValidation() {
        let comp = TestHelper.weekly(days: Weekday.allCases, hour: 0, minute: 0, skipped: nil)
        let result = comp.setZonedWeekdays([])
        XCTAssertFalse(result)
        XCTAssertEqual(Set(comp.zonedWeekdays), Set(Weekday.allCases))
        XCTAssertTrue(comp.setZonedWeekdays([.tuesday, .thursday]))
        XCTAssertEqual(Set(comp.zonedWeekdays), Set([.tuesday, .thursday]))
    }
    
    func testConfigureUpdatesComponents() {
        let comp = TestHelper.weekly(days: Weekday.allCases, hour: 0, minute: 0, skipped: nil)
        let tz = TestHelper.utc
        let date = TestHelper.date("2024-06-01T12:34:00Z")
        let result = comp.configure(from: date, timeZone: tz, weekdays: [.monday])
        XCTAssertTrue(result)
        XCTAssertEqual(comp.zonedHour, 12)
        XCTAssertEqual(comp.zonedMinute, 34)
        XCTAssertEqual(Set(comp.zonedWeekdays), Set([.monday]))
    }
    
    func testConfigureWithInvalidWeekdaysStillUpdatesTime() {
        let comp = TestHelper.weekly(days: Weekday.allCases, hour: 0, minute: 0, skipped: nil)
        let tz = TestHelper.utc
        let date = TestHelper.date("2024-06-01T01:02:00Z")
        let result = comp.configure(from: date, timeZone: tz, weekdays: [])
        XCTAssertFalse(result)
        XCTAssertEqual(comp.zonedHour, 1)
        XCTAssertEqual(comp.zonedMinute, 2)
        XCTAssertEqual(Set(comp.zonedWeekdays), Set(Weekday.allCases))
    }
    
    func testNextExecutionHandlesDSTSpringForward() {
        let comp = TestHelper.weekly(days: [.sunday], hour: 2, minute: 30, skipped: nil)
        let tz = TestHelper.utc
        let basis = TestHelper.date("2024-03-01T00:00:00Z")
        let next = comp.notSkippingExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz)
        // next Sunday 2:30 UTC is 2024-03-03T02:30:00Z
        XCTAssertEqual(next, TestHelper.date("2024-03-03T02:30:00Z"))
    }
    
    func testLocalWeekdaysCrossMidnight() {
        let comp = TestHelper.weekly(days: [.sunday], hour: 23, minute: 30, skipped: nil)
        let utc = TestHelper.utc
        let tokyo = TimeZone(identifier: "Asia/Tokyo")!
        let basis = TestHelper.date("2024-05-05T00:00:00Z")
        let local = comp.localWeekdays(reminderExecutionBasis: basis, reminderTimeZone: utc, displayTimeZone: tokyo)
        XCTAssertEqual(Set(local), Set(utc.convert(weekdays: [.sunday], hour: 23, minute: 30, to: tokyo, referenceDate: basis)))
    }
    
    func testReadableRecurranceFormatting() {
        let comp = TestHelper.weekly(days: [.monday, .wednesday], hour: 9, minute: 0, skipped: nil)
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let utc = TestHelper.utc
        let basis = TestHelper.date("2024-07-01T00:00:00Z")
        let rec = comp.readableRecurrance(reminderExecutionBasis: basis, reminderTimeZone: pst, displayTimeZone: utc)
        let days = pst.convert(weekdays: [.monday, .wednesday], hour: 9, minute: 0, to: utc, referenceDate: basis)
        let time = String.convert(hour: pst.convert(hour: 9, minute: 0, to: utc, referenceDate: basis).hour,
                                  minute: pst.convert(hour: 9, minute: 0, to: utc, referenceDate: basis).minute)
        let daysString = days.count > 1 ? days.sorted().map { $0.shortAbbreviation }.joined(separator: ", ") : days.first!.longName
        let expected = "\(daysString) at \(time)"
        XCTAssertEqual(rec, expected)
    }
    
    func testReminderIntegrationWithSkipping() {
        let tz = TimeZone(identifier: "UTC")!
        let basis = TestHelper.date("2024-06-01T00:00:00Z")
        let comp = TestHelper.weekly(days: [.sunday], hour: 8, minute: 0, skipped: nil)
        let rem = Reminder(reminderType: .weekly,
                           reminderExecutionBasis: basis,
                           reminderTimeZone: tz,
                           weeklyComponents: comp)
        let first = rem.reminderExecutionDate
        rem.enableIsSkipping(skippedDate: first)
        let next = rem.reminderExecutionDate
        // first execution 2024-06-02T08:00:00Z was skipped so new execution is 2024-06-09T08:00:00Z
        XCTAssertEqual(next, TestHelper.date("2024-06-09T08:00:00Z"))
    }
    
    func testNoWeekdaysProducesNil() {
        let comp = WeeklyComponents(zonedSunday: false, zonedMonday: false,
                                    zonedTuesday: false, zonedWednesday: false,
                                    zonedThursday: false, zonedFriday: false,
                                    zonedSaturday: false, zonedHour: 8, zonedMinute: 0)
        let tz = TestHelper.utc
        let basis = TestHelper.date("2024-06-01T00:00:00Z")
        XCTAssertNil(comp.nextExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz))
        XCTAssertNil(comp.previousExecutionDate(reminderExecutionBasis: basis, reminderTimeZone: tz))
    }
    
    func testReadableDaysOfWeekAggregations() {
        let tz = TestHelper.utc
        let basis = TestHelper.date("2024-05-01T00:00:00Z")
        
        let everyday = TestHelper.weekly(days: Weekday.allCases, hour: 0, minute: 0, skipped: nil)
        XCTAssertEqual(everyday.readableDaysOfWeek(reminderExecutionBasis: basis, reminderTimeZone: tz), "Everyday")
        
        let weekdays = TestHelper.weekly(days: [.monday, .tuesday, .wednesday, .thursday, .friday], hour: 0, minute: 0, skipped: nil)
        XCTAssertEqual(weekdays.readableDaysOfWeek(reminderExecutionBasis: basis, reminderTimeZone: tz), "Weekdays")
        
        let weekends = TestHelper.weekly(days: [.sunday, .saturday], hour: 0, minute: 0, skipped: nil)
        XCTAssertEqual(weekends.readableDaysOfWeek(reminderExecutionBasis: basis, reminderTimeZone: tz), "Weekends")
        
        let abbrev = TestHelper.weekly(days: [.tuesday, .thursday], hour: 0, minute: 0, skipped: nil)
        XCTAssertEqual(abbrev.readableDaysOfWeek(reminderExecutionBasis: basis, reminderTimeZone: tz), "Tu, Th")
    }
    
    func testReadableRecurranceReferenceDateDSTDifference() {
        let comp = TestHelper.weekly(days: [.monday], hour: 9, minute: 0, skipped: nil)
        let newYork = TimeZone(identifier: "America/New_York")!
        let utc = TestHelper.utc
        let winter = TestHelper.date("2024-01-15T00:00:00Z")
        let summer = TestHelper.date("2024-07-15T00:00:00Z")
        let winterRec = comp.readableRecurrance(reminderExecutionBasis: winter, reminderTimeZone: newYork, displayTimeZone: utc)
        let summerRec = comp.readableRecurrance(reminderExecutionBasis: summer, reminderTimeZone: newYork, displayTimeZone: utc)
        XCTAssertEqual(winterRec.normalizeSpaces(), "Monday at 2:00 PM")
        XCTAssertEqual(summerRec.normalizeSpaces(), "Monday at 1:00 PM")
        XCTAssertNotEqual(winterRec, summerRec)
    }
    
    func testReferenceDateChangesWeekdayOutput() {
        let comp = TestHelper.weekly(days: [.monday], hour: 7, minute: 0, skipped: nil)
        let pst = TimeZone(identifier: "America/Los_Angeles")!
        let tokyo = TimeZone(identifier: "Asia/Tokyo")!
        
        let winter = TestHelper.date("2024-01-15T00:00:00Z")
        let summer = TestHelper.date("2024-07-15T00:00:00Z")
        
        let winterReadable = comp.readableDaysOfWeek(reminderExecutionBasis: winter, reminderTimeZone: pst, displayTimeZone: tokyo)
        let summerReadable = comp.readableDaysOfWeek(reminderExecutionBasis: summer, reminderTimeZone: pst, displayTimeZone: tokyo)
        
        XCTAssertEqual(winterReadable, "Tuesday")
        XCTAssertEqual(summerReadable, "Monday")
    }
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2018 Denis Kozhukhov
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit
import SnapKit

open class FloatingNotificationBanner: GrowingNotificationBanner {
    
    public init(
        title: String? = nil,
        subtitle: String? = nil,
        titleFont: UIFont? = nil,
        titleColor: UIColor? = nil,
        titleTextAlign: NSTextAlignment? = nil,
        subtitleFont: UIFont? = nil,
        subtitleColor: UIColor? = nil,
        subtitleTextAlign: NSTextAlignment? = nil,
        leftView: UIView? = nil,
        rightView: UIView? = nil,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil,
        iconPosition: IconPosition = .center
    ) {

        super.init(
            title: title,
            subtitle: subtitle,
            leftView: leftView,
            rightView: rightView,
            style: style,
            colors: colors,
            iconPosition: iconPosition
        )
        
        if let titleFont = titleFont {
            self.titleFont = titleFont
            titleLabel!.font = titleFont
        }
        
        if let titleColor = titleColor {
            titleLabel!.textColor = titleColor
        }
        
        if let titleTextAlign = titleTextAlign {
            titleLabel!.textAlignment = titleTextAlign
        }
        
        if let subtitleFont = subtitleFont {
            self.subtitleFont = subtitleFont
            subtitleLabel!.font = subtitleFont
        }
        
        if let subtitleColor = subtitleColor {
            subtitleLabel!.textColor = subtitleColor
        }
        
        if let subtitleTextAlign = subtitleTextAlign {
            subtitleLabel!.textAlignment = subtitleTextAlign
        }
    }
    
    public init(customView: UIView) {
        super.init(style: .customView)
        self.customView = customView
        
        contentView.addSubview(customView)
        customView.snp.makeConstraints { (make) in
            make.edges.equalTo(contentView)
        }
        
        spacerView.backgroundColor = customView.backgroundColor
    }
    
    /**
     Convenience function to display banner with non .zero default edge insets
     */
    public func show(
        queuePosition: QueuePosition = .back,
        bannerPosition: BannerPosition = .top,
        queue: NotificationBannerQueue = NotificationBannerQueue.default,
        on viewController: UIViewController? = nil,
        edgeInsets: UIEdgeInsets = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8),
        cornerRadius: CGFloat? = nil,
        shadowColor: UIColor = .black,
        shadowOpacity: CGFloat = 1,
        shadowBlurRadius: CGFloat = 0,
        shadowCornerRadius: CGFloat = 0,
        shadowOffset: UIOffset = .zero,
        shadowEdgeInsets: UIEdgeInsets? = nil
    ) {

        self.bannerEdgeInsets = edgeInsets
        
        if let cornerRadius = cornerRadius {
            contentView.layer.cornerRadius = cornerRadius
            contentView.subviews.last?.layer.cornerRadius = cornerRadius
        }
        
        if style == .customView, let customView = contentView.subviews.last {
           customView.backgroundColor = customView.backgroundColor?.withAlphaComponent(transparency)
        }

        show(
            queuePosition: queuePosition,
            bannerPosition: bannerPosition,
            queue: queue,
            on: viewController
        )
        
        applyShadow(
            withColor: shadowColor,
            opacity: shadowOpacity,
            blurRadius: shadowBlurRadius,
            cornerRadius: shadowCornerRadius,
            offset: shadowOffset,
            edgeInsets: shadowEdgeInsets
        )
        
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
}

private extension FloatingNotificationBanner {
    
    /**
     Add shadow for notification with specified parameters.
     */
    private func applyShadow(
        withColor color: UIColor = .black,
        opacity: CGFloat = 1,
        blurRadius: CGFloat = 0,
        cornerRadius: CGFloat = 0,
        offset: UIOffset = .zero,
        edgeInsets: UIEdgeInsets? = nil
    ) {

        guard blurRadius >= 0 else { return }

        contentView.layer.shadowColor = color.cgColor
        contentView.layer.shadowOpacity = Float(opacity)
        contentView.layer.shadowRadius = blurRadius
        contentView.layer.shadowOffset = CGSize(width: offset.horizontal, height: offset.vertical)
        
        if let edgeInsets = edgeInsets {
            var shadowRect = CGRect(origin: .zero, size: bannerPositionFrame.startFrame.size)
            shadowRect.size.height -= (spacerViewHeight() - spacerViewDefaultOffset) // to proper handle spacer height affects
            shadowRect.origin.x += edgeInsets.left
            shadowRect.origin.y += edgeInsets.top
            shadowRect.size.width -= (edgeInsets.left + edgeInsets.right)
            shadowRect.size.height -= (edgeInsets.top + edgeInsets.bottom)
            contentView.layer.shadowPath = UIBezierPath(roundedRect: shadowRect, cornerRadius: cornerRadius).cgPath
        }
        
        contentView.layer.rasterizationScale = UIScreen.main.scale
        contentView.layer.shouldRasterize = true
    }
    
}
//
//  UIWindow+orientation.swift
//  NotificationBannerSwift
//
//  Created by gabmarfer on 15/10/2019.
//

import UIKit

extension UIWindow {

    public var width: CGFloat {
        let orientation = UIDevice.current.orientation
        switch orientation {
        case .landscapeLeft, .landscapeRight:
            return max(frame.width, frame.height)
        case .portrait, .portraitUpsideDown:
            return min(frame.width, frame.height)
        default:
            return frame.width
        }
    }

    public var height: CGFloat {
        let orientation = UIDevice.current.orientation
        switch orientation {
        case .landscapeLeft, .landscapeRight:
            return min(frame.width, frame.height)
        case .portrait, .portraitUpsideDown:
            return max(frame.width, frame.height)
        default:
            return frame.height
        }
    }

}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit

@objc
public enum BannerPosition: Int {
    case bottom
    case top
}

class BannerPositionFrame {
    
    private(set) var startFrame: CGRect = .zero
    private(set) var endFrame: CGRect = .zero

    init(
        bannerPosition: BannerPosition,
        bannerWidth: CGFloat,
        bannerHeight: CGFloat,
        maxY: CGFloat,
        finishYOffset: CGFloat = 0,
        edgeInsets: UIEdgeInsets?
    ) {

        self.startFrame = startFrame(
            for: bannerPosition,
            bannerWidth: bannerWidth,
            bannerHeight: bannerHeight,
            maxY: maxY,
            edgeInsets: edgeInsets
        )
        
        self.endFrame = endFrame(
            for: bannerPosition,
            bannerWidth: bannerWidth,
            bannerHeight: bannerHeight,
            maxY: maxY,
            finishYOffset: finishYOffset,
            edgeInsets: edgeInsets
        )
    }
    
    /**
        Returns the start frame for the notification banner based on the given banner position
        - parameter bannerPosition: The position the notification banners should slide in from
        - parameter bannerWidth: The width of the notification banner
        - parameter bannerHeight: The height of the notification banner
        - parameter maxY: The maximum `y` position the banner can slide in from. This value is only used 
        if the bannerPosition is .bottom
        - parameter edgeInsets: The sides edges insets from superview
     */
    private func startFrame(
        for bannerPosition: BannerPosition,
        bannerWidth: CGFloat,
        bannerHeight: CGFloat,
        maxY: CGFloat,
        edgeInsets: UIEdgeInsets?
    ) -> CGRect {
        
        let edgeInsets = edgeInsets ?? .zero
        
        switch bannerPosition {
        case .bottom:
            return CGRect(
                x: edgeInsets.left,
                y: maxY,
                width: bannerWidth - edgeInsets.left - edgeInsets.right,
                height: bannerHeight
            )
        case .top:
            return CGRect(
                x: edgeInsets.left,
                y: -bannerHeight,
                width: bannerWidth - edgeInsets.left - edgeInsets.right,
                height: bannerHeight
            )

        }
    }
    
    /**
     Returns the end frame for the notification banner based on the given banner position
     - parameter bannerPosition: The position the notification banners should slide in from
     - parameter bannerWidth: The width of the notification banner
     - parameter bannerHeight: The height of the notification banner
     - parameter maxY: The maximum `y` position the banner can slide in from. This value is only used if the bannerPosition is .bottom
     - parameter finishYOffset: The `y` position offset the banner can slide in. Used for displaying several banenrs simaltaneously
     - parameter edgeInsets: The sides edges insets from superview
     */
    private func endFrame(
        for bannerPosition: BannerPosition,
        bannerWidth: CGFloat,
        bannerHeight: CGFloat,
        maxY: CGFloat,
        finishYOffset: CGFloat = 0,
        edgeInsets: UIEdgeInsets?
    ) -> CGRect {
        
        let edgeInsets = edgeInsets ?? .zero

        switch bannerPosition {
        case .bottom:
            return CGRect(
                x: edgeInsets.left,
                y: maxY - bannerHeight - edgeInsets.bottom - finishYOffset,
                width: startFrame.width,
                height: startFrame.height)
        case .top:
            return CGRect(
                x: edgeInsets.left,
                y: edgeInsets.top + finishYOffset,
                width: startFrame.width,
                height: startFrame.height
            )
        }
    }

}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import Foundation

@objc
public enum BannerStyle: Int {
    case danger
    case info
    case customView
    case success
    case warning
}

/*

 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

import UIKit

import MarqueeLabel

@objcMembers
open class StatusBarNotificationBanner: BaseNotificationBanner {

    public override var bannerHeight: CGFloat {
        get {
            if let customBannerHeight = customBannerHeight {
                return customBannerHeight
            } else if shouldAdjustForDynamicIsland() {
                return 70.0
            } else if shouldAdjustForNotchFeaturedIphone() {
                return 50.0
            } else {
                return 20.0 + heightAdjustment
            }
        } set {
            customBannerHeight = newValue
        }
    }

    override init(style: BannerStyle, colors: BannerColorsProtocol? = nil) {
        super.init(style: style, colors: colors)

        titleLabel = MarqueeLabel()
        (titleLabel as! MarqueeLabel).animationDelay = 2
        (titleLabel as! MarqueeLabel).type = .leftRight
        titleLabel!.font = UIFont.systemFont(ofSize: 12.5, weight: UIFont.Weight.bold)
        titleLabel!.textAlignment = .center
        titleLabel!.textColor = .white
        contentView.addSubview(titleLabel!)

        titleLabel!.snp.makeConstraints { (make) in
            make.top.equalToSuperview().offset(heightAdjustment)
            make.left.equalToSuperview().offset(5)
            make.right.equalToSuperview().offset(-5)
            make.bottom.equalToSuperview()
        }

        updateMarqueeLabelsDurations()
    }

    public convenience init(
        title: String,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil
    ) {
        self.init(style: style, colors: colors)
        titleLabel!.text = title
    }

    public convenience init(
        attributedTitle: NSAttributedString,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil
    ) {
        self.init(style: style, colors: colors)
        titleLabel!.attributedText = attributedTitle
    }

    public init(customView: UIView) {
        super.init(style: .customView)
        self.customView = customView
        
        contentView.addSubview(customView)
        customView.snp.makeConstraints { make in
            make.edges.equalTo(contentView)
        }

        spacerView.backgroundColor = customView.backgroundColor
    }

    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }

}

public extension StatusBarNotificationBanner {
    
    func applyStyling(
        titleColor: UIColor? = nil,
        titleTextAlign: NSTextAlignment? = nil
    ) {
        
        if let titleColor = titleColor {
            titleLabel!.textColor = titleColor
        }
        
        if let titleTextAlign = titleTextAlign {
            titleLabel!.textAlignment = titleTextAlign
        }
    }
    
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit

class NotificationBannerUtilities: NSObject {

    class func isNotchFeaturedIPhone() -> Bool {
        if #available(iOS 11, *) {
            if UIApplication.shared.keyWindow?.safeAreaInsets.bottom ?? 0.0 > 0.0 {
                return true
            } else {
                return false
            }
        } else {
            return false
        }
    }
    
    class func hasDynamicIsland() -> Bool {
        if #available(iOS 11, *) {
            if UIApplication.shared.keyWindow?.safeAreaInsets.top ?? 0.0 > 50.0 {
                return true
            } else {
                return false
            }
        } else {
            return false
        }
    }
    
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit

@objc
public protocol BannerColorsProtocol {
    func color(for style: BannerStyle) -> UIColor
}

public class BannerColors: BannerColorsProtocol {

    public func color(for style: BannerStyle) -> UIColor {
        switch style {
            case .danger:
                return UIColor(red:0.90, green:0.31, blue:0.26, alpha:1.00)
            case .info:
                return UIColor(red:0.23, green:0.60, blue:0.85, alpha:1.00)
            case .customView:
                return .clear
            case .success:
                return UIColor(red:0.22, green:0.80, blue:0.46, alpha:1.00)
            case .warning:
                return UIColor(red:1.00, green:0.66, blue:0.16, alpha:1.00)
        }
    }
}
//
//  String+heightForConstrainedWidth.swift
//  NotificationBanner
//
//  Created by Sascha Gordner on 03.10.18.
//  Copyright © 2018 Dalton Hinterscher. All rights reserved.
//
// https://stackoverflow.com/questions/30450434/figure-out-size-of-uilabel-based-on-string-in-swift

import UIKit

public extension String {
    
    /// Calculates the height a label will need in order to display the String for the given width and font.
    ///
    /// - Parameters:
    ///   - width: Max width of the bounding rect
    ///   - font: Font used to render the string
    /// - Returns: Height a string will need to be completely visible
    func height(forConstrainedWidth width: CGFloat, font: UIFont) -> CGFloat {
        let constraintRect = CGSize(width: width, height: .greatestFiniteMagnitude)
        let boundingBox = self.boundingRect(
            with: constraintRect,
            options: [.usesLineFragmentOrigin, .usesFontLeading],
            attributes: [.font: font],
            context: nil
        )
        return boundingBox.height
    }
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit
import SnapKit

open class GrowingNotificationBanner: BaseNotificationBanner {
    
    public enum IconPosition {
        case top
        case center
    }
    
    /// The height of the banner when it is presented
    override public var bannerHeight: CGFloat {
        get {
            if let customBannerHeight = customBannerHeight {
                return customBannerHeight
            } else {
                // Calculate the height based on contents of labels
                
                // Determine available width for displaying the label
                var boundingWidth = UIScreen.main.bounds.width - padding * 2
                
                // Substract safeAreaInsets from width, if available
                // We have to use keyWindow to ask for safeAreaInsets as `self` only knows its' safeAreaInsets in layoutSubviews
                if #available(iOS 11.0, *), let keyWindow = UIApplication.shared.keyWindow {
                    let safeAreaOffset = keyWindow.safeAreaInsets.left + keyWindow.safeAreaInsets.right
                    
                    boundingWidth -= safeAreaOffset
                }
                
                if leftView != nil {
                    boundingWidth -= sideViewSize + padding
                }
                
                if rightView != nil {
                    boundingWidth -= sideViewSize + padding
                }
                
                let titleHeight = ceil(titleLabel?.sizeThatFits(
                    CGSize(width: boundingWidth,
                           height: .greatestFiniteMagnitude)).height ?? 0.0)
                
                let subtitleHeight = ceil(subtitleLabel?.sizeThatFits(
                    CGSize(width: boundingWidth,
                           height: .greatestFiniteMagnitude)).height ?? 0.0)
             
                let topOffset: CGFloat
                let minHeight: CGFloat

                if shouldAdjustForNotchFeaturedIphone() {
                    topOffset = 44.0
                    minHeight = 88.0
                } else if shouldAdjustForDynamicIsland() {
                    topOffset = 44.0
                    minHeight = 104.0
                } else {
                    topOffset = verticalSpacing
                    minHeight = 64.0
                }
                
                var actualBannerHeight = topOffset + titleHeight + subtitleHeight + verticalSpacing
                
                if !subtitleHeight.isZero && !titleHeight.isZero {
                    actualBannerHeight += innerSpacing
                }
                
                return heightAdjustment + max(actualBannerHeight, minHeight)
            }
        } set {
            customBannerHeight = newValue
        }
    }
    
    /// Spacing between the last label and the bottom edge of the banner
    private let verticalSpacing: CGFloat = 14.0
    
    /// Spacing between title and subtitle
    private let innerSpacing: CGFloat = 2.5
    
    /// The bottom most label of the notification if a subtitle is provided
    public internal(set) var subtitleLabel: UILabel?
    
    /// The view that is presented on the left side of the notification
    private var leftView: UIView?
    
    /// The view that is presented on the right side of the notification
    private var rightView: UIView?
    
    /// Square size for left/right view if set
    private let sideViewSize: CGFloat
    
    /// Font used for the title label
    internal var titleFont: UIFont = UIFont.systemFont(ofSize: 17.5, weight: UIFont.Weight.bold)
    
    /// Font used for the subtitle label
    internal var subtitleFont: UIFont = UIFont.systemFont(ofSize: 15.0)
    
    public init(
        title: String? = nil,
        subtitle: String? = nil,
        leftView: UIView? = nil,
        rightView: UIView? = nil,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil,
        iconPosition: IconPosition = .center,
        sideViewSize: CGFloat = 24.0
    ) {
        
        self.leftView = leftView
        self.rightView = rightView
        self.sideViewSize = sideViewSize
        
        super.init(style: style, colors: colors)
        
        let labelsView = UIStackView()
        labelsView.axis = .vertical
        labelsView.spacing = innerSpacing
        
        let outerStackView = UIStackView()
        outerStackView.spacing = padding
        
        switch iconPosition {
        case .top:
            outerStackView.alignment = .top
        case .center:
            outerStackView.alignment = .center
        }
        
        if let leftView = leftView {
            outerStackView.addArrangedSubview(leftView)
            leftView.snp.makeConstraints { $0.size.equalTo(sideViewSize) }
        }
        
        outerStackView.addArrangedSubview(labelsView)
        
        if let title = title {
            titleLabel = UILabel()
            titleLabel!.font = titleFont
            titleLabel!.numberOfLines = 0
            titleLabel!.textColor = .white
            titleLabel!.text = title
            titleLabel!.setContentHuggingPriority(.required, for: .vertical)
            labelsView.addArrangedSubview(titleLabel!)
        }
        
        if let subtitle = subtitle {
            subtitleLabel = UILabel()
            subtitleLabel!.font = subtitleFont
            subtitleLabel!.numberOfLines = 0
            subtitleLabel!.textColor = .white
            subtitleLabel!.text = subtitle
            if title == nil {
                subtitleLabel!.setContentHuggingPriority(.required, for: .vertical)
            }
            labelsView.addArrangedSubview(subtitleLabel!)
        }
        
        if let rightView = rightView {
            outerStackView.addArrangedSubview(rightView)
            rightView.snp.makeConstraints { $0.size.equalTo(sideViewSize) }
        }
        
        contentView.addSubview(outerStackView)
        outerStackView.snp.makeConstraints { (make) in
            if #available(iOS 11.0, *) {
                make.left.equalTo(safeAreaLayoutGuide).offset(padding)
                make.right.equalTo(safeAreaLayoutGuide).offset(-padding)
            } else {
                make.left.equalToSuperview().offset(padding)
                make.right.equalToSuperview().offset(-padding)
            }
            
            make.centerY.equalToSuperview()
        }
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func spacerViewHeight() -> CGFloat {
        return super.spacerViewHeight() + heightAdjustment
    }
}

public extension GrowingNotificationBanner {
    
    func applyStyling(
        cornerRadius: CGFloat? = nil,
        titleFont: UIFont? = nil,
        titleColor: UIColor? = nil,
        titleTextAlign: NSTextAlignment? = nil,
        subtitleFont: UIFont? = nil,
        subtitleColor: UIColor? = nil,
        subtitleTextAlign: NSTextAlignment? = nil
    ) {
        
        if let cornerRadius = cornerRadius {
            contentView.layer.cornerRadius = cornerRadius
        }
        
        if let titleFont = titleFont {
            self.titleFont = titleFont
            titleLabel!.font = titleFont
        }
        
        if let titleColor = titleColor {
            titleLabel!.textColor = titleColor
        }
        
        if let titleTextAlign = titleTextAlign {
            titleLabel!.textAlignment = titleTextAlign
        }
        
        if let subtitleFont = subtitleFont {
            self.subtitleFont = subtitleFont
            subtitleLabel!.font = subtitleFont
        }
        
        if let subtitleColor = subtitleColor {
            subtitleLabel!.textColor = subtitleColor
        }
        
        if let subtitleTextAlign = subtitleTextAlign {
            subtitleLabel!.textAlignment = subtitleTextAlign
        }
        
        if titleFont != nil || subtitleFont != nil {
            updateBannerHeight()
        }
    }
    
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit

public enum BannerHaptic {
    case light
    case medium
    case heavy
    case none

    @available(iOS 10.0, *)
    var impactStyle: UIImpactFeedbackGenerator.FeedbackStyle? {
        switch self {
        case .light:
            return .light
        case .medium:
            return .medium
        case .heavy:
            return .heavy
        case .none:
            return nil
        }
    }
}

open class BannerHapticGenerator: NSObject {

    /**
        Generates a haptic based on the given haptic
        -parameter haptic: The haptic strength to generate when a banner is shown
     */
    open class func generate(_ haptic: BannerHaptic) {
        guard let style = haptic.impactStyle else { return }
        let feedbackGenerator = UIImpactFeedbackGenerator(style: style)
        feedbackGenerator.prepare()
        feedbackGenerator.impactOccurred()
    }
}
/*

 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

import UIKit
import SnapKit

import MarqueeLabel

public protocol NotificationBannerDelegate: AnyObject {
    func notificationBannerWillAppear(_ banner: BaseNotificationBanner)
    func notificationBannerDidAppear(_ banner: BaseNotificationBanner)
    func notificationBannerWillDisappear(_ banner: BaseNotificationBanner)
    func notificationBannerDidDisappear(_ banner: BaseNotificationBanner)
}

@objcMembers
open class BaseNotificationBanner: UIView {

    /// Notification that will be posted when a notification banner will appear
    public static let BannerWillAppear: Notification.Name = Notification.Name(rawValue: "NotificationBannerWillAppear")

    /// Notification that will be posted when a notification banner did appear
    public static let BannerDidAppear: Notification.Name = Notification.Name(rawValue: "NotificationBannerDidAppear")

    /// Notification that will be posted when a notification banner will appear
    public static let BannerWillDisappear: Notification.Name = Notification.Name(rawValue: "NotificationBannerWillDisappear")

    /// Notification that will be posted when a notification banner did appear
    public static let BannerDidDisappear: Notification.Name = Notification.Name(rawValue: "NotificationBannerDidDisappear")

    /// Notification banner object key that is included with each Notification
    public static let BannerObjectKey: String = "NotificationBannerObjectKey"

    /// The delegate of the notification banner
    public weak var delegate: NotificationBannerDelegate?

    /// The style of the notification banner
    public let style: BannerStyle

    /// The height of the banner when it is presented
    public var bannerHeight: CGFloat {
        get {
            if let customBannerHeight = customBannerHeight {
                return customBannerHeight
            } else if shouldAdjustForDynamicIsland() {
                return 104.0
            } else if shouldAdjustForNotchFeaturedIphone() {
                return 88.0
            } else {
                return 64.0 + heightAdjustment
            }
        } set {
            customBannerHeight = newValue
        }
    }

    /// The topmost label of the notification if a custom view is not desired
    public internal(set) var titleLabel: UILabel?

    /// The time before the notificaiton is automatically dismissed
    public var duration: TimeInterval = 5.0 {
        didSet {
            updateMarqueeLabelsDurations()
        }
    }

    /// If false, the banner will not be dismissed until the developer programatically dismisses it
    public var autoDismiss: Bool = true {
        didSet {
            if !autoDismiss {
                dismissOnTap = false
                dismissOnSwipeUp = false
            }
        }
    }

    /// The transparency of the background of the notification banner
    public var transparency: CGFloat = 1.0 {
        didSet {
            if let customView = customView {
                customView.backgroundColor = customView.backgroundColor?.withAlphaComponent(transparency)
            } else {
                let color = backgroundColor
                self.backgroundColor = color
            }
        }
    }

    /// The type of haptic to generate when a banner is displayed
    public var haptic: BannerHaptic = .heavy

    /// If true, notification will dismissed when tapped
    public var dismissOnTap: Bool = true

    /// If true, notification will dismissed when swiped up
    public var dismissOnSwipeUp: Bool = true

    /// Closure that will be executed if the notification banner is tapped
    public var onTap: (() -> Void)?

    /// Closure that will be executed if the notification banner is swiped up
    public var onSwipeUp: (() -> Void)?

    /// Responsible for positioning and auto managing notification banners
    public var bannerQueue: NotificationBannerQueue = NotificationBannerQueue.default

    /// Banner show and dimiss animation duration
    public var animationDuration: TimeInterval = 0.5

    /// Whether or not the notification banner is currently being displayed
    public var isDisplaying: Bool = false
    
    /// Whether or not to post the default accessibility notification.
    public var shouldPostAccessibilityNotification: Bool = true

    /// The view that the notification layout is presented on. The constraints/frame of this should not be changed
    internal var contentView: UIView!

    /// A view that helps the spring animation look nice when the banner appears
    internal var spacerView: UIView!

    // The custom view inside the notification banner
    internal var customView: UIView?

    /// The default offset for spacerView top or bottom
    internal var spacerViewDefaultOffset: CGFloat = 10.0

    /// The maximum number of banners simultaneously visible on screen
    internal var maximumVisibleBanners: Int = 1

    /// The default padding between edges and views
    internal var padding: CGFloat = 15.0

    /// The view controller to display the banner on. This is useful if you are wanting to display a banner underneath a navigation bar
    internal weak var parentViewController: UIViewController?

    /// If this is not nil, then this height will be used instead of the auto calculated height
    internal var customBannerHeight: CGFloat?

    /// Used by the banner queue to determine wether a notification banner was placed in front of it in the queue
    var isSuspended: Bool = false

    /// The main window of the application which banner views are placed on
    private let appWindow: UIWindow? = {
        if #available(iOS 13.0, *) {
            return UIApplication.shared.connectedScenes
                .first { $0.activationState == .foregroundActive || $0.activationState == .foregroundInactive }
                .map { $0 as? UIWindowScene }
                .flatMap { $0?.windows.first } ?? UIApplication.shared.delegate?.window ?? UIApplication.shared.keyWindow
        }

        return UIApplication.shared.delegate?.window ?? nil
    }()

    /// The position the notification banner should slide in from
    private(set) var bannerPosition: BannerPosition = .top

    /// The notification banner sides edges insets from superview. If presented - spacerView color will be transparent
    internal var bannerEdgeInsets: UIEdgeInsets? = nil {
        didSet {
            if bannerEdgeInsets != nil {
                spacerView.backgroundColor = .clear
            }
        }
    }

    /// Object that stores the start and end frames for the notification banner based on the provided banner position
    internal var bannerPositionFrame: BannerPositionFrame!

    /// The user info that gets passed to each notification
    private var notificationUserInfo: [String: BaseNotificationBanner] {
        return [BaseNotificationBanner.BannerObjectKey: self]
    }

    open override var backgroundColor: UIColor? {
        get {
            return contentView.backgroundColor
        } set {
            guard style != .customView else { return }
            let color = newValue?.withAlphaComponent(transparency)
            contentView.backgroundColor = color
            spacerView.backgroundColor = color
        }
    }

    init(style: BannerStyle, colors: BannerColorsProtocol? = nil) {
        self.style = style
        super.init(frame: .zero)

        spacerView = UIView()
        addSubview(spacerView)

        contentView = UIView()
        addSubview(contentView)

        if let colors = colors {
            backgroundColor = colors.color(for: style)
        } else {
            backgroundColor = BannerColors().color(for: style)
        }

        let swipeUpGesture = UISwipeGestureRecognizer(target: self, action: #selector(onSwipeUpGestureRecognizer))
        swipeUpGesture.direction = .up
        addGestureRecognizer(swipeUpGesture)
    }

    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    deinit {
        NotificationCenter.default.removeObserver(
            self,
            name: UIDevice.orientationDidChangeNotification,
            object: nil
        )
    }

    /**
        Creates the proper banner constraints based on the desired banner position
     */
    private func createBannerConstraints(for bannerPosition: BannerPosition) {

        spacerView.snp.remakeConstraints { (make) in
            if bannerPosition == .top {
                make.top.equalToSuperview().offset(-spacerViewDefaultOffset)
            } else {
                make.bottom.equalToSuperview().offset(spacerViewDefaultOffset)
            }
            make.left.equalToSuperview()
            make.right.equalToSuperview()
            updateSpacerViewHeight(make: make)
        }

        contentView.snp.remakeConstraints { (make) in
            if bannerPosition == .top {
                make.top.equalTo(spacerView.snp.bottom)
                make.bottom.equalToSuperview()
            } else {
                make.top.equalToSuperview()
                make.bottom.equalTo(spacerView.snp.top)
            }

            make.left.equalToSuperview()
            make.right.equalToSuperview()
        }

    }

    /**
         Updates the spacer view height. Specifically used for orientation changes.
     */
    private func updateSpacerViewHeight(make: ConstraintMaker? = nil) {
        let finalHeight = spacerViewHeight()
        if let make = make {
            make.height.equalTo(finalHeight)
        } else {
            spacerView.snp.updateConstraints({ (make) in
                make.height.equalTo(finalHeight)
            })
        }
    }

    internal func spacerViewHeight() -> CGFloat {
        if shouldAdjustForDynamicIsland() {
            return 44.0
        } else if shouldAdjustForNotchFeaturedIphone() {
            return 40.0
        } else {
            return 10.0
        }
    }

    private func finishBannerYOffset() -> CGFloat {
        let bannerIndex = (bannerQueue.banners.firstIndex(of: self) ?? bannerQueue.banners.filter { $0.isDisplaying }.count)
        
        return bannerQueue.banners.prefix(bannerIndex).reduce(0) { $0
            + $1.bannerHeight
            - (bannerPosition == .top ? spacerViewHeight() : 0) // notch spacer height for top position only
            + (bannerPosition == .top ? spacerViewDefaultOffset : -spacerViewDefaultOffset) // to reduct additions in createBannerConstraints (it's needed for proper shadow framing)
            + (bannerPosition == .top ? spacerViewDefaultOffset : -spacerViewDefaultOffset) // default space between banners
            // this calculations are made only for banners except first one, for first banner it'll be 0
        }
    }
    
    internal func updateBannerPositionFrames() {
        guard let window = appWindow else { return }
        bannerPositionFrame = BannerPositionFrame(
            bannerPosition: bannerPosition,
            bannerWidth: window.width,
            bannerHeight: bannerHeight,
            maxY: maximumYPosition(),
            finishYOffset: finishBannerYOffset(),
            edgeInsets: bannerEdgeInsets
        )
    }

    internal func animateUpdatedBannerPositionFrames() {
        UIView.animate(
            withDuration: animationDuration,
            delay: 0.0,
            usingSpringWithDamping: 0.7,
            initialSpringVelocity: 1,
            options: [.curveLinear, .allowUserInteraction],
            animations: {
                self.frame = self.bannerPositionFrame.endFrame
        })
    }

    /**
        Places a NotificationBanner on the queue and shows it if its the first one in the queue
        - parameter queuePosition: The position to show the notification banner. If the position is .front, the
        banner will be displayed immediately
        - parameter bannerPosition: The position the notification banner should slide in from
        - parameter queue: The queue to display the notification banner on. It is up to the developer
        to manage multiple banner queues and prevent any conflicts that may occur.
        - parameter viewController: The view controller to display the notifification banner on. If nil, it will
        be placed on the main app window
    */
    public func show(
        queuePosition: QueuePosition = .back,
        bannerPosition: BannerPosition = .top,
        queue: NotificationBannerQueue = NotificationBannerQueue.default,
        on viewController: UIViewController? = nil
    ) {
        parentViewController = viewController
        bannerQueue = queue
        show(
            placeOnQueue: true,
            queuePosition: queuePosition,
            bannerPosition: bannerPosition
        )
    }

    /**
        Places a NotificationBanner on the queue and shows it if its the first one in the queue
        - parameter placeOnQueue: If false, banner will not be placed on the queue and will be showed/resumed immediately
        - parameter queuePosition: The position to show the notification banner. If the position is .front, the
        banner will be displayed immediately
        - parameter bannerPosition: The position the notification banner should slide in from
    */
    func show(
        placeOnQueue: Bool,
        queuePosition: QueuePosition = .back,
        bannerPosition: BannerPosition = .top
    ) {

        guard !isDisplaying else {
            return
        }

        self.bannerPosition = bannerPosition
        createBannerConstraints(for: bannerPosition)
        updateBannerPositionFrames()

        NotificationCenter.default.removeObserver(
            self,
            name: UIDevice.orientationDidChangeNotification,
            object: nil
        )
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(onOrientationChanged),
            name: UIDevice.orientationDidChangeNotification,
            object: nil
        )

        if placeOnQueue {
            bannerQueue.addBanner(
                self,
                bannerPosition: bannerPosition,
                queuePosition: queuePosition
            )
        } else {
            guard bannerPositionFrame != nil else {
                remove();
                return
            }

            self.frame = bannerPositionFrame.startFrame

            if let parentViewController = parentViewController, parentViewController.view != nil {
                parentViewController.view.addSubview(self)
                if statusBarShouldBeShown() {
                    appWindow?.windowLevel = UIWindow.Level.normal
                }
            } else {
                appWindow?.addSubview(self)
                if statusBarShouldBeShown() && !(parentViewController == nil && bannerPosition == .top) {
                    appWindow?.windowLevel = UIWindow.Level.normal
                } else {
                    appWindow?.windowLevel = UIWindow.Level.statusBar + 1
                }
            }

            NotificationCenter.default.post(
                name: BaseNotificationBanner.BannerWillAppear,
                object: self,
                userInfo: notificationUserInfo
            )
            
            delegate?.notificationBannerWillAppear(self)
            
            if self.shouldPostAccessibilityNotification {
                postAccessibilityNotification()
            }

            let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(self.onTapGestureRecognizer))
            self.addGestureRecognizer(tapGestureRecognizer)

            self.isDisplaying = true

            let bannerIndex = Double(bannerQueue.banners.firstIndex(of: self) ?? 0) + 1
            UIView.animate(
                withDuration: animationDuration * bannerIndex,
                delay: 0.0,
                usingSpringWithDamping: 0.7,
                initialSpringVelocity: 1,
                options: [.curveLinear, .allowUserInteraction],
                animations: {
                    BannerHapticGenerator.generate(self.haptic)
                    self.frame = self.bannerPositionFrame.endFrame
            }) { (completed) in

                NotificationCenter.default.post(
                    name: BaseNotificationBanner.BannerDidAppear,
                    object: self,
                    userInfo: self.notificationUserInfo
                )
                
                self.delegate?.notificationBannerDidAppear(self)

                /* We don't want to add the selector if another banner was queued in front of it
                   before it finished animating or if it is meant to be shown infinitely
                */
                if !self.isSuspended && self.autoDismiss {
                    self.perform(
                        #selector(self.dismiss),
                        with: nil,
                        afterDelay: self.duration
                    )
                }
            }
        }
    }

    /**
        Suspends a notification banner so it will not be dismissed. This happens because a new notification banner was placed in front of it on the queue.
    */
    func suspend() {
        if autoDismiss {
            NSObject.cancelPreviousPerformRequests(
                withTarget: self,
                selector: #selector(dismiss),
                object: nil
            )
            isSuspended = true
            isDisplaying = false
        }
    }

    /**
        Resumes a notification banner immediately.
    */
    func resume() {
        if autoDismiss {
            self.perform(
                #selector(dismiss),
                with: nil,
                afterDelay: self.duration
            )
            isSuspended = false
            isDisplaying = true
        }
    }

    /**
        Resets a notification banner's elapsed duration to zero.
    */
    public func resetDuration() {
        if autoDismiss {
             NSObject.cancelPreviousPerformRequests(
                withTarget: self,
                selector: #selector(dismiss),
                object: nil
             )
            
             self.perform(#selector(dismiss), with: nil, afterDelay: self.duration)
        }
    }
    
    /**
        The height adjustment needed in order for the banner to look properly displayed.
     */
    internal var heightAdjustment: CGFloat {
        if NotificationBannerUtilities.hasDynamicIsland() {
            return 16.0
        }
        
        // iOS 13 does not allow covering the status bar on non-notch iPhones
        // The banner needs to be moved further down under the status bar in this case
        guard #available(iOS 13.0, *), !NotificationBannerUtilities.isNotchFeaturedIPhone() else {
            return 0
        }

        return UIApplication.shared.statusBarFrame.height
    }

    /**
        Update banner height, it's necessary after banner labels font update
     */
    internal func updateBannerHeight() {
        onOrientationChanged()
    }

    /**
        Changes the frame of the notification banner when the orientation of the device changes
    */
    @objc private dynamic func onOrientationChanged() {
        guard let window = appWindow,
              currentDeviceOrientationIsSupportedByApp() else { return }
        
        updateSpacerViewHeight()

        let edgeInsets = bannerEdgeInsets ?? .zero

        let newY = (bannerPosition == .top) ? (frame.origin.y) : (window.height - bannerHeight + edgeInsets.top - edgeInsets.bottom)
        
        frame = CGRect(
            x: frame.origin.x,
            y: newY,
            width: window.width - edgeInsets.left - edgeInsets.right,
            height: bannerHeight
        )

        bannerPositionFrame = BannerPositionFrame(
            bannerPosition: bannerPosition,
            bannerWidth: window.width,
            bannerHeight: bannerHeight,
            maxY: maximumYPosition(),
            finishYOffset: finishBannerYOffset(),
            edgeInsets: bannerEdgeInsets
        )
    }

    /**
     Dismisses the NotificationBanner and shows the next one if there is one to show on the queue
     */
    @objc public func dismiss(forced: Bool = false) {

        guard isDisplaying else {
            return
        }

        NSObject.cancelPreviousPerformRequests(
            withTarget: self,
            selector: #selector(dismiss),
            object: nil
        )

        NotificationCenter.default.post(
            name: BaseNotificationBanner.BannerWillDisappear,
            object: self,
            userInfo: notificationUserInfo
        )
        
        delegate?.notificationBannerWillDisappear(self)

        isDisplaying = false
        remove()

        // Prevent any user action from showing an additional animation
        self.bannerQueue.activeAnimation = true

        UIView.animate(
            withDuration: forced ? animationDuration / 2 : animationDuration,
            animations: {
                self.frame = self.bannerPositionFrame.startFrame
        }) { (completed) in
            self.bannerQueue.activeAnimation = false

            self.removeFromSuperview()

            NotificationCenter.default.post(
                name: BaseNotificationBanner.BannerDidDisappear,
                object: self,
                userInfo: self.notificationUserInfo
            )
            
            self.delegate?.notificationBannerDidDisappear(self)

            self.bannerQueue.showNext(callback: { (isEmpty) in
                if isEmpty || self.statusBarShouldBeShown() {
                    self.appWindow?.windowLevel = UIWindow.Level.normal
                }
            })
        }
    }

    /**
     Removes the NotificationBanner from the queue if not displaying
     */
    public func remove() {

        guard !isDisplaying else {
            return
        }

        bannerQueue.removeBanner(self)
    }

    /**
        Called when a notification banner is tapped
    */
    @objc private dynamic func onTapGestureRecognizer() {
        if dismissOnTap {
            dismiss()
        }

        onTap?()
    }

    /**
        Called when a notification banner is swiped up
    */
    @objc private dynamic func onSwipeUpGestureRecognizer() {
        if dismissOnSwipeUp {
            dismiss()
        }

        onSwipeUp?()
    }


    /**
        Determines wether or not the status bar should be shown when displaying
        a banner underneath the navigation bar
     */
    private func statusBarShouldBeShown() -> Bool {

        for banner in bannerQueue.banners {
            if (banner.parentViewController == nil && banner.bannerPosition == .top) {
                return false
            }
        }

        return true
    }
    
    /**
        Determines wether or not the current orientation that the device is in
        is supported by the current application.
     */
    private func currentDeviceOrientationIsSupportedByApp() -> Bool {
        let supportedOrientations = UIApplication.shared.supportedInterfaceOrientations(for: appWindow)
        
        switch UIDevice.current.orientation {
        case .portrait:
            return supportedOrientations.contains(.portrait)
        case .portraitUpsideDown:
            return supportedOrientations.contains(.portraitUpsideDown)
        case .landscapeLeft:
            return supportedOrientations.contains(.landscapeLeft)
        case .landscapeRight:
            return supportedOrientations.contains(.landscapeRight)
        default:
            return false
        }
    }

    /**
        Calculates the maximum `y` position that a notification banner can slide in from
    */

    private func maximumYPosition() -> CGFloat {
        if let parentViewController = parentViewController {
            return parentViewController.view.frame.height
        } else {
            return appWindow?.height ?? 0
        }
    }

    /**
         Determines wether or not we should adjust the banner for notch featured iPhone
     */

    internal func shouldAdjustForDynamicIsland() -> Bool {
        return NotificationBannerUtilities.hasDynamicIsland()
            && UIApplication.shared.statusBarOrientation.isPortrait
            && (self.parentViewController?.navigationController?.isNavigationBarHidden ?? true)
    }
    
    internal func shouldAdjustForNotchFeaturedIphone() -> Bool {
        return NotificationBannerUtilities.isNotchFeaturedIPhone()
            && UIApplication.shared.statusBarOrientation.isPortrait
            && (self.parentViewController?.navigationController?.isNavigationBarHidden ?? true)
    }
    /**
        Updates the scrolling marquee label duration
    */
    internal func updateMarqueeLabelsDurations() {
        (titleLabel as? MarqueeLabel)?.speed = .duration(CGFloat(duration <= 3 ? 0.5 : duration - 3))
    }


    /**
     Posts a `UIAccessibility` notification when a notification appears.
     */
    private func postAccessibilityNotification() {
        var bannerAccessibilityLabel: String? = nil
        switch self {
        case let banner as NotificationBanner:
            if let title = banner.titleLabel?.text, let subtitle = banner.subtitleLabel?.text {
                bannerAccessibilityLabel = "\(title) \(subtitle)"
            }
        case let banner as FloatingNotificationBanner:
            if let title = banner.titleLabel?.text, let subtitle = banner.subtitleLabel?.text {
                bannerAccessibilityLabel = "\(title) \(subtitle)"
            }
        case let banner as GrowingNotificationBanner:
            if let title = banner.titleLabel?.text, let subtitle = banner.subtitleLabel?.text {
                bannerAccessibilityLabel = "\(title) \(subtitle)"
            }
        default:
            break
        }
        accessibilityLabel = bannerAccessibilityLabel
        isAccessibilityElement = true
        UIAccessibility.post(notification: .screenChanged, argument: self)
    }
}

/*

 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

import UIKit

@objc
public enum QueuePosition: Int {
    case back
    case front
}

@objcMembers
open class NotificationBannerQueue: NSObject {

    /// The default instance of the NotificationBannerQueue
    public static let `default` = NotificationBannerQueue()

    /// The notification banners currently placed on the queue
    public private(set) var banners: [BaseNotificationBanner] = []

    /// The notification banners currently placed on the queue
    private(set) var maxBannersOnScreenSimultaneously: Int = 1

    /// This is a mutex to prevent too many notification banners from appearing on screen at once
    /// while our BaseNotificationBanner is animating itself off screen
    public var activeAnimation = false

    /// The current number of notification banners on the queue
    public var numberOfBanners: Int {
        return banners.count
    }

    public init(maxBannersOnScreenSimultaneously: Int = 1) {
        self.maxBannersOnScreenSimultaneously = maxBannersOnScreenSimultaneously
    }

    /**
        Adds a banner to the queue
        -parameter banner: The notification banner to add to the queue
        -parameter queuePosition: The position to show the notification banner. If the position is .front, the
        banner will be displayed immediately
    */
    func addBanner(
        _ banner: BaseNotificationBanner,
        bannerPosition: BannerPosition,
        queuePosition: QueuePosition
    ) {

        if queuePosition == .back {
            banners.append(banner)

            let bannersCount =  banners.filter { $0.isDisplaying }.count
            if bannersCount < maxBannersOnScreenSimultaneously && self.activeAnimation == false {
                banner.show(placeOnQueue: false, bannerPosition: banner.bannerPosition)
            }

        } else {
            banner.show(placeOnQueue: false, bannerPosition: bannerPosition)

            if let firstBanner = firstNotDisplayedBanner() {
                firstBanner.suspend()
            }

            banners.insert(banner, at: 0)
        }

    }

    /**
        Removes a banner from the queue
        -parameter banner: A notification banner to remove from the queue.
     */
    func removeBanner(_ banner: BaseNotificationBanner) {

        if let index = banners.firstIndex(of: banner) {
            banners.remove(at: index)
        }

        banners.forEach {
            $0.updateBannerPositionFrames()
            if $0.isDisplaying {
                $0.animateUpdatedBannerPositionFrames()
            }
        }
    }

    /**
        Shows the next notificaiton banner on the queue if one exists
        -parameter callback: The closure to execute after a banner is shown or when the queue is empty
    */
    func showNext(callback: ((_ isEmpty: Bool) -> Void)) {

        if let banner = firstNotDisplayedBanner() {

            if banner.isSuspended {
                banner.resume()
            } else {
                banner.show(placeOnQueue: false, bannerPosition: banner.bannerPosition)
            }

            callback(false)
        }
        else {
            callback(true)
            return
        }
    }

    func firstNotDisplayedBanner() -> BaseNotificationBanner? {
        return banners.filter { !$0.isDisplaying }.first
    }

    /**
        Removes all notification banners from the queue
    */
    public func removeAll() {
        banners.removeAll()
    }

    /**
     Forced dissmiss all notification banners from the queue
     */
    public func dismissAllForced() {
        banners.forEach { $0.dismiss(forced: true) }
        banners.removeAll()
    }

}

/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit
import SnapKit

import MarqueeLabel

@objcMembers
open class NotificationBanner: BaseNotificationBanner {
    
    /// The bottom most label of the notification if a subtitle is provided
    public internal(set) var subtitleLabel: MarqueeLabel?
    
    /// The view that is presented on the left side of the notification
    private var leftView: UIView?
    
    /// The view that is presented on the right side of the notification
    private var rightView: UIView?
    
    /// Font used for the title label
    private var titleFont: UIFont = UIFont.systemFont(ofSize: 17.5, weight: UIFont.Weight.bold)
    
    /// Font used for the subtitle label
    private var subtitleFont: UIFont = UIFont.systemFont(ofSize: 15.0)

    public init(
        title: String? = nil,
        subtitle: String? = nil,
        leftView: UIView? = nil,
        rightView: UIView? = nil,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil
    ) {
        
        super.init(style: style, colors: colors)
        
        if let leftView = leftView {
            contentView.addSubview(leftView)
            
            let size = (leftView.frame.height > 0) ? min(44, leftView.frame.height) : 44
            
            leftView.snp.makeConstraints({ (make) in
                make.centerY.equalToSuperview().offset(heightAdjustment / 4)
                make.left.equalToSuperview().offset(10)
                make.size.equalTo(size)
            })
        }
        
        if let rightView = rightView {
            contentView.addSubview(rightView)
            
            let size = (rightView.frame.height > 0) ? min(44, rightView.frame.height) : 44
            rightView.snp.makeConstraints({ (make) in
                make.centerY.equalToSuperview().offset(heightAdjustment / 4)
                make.right.equalToSuperview().offset(-10)
                make.size.equalTo(size)
            })
        }
        
        let labelsView = UIView()
        contentView.addSubview(labelsView)
        
        if let title = title {
            titleLabel = MarqueeLabel()
            (titleLabel as! MarqueeLabel).type = .left
            titleLabel!.font = titleFont
            titleLabel!.textColor = .white
            titleLabel!.text = title
            labelsView.addSubview(titleLabel!)
            
            titleLabel!.snp.makeConstraints { (make) in
                make.top.equalToSuperview()
                make.left.equalToSuperview()
                make.right.equalToSuperview()
                if let _ = subtitle {
                    titleLabel!.numberOfLines = 1
                } else {
                    titleLabel!.numberOfLines = 2
                }
            }
        }
        
        if let subtitle = subtitle {
            subtitleLabel = MarqueeLabel()
            subtitleLabel!.type = .left
            subtitleLabel!.font = subtitleFont
            subtitleLabel!.numberOfLines = 1
            subtitleLabel!.textColor = .white
            subtitleLabel!.text = subtitle
            labelsView.addSubview(subtitleLabel!)
            
            subtitleLabel!.snp.makeConstraints { (make) in
                if title != nil {
                    make.top.equalTo(titleLabel!.snp.bottom).offset(2.5)
                    make.left.equalTo(titleLabel!)
                    make.right.equalTo(titleLabel!)
                }
                else {
                    make.top.equalToSuperview()
                    make.left.equalToSuperview()
                    make.right.equalToSuperview()
                }
            }
        }
        
        labelsView.snp.makeConstraints { (make) in
            make.centerY.equalToSuperview().offset(heightAdjustment / 4)
            
            if let leftView = leftView {
                make.left.equalTo(leftView.snp.right).offset(padding)
            } else {
                make.left.equalToSuperview().offset(padding)
            }
            
            if let rightView = rightView {
                make.right.equalTo(rightView.snp.left).offset(-padding)
            } else {
                make.right.equalToSuperview().offset(-padding)
            }
            
            if let subtitleLabel = subtitleLabel {
                make.bottom.equalTo(subtitleLabel)
            } else {
                make.bottom.equalTo(titleLabel!)
            }
        }
        
        updateMarqueeLabelsDurations()
        
    }
    
    public convenience init(
        attributedTitle: NSAttributedString,
        attributedSubtitle: NSAttributedString? = nil,
        leftView: UIView? = nil,
        rightView: UIView? = nil,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil
    ) {
        
        let subtitle: String? = (attributedSubtitle != nil) ? "" : nil
        self.init(title: "", subtitle: subtitle, leftView: leftView, rightView: rightView, style: style, colors: colors)
        titleLabel!.attributedText = attributedTitle
        subtitleLabel?.attributedText = attributedSubtitle
    }
    
    public init(customView: UIView) {
        super.init(style: .customView)
        self.customView = customView
        
        contentView.addSubview(customView)
        customView.snp.makeConstraints { (make) in
            make.edges.equalTo(contentView)
        }
        
        spacerView.backgroundColor = customView.backgroundColor
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    internal override func updateMarqueeLabelsDurations() {
        super.updateMarqueeLabelsDurations()
        subtitleLabel?.speed = .duration(CGFloat(duration <= 1 ? 1 : duration - 1))
    }
    
}

public extension NotificationBanner {
    
    func applyStyling(
        cornerRadius: CGFloat? = nil,
        titleFont: UIFont? = nil,
        titleColor: UIColor? = nil,
        titleTextAlign: NSTextAlignment? = nil,
        subtitleFont: UIFont? = nil,
        subtitleColor: UIColor? = nil,
        subtitleTextAlign: NSTextAlignment? = nil
    ) {
        
        if let cornerRadius = cornerRadius {
            contentView.layer.cornerRadius = cornerRadius
        }
        
        if let titleFont = titleFont {
            titleLabel!.font = titleFont
        }
        
        if let titleColor = titleColor {
            titleLabel!.textColor = titleColor
        }
        
        if let titleTextAlign = titleTextAlign {
            titleLabel!.textAlignment = titleTextAlign
        }
        
        if let subtitleFont = subtitleFont {
            subtitleLabel!.font = subtitleFont
        }
        
        if let subtitleColor = subtitleColor {
            subtitleLabel!.textColor = subtitleColor
        }
        
        if let subtitleTextAlign = subtitleTextAlign {
            subtitleLabel!.textAlignment = subtitleTextAlign
        }
        
        if titleFont != nil || subtitleFont != nil {
            updateBannerHeight()
        }
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintMultiplierTarget {
    
    var constraintMultiplierTargetValue: CGFloat { get }
    
}

extension Int: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}

extension UInt: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}

extension Float: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}

extension Double: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}

extension CGFloat: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return self
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol LayoutConstraintItem: AnyObject {
}

@available(iOS 9.0, OSX 10.11, *)
extension ConstraintLayoutGuide : LayoutConstraintItem {
}

extension ConstraintView : LayoutConstraintItem {
}


extension LayoutConstraintItem {
    
    internal func prepare() {
        if let view = self as? ConstraintView {
            view.translatesAutoresizingMaskIntoConstraints = false
        }
    }
    
    internal var superview: ConstraintView? {
        if let view = self as? ConstraintView {
            return view.superview
        }
        
        if #available(iOS 9.0, OSX 10.11, *), let guide = self as? ConstraintLayoutGuide {
            return guide.owningView
        }
        
        return nil
    }
    internal var constraints: [Constraint] {
        return self.constraintsSet.allObjects as! [Constraint]
    }
    
    internal func add(constraints: [Constraint]) {
        let constraintsSet = self.constraintsSet
        for constraint in constraints {
            constraintsSet.add(constraint)
        }
    }
    
    internal func remove(constraints: [Constraint]) {
        let constraintsSet = self.constraintsSet
        for constraint in constraints {
            constraintsSet.remove(constraint)
        }
    }
    
    private var constraintsSet: NSMutableSet {
        let constraintsSet: NSMutableSet
        
        if let existing = objc_getAssociatedObject(self, &constraintsKey) as? NSMutableSet {
            constraintsSet = existing
        } else {
            constraintsSet = NSMutableSet()
            objc_setAssociatedObject(self, &constraintsKey, constraintsSet, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
        return constraintsSet
        
    }
    
}
private var constraintsKey: UInt8 = 0
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

@available(*, deprecated, message:"Use ConstraintMakerPrioritizable instead.")
public typealias ConstraintMakerPriortizable = ConstraintMakerPrioritizable

public class ConstraintMakerPrioritizable: ConstraintMakerFinalizable {
    
    @discardableResult
    public func priority(_ amount: ConstraintPriority) -> ConstraintMakerFinalizable {
        self.description.priority = amount.value
        return self
    }
    
    @discardableResult
    public func priority(_ amount: ConstraintPriorityTarget) -> ConstraintMakerFinalizable {
        self.description.priority = amount
        return self
    }
    
    @available(*, deprecated, message:"Use priority(.required) instead.")
    @discardableResult
    public func priorityRequired() -> ConstraintMakerFinalizable {
        return self.priority(.required)
    }
    
    @available(*, deprecated, message:"Use priority(.high) instead.")
    @discardableResult
    public func priorityHigh() -> ConstraintMakerFinalizable {
        return self.priority(.high)
    }
    
    @available(*, deprecated, message:"Use priority(.medium) instead.")
    @discardableResult
    public func priorityMedium() -> ConstraintMakerFinalizable {
        return self.priority(.medium)
    }
    
    @available(*, deprecated, message:"Use priority(.low) instead.")
    @discardableResult
    public func priorityLow() -> ConstraintMakerFinalizable {
        return self.priority(.low)
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintDescription {
    
    internal let item: LayoutConstraintItem
    internal var attributes: ConstraintAttributes
    internal var relation: ConstraintRelation? = nil
    internal var sourceLocation: (String, UInt)? = nil
    internal var label: String? = nil
    internal var related: ConstraintItem? = nil
    internal var multiplier: ConstraintMultiplierTarget = 1.0
    internal var constant: ConstraintConstantTarget = 0.0
    internal var priority: ConstraintPriorityTarget = 1000.0
    internal lazy var constraint: Constraint? = {
        guard let relation = self.relation,
              let related = self.related,
              let sourceLocation = self.sourceLocation else {
            return nil
        }
        let from = ConstraintItem(target: self.item, attributes: self.attributes)
        
        return Constraint(
            from: from,
            to: related,
            relation: relation,
            sourceLocation: sourceLocation,
            label: self.label,
            multiplier: self.multiplier,
            constant: self.constant,
            priority: self.priority
        )
    }()
    
    // MARK: Initialization
    
    internal init(item: LayoutConstraintItem, attributes: ConstraintAttributes) {
        self.item = item
        self.attributes = attributes
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


internal struct ConstraintAttributes : OptionSet, ExpressibleByIntegerLiteral {
    
    typealias IntegerLiteralType = UInt
    
    internal init(rawValue: UInt) {
        self.rawValue = rawValue
    }
    internal init(_ rawValue: UInt) {
        self.init(rawValue: rawValue)
    }
    internal init(nilLiteral: ()) {
        self.rawValue = 0
    }
    internal init(integerLiteral rawValue: IntegerLiteralType) {
        self.init(rawValue: rawValue)
    }
    
    internal private(set) var rawValue: UInt
    internal static var allZeros: ConstraintAttributes { return 0 }
    internal static func convertFromNilLiteral() -> ConstraintAttributes { return 0 }
    internal var boolValue: Bool { return self.rawValue != 0 }
    
    internal func toRaw() -> UInt { return self.rawValue }
    internal static func fromRaw(_ raw: UInt) -> ConstraintAttributes? { return self.init(raw) }
    internal static func fromMask(_ raw: UInt) -> ConstraintAttributes { return self.init(raw) }
    
    // normal
    
    internal static let none: ConstraintAttributes = 0
    internal static let left: ConstraintAttributes = ConstraintAttributes(UInt(1) << 0)
    internal static let top: ConstraintAttributes = ConstraintAttributes(UInt(1) << 1)
    internal static let right: ConstraintAttributes = ConstraintAttributes(UInt(1) << 2)
    internal static let bottom: ConstraintAttributes = ConstraintAttributes(UInt(1) << 3)
    internal static let leading: ConstraintAttributes = ConstraintAttributes(UInt(1) << 4)
    internal static let trailing: ConstraintAttributes = ConstraintAttributes(UInt(1) << 5)
    internal static let width: ConstraintAttributes = ConstraintAttributes(UInt(1) << 6)
    internal static let height: ConstraintAttributes = ConstraintAttributes(UInt(1) << 7)
    internal static let centerX: ConstraintAttributes = ConstraintAttributes(UInt(1) << 8)
    internal static let centerY: ConstraintAttributes = ConstraintAttributes(UInt(1) << 9)
    internal static let lastBaseline: ConstraintAttributes = ConstraintAttributes(UInt(1) << 10)
    
    @available(iOS 8.0, OSX 10.11, *)
    internal static let firstBaseline: ConstraintAttributes = ConstraintAttributes(UInt(1) << 11)

    @available(iOS 8.0, *)
    internal static let leftMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 12)

    @available(iOS 8.0, *)
    internal static let rightMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 13)

    @available(iOS 8.0, *)
    internal static let topMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 14)

    @available(iOS 8.0, *)
    internal static let bottomMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 15)

    @available(iOS 8.0, *)
    internal static let leadingMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 16)

    @available(iOS 8.0, *)
    internal static let trailingMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 17)

    @available(iOS 8.0, *)
    internal static let centerXWithinMargins: ConstraintAttributes = ConstraintAttributes(UInt(1) << 18)

    @available(iOS 8.0, *)
    internal static let centerYWithinMargins: ConstraintAttributes = ConstraintAttributes(UInt(1) << 19)
    
    // aggregates
    
    internal static let edges: ConstraintAttributes = [.horizontalEdges, .verticalEdges]
    internal static let horizontalEdges: ConstraintAttributes = [.left, .right]
    internal static let verticalEdges: ConstraintAttributes = [.top, .bottom]
    internal static let directionalEdges: ConstraintAttributes = [.directionalHorizontalEdges, .directionalVerticalEdges]
    internal static let directionalHorizontalEdges: ConstraintAttributes = [.leading, .trailing]
    internal static let directionalVerticalEdges: ConstraintAttributes = [.top, .bottom]
    internal static let size: ConstraintAttributes = [.width, .height]
    internal static let center: ConstraintAttributes = [.centerX, .centerY]

    @available(iOS 8.0, *)
    internal static let margins: ConstraintAttributes = [.leftMargin, .topMargin, .rightMargin, .bottomMargin]

    @available(iOS 8.0, *)
    internal static let directionalMargins: ConstraintAttributes = [.leadingMargin, .topMargin, .trailingMargin, .bottomMargin]

    @available(iOS 8.0, *)
    internal static let centerWithinMargins: ConstraintAttributes = [.centerXWithinMargins, .centerYWithinMargins]
    
    internal var layoutAttributes:[LayoutAttribute] {
        var attrs = [LayoutAttribute]()
        if (self.contains(ConstraintAttributes.left)) {
            attrs.append(.left)
        }
        if (self.contains(ConstraintAttributes.top)) {
            attrs.append(.top)
        }
        if (self.contains(ConstraintAttributes.right)) {
            attrs.append(.right)
        }
        if (self.contains(ConstraintAttributes.bottom)) {
            attrs.append(.bottom)
        }
        if (self.contains(ConstraintAttributes.leading)) {
            attrs.append(.leading)
        }
        if (self.contains(ConstraintAttributes.trailing)) {
            attrs.append(.trailing)
        }
        if (self.contains(ConstraintAttributes.width)) {
            attrs.append(.width)
        }
        if (self.contains(ConstraintAttributes.height)) {
            attrs.append(.height)
        }
        if (self.contains(ConstraintAttributes.centerX)) {
            attrs.append(.centerX)
        }
        if (self.contains(ConstraintAttributes.centerY)) {
            attrs.append(.centerY)
        }
        if (self.contains(ConstraintAttributes.lastBaseline)) {
            attrs.append(.lastBaseline)
        }
        
        #if os(iOS) || os(tvOS)
            if (self.contains(ConstraintAttributes.firstBaseline)) {
                attrs.append(.firstBaseline)
            }
            if (self.contains(ConstraintAttributes.leftMargin)) {
                attrs.append(.leftMargin)
            }
            if (self.contains(ConstraintAttributes.rightMargin)) {
                attrs.append(.rightMargin)
            }
            if (self.contains(ConstraintAttributes.topMargin)) {
                attrs.append(.topMargin)
            }
            if (self.contains(ConstraintAttributes.bottomMargin)) {
                attrs.append(.bottomMargin)
            }
            if (self.contains(ConstraintAttributes.leadingMargin)) {
                attrs.append(.leadingMargin)
            }
            if (self.contains(ConstraintAttributes.trailingMargin)) {
                attrs.append(.trailingMargin)
            }
            if (self.contains(ConstraintAttributes.centerXWithinMargins)) {
                attrs.append(.centerXWithinMargins)
            }
            if (self.contains(ConstraintAttributes.centerYWithinMargins)) {
                attrs.append(.centerYWithinMargins)
            }
        #endif
        
        return attrs
    }
}

internal func + (left: ConstraintAttributes, right: ConstraintAttributes) -> ConstraintAttributes {
    return left.union(right)
}

internal func +=(left: inout ConstraintAttributes, right: ConstraintAttributes) {
    left.formUnion(right)
}

internal func -=(left: inout ConstraintAttributes, right: ConstraintAttributes) {
    left.subtract(right)
}

internal func ==(left: ConstraintAttributes, right: ConstraintAttributes) -> Bool {
    return left.rawValue == right.rawValue
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public struct ConstraintViewDSL: ConstraintAttributesDSL {
    
    @discardableResult
    public func prepareConstraints(_ closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        return ConstraintMaker.prepareConstraints(item: self.view, closure: closure)
    }
    
    public func makeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.makeConstraints(item: self.view, closure: closure)
    }
    
    public func remakeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.remakeConstraints(item: self.view, closure: closure)
    }
    
    public func updateConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.updateConstraints(item: self.view, closure: closure)
    }
    
    public func removeConstraints() {
        ConstraintMaker.removeConstraints(item: self.view)
    }
    
    public var contentHuggingHorizontalPriority: Float {
        get {
            return self.view.contentHuggingPriority(for: .horizontal).rawValue
        }
        nonmutating set {
            self.view.setContentHuggingPriority(LayoutPriority(rawValue: newValue), for: .horizontal)
        }
    }
    
    public var contentHuggingVerticalPriority: Float {
        get {
            return self.view.contentHuggingPriority(for: .vertical).rawValue
        }
        nonmutating set {
            self.view.setContentHuggingPriority(LayoutPriority(rawValue: newValue), for: .vertical)
        }
    }
    
    public var contentCompressionResistanceHorizontalPriority: Float {
        get {
            return self.view.contentCompressionResistancePriority(for: .horizontal).rawValue
        }
        nonmutating set {
            self.view.setContentCompressionResistancePriority(LayoutPriority(rawValue: newValue), for: .horizontal)
        }
    }
    
    public var contentCompressionResistanceVerticalPriority: Float {
        get {
            return self.view.contentCompressionResistancePriority(for: .vertical).rawValue
        }
        nonmutating set {
            self.view.setContentCompressionResistancePriority(LayoutPriority(rawValue: newValue), for: .vertical)
        }
    }
    
    public var target: AnyObject? {
        return self.view
    }
    
    internal let view: ConstraintView
    
    internal init(view: ConstraintView) {
        self.view = view
        
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintPriorityTarget {
    
    var constraintPriorityTargetValue: Float { get }
    
}

extension Int: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}

extension UInt: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}

extension Float: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return self
    }
    
}

extension Double: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}

extension CGFloat: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}

#if os(iOS) || os(tvOS)
extension UILayoutPriority: ConstraintPriorityTarget {

    public var constraintPriorityTargetValue: Float {
        return self.rawValue
    }

}
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    public typealias ConstraintInsets = UIEdgeInsets
#else
    public typealias ConstraintInsets = NSEdgeInsets
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintMakerFinalizable {
    
    internal let description: ConstraintDescription
    
    internal init(_ description: ConstraintDescription) {
        self.description = description
    }
    
    @discardableResult
    public func labeled(_ label: String) -> ConstraintMakerFinalizable {
        self.description.label = label
        return self
    }
    
    public var constraint: Constraint {
        return self.description.constraint!
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintDSL {
    
    var target: AnyObject? { get }
    
    func setLabel(_ value: String?)
    func label() -> String?
    
}
extension ConstraintDSL {
    
    public func setLabel(_ value: String?) {
        objc_setAssociatedObject(self.target as Any, &labelKey, value, .OBJC_ASSOCIATION_COPY_NONATOMIC)
    }
    public func label() -> String? {
        return objc_getAssociatedObject(self.target as Any, &labelKey) as? String
    }
    
}
private var labelKey: UInt8 = 0


public protocol ConstraintBasicAttributesDSL : ConstraintDSL {
}
extension ConstraintBasicAttributesDSL {
    
    // MARK: Basics
    
    public var left: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.left)
    }
    
    public var top: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.top)
    }
    
    public var right: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.right)
    }
    
    public var bottom: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.bottom)
    }
    
    public var leading: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.leading)
    }
    
    public var trailing: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.trailing)
    }
    
    public var width: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.width)
    }
    
    public var height: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.height)
    }
    
    public var centerX: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerX)
    }
    
    public var centerY: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerY)
    }
    
    public var edges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.edges)
    }
    
    public var directionalEdges: ConstraintItem {
      return ConstraintItem(target: self.target, attributes: ConstraintAttributes.directionalEdges)
    }

    public var horizontalEdges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.horizontalEdges)
    }

    public var verticalEdges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.verticalEdges)
    }

    public var directionalHorizontalEdges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.directionalHorizontalEdges)
    }

    public var directionalVerticalEdges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.directionalVerticalEdges)
    }

    public var size: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.size)
    }
    
    public var center: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.center)
    }
    
}

public protocol ConstraintAttributesDSL : ConstraintBasicAttributesDSL {
}
extension ConstraintAttributesDSL {
    
    // MARK: Baselines
    @available(*, deprecated, renamed:"lastBaseline")
    public var baseline: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.lastBaseline)
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var lastBaseline: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.lastBaseline)
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var firstBaseline: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.firstBaseline)
    }
    
    // MARK: Margins
    
    @available(iOS 8.0, *)
    public var leftMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.leftMargin)
    }
    
    @available(iOS 8.0, *)
    public var topMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.topMargin)
    }
    
    @available(iOS 8.0, *)
    public var rightMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.rightMargin)
    }
    
    @available(iOS 8.0, *)
    public var bottomMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.bottomMargin)
    }
    
    @available(iOS 8.0, *)
    public var leadingMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.leadingMargin)
    }
    
    @available(iOS 8.0, *)
    public var trailingMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.trailingMargin)
    }
    
    @available(iOS 8.0, *)
    public var centerXWithinMargins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerXWithinMargins)
    }
    
    @available(iOS 8.0, *)
    public var centerYWithinMargins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerYWithinMargins)
    }
    
    @available(iOS 8.0, *)
    public var margins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.margins)
    }
    
    @available(iOS 8.0, *)
    public var directionalMargins: ConstraintItem {
      return ConstraintItem(target: self.target, attributes: ConstraintAttributes.directionalMargins)
    }

    @available(iOS 8.0, *)
    public var centerWithinMargins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerWithinMargins)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintMakerExtendable: ConstraintMakerRelatable {
    
    public var left: ConstraintMakerExtendable {
        self.description.attributes += .left
        return self
    }
    
    public var top: ConstraintMakerExtendable {
        self.description.attributes += .top
        return self
    }
    
    public var bottom: ConstraintMakerExtendable {
        self.description.attributes += .bottom
        return self
    }
    
    public var right: ConstraintMakerExtendable {
        self.description.attributes += .right
        return self
    }
    
    public var leading: ConstraintMakerExtendable {
        self.description.attributes += .leading
        return self
    }
    
    public var trailing: ConstraintMakerExtendable {
        self.description.attributes += .trailing
        return self
    }
    
    public var width: ConstraintMakerExtendable {
        self.description.attributes += .width
        return self
    }
    
    public var height: ConstraintMakerExtendable {
        self.description.attributes += .height
        return self
    }
    
    public var centerX: ConstraintMakerExtendable {
        self.description.attributes += .centerX
        return self
    }
    
    public var centerY: ConstraintMakerExtendable {
        self.description.attributes += .centerY
        return self
    }
    
    @available(*, deprecated, renamed:"lastBaseline")
    public var baseline: ConstraintMakerExtendable {
        self.description.attributes += .lastBaseline
        return self
    }
    
    public var lastBaseline: ConstraintMakerExtendable {
        self.description.attributes += .lastBaseline
        return self
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var firstBaseline: ConstraintMakerExtendable {
        self.description.attributes += .firstBaseline
        return self
    }
    
    @available(iOS 8.0, *)
    public var leftMargin: ConstraintMakerExtendable {
        self.description.attributes += .leftMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var rightMargin: ConstraintMakerExtendable {
        self.description.attributes += .rightMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var topMargin: ConstraintMakerExtendable {
        self.description.attributes += .topMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var bottomMargin: ConstraintMakerExtendable {
        self.description.attributes += .bottomMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var leadingMargin: ConstraintMakerExtendable {
        self.description.attributes += .leadingMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var trailingMargin: ConstraintMakerExtendable {
        self.description.attributes += .trailingMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var centerXWithinMargins: ConstraintMakerExtendable {
        self.description.attributes += .centerXWithinMargins
        return self
    }
    
    @available(iOS 8.0, *)
    public var centerYWithinMargins: ConstraintMakerExtendable {
        self.description.attributes += .centerYWithinMargins
        return self
    }
    
    public var edges: ConstraintMakerExtendable {
        self.description.attributes += .edges
        return self
    }
    public var horizontalEdges: ConstraintMakerExtendable {
        self.description.attributes += .horizontalEdges
        return self
    }
    public var verticalEdges: ConstraintMakerExtendable {
        self.description.attributes += .verticalEdges
        return self
    }
    public var directionalEdges: ConstraintMakerExtendable {
        self.description.attributes += .directionalEdges
        return self
    }
    public var directionalHorizontalEdges: ConstraintMakerExtendable {
        self.description.attributes += .directionalHorizontalEdges
        return self
    }
    public var directionalVerticalEdges: ConstraintMakerExtendable {
        self.description.attributes += .directionalVerticalEdges
        return self
    }
    public var size: ConstraintMakerExtendable {
        self.description.attributes += .size
        return self
    }
    
    @available(iOS 8.0, *)
    public var margins: ConstraintMakerExtendable {
        self.description.attributes += .margins
        return self
    }
    
    @available(iOS 8.0, *)
    public var directionalMargins: ConstraintMakerExtendable {
      self.description.attributes += .directionalMargins
      return self
    }

    @available(iOS 8.0, *)
    public var centerWithinMargins: ConstraintMakerExtendable {
        self.description.attributes += .centerWithinMargins
        return self
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

public struct ConstraintPriority : ExpressibleByFloatLiteral, Equatable, Strideable {
    public typealias FloatLiteralType = Float
    
    public let value: Float
    
    public init(floatLiteral value: Float) {
        self.value = value
    }
    
    public init(_ value: Float) {
        self.value = value
    }
    
    public static var required: ConstraintPriority {
        return 1000.0
    }
    
    public static var high: ConstraintPriority {
        return 750.0
    }
    
    public static var medium: ConstraintPriority {
        #if os(OSX)
            return 501.0
        #else
            return 500.0
        #endif
        
    }
    
    public static var low: ConstraintPriority {
        return 250.0
    }
    
    public static func ==(lhs: ConstraintPriority, rhs: ConstraintPriority) -> Bool {
        return lhs.value == rhs.value
    }

    // MARK: Strideable

    public func advanced(by n: FloatLiteralType) -> ConstraintPriority {
        return ConstraintPriority(floatLiteral: value + n)
    }

    public func distance(to other: ConstraintPriority) -> FloatLiteralType {
        return other.value - value
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintInsetTarget: ConstraintConstantTarget {
}

extension Int: ConstraintInsetTarget {
}

extension UInt: ConstraintInsetTarget {
}

extension Float: ConstraintInsetTarget {
}

extension Double: ConstraintInsetTarget {
}

extension CGFloat: ConstraintInsetTarget {
}

extension ConstraintInsets: ConstraintInsetTarget {
}

extension ConstraintInsetTarget {

    internal var constraintInsetTargetValue: ConstraintInsets {
        if let amount = self as? ConstraintInsets {
            return amount
        } else if let amount = self as? Float {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else if let amount = self as? Double {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else if let amount = self as? CGFloat {
            return ConstraintInsets(top: amount, left: amount, bottom: amount, right: amount)
        } else if let amount = self as? Int {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else if let amount = self as? UInt {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else {
            return ConstraintInsets(top: 0, left: 0, bottom: 0, right: 0)
        }
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
import UIKit
#else
import AppKit
#endif

#if os(iOS) || os(tvOS)
public protocol ConstraintDirectionalInsetTarget: ConstraintConstantTarget {
}

@available(iOS 11.0, tvOS 11.0, *)
extension ConstraintDirectionalInsets: ConstraintDirectionalInsetTarget {
}

extension ConstraintDirectionalInsetTarget {

  @available(iOS 11.0, tvOS 11.0, *)
  internal var constraintDirectionalInsetTargetValue: ConstraintDirectionalInsets {
    if let amount = self as? ConstraintDirectionalInsets {
      return amount
    } else {
      return ConstraintDirectionalInsets(top: 0, leading: 0, bottom: 0, trailing: 0)
    }
  }
}
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


extension ConstraintMakerRelatable {
  
    @discardableResult
    public func equalToSuperview<T: ConstraintRelatableTarget>(_ closure: (ConstraintView) -> T, _ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `equalToSuperview`.")
        }
        return self.relatedTo(closure(other), relation: .equal, file: file, line: line)
    }
  
    @discardableResult
    public func lessThanOrEqualToSuperview<T: ConstraintRelatableTarget>(_ closure: (ConstraintView) -> T, _ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `lessThanOrEqualToSuperview`.")
        }
        return self.relatedTo(closure(other), relation: .lessThanOrEqual, file: file, line: line)
    }
  
    @discardableResult
    public func greaterThanOrEqualTo<T: ConstraintRelatableTarget>(_ closure: (ConstraintView) -> T, _ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `greaterThanOrEqualToSuperview`.")
        }
        return self.relatedTo(closure(other), relation: .greaterThanOrEqual, file: file, line: line)
    }
  
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
    public typealias ConstraintInterfaceLayoutDirection = UIUserInterfaceLayoutDirection
#else
    import AppKit
    public typealias ConstraintInterfaceLayoutDirection = NSUserInterfaceLayoutDirection
#endif


public struct ConstraintConfig {
    
    public static var interfaceLayoutDirection: ConstraintInterfaceLayoutDirection = .leftToRight
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#endif

    
@available(iOS 8.0, *)
public extension ConstraintLayoutSupport {
    
    var snp: ConstraintLayoutSupportDSL {
        return ConstraintLayoutSupportDSL(support: self)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    public typealias ConstraintView = UIView
#else
    public typealias ConstraintView = NSView
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    @available(iOS 9.0, *)
    public typealias ConstraintLayoutGuide = UILayoutGuide
#else
    @available(OSX 10.11, *)
    public typealias ConstraintLayoutGuide = NSLayoutGuide
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    @available(iOS 8.0, *)
    public typealias ConstraintLayoutSupport = UILayoutSupport
#else
    public class ConstraintLayoutSupport {}
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

import Foundation

#if os(iOS) || os(tvOS)
    import UIKit
#if swift(>=4.2)
    typealias LayoutRelation = NSLayoutConstraint.Relation
    typealias LayoutAttribute = NSLayoutConstraint.Attribute
#else
    typealias LayoutRelation = NSLayoutRelation
    typealias LayoutAttribute = NSLayoutAttribute
#endif
    typealias LayoutPriority = UILayoutPriority
#else
    import AppKit
    typealias LayoutRelation = NSLayoutConstraint.Relation
    typealias LayoutAttribute = NSLayoutConstraint.Attribute
    typealias LayoutPriority = NSLayoutConstraint.Priority
#endif

//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintConstantTarget {
}

extension CGPoint: ConstraintConstantTarget {
}

extension CGSize: ConstraintConstantTarget {    
}

extension ConstraintInsets: ConstraintConstantTarget {
}

#if os(iOS) || os(tvOS)
@available(iOS 11.0, tvOS 11.0, *)
extension ConstraintDirectionalInsets: ConstraintConstantTarget {
}
#endif

extension ConstraintConstantTarget {
    
    internal func constraintConstantTargetValueFor(layoutAttribute: LayoutAttribute) -> CGFloat {
        if let value = self as? CGFloat {
            return value
        }
        
        if let value = self as? Float {
            return CGFloat(value)
        }
        
        if let value = self as? Double {
            return CGFloat(value)
        }
        
        if let value = self as? Int {
            return CGFloat(value)
        }
        
        if let value = self as? UInt {
            return CGFloat(value)
        }
        
        if let value = self as? CGSize {
            if layoutAttribute == .width {
                return value.width
            } else if layoutAttribute == .height {
                return value.height
            } else {
                return 0.0
            }
        }
        
        if let value = self as? CGPoint {
            #if os(iOS) || os(tvOS)
                switch layoutAttribute {
                case .left, .right, .leading, .trailing, .centerX, .leftMargin, .rightMargin, .leadingMargin, .trailingMargin, .centerXWithinMargins:
                    return value.x
                case .top, .bottom, .centerY, .topMargin, .bottomMargin, .centerYWithinMargins, .lastBaseline, .firstBaseline:
                    return value.y
                case .width, .height, .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #endif
            }
            #else
                switch layoutAttribute {
                case .left, .right, .leading, .trailing, .centerX:
                    return value.x
                case .top, .bottom, .centerY, .lastBaseline, .firstBaseline:
                    return value.y
                case .width, .height, .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #endif
            }
            #endif
        }
        
        if let value = self as? ConstraintInsets {
            #if os(iOS) || os(tvOS)
                switch layoutAttribute {
                case .left, .leftMargin:
                    return value.left
                case .top, .topMargin, .firstBaseline:
                    return value.top
                case .right, .rightMargin:
                    return -value.right
                case .bottom, .bottomMargin, .lastBaseline:
                    return -value.bottom
                case .leading, .leadingMargin:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? value.left : value.right
                case .trailing, .trailingMargin:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? -value.right : -value.left
                case .centerX, .centerXWithinMargins:
                    return (value.left - value.right) / 2
                case .centerY, .centerYWithinMargins:
                    return (value.top - value.bottom) / 2
                case .width:
                    return -(value.left + value.right)
                case .height:
                    return -(value.top + value.bottom)
                case .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #endif
            }
            #else
                switch layoutAttribute {
                case .left:
                    return value.left
                case .top, .firstBaseline:
                    return value.top
                case .right:
                    return -value.right
                case .bottom, .lastBaseline:
                    return -value.bottom
                case .leading:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? value.left : value.right
                case .trailing:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? -value.right : -value.left
                case .centerX:
                    return (value.left - value.right) / 2
                case .centerY:
                    return (value.top - value.bottom) / 2
                case .width:
                    return -(value.left + value.right)
                case .height:
                    return -(value.top + value.bottom)
                case .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #endif
            }
            #endif
        }
        
        #if os(iOS) || os(tvOS)
            if #available(iOS 11.0, tvOS 11.0, *), let value = self as? ConstraintDirectionalInsets {
                switch layoutAttribute {
                case .left, .leftMargin:
                  return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? value.leading : value.trailing
                case .top, .topMargin, .firstBaseline:
                    return value.top
                case .right, .rightMargin:
                  return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? -value.trailing : -value.leading
                case .bottom, .bottomMargin, .lastBaseline:
                    return -value.bottom
                case .leading, .leadingMargin:
                    return value.leading
                case .trailing, .trailingMargin:
                    return -value.trailing
                case .centerX, .centerXWithinMargins:
                    return (value.leading - value.trailing) / 2
                case .centerY, .centerYWithinMargins:
                    return (value.top - value.bottom) / 2
                case .width:
                    return -(value.leading + value.trailing)
                case .height:
                    return -(value.top + value.bottom)
                case .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #else
                default:
                    return 0.0
                #endif
                }
            }
        #endif

        return 0.0
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintOffsetTarget: ConstraintConstantTarget {
}

extension Int: ConstraintOffsetTarget {
}

extension UInt: ConstraintOffsetTarget {
}

extension Float: ConstraintOffsetTarget {
}

extension Double: ConstraintOffsetTarget {
}

extension CGFloat: ConstraintOffsetTarget {
}

extension ConstraintOffsetTarget {
    
    internal var constraintOffsetTargetValue: CGFloat {
        let offset: CGFloat
        if let amount = self as? Float {
            offset = CGFloat(amount)
        } else if let amount = self as? Double {
            offset = CGFloat(amount)
        } else if let amount = self as? CGFloat {
            offset = CGFloat(amount)
        } else if let amount = self as? Int {
            offset = CGFloat(amount)
        } else if let amount = self as? UInt {
            offset = CGFloat(amount)
        } else {
            offset = 0.0
        }
        return offset
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintMakerEditable: ConstraintMakerPrioritizable {

    @discardableResult
    public func multipliedBy(_ amount: ConstraintMultiplierTarget) -> ConstraintMakerEditable {
        self.description.multiplier = amount
        return self
    }
    
    @discardableResult
    public func dividedBy(_ amount: ConstraintMultiplierTarget) -> ConstraintMakerEditable {
        return self.multipliedBy(1.0 / amount.constraintMultiplierTargetValue)
    }
    
    @discardableResult
    public func offset(_ amount: ConstraintOffsetTarget) -> ConstraintMakerEditable {
        self.description.constant = amount.constraintOffsetTargetValue
        return self
    }
    
    @discardableResult
    public func inset(_ amount: ConstraintInsetTarget) -> ConstraintMakerEditable {
        self.description.constant = amount.constraintInsetTargetValue
        return self
    }
    
    #if os(iOS) || os(tvOS)
    @discardableResult
    @available(iOS 11.0, tvOS 11.0, *)
    public func inset(_ amount: ConstraintDirectionalInsetTarget) -> ConstraintMakerEditable {
        self.description.constant = amount.constraintDirectionalInsetTargetValue
        return self
    }
    #endif
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

public class ConstraintMaker {
    
    public var left: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.left)
    }
    
    public var top: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.top)
    }
    
    public var bottom: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.bottom)
    }
    
    public var right: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.right)
    }
    
    public var leading: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.leading)
    }
    
    public var trailing: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.trailing)
    }
    
    public var width: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.width)
    }
    
    public var height: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.height)
    }
    
    public var centerX: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerX)
    }
    
    public var centerY: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerY)
    }
    
    @available(*, deprecated, renamed:"lastBaseline")
    public var baseline: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.lastBaseline)
    }
    
    public var lastBaseline: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.lastBaseline)
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var firstBaseline: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.firstBaseline)
    }
    
    @available(iOS 8.0, *)
    public var leftMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.leftMargin)
    }
    
    @available(iOS 8.0, *)
    public var rightMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.rightMargin)
    }
    
    @available(iOS 8.0, *)
    public var topMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.topMargin)
    }
    
    @available(iOS 8.0, *)
    public var bottomMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.bottomMargin)
    }
    
    @available(iOS 8.0, *)
    public var leadingMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.leadingMargin)
    }
    
    @available(iOS 8.0, *)
    public var trailingMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.trailingMargin)
    }
    
    @available(iOS 8.0, *)
    public var centerXWithinMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerXWithinMargins)
    }
    
    @available(iOS 8.0, *)
    public var centerYWithinMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerYWithinMargins)
    }
    
    public var edges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.edges)
    }
    public var horizontalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.horizontalEdges)
    }
    public var verticalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.verticalEdges)
    }
    public var directionalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.directionalEdges)
    }
    public var directionalHorizontalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.directionalHorizontalEdges)
    }
    public var directionalVerticalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.directionalVerticalEdges)
    }
    public var size: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.size)
    }
    public var center: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.center)
    }
    
    @available(iOS 8.0, *)
    public var margins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.margins)
    }
    
    @available(iOS 8.0, *)
    public var directionalMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.directionalMargins)
    }

    @available(iOS 8.0, *)
    public var centerWithinMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerWithinMargins)
    }
    
    public let item: LayoutConstraintItem
    private var descriptions = [ConstraintDescription]()
    
    internal init(item: LayoutConstraintItem) {
        self.item = item
        self.item.prepare()
    }
    
    internal func makeExtendableWithAttributes(_ attributes: ConstraintAttributes) -> ConstraintMakerExtendable {
        let description = ConstraintDescription(item: self.item, attributes: attributes)
        self.descriptions.append(description)
        return ConstraintMakerExtendable(description)
    }
    
    internal static func prepareConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        let maker = ConstraintMaker(item: item)
        closure(maker)
        var constraints: [Constraint] = []
        for description in maker.descriptions {
            guard let constraint = description.constraint else {
                continue
            }
            constraints.append(constraint)
        }
        return constraints
    }
    
    internal static func makeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) {
        let constraints = prepareConstraints(item: item, closure: closure)
        for constraint in constraints {
            constraint.activateIfNeeded(updatingExisting: false)
        }
    }
    
    internal static func remakeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) {
        self.removeConstraints(item: item)
        self.makeConstraints(item: item, closure: closure)
    }
    
    internal static func updateConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) {
        guard item.constraints.count > 0 else {
            self.makeConstraints(item: item, closure: closure)
            return
        }
        
        let constraints = prepareConstraints(item: item, closure: closure)
        for constraint in constraints {
            constraint.activateIfNeeded(updatingExisting: true)
        }
    }
    
    internal static func removeConstraints(item: LayoutConstraintItem) {
        let constraints = item.constraints
        for constraint in constraints {
            constraint.deactivateIfNeeded()
        }
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


internal enum ConstraintRelation : Int {
    case equal = 1
    case lessThanOrEqual
    case greaterThanOrEqual
    
    internal var layoutRelation: LayoutRelation {
        get {
            switch(self) {
            case .equal:
                return .equal
            case .lessThanOrEqual:
                return .lessThanOrEqual
            case .greaterThanOrEqual:
                return .greaterThanOrEqual
            }
        }
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


@available(iOS 9.0, OSX 10.11, *)
public struct ConstraintLayoutGuideDSL: ConstraintAttributesDSL {
    
    @discardableResult
    public func prepareConstraints(_ closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        return ConstraintMaker.prepareConstraints(item: self.guide, closure: closure)
    }
    
    public func makeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.makeConstraints(item: self.guide, closure: closure)
    }
    
    public func remakeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.remakeConstraints(item: self.guide, closure: closure)
    }
    
    public func updateConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.updateConstraints(item: self.guide, closure: closure)
    }
    
    public func removeConstraints() {
        ConstraintMaker.removeConstraints(item: self.guide)
    }
    
    public var target: AnyObject? {
        return self.guide
    }
    
    internal let guide: ConstraintLayoutGuide
    
    internal init(guide: ConstraintLayoutGuide) {
        self.guide = guide
        
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public extension ConstraintView {
    
    @available(*, deprecated, renamed:"snp.left")
    var snp_left: ConstraintItem { return self.snp.left }
    
    @available(*, deprecated, renamed:"snp.top")
    var snp_top: ConstraintItem { return self.snp.top }
    
    @available(*, deprecated, renamed:"snp.right")
    var snp_right: ConstraintItem { return self.snp.right }
    
    @available(*, deprecated, renamed:"snp.bottom")
    var snp_bottom: ConstraintItem { return self.snp.bottom }
    
    @available(*, deprecated, renamed:"snp.leading")
    var snp_leading: ConstraintItem { return self.snp.leading }
    
    @available(*, deprecated, renamed:"snp.trailing")
    var snp_trailing: ConstraintItem { return self.snp.trailing }
    
    @available(*, deprecated, renamed:"snp.width")
    var snp_width: ConstraintItem { return self.snp.width }
    
    @available(*, deprecated, renamed:"snp.height")
    var snp_height: ConstraintItem { return self.snp.height }
    
    @available(*, deprecated, renamed:"snp.centerX")
    var snp_centerX: ConstraintItem { return self.snp.centerX }
    
    @available(*, deprecated, renamed:"snp.centerY")
    var snp_centerY: ConstraintItem { return self.snp.centerY }
    
    @available(*, deprecated, renamed:"snp.baseline")
    var snp_baseline: ConstraintItem { return self.snp.baseline }
    
    @available(*, deprecated, renamed:"snp.lastBaseline")
    @available(iOS 8.0, OSX 10.11, *)
    var snp_lastBaseline: ConstraintItem { return self.snp.lastBaseline }
    
    @available(iOS, deprecated, renamed:"snp.firstBaseline")
    @available(iOS 8.0, OSX 10.11, *)
    var snp_firstBaseline: ConstraintItem { return self.snp.firstBaseline }
    
    @available(iOS, deprecated, renamed:"snp.leftMargin")
    @available(iOS 8.0, *)
    var snp_leftMargin: ConstraintItem { return self.snp.leftMargin }
    
    @available(iOS, deprecated, renamed:"snp.topMargin")
    @available(iOS 8.0, *)
    var snp_topMargin: ConstraintItem { return self.snp.topMargin }
    
    @available(iOS, deprecated, renamed:"snp.rightMargin")
    @available(iOS 8.0, *)
    var snp_rightMargin: ConstraintItem { return self.snp.rightMargin }
    
    @available(iOS, deprecated, renamed:"snp.bottomMargin")
    @available(iOS 8.0, *)
    var snp_bottomMargin: ConstraintItem { return self.snp.bottomMargin }
    
    @available(iOS, deprecated, renamed:"snp.leadingMargin")
    @available(iOS 8.0, *)
    var snp_leadingMargin: ConstraintItem { return self.snp.leadingMargin }
    
    @available(iOS, deprecated, renamed:"snp.trailingMargin")
    @available(iOS 8.0, *)
    var snp_trailingMargin: ConstraintItem { return self.snp.trailingMargin }
    
    @available(iOS, deprecated, renamed:"snp.centerXWithinMargins")
    @available(iOS 8.0, *)
    var snp_centerXWithinMargins: ConstraintItem { return self.snp.centerXWithinMargins }
    
    @available(iOS, deprecated, renamed:"snp.centerYWithinMargins")
    @available(iOS 8.0, *)
    var snp_centerYWithinMargins: ConstraintItem { return self.snp.centerYWithinMargins }
    
    @available(*, deprecated, renamed:"snp.edges")
    var snp_edges: ConstraintItem { return self.snp.edges }
    
    @available(*, deprecated, renamed:"snp.size")
    var snp_size: ConstraintItem { return self.snp.size }
    
    @available(*, deprecated, renamed:"snp.center")
    var snp_center: ConstraintItem { return self.snp.center }
    
    @available(iOS, deprecated, renamed:"snp.margins")
    @available(iOS 8.0, *)
    var snp_margins: ConstraintItem { return self.snp.margins }
    
    @available(iOS, deprecated, renamed:"snp.centerWithinMargins")
    @available(iOS 8.0, *)
    var snp_centerWithinMargins: ConstraintItem { return self.snp.centerWithinMargins }
    
    @available(*, deprecated, renamed:"snp.prepareConstraints(_:)")
    func snp_prepareConstraints(_ closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        return self.snp.prepareConstraints(closure)
    }
    
    @available(*, deprecated, renamed:"snp.makeConstraints(_:)")
    func snp_makeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        self.snp.makeConstraints(closure)
    }
    
    @available(*, deprecated, renamed:"snp.remakeConstraints(_:)")
    func snp_remakeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        self.snp.remakeConstraints(closure)
    }
    
    @available(*, deprecated, renamed:"snp.updateConstraints(_:)")
    func snp_updateConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        self.snp.updateConstraints(closure)
    }
    
    @available(*, deprecated, renamed:"snp.removeConstraints()")
    func snp_removeConstraints() {
        self.snp.removeConstraints()
    }
    
    var snp: ConstraintViewDSL {
        return ConstraintViewDSL(view: self)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public final class ConstraintItem {
    
    internal weak var target: AnyObject?
    internal let attributes: ConstraintAttributes
    
    internal init(target: AnyObject?, attributes: ConstraintAttributes) {
        self.target = target
        self.attributes = attributes
    }
    
    internal var layoutConstraintItem: LayoutConstraintItem? {
        return self.target as? LayoutConstraintItem
    }
    
}

public func ==(lhs: ConstraintItem, rhs: ConstraintItem) -> Bool {
    // pointer equality
    guard lhs !== rhs else {
        return true
    }
    
    // must both have valid targets and identical attributes
    guard let target1 = lhs.target,
          let target2 = rhs.target,
          target1 === target2 && lhs.attributes == rhs.attributes else {
            return false
    }
    
    return true
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

public final class Constraint {

    internal let sourceLocation: (String, UInt)
    internal let label: String?

    private let from: ConstraintItem
    private let to: ConstraintItem
    private let relation: ConstraintRelation
    private let multiplier: ConstraintMultiplierTarget
    private var constant: ConstraintConstantTarget {
        didSet {
            self.updateConstantAndPriorityIfNeeded()
        }
    }
    private var priority: ConstraintPriorityTarget {
        didSet {
          self.updateConstantAndPriorityIfNeeded()
        }
    }
    public var layoutConstraints: [LayoutConstraint]
    
    public var isActive: Bool {
        set {
            if newValue {
                activate()
            }
            else {
                deactivate()
            }
        }
        
        get {
            for layoutConstraint in self.layoutConstraints {
                if layoutConstraint.isActive {
                    return true
                }
            }
            return false
        }
    }
    
    // MARK: Initialization

    internal init(from: ConstraintItem,
                  to: ConstraintItem,
                  relation: ConstraintRelation,
                  sourceLocation: (String, UInt),
                  label: String?,
                  multiplier: ConstraintMultiplierTarget,
                  constant: ConstraintConstantTarget,
                  priority: ConstraintPriorityTarget) {
        self.from = from
        self.to = to
        self.relation = relation
        self.sourceLocation = sourceLocation
        self.label = label
        self.multiplier = multiplier
        self.constant = constant
        self.priority = priority
        self.layoutConstraints = []

        // get attributes
        let layoutFromAttributes = self.from.attributes.layoutAttributes
        let layoutToAttributes = self.to.attributes.layoutAttributes

        // get layout from
        let layoutFrom = self.from.layoutConstraintItem!

        // get relation
        let layoutRelation = self.relation.layoutRelation

        for layoutFromAttribute in layoutFromAttributes {
            // get layout to attribute
            let layoutToAttribute: LayoutAttribute
            #if os(iOS) || os(tvOS)
                if layoutToAttributes.count > 0 {
                    if self.from.attributes == .edges && self.to.attributes == .margins {
                        switch layoutFromAttribute {
                        case .left:
                            layoutToAttribute = .leftMargin
                        case .right:
                            layoutToAttribute = .rightMargin
                        case .top:
                            layoutToAttribute = .topMargin
                        case .bottom:
                            layoutToAttribute = .bottomMargin
                        default:
                            fatalError()
                        }
                    } else if self.from.attributes == .margins && self.to.attributes == .edges {
                        switch layoutFromAttribute {
                        case .leftMargin:
                            layoutToAttribute = .left
                        case .rightMargin:
                            layoutToAttribute = .right
                        case .topMargin:
                            layoutToAttribute = .top
                        case .bottomMargin:
                            layoutToAttribute = .bottom
                        default:
                            fatalError()
                        }
                    } else if self.from.attributes == .directionalEdges && self.to.attributes == .directionalMargins {
                      switch layoutFromAttribute {
                      case .leading:
                        layoutToAttribute = .leadingMargin
                      case .trailing:
                        layoutToAttribute = .trailingMargin
                      case .top:
                        layoutToAttribute = .topMargin
                      case .bottom:
                        layoutToAttribute = .bottomMargin
                      default:
                        fatalError()
                      }
                    } else if self.from.attributes == .directionalMargins && self.to.attributes == .directionalEdges {
                      switch layoutFromAttribute {
                      case .leadingMargin:
                        layoutToAttribute = .leading
                      case .trailingMargin:
                        layoutToAttribute = .trailing
                      case .topMargin:
                        layoutToAttribute = .top
                      case .bottomMargin:
                        layoutToAttribute = .bottom
                      default:
                        fatalError()
                      }
                    } else if self.from.attributes == self.to.attributes {
                        layoutToAttribute = layoutFromAttribute
                    } else {
                        layoutToAttribute = layoutToAttributes[0]
                    }
                } else {
                    if self.to.target == nil && (layoutFromAttribute == .centerX || layoutFromAttribute == .centerY) {
                        layoutToAttribute = layoutFromAttribute == .centerX ? .left : .top
                    } else {
                        layoutToAttribute = layoutFromAttribute
                    }
                }
            #else
                if self.from.attributes == self.to.attributes {
                    layoutToAttribute = layoutFromAttribute
                } else if layoutToAttributes.count > 0 {
                    layoutToAttribute = layoutToAttributes[0]
                } else {
                    layoutToAttribute = layoutFromAttribute
                }
            #endif

            // get layout constant
            let layoutConstant: CGFloat = self.constant.constraintConstantTargetValueFor(layoutAttribute: layoutToAttribute)

            // get layout to
            var layoutTo: AnyObject? = self.to.target

            // use superview if possible
            if layoutTo == nil && layoutToAttribute != .width && layoutToAttribute != .height {
                layoutTo = layoutFrom.superview
            }

            // create layout constraint
            let layoutConstraint = LayoutConstraint(
                item: layoutFrom,
                attribute: layoutFromAttribute,
                relatedBy: layoutRelation,
                toItem: layoutTo,
                attribute: layoutToAttribute,
                multiplier: self.multiplier.constraintMultiplierTargetValue,
                constant: layoutConstant
            )

            // set label
            layoutConstraint.label = self.label

            // set priority
            layoutConstraint.priority = LayoutPriority(rawValue: self.priority.constraintPriorityTargetValue)

            // set constraint
            layoutConstraint.constraint = self

            // append
            self.layoutConstraints.append(layoutConstraint)
        }
    }

    // MARK: Public

    @available(*, deprecated, renamed:"activate()")
    public func install() {
        self.activate()
    }

    @available(*, deprecated, renamed:"deactivate()")
    public func uninstall() {
        self.deactivate()
    }

    public func activate() {
        self.activateIfNeeded()
    }

    public func deactivate() {
        self.deactivateIfNeeded()
    }

    @discardableResult
    public func update(offset: ConstraintOffsetTarget) -> Constraint {
        self.constant = offset.constraintOffsetTargetValue
        return self
    }

    @discardableResult
    public func update(inset: ConstraintInsetTarget) -> Constraint {
        self.constant = inset.constraintInsetTargetValue
        return self
    }

    #if os(iOS) || os(tvOS)
    @discardableResult
    @available(iOS 11.0, tvOS 11.0, *)
    public func update(inset: ConstraintDirectionalInsetTarget) -> Constraint {
      self.constant = inset.constraintDirectionalInsetTargetValue
      return self
    }
    #endif

    @discardableResult
    public func update(priority: ConstraintPriorityTarget) -> Constraint {
        self.priority = priority.constraintPriorityTargetValue
        return self
    }

    @discardableResult
    public func update(priority: ConstraintPriority) -> Constraint {
        self.priority = priority.value
        return self
    }

    @available(*, deprecated, renamed:"update(offset:)")
    public func updateOffset(amount: ConstraintOffsetTarget) -> Void { self.update(offset: amount) }

    @available(*, deprecated, renamed:"update(inset:)")
    public func updateInsets(amount: ConstraintInsetTarget) -> Void { self.update(inset: amount) }

    @available(*, deprecated, renamed:"update(priority:)")
    public func updatePriority(amount: ConstraintPriorityTarget) -> Void { self.update(priority: amount) }

    @available(*, deprecated, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityRequired() -> Void {}

    @available(*, deprecated, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityHigh() -> Void { fatalError("Must be implemented by Concrete subclass.") }

    @available(*, deprecated, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityMedium() -> Void { fatalError("Must be implemented by Concrete subclass.") }

    @available(*, deprecated, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityLow() -> Void { fatalError("Must be implemented by Concrete subclass.") }

    // MARK: Internal

    internal func updateConstantAndPriorityIfNeeded() {
        for layoutConstraint in self.layoutConstraints {
            let attribute = (layoutConstraint.secondAttribute == .notAnAttribute) ? layoutConstraint.firstAttribute : layoutConstraint.secondAttribute
            layoutConstraint.constant = self.constant.constraintConstantTargetValueFor(layoutAttribute: attribute)

            let requiredPriority = ConstraintPriority.required.value
            if (layoutConstraint.priority.rawValue < requiredPriority), (self.priority.constraintPriorityTargetValue != requiredPriority) {
                layoutConstraint.priority = LayoutPriority(rawValue: self.priority.constraintPriorityTargetValue)
            }
        }
    }

    internal func activateIfNeeded(updatingExisting: Bool = false) {
        guard let item = self.from.layoutConstraintItem else {
            print("WARNING: SnapKit failed to get from item from constraint. Activate will be a no-op.")
            return
        }
        let layoutConstraints = self.layoutConstraints

        if updatingExisting {
            var existingLayoutConstraints: [LayoutConstraint] = []
            for constraint in item.constraints {
                existingLayoutConstraints += constraint.layoutConstraints
            }

            for layoutConstraint in layoutConstraints {
                let existingLayoutConstraint = existingLayoutConstraints.first { $0 == layoutConstraint }
                guard let updateLayoutConstraint = existingLayoutConstraint else {
                    fatalError("Updated constraint could not find existing matching constraint to update: \(layoutConstraint)")
                }

                let updateLayoutAttribute = (updateLayoutConstraint.secondAttribute == .notAnAttribute) ? updateLayoutConstraint.firstAttribute : updateLayoutConstraint.secondAttribute
                updateLayoutConstraint.constant = self.constant.constraintConstantTargetValueFor(layoutAttribute: updateLayoutAttribute)
            }
        } else {
            NSLayoutConstraint.activate(layoutConstraints)
            item.add(constraints: [self])
        }
    }

    internal func deactivateIfNeeded() {
        guard let item = self.from.layoutConstraintItem else {
            print("WARNING: SnapKit failed to get from item from constraint. Deactivate will be a no-op.")
            return
        }
        let layoutConstraints = self.layoutConstraints
        NSLayoutConstraint.deactivate(layoutConstraints)
        item.remove(constraints: [self])
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

public extension LayoutConstraint {
    
    override var description: String {
        var description = "<"
        
        description += descriptionForObject(self)
        
        if let firstItem = conditionalOptional(from: self.firstItem) {
            description += " \(descriptionForObject(firstItem))"
        }
        
        if self.firstAttribute != .notAnAttribute {
            description += ".\(descriptionForAttribute(self.firstAttribute))"
        }
        
        description += " \(descriptionForRelation(self.relation))"
        
        if let secondItem = self.secondItem {
            description += " \(descriptionForObject(secondItem))"
        }
        
        if self.secondAttribute != .notAnAttribute {
            description += ".\(descriptionForAttribute(self.secondAttribute))"
        }
        
        if self.multiplier != 1.0 {
            description += " * \(self.multiplier)"
        }
        
        if self.secondAttribute == .notAnAttribute {
            description += " \(self.constant)"
        } else {
            if self.constant > 0.0 {
                description += " + \(self.constant)"
            } else if self.constant < 0.0 {
                description += " - \(abs(self.constant))"
            }
        }
        
        if self.priority.rawValue != 1000.0 {
            description += " ^\(self.priority)"
        }
        
        description += ">"
        
        return description
    }
    
}

private func descriptionForRelation(_ relation: LayoutRelation) -> String {
    switch relation {
    case .equal:                return "=="
    case .greaterThanOrEqual:   return ">="
    case .lessThanOrEqual:      return "<="
    #if swift(>=5.0)
    @unknown default:           return "unknown"
    #endif
    }
}

private func descriptionForAttribute(_ attribute: LayoutAttribute) -> String {
    #if os(iOS) || os(tvOS)
        switch attribute {
        case .notAnAttribute:       return "notAnAttribute"
        case .top:                  return "top"
        case .left:                 return "left"
        case .bottom:               return "bottom"
        case .right:                return "right"
        case .leading:              return "leading"
        case .trailing:             return "trailing"
        case .width:                return "width"
        case .height:               return "height"
        case .centerX:              return "centerX"
        case .centerY:              return "centerY"
        case .lastBaseline:         return "lastBaseline"
        case .firstBaseline:        return "firstBaseline"
        case .topMargin:            return "topMargin"
        case .leftMargin:           return "leftMargin"
        case .bottomMargin:         return "bottomMargin"
        case .rightMargin:          return "rightMargin"
        case .leadingMargin:        return "leadingMargin"
        case .trailingMargin:       return "trailingMargin"
        case .centerXWithinMargins: return "centerXWithinMargins"
        case .centerYWithinMargins: return "centerYWithinMargins"
        #if swift(>=5.0)
        @unknown default:           return "unknown"
        #endif
    }
    #else
        switch attribute {
        case .notAnAttribute:       return "notAnAttribute"
        case .top:                  return "top"
        case .left:                 return "left"
        case .bottom:               return "bottom"
        case .right:                return "right"
        case .leading:              return "leading"
        case .trailing:             return "trailing"
        case .width:                return "width"
        case .height:               return "height"
        case .centerX:              return "centerX"
        case .centerY:              return "centerY"
        case .lastBaseline:         return "lastBaseline"
        case .firstBaseline:        return "firstBaseline"
        #if swift(>=5.0)
        @unknown default:           return "unknown"
        #endif
    }
    #endif
}

private func conditionalOptional<T>(from object: Optional<T>) -> Optional<T> {
    return object
}

private func conditionalOptional<T>(from object: T) -> Optional<T> {
    return Optional.some(object)
}

private func descriptionForObject(_ object: AnyObject) -> String {
    let pointerDescription = String(format: "%p", UInt(bitPattern: ObjectIdentifier(object)))
    var desc = ""
    
    desc += type(of: object).description()
    
    if let object = object as? ConstraintView {
        desc += ":\(object.snp.label() ?? pointerDescription)"
    } else if let object = object as? LayoutConstraint {
        desc += ":\(object.label ?? pointerDescription)"
    } else {
        desc += ":\(pointerDescription)"
    }
    
    if let object = object as? LayoutConstraint, let file = object.constraint?.sourceLocation.0, let line = object.constraint?.sourceLocation.1 {
        desc += "@\((file as NSString).lastPathComponent)#\(line)"
    }
    
    desc += ""
    return desc
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintRelatableTarget {
}

extension Int: ConstraintRelatableTarget {
}

extension UInt: ConstraintRelatableTarget {
}

extension Float: ConstraintRelatableTarget {
}

extension Double: ConstraintRelatableTarget {
}

extension CGFloat: ConstraintRelatableTarget {
}

extension CGSize: ConstraintRelatableTarget {
}

extension CGPoint: ConstraintRelatableTarget {
}

extension ConstraintInsets: ConstraintRelatableTarget {
}

#if os(iOS) || os(tvOS)
@available(iOS 11.0, tvOS 11.0, *)
extension ConstraintDirectionalInsets: ConstraintRelatableTarget {
}
#endif

extension ConstraintItem: ConstraintRelatableTarget {
}

extension ConstraintView: ConstraintRelatableTarget {
}

@available(iOS 9.0, OSX 10.11, *)
extension ConstraintLayoutGuide: ConstraintRelatableTarget {
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class LayoutConstraint : NSLayoutConstraint {
    
    public var label: String? {
        get {
            return self.identifier
        }
        set {
            self.identifier = newValue
        }
    }
    
    internal weak var constraint: Constraint? = nil
    
}

internal func ==(lhs: LayoutConstraint, rhs: LayoutConstraint) -> Bool {
    // If firstItem or secondItem on either constraint has a dangling pointer
    // this comparison can cause a crash. The solution for this is to ensure
    // your layout code hold strong references to things like Views, LayoutGuides
    // and LayoutAnchors as SnapKit will not keep strong references to any of these.
    guard lhs.firstAttribute == rhs.firstAttribute &&
          lhs.secondAttribute == rhs.secondAttribute &&
          lhs.relation == rhs.relation &&
          lhs.priority == rhs.priority &&
          lhs.multiplier == rhs.multiplier &&
          lhs.secondItem === rhs.secondItem &&
          lhs.firstItem === rhs.firstItem else {
        return false
    }
    return true
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#endif
    
    
@available(iOS 9.0, OSX 10.11, *)
public extension ConstraintLayoutGuide {
    
    var snp: ConstraintLayoutGuideDSL {
        return ConstraintLayoutGuideDSL(guide: self)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    @available(iOS 11.0, tvOS 11.0, *)
    public typealias ConstraintDirectionalInsets = NSDirectionalEdgeInsets
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


@available(iOS 8.0, *)
public struct ConstraintLayoutSupportDSL: ConstraintDSL {
    
    public var target: AnyObject? {
        return self.support
    }
    
    internal let support: ConstraintLayoutSupport
    
    internal init(support: ConstraintLayoutSupport) {
        self.support = support
        
    }
    
    public var top: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.top)
    }
    
    public var bottom: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.bottom)
    }
    
    public var height: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.height)
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintMakerRelatable {
    
    internal let description: ConstraintDescription
    
    internal init(_ description: ConstraintDescription) {
        self.description = description
    }
    
    internal func relatedTo(_ other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt) -> ConstraintMakerEditable {
        let related: ConstraintItem
        let constant: ConstraintConstantTarget
        
        if let other = other as? ConstraintItem {
            guard other.attributes == ConstraintAttributes.none ||
                  other.attributes.layoutAttributes.count <= 1 ||
                  other.attributes.layoutAttributes == self.description.attributes.layoutAttributes ||
                  other.attributes == .edges && self.description.attributes == .margins ||
                  other.attributes == .margins && self.description.attributes == .edges ||
                  other.attributes == .directionalEdges && self.description.attributes == .directionalMargins ||
                  other.attributes == .directionalMargins && self.description.attributes == .directionalEdges else {
                fatalError("Cannot constraint to multiple non identical attributes. (\(file), \(line))");
            }
            
            related = other
            constant = 0.0
        } else if let other = other as? ConstraintView {
            related = ConstraintItem(target: other, attributes: ConstraintAttributes.none)
            constant = 0.0
        } else if let other = other as? ConstraintConstantTarget {
            related = ConstraintItem(target: nil, attributes: ConstraintAttributes.none)
            constant = other
        } else if #available(iOS 9.0, OSX 10.11, *), let other = other as? ConstraintLayoutGuide {
            related = ConstraintItem(target: other, attributes: ConstraintAttributes.none)
            constant = 0.0
        } else {
            fatalError("Invalid constraint. (\(file), \(line))")
        }
        
        let editable = ConstraintMakerEditable(self.description)
        editable.description.sourceLocation = (file, line)
        editable.description.relation = relation
        editable.description.related = related
        editable.description.constant = constant
        return editable
    }
    
    @discardableResult
    public func equalTo(_ other: ConstraintRelatableTarget, _ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        return self.relatedTo(other, relation: .equal, file: file, line: line)
    }
    
    @discardableResult
    public func equalToSuperview(_ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `equalToSuperview`.")
        }
        return self.relatedTo(other, relation: .equal, file: file, line: line)
    }
    
    @discardableResult
    public func lessThanOrEqualTo(_ other: ConstraintRelatableTarget, _ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        return self.relatedTo(other, relation: .lessThanOrEqual, file: file, line: line)
    }
    
    @discardableResult
    public func lessThanOrEqualToSuperview(_ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `lessThanOrEqualToSuperview`.")
        }
        return self.relatedTo(other, relation: .lessThanOrEqual, file: file, line: line)
    }
    
    @discardableResult
    public func greaterThanOrEqualTo(_ other: ConstraintRelatableTarget, _ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        return self.relatedTo(other, relation: .greaterThanOrEqual, file: file, line: line)
    }
    
    @discardableResult
    public func greaterThanOrEqualToSuperview(_ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `greaterThanOrEqualToSuperview`.")
        }
        return self.relatedTo(other, relation: .greaterThanOrEqual, file: file, line: line)
    }
}
//
//  KeyboardTrackingView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 5/20/19.
//  Copyright © 2019 SwiftKick Mobile. All rights reserved.
//

import UIKit

public protocol KeyboardTrackingViewDelegate: AnyObject {
    func keyboardTrackingViewWillChange(change: KeyboardTrackingView.Change, userInfo: [AnyHashable : Any])
    func keyboardTrackingViewDidChange(change: KeyboardTrackingView.Change, userInfo: [AnyHashable : Any])
}

/// A view that adjusts it's height based on keyboard hide and show notifications.
/// Pin it to the bottom of the screen using Auto Layout and then pin views that
/// should avoid the keyboard to the top of it. Supply an instance of this class
/// on `SwiftMessages.Config.keyboardTrackingView` or `SwiftMessagesSegue.keyboardTrackingView`
/// for automatic keyboard avoidance for the entire SwiftMessages view or view controller.
open class KeyboardTrackingView: UIView {

    public enum Change {
        case show
        case hide
        case frame
    }

    public weak var delegate: KeyboardTrackingViewDelegate?

    /// Typically, when a view controller is not being displayed, keyboard
    /// tracking should be paused to avoid responding to keyboard events
    /// caused by other view controllers or apps. Setting `isPaused = false` in
    /// `viewWillAppear` and `isPaused = true` in `viewWillDisappear` usually works. This class
    /// automatically pauses and resumes when the app resigns and becomes active, respectively.
    open var isPaused = false {
        didSet {
            if !isPaused {
                isAutomaticallyPaused = false
            }
        }
    }

    /// The margin to maintain between the keyboard and the top of the view.
    open var topMargin: CGFloat = 0

    /// Subclasses can override this to do something before the change.
    open func willChange(
        change: KeyboardTrackingView.Change,
        userInfo: [AnyHashable : Any]
    ) {}

    /// Subclasses can override this to do something after the change.
    open func didChange(
        change: KeyboardTrackingView.Change,
        userInfo: [AnyHashable : Any]
    ) {}

    override public init(frame: CGRect) {
        super.init(frame: frame)
        postInit()
    }

    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }

    open override func awakeFromNib() {
        super.awakeFromNib()
        postInit()
    }

    private var isAutomaticallyPaused = false
    private var heightConstraint: NSLayoutConstraint!

    private func postInit() {
        translatesAutoresizingMaskIntoConstraints = false
        heightConstraint = heightAnchor.constraint(equalToConstant: 0)
        heightConstraint.isActive = true
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow(_:)), name: UIResponder.keyboardWillShowNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow(_:)), name: UIResponder.keyboardWillChangeFrameNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide(_:)), name: UIResponder.keyboardWillHideNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(pause), name: UIApplication.willResignActiveNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(resume), name: UIApplication.didBecomeActiveNotification, object: nil)
        backgroundColor = .clear
    }

    @objc private func keyboardWillChangeFrame(_ notification: Notification) {
        show(change: .frame, notification)
    }

    @objc private func keyboardWillShow(_ notification: Notification) {
        show(change: .show, notification)
    }

    @objc private func keyboardWillHide(_ notification: Notification) {
        guard !(isPaused || isAutomaticallyPaused),
            let userInfo = (notification as NSNotification).userInfo else { return }
        guard heightConstraint.constant != 0 else { return }
        delegate?.keyboardTrackingViewWillChange(change: .hide, userInfo: userInfo)
        animateKeyboardChange(change: .hide, height: 0, userInfo: userInfo)
    }

    @objc private func pause() {
        isAutomaticallyPaused = true
    }

    @objc private func resume() {
        isAutomaticallyPaused = false
    }

    private func show(change: Change, _ notification: Notification) {
        guard !(isPaused || isAutomaticallyPaused),
            let userInfo = (notification as NSNotification).userInfo,
            let value = userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue else { return }
        willChange(change: change, userInfo: userInfo)
        delegate?.keyboardTrackingViewWillChange(change: change, userInfo: userInfo)
        let keyboardRect = value.cgRectValue
        let thisRect = convert(bounds, to: nil)
        let newHeight = max(0, thisRect.maxY - keyboardRect.minY) + topMargin
        guard heightConstraint.constant != newHeight else { return }
        animateKeyboardChange(change: change, height: newHeight, userInfo: userInfo)
    }

    private func animateKeyboardChange(change: Change, height: CGFloat, userInfo: [AnyHashable: Any]) {
        self.heightConstraint.constant = height
        if let durationNumber = userInfo[UIResponder.keyboardAnimationDurationUserInfoKey] as? NSNumber,
            let curveNumber = userInfo[UIResponder.keyboardAnimationCurveUserInfoKey] as? NSNumber {
            CATransaction.begin()
            CATransaction.setCompletionBlock {
                self.didChange(change: change, userInfo: userInfo)
                self.delegate?.keyboardTrackingViewDidChange(change: change, userInfo: userInfo)
            }
            UIView.beginAnimations(nil, context: nil)
            UIView.setAnimationDuration(durationNumber.doubleValue)
            UIView.setAnimationCurve(UIView.AnimationCurve(rawValue: curveNumber.intValue)!)
            UIView.setAnimationBeginsFromCurrentState(true)
            self.superview?.layoutIfNeeded()
            UIView.commitAnimations()
            CATransaction.commit()
        }
    }
}
//
//  MaskingView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 3/11/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit


class MaskingView: PassthroughView {

    func install(keyboardTrackingView: KeyboardTrackingView) {
        self.keyboardTrackingView = keyboardTrackingView
        keyboardTrackingView.translatesAutoresizingMaskIntoConstraints = false
        addSubview(keyboardTrackingView)
        keyboardTrackingView.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = true
        keyboardTrackingView.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true
        keyboardTrackingView.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true
    }

    var accessibleElements: [NSObject] = []

    weak var backgroundView: UIView? {
        didSet {
            oldValue?.removeFromSuperview()
            if let view = backgroundView {
                view.isUserInteractionEnabled = false
                view.frame = bounds
                view.autoresizingMask = [.flexibleWidth, .flexibleHeight]
                addSubview(view)
                sendSubviewToBack(view)
            }
        }
    }

    override func accessibilityElementCount() -> Int {
        return accessibleElements.count
    }

    override func accessibilityElement(at index: Int) -> Any? {
        return accessibleElements[index]
    }

    override func index(ofAccessibilityElement element: Any) -> Int {
        guard let object = element as? NSObject else { return 0 }
        return accessibleElements.firstIndex(of: object) ?? 0
    }

    init() {
        super.init(frame: CGRect.zero)
        clipsToBounds = true
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        clipsToBounds = true
    }

    private var keyboardTrackingView: KeyboardTrackingView?

    override func addSubview(_ view: UIView) {
        super.addSubview(view)
        guard let keyboardTrackingView = keyboardTrackingView,
            view != keyboardTrackingView,
            view != backgroundView else { return }
        let offset: CGFloat
        if let adjustable = view as? MarginAdjustable {
            offset = -adjustable.bounceAnimationOffset
        } else {
            offset = 0
        }
        keyboardTrackingView.topAnchor.constraint(
            greaterThanOrEqualTo: view.bottomAnchor,
            constant: offset
        ).with(priority: UILayoutPriority(250)).isActive = true
    }
}
//
//  UIViewController+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/5/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

extension UIViewController {
    
    func sm_selectPresentationContextTopDown(_ config: SwiftMessages.Config) -> UIViewController {
        let topBottomStyle = config.presentationStyle.topBottomStyle
        if let presented = presentedViewController {
            return presented.sm_selectPresentationContextTopDown(config)
        } else if case .top? = topBottomStyle, let navigationController = sm_selectNavigationControllerTopDown() {
            return navigationController
        } else if case .bottom? = topBottomStyle, let tabBarController = sm_selectTabBarControllerTopDown() {
            return tabBarController
        }
        return WindowViewController.newInstance(config: config)
    }
    
    fileprivate func sm_selectNavigationControllerTopDown() -> UINavigationController? {
        if let presented = presentedViewController {
            return presented.sm_selectNavigationControllerTopDown()
        } else if let navigationController = self as? UINavigationController {
            if navigationController.sm_isVisible(view: navigationController.navigationBar) {
                return navigationController
            }
            return navigationController.topViewController?.sm_selectNavigationControllerTopDown()
        } else if let tabBarController = self as? UITabBarController {
            return tabBarController.selectedViewController?.sm_selectNavigationControllerTopDown()
        }
        return nil
    }

    fileprivate func sm_selectTabBarControllerTopDown() -> UITabBarController? {
        if let presented = presentedViewController {
            return presented.sm_selectTabBarControllerTopDown()
        } else if let navigationController = self as? UINavigationController {
            return navigationController.topViewController?.sm_selectTabBarControllerTopDown()
        } else if let tabBarController = self as? UITabBarController {
            if tabBarController.sm_isVisible(view: tabBarController.tabBar) {
                return tabBarController
            }
            return tabBarController.selectedViewController?.sm_selectTabBarControllerTopDown()
        }
        return nil
    }

    func sm_selectPresentationContextBottomUp(_ config: SwiftMessages.Config) -> UIViewController {
        let topBottomStyle = config.presentationStyle.topBottomStyle
        if let parent = parent {
            if let navigationController = parent as? UINavigationController {
                if case .top? = topBottomStyle, navigationController.sm_isVisible(view: navigationController.navigationBar) {
                    return navigationController
                }
                return navigationController.sm_selectPresentationContextBottomUp(config)
            } else if let tabBarController = parent as? UITabBarController {
                if case .bottom? = topBottomStyle, tabBarController.sm_isVisible(view: tabBarController.tabBar) {
                    return tabBarController
                }
                return tabBarController.sm_selectPresentationContextBottomUp(config)
            }
        }
        if self.view is UITableView {
            // Never select scroll view as presentation context
            // because, you know, it scrolls.
            if let parent = self.parent {
                return parent.sm_selectPresentationContextBottomUp(config)
            } else {
                return WindowViewController.newInstance(config: config)
            }
        }
        return self
    }
    
    func sm_isVisible(view: UIView) -> Bool {
        if view.isHidden { return false }
        if view.alpha == 0.0 { return false }
        let frame = self.view.convert(view.bounds, from: view)
        if !self.view.bounds.intersects(frame) { return false }
        return true
    }
}

extension SwiftMessages.PresentationStyle {
    /// A temporary workaround to allow custom presentation contexts using `TopBottomAnimation`
    /// to display properly behind bars. THe long term solution is to refactor all of the
    /// presentation context logic to work with safe area insets.
    var topBottomStyle: TopBottomAnimation.Style? {
        switch self {
        case .top: return .top
        case .bottom: return .bottom
        case .custom(let animator): return (animator as? TopBottomAnimation)?.style
        case .center: return nil
        }
    }
}
//
//  SwiftMessages.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/1/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

private let globalInstance = SwiftMessages()

/**
 The `SwiftMessages` class provides the interface for showing and hiding messages.
 It behaves like a queue, only showing one message at a time. Message views that
 adopt the `Identifiable` protocol (as `MessageView` does) will have duplicates removed.
 */
open class SwiftMessages {
    
    /**
     Specifies whether the message view is displayed at the top or bottom
     of the selected presentation container.
    */
    public enum PresentationStyle {
        
        /**
         Message view slides down from the top.
        */
        case top

        /**
         Message view slides up from the bottom.
         */
        case bottom

        /**
         Message view fades into the center.
         */
        case center

        /**
         User-defined animation
        */
        case custom(animator: Animator)
    }

    /**
     Specifies how the container for presenting the message view
     is selected.
    */
    public enum PresentationContext {
        
        /**
         Displays the message view under navigation bars and tab bars if an
         appropriate one is found. Otherwise, it is displayed in a new window
         at level `UIWindow.Level.normal`. Use this option to automatically display
         under bars, where applicable. Because this option involves a top-down
         search, an appropriate context might not be found when the view controller
         hierarchy incorporates custom containers. If this is the case, the
         .ViewController option can provide a more targeted context.
        */
        case automatic

        /**
         Displays the message in a new window at the specified window level.
         SwiftMessages automatically increases the top margins of any message
         view that adopts the `MarginInsetting` protocol (as `MessageView` does)
         to account for the status bar. As of iOS 13, windows can no longer cover the
         status bar. The only alternative is to set `Config.prefersStatusBarHidden = true`
         to hide it.
        */
        case window(windowLevel: UIWindow.Level)

        /**
         Displays the message in a new window, at the specified window level,
         in the specified window scene. SwiftMessages automatically increases the top margins
         of any message view that adopts the `MarginInsetting` protocol (as `MessageView` does)
         to account for the status bar. As of iOS 13, windows can no longer cover the
         status bar. The only alternative is to set `Config.prefersStatusBarHidden = true`
         to hide it. The `WindowScene` protocol works around the change in Xcode 13 that prevents
         using `@availability` attribute with `enum` cases containing associated values.
        */
        case windowScene(_: WindowScene, windowLevel: UIWindow.Level)

        /**
         Displays the message view under navigation bars and tab bars if an
         appropriate one is found using the given view controller as a starting
         point and searching up the parent view controller chain. Otherwise, it
         is displayed in the given view controller's view. This option can be used
         for targeted placement in a view controller hierarchy.
        */
        case viewController(_: UIViewController)

        /**
         Displays the message view in the given container view.
         */
        case view(_: UIView)
    }
    
    /**
     Specifies the duration of the message view's time on screen before it is
     automatically hidden.
    */
    public enum Duration {
        
        /**
         Hide the message view after the default duration.
        */
        case automatic
        
        /**
         Disables automatic hiding of the message view.
        */
        case forever
        
        /**
         Hide the message view after the speficied number of seconds.
         
         - Parameter seconds: The number of seconds.
        */
        case seconds(seconds: TimeInterval)

        /**
         The `indefinite` option is similar to `forever` in the sense that
         the message view will not be automatically hidden. However, it
         provides two options that can be useful in some scenarios:
         
            - `delay`: wait the specified time interval before displaying
                       the message. If you hide the message during the delay
                       interval by calling either `hideAll()` or `hide(id:)`,
                       the message will not be displayed. This is not the case for
                       `hide()` because it only acts on a visible message. Messages
                       shown during another message's delay window are displayed first.
            - `minimum`: if the message is displayed, ensure that it is displayed
                         for a minimum time interval. If you explicitly hide the
                         during this interval, the message will be hidden at the
                         end of the interval.

         This option is useful for displaying a message when a process is taking
         too long but you don't want to display the message if the process completes
         in a reasonable amount of time. The value `indefinite(delay: 0, minimum: 0)`
         is equivalent to `forever`.
         
         For example, if a URL load is expected to complete in 2 seconds, you may use
         the value `indefinite(delay: 2, minimum 1)` to ensure that the message will not
         be displayed in most cases, but will be displayed for at least 1 second if
         the operation takes longer than 2 seconds. By specifying a minimum duration,
         you can avoid hiding the message too fast if the operation finishes right
         after the delay interval.
        */
        case indefinite(delay: TimeInterval, minimum: TimeInterval)
    }
    
    /**
     Specifies options for dimming the background behind the message view
     similar to a popover view controller.
    */
    public enum DimMode {
        
        /**
         Don't dim the background behind the message view.
        */
        case none

        /**
         Dim the background behind the message view a gray color.
         
         - `interactive`: Specifies whether or not tapping the
                          dimmed area dismisses the message view.
         */
        case gray(interactive: Bool)

        /**
         Dim the background behind the message view using the given color.
         SwiftMessages does not apply alpha transparency to the color, so any alpha
         must be baked into the `UIColor` instance.
         
         - `color`: The color of the dim view.
         - `interactive`: Specifies whether or not tapping the
                          dimmed area dismisses the message view.
         */
        case color(color: UIColor, interactive: Bool)

        /**
         Dim the background behind the message view using a blur effect with
         the given style

         - `style`: The blur effect style to use
         - `alpha`: The alpha level of the blur
         - `interactive`: Specifies whether or not tapping the
         dimmed area dismisses the message view.
         */
        case blur(style: UIBlurEffect.Style, alpha: CGFloat, interactive: Bool)

        public var interactive: Bool {
            switch self {
            case .gray(let interactive):
                return interactive
            case .color(_, let interactive):
                return interactive
            case .blur (_, _, let interactive):
                return interactive
            case .none:
                return false
            }
        }

        public var modal: Bool {
            switch self {
            case .gray, .color, .blur:
                return true
            case .none:
                return false
            }
        }
    }

    /**
     Specifies events in the message lifecycle.
    */
    public enum Event {
        case willShow(UIView)
        case didShow(UIView)
        case willHide(UIView)
        case didHide(UIView)

        public var view: UIView {
            switch self {
            case .willShow(let view): return view
            case .didShow(let view): return view
            case .willHide(let view): return view
            case .didHide(let view): return view
            }
        }

        public var id: String? {
            return (view as? Identifiable)?.id
        }
    }
    
    /**
     A closure that takes an `Event` as an argument.
     */
    public typealias EventListener = (Event) -> Void
    
    /**
     The `Config` struct specifies options for displaying a single message view. It is
     provided as an optional argument to one of the `MessageView.show()` methods.
     */
    public struct Config {
        
        public init() {}
        
        /**
         Specifies whether the message view is displayed at the top or bottom
         of the selected presentation container. The default is `.Top`.
         */
        public var presentationStyle = PresentationStyle.top

        /**
         Specifies how the container for presenting the message view
         is selected. The default is `.Automatic`.
         */
        public var presentationContext = PresentationContext.automatic {
            didSet {
                if case .windowScene = presentationContext {
                    guard #available(iOS 13.0, *) else {
                        assertionFailure("windowScene is not supported below iOS 13.0.")
                        return
                    }
                }
            }
        }

        /**
         Specifies the duration of the message view's time on screen before it is
         automatically hidden. The default is `.Automatic`.
         */
        public var duration = Duration.automatic
        
        /**
         Specifies options for dimming the background behind the message view
         similar to a popover view controller. The default is `.None`.
         */
        public var dimMode = DimMode.none
        
        /**
         Specifies whether or not the interactive pan-to-hide gesture is enabled
         on the message view. For views that implement the `BackgroundViewable` 
         protocol (as `MessageView` does), the pan gesture recognizer is installed
         in the `backgroundView`, which allows for card-style views with transparent
         margins that shouldn't be interactive. Otherwise, it is installed in
         the message view itself. The default is `true`.
        */
        public var interactiveHide = true
        
        /**
         Specifies the preferred status bar style when the view is being
         displayed in a window. This can be useful when the view is being
         displayed behind the status bar and the message view has a background
         color that needs a different status bar style than the current one.
         The default is `nil`.
         */
        public var preferredStatusBarStyle: UIStatusBarStyle?

        /**
         Specifies the preferred status bar visibility when the view is being
         displayed in a window. As of iOS 13, windows can no longer cover the
         status bar. The only alternative is to hide the status bar by setting
         this options to `true`. Default is `nil`.
         */
        public var prefersStatusBarHidden: Bool?

        /**
         If a view controller is created to host the message view, should the view 
         controller auto rotate?  The default is 'true', meaning it should auto
         rotate.
         */
        public var shouldAutorotate = true

        /**
         Specified whether or not duplicate `Identifiable` messages are ignored.
         The default is `true`.
        */
        public var ignoreDuplicates = true
        
        /**
         Specifies an optional array of event listeners.
        */
        public var eventListeners: [EventListener] = []
        
        /**
         Specifies that in cases where the message is displayed in its own window,
         such as with `.window` presentation context, the window should become
         the key window. This option should only be used if the message view
         needs to receive non-touch events, such as keyboard input. From Apple's
         documentation https://developer.apple.com/reference/uikit/uiwindow:
         
         > Whereas touch events are delivered to the window where they occurred,
         > events that do not have a relevant coordinate value are delivered to
         > the key window. Only one window at a time can be the key window, and
         > you can use a window’s keyWindow property to determine its status.
         > Most of the time, your app’s main window is the key window, but UIKit
         > may designate a different window as needed.
         */
        public var becomeKeyWindow: Bool?

        /**
         The `dimMode` background will use this accessibility
         label, e.g. "dismiss" when the `interactive` option is used.
        */
        public var dimModeAccessibilityLabel: String = "dismiss"

        /**
         The user interface style to use when SwiftMessages displays a message its own window.
         Use with apps that don't support dark mode to prevent messages from adopting the
         system's interface style.
        */
        @available(iOS 13, *)
        public var overrideUserInterfaceStyle: UIUserInterfaceStyle {
            // Note that this is modelled as a computed property because
            // Swift doesn't allow `@available` with stored properties.
            get {
                guard let rawValue = overrideUserInterfaceStyleRawValue else { return .unspecified }
                return UIUserInterfaceStyle(rawValue: rawValue) ?? .unspecified
            }
            set {
                overrideUserInterfaceStyleRawValue = newValue.rawValue
            }
        }
        private var overrideUserInterfaceStyleRawValue: Int?

        /**
         If specified, SwiftMessages calls this closure when an instance of
         `WindowViewController` is needed. Use this if you need to supply a custom subclass
         of `WindowViewController`.
         */
        public var windowViewController: ((_ config: SwiftMessages.Config) -> WindowViewController)?

        /**
         Supply an instance of `KeyboardTrackingView` to have the message view avoid the keyboard.
         */
        public var keyboardTrackingView: KeyboardTrackingView?
    }
    
    /**
     Not much to say here.
     */
    public init() {}
    
    /**
     Adds the given configuration and view to the message queue to be displayed.
     
     - Parameter config: The configuration options.
     - Parameter view: The view to be displayed.
     */
    open func show(config: Config, view: UIView) {
        let presenter = Presenter(config: config, view: view, delegate: self)
        messageQueue.sync {
            enqueue(presenter: presenter)
        }
    }
    
    /**
     Adds the given view to the message queue to be displayed
     with default configuration options.
     
     - Parameter config: The configuration options.
     - Parameter view: The view to be displayed.
     */
    public func show(view: UIView) {
        show(config: defaultConfig, view: view)
    }
    
    /// A block that returns an arbitrary view.
    public typealias ViewProvider = () -> UIView

    /**
     Adds the given configuration and view provider to the message queue to be displayed.

     The `viewProvider` block is guaranteed to be called on the main queue where
     it is safe to interact with `UIKit` components. This variant of `show()` is
     recommended when the message might be added from a background queue.
     
     - Parameter config: The configuration options.
     - Parameter viewProvider: A block that returns the view to be displayed.
     */
    open func show(config: Config, viewProvider: @escaping ViewProvider) {
        DispatchQueue.main.async { [weak self] in
            guard let strongSelf = self else { return }
            let view = viewProvider()
            strongSelf.show(config: config, view: view)
        }
    }
    
    /**
     Adds the given view provider to the message queue to be displayed
     with default configuration options.
     
     The `viewProvider` block is guaranteed to be called on the main queue where
     it is safe to interact with `UIKit` components. This variant of `show()` is
     recommended when the message might be added from a background queue.
     
     - Parameter viewProvider: A block that returns the view to be displayed.
     */
    public func show(viewProvider: @escaping ViewProvider) {
        show(config: defaultConfig, viewProvider: viewProvider)
    }
    
    /**
     Hide the current message being displayed by animating it away.
     */
    open func hide(animated: Bool = true) {
        messageQueue.sync {
            hideCurrent(animated: animated)
        }
    }

    /**
     Hide the current message, if there is one, by animating it away and
     clear the message queue.
     */
    open func hideAll() {
        messageQueue.sync {
            queue.removeAll()
            delays.removeAll()
            counts.removeAll()
            hideCurrent()
        }
    }

    /**
     Hide a message with the given `id`. If the specified message is
     currently being displayed, it will be animated away. Works with message
     views, such as `MessageView`, that adopt the `Identifiable` protocol.
     - Parameter id: The identifier of the message to remove.
     */
    open func hide(id: String) {
        messageQueue.sync {
            if id == _current?.id {
                hideCurrent()
            }
            queue = queue.filter { $0.id != id }
            delays.remove(id: id)
            counts[id] = nil
        }
    }

    /**
     Hide the message when the number of calls to show() and hideCounted(id:) for a
     given message ID are equal. This can be useful for messages that may be
     shown from  multiple code paths to ensure that all paths are ready to hide.
     */
    open func hideCounted(id: String) {
        messageQueue.sync {
            if let count = counts[id] {
                if count < 2 {
                    counts[id] = nil
                } else {
                    counts[id] = count - 1
                    return
                }
            }
            if id == _current?.id {
                hideCurrent()
            }
            queue = queue.filter { $0.id != id }
            delays.remove(id: id)
        }
    }

    /**
     Get the count of a message with the given ID (see `hideCounted(id:)`)
     */
    public func count(id: String) -> Int {
        return counts[id] ?? 0
    }

    /**
     Explicitly set the count of a message with the given ID (see `hideCounted(id:)`).
     Not sure if there's a use case for this, but why not?!
     */
    public func set(count: Int, for id: String) {
        guard counts[id] != nil else { return }
        return counts[id] = count
    }

    /**
     Specifies the default configuration to use when calling the variants of
     `show()` that don't take a `config` argument or as a base for custom configs.
     */
    public var defaultConfig = Config()

    /**
     Specifies the amount of time to pause between removing a message
     and showing the next. Default is 0.5 seconds.
     */
    open var pauseBetweenMessages: TimeInterval = 0.5

    /// Type for keeping track of delayed presentations
    fileprivate class Delays {

        fileprivate func add(presenter: Presenter) {
            presenters.insert(presenter)
        }

        @discardableResult
        fileprivate func remove(presenter: Presenter) -> Bool {
            guard presenters.contains(presenter) else { return false }
            presenters.remove(presenter)
            return true
        }

        fileprivate func remove(id: String) {
            presenters = presenters.filter { $0.id != id }
        }

        fileprivate func removeAll() {
            presenters.removeAll()
        }

        private var presenters = Set<Presenter>()
    }

    func show(presenter: Presenter) {
        messageQueue.sync {
            enqueue(presenter: presenter)
        }
    }

    fileprivate let messageQueue = DispatchQueue(label: "it.swiftkick.SwiftMessages", attributes: [])
    fileprivate var queue: [Presenter] = []
    fileprivate var delays = Delays()
    fileprivate var counts: [String : Int] = [:]
    fileprivate var _current: Presenter? = nil {
        didSet {
            if oldValue != nil {
                let delayTime = DispatchTime.now() + pauseBetweenMessages
                messageQueue.asyncAfter(deadline: delayTime) { [weak self] in
                    self?.dequeueNext()
                }
            }
        }
    }

    fileprivate func enqueue(presenter: Presenter) {
        if presenter.config.ignoreDuplicates {
            counts[presenter.id] = (counts[presenter.id] ?? 0) + 1
            if _current?.id == presenter.id && _current?.isHiding == false { return }
            if queue.filter({ $0.id == presenter.id }).count > 0 { return }
        }
        func doEnqueue() {
            queue.append(presenter)
            dequeueNext()
        }
        if let delay = presenter.delayShow {
            delays.add(presenter: presenter)
            messageQueue.asyncAfter(deadline: .now() + delay) { [weak self] in
                // Don't enqueue if the view has been hidden during the delay window.
                guard let strongSelf = self, strongSelf.delays.remove(presenter: presenter) else { return }
                doEnqueue()
            }
        } else {
            doEnqueue()
        }
    }
    
    fileprivate func dequeueNext() {
        guard self._current == nil, queue.count > 0 else { return }
        let current = queue.removeFirst()
        self._current = current
        // Set `autohideToken` before the animation starts in case
        // the dismiss gesture begins before we've queued the autohide
        // block on animation completion.
        self.autohideToken = current
        current.showDate = CACurrentMediaTime()
        DispatchQueue.main.async { [weak self] in
            guard let strongSelf = self else { return }
            do {
                try current.show { completed in
                    guard let strongSelf = self else { return }
                    guard completed else {
                        strongSelf.messageQueue.sync {
                            strongSelf.internalHide(presenter: current)
                        }
                        return
                    }
                    if current === strongSelf.autohideToken {
                        strongSelf.queueAutoHide()
                    }
                }
            } catch {
                strongSelf.messageQueue.sync {
                    strongSelf._current = nil
                }
            }
        }
    }

    fileprivate func internalHide(presenter: Presenter) {
        if presenter == _current {
            hideCurrent()
        } else {
            queue = queue.filter { $0 != presenter }
            delays.remove(presenter: presenter)
        }
    }
 
    fileprivate func hideCurrent(animated: Bool = true) {
        guard let current = _current, !current.isHiding else { return }
        let action = { [weak self] in
            current.hide(animated: animated) { (completed) in
                guard completed, let strongSelf = self else { return }
                strongSelf.messageQueue.sync {
                    guard strongSelf._current === current else { return }
                    strongSelf.counts[current.id] = nil
                    strongSelf._current = nil
                }
            }
        }
        let delay = current.delayHide ?? 0
        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
            action()
        }
    }

    fileprivate weak var autohideToken: AnyObject?

    fileprivate func queueAutoHide() {
        guard let current = _current else { return }
        autohideToken = current
        if let pauseDuration = current.pauseDuration {
            let delayTime = DispatchTime.now() + pauseDuration
            messageQueue.asyncAfter(deadline: delayTime, execute: {
                // Make sure we've still got a green light to auto-hide.
                if self.autohideToken !== current { return }
                self.internalHide(presenter: current)
            })
        }
    }

    deinit {
        // Prevent orphaned messages
        hideCurrent()
    }
}

/*
 MARK: - Accessing messages
 */

extension SwiftMessages {

    /**
     Returns the message view of type `T` if it is currently being shown or hidden.

     - Returns: The view of type `T` if it is currently being shown or hidden.
     */
    public func current<T: UIView>() -> T? {
        var view: T?
        messageQueue.sync {
            view = _current?.view as? T
        }
        return view
    }

    /**
     Returns a message view with the given `id` if it is currently being shown or hidden.

     - Parameter id: The id of a message that adopts `Identifiable`.
     - Returns: The view with matching id if currently being shown or hidden.
    */
    public func current<T: UIView>(id: String) -> T? {
        var view: T?
        messageQueue.sync {
            if let current = _current, current.id == id {
                view = current.view as? T
            }
        }
        return view
    }

    /**
     Returns a message view with the given `id` if it is currently in the queue to be shown.

     - Parameter id: The id of a message that adopts `Identifiable`.
     - Returns: The view with matching id if currently queued to be shown.
     */
    public func queued<T: UIView>(id: String) -> T? {
        var view: T?
        messageQueue.sync {
            if let queued = queue.first(where: { $0.id == id }) {
                view = queued.view as? T
            }
        }
        return view
    }

    /**
     Returns a message view with the given `id` if it is currently being 
     shown, hidden or in the queue to be shown.

     - Parameter id: The id of a message that adopts `Identifiable`.
     - Returns: The view with matching id if currently queued to be shown.
     */
    public func currentOrQueued<T: UIView>(id: String) -> T? {
        return current(id: id) ?? queued(id: id)
    }
}

/*
 MARK: - PresenterDelegate
 */

extension SwiftMessages: PresenterDelegate {

    func hide(presenter: Presenter) {
        messageQueue.sync {
            self.internalHide(presenter: presenter)
        }
    }

    public func hide(animator: Animator) {
        messageQueue.sync {
            guard let presenter = self.presenter(forAnimator: animator) else { return }
            self.internalHide(presenter: presenter)
        }
    }

    public func panStarted(animator: Animator) {
        autohideToken = nil
    }

    public func panEnded(animator: Animator) {
        queueAutoHide()
    }

    private func presenter(forAnimator animator: Animator) -> Presenter? {
        if let current = _current, animator === current.animator {
            return current
        }
        let queued = queue.filter { $0.animator === animator }
        return queued.first
    }
}

/**
 MARK: - Creating views from nibs

 This extension provides several convenience functions for instantiating views from nib files.
 SwiftMessages provides several default nib files in the Resources folder that can be
 drag-and-dropped into a project as a starting point and modified.
 */

extension SwiftMessages {
    
    /**
     Loads a nib file with the same name as the generic view type `T` and returns
     the first view found in the nib file with matching type `T`. For example, if
     the generic type is `MyView`, a nib file named `MyView.nib` is loaded and the
     first top-level view of type `MyView` is returned. The main bundle is searched
     first followed by the SwiftMessages bundle.
     
     - Parameter filesOwner: An optional files owner.
     
     - Throws: `Error.CannotLoadViewFromNib` if a view matching the
       generic type `T` is not found in the nib.
     
     - Returns: An instance of generic view type `T`.
     */
    public class func viewFromNib<T: UIView>(_ filesOwner: AnyObject = NSNull.init()) throws -> T {
        let name = T.description().components(separatedBy: ".").last
        assert(name != nil)
        let view: T = try internalViewFromNib(named: name!, bundle: nil, filesOwner: filesOwner)
        return view
    }
    
    /**
     Loads a nib file with specified name and returns the first view found in the  nib file
     with matching type `T`. The main bundle is searched first followed by the SwiftMessages bundle.
     
     - Parameter name: The name of the nib file (excluding the .xib extension).
     - Parameter filesOwner: An optional files owner.
     
     - Throws: `Error.CannotLoadViewFromNib` if a view matching the
     generic type `T` is not found in the nib.
     
     - Returns: An instance of generic view type `T`.
     */
    public class func viewFromNib<T: UIView>(named name: String, filesOwner: AnyObject = NSNull.init()) throws -> T {
        let view: T = try internalViewFromNib(named: name, bundle: nil, filesOwner: filesOwner)
        return view
    }
    
    /**
     Loads a nib file with specified name in the specified bundle and returns the
     first view found in the  nib file with matching type `T`.
     
     - Parameter name: The name of the nib file (excluding the .xib extension).
     - Parameter bundle: The name of the bundle containing the nib file.
     - Parameter filesOwner: An optional files owner.
     
     - Throws: `Error.CannotLoadViewFromNib` if a view matching the
     generic type `T` is not found in the nib.
     
     - Returns: An instance of generic view type `T`.
     */
    public class func viewFromNib<T: UIView>(named name: String, bundle: Bundle, filesOwner: AnyObject = NSNull.init()) throws -> T {
        let view: T = try internalViewFromNib(named: name, bundle: bundle, filesOwner: filesOwner)
        return view
    }
    
    fileprivate class func internalViewFromNib<T: UIView>(named name: String, bundle: Bundle? = nil, filesOwner: AnyObject = NSNull.init()) throws -> T {
        let resolvedBundle: Bundle
        if let bundle = bundle {
            resolvedBundle = bundle
        } else {
            if Bundle.main.path(forResource: name, ofType: "nib") != nil {
                resolvedBundle = Bundle.main
            } else {
                resolvedBundle = Bundle.sm_frameworkBundle()
            }
        }
        let arrayOfViews = resolvedBundle.loadNibNamed(name, owner: filesOwner, options: nil) ?? []
        #if swift(>=4.1)
        guard let view = arrayOfViews.compactMap( { $0 as? T} ).first else { throw SwiftMessagesError.cannotLoadViewFromNib(nibName: name) }
        #else
        guard let view = arrayOfViews.flatMap( { $0 as? T} ).first else { throw SwiftMessagesError.cannotLoadViewFromNib(nibName: name) }
        #endif
        return view
    }
}

/*
 MARK: - Static APIs
 
 This extension provides a shared instance of `SwiftMessages` and a static API wrapper around
 this instance for simplified syntax. For example, `SwiftMessages.show()` is equivalent
 to `SwiftMessages.sharedInstance.show()`.
 */

extension SwiftMessages {
    
    /**
     A default shared instance of `SwiftMessages`. The `SwiftMessages` class provides
     a set of static APIs that wrap calls to this instance. For example, `SwiftMessages.show()`
     is equivalent to `SwiftMessages.sharedInstance.show()`.
     */
    public static var sharedInstance: SwiftMessages {
        return globalInstance
    }
    
    public static func show(viewProvider: @escaping ViewProvider) {
        globalInstance.show(viewProvider: viewProvider)
    }
    
    public static func show(config: Config, viewProvider: @escaping ViewProvider) {
        globalInstance.show(config: config, viewProvider: viewProvider)
    }
    
    public static func show(view: UIView) {
        globalInstance.show(view: view)
    }

    public static func show(config: Config, view: UIView) {
        globalInstance.show(config: config, view: view)
    }

    public static func hide(animated: Bool = true) {
        globalInstance.hide(animated: animated)
    }
    
    public static func hideAll() {
        globalInstance.hideAll()
    }
    
    public static func hide(id: String) {
        globalInstance.hide(id: id)
    }

    public static func hideCounted(id: String) {
        globalInstance.hideCounted(id: id)
    }

    public static var defaultConfig: Config {
        get {
            return globalInstance.defaultConfig
        }
        set {
            globalInstance.defaultConfig = newValue
        }
    }
    
    public static var pauseBetweenMessages: TimeInterval {
        get {
            return globalInstance.pauseBetweenMessages
        }
        set {
            globalInstance.pauseBetweenMessages = newValue
        }
    }

    public static func current<T: UIView>(id: String) -> T? {
        return globalInstance.current(id: id)
    }

    public static func queued<T: UIView>(id: String) -> T? {
        return globalInstance.queued(id: id)
    }

    public static func currentOrQueued<T: UIView>(id: String) -> T? {
        return globalInstance.currentOrQueued(id: id)
    }

    public static func count(id: String) -> Int {
        return globalInstance.count(id: id)
    }

    public static func set(count: Int, for id: String) {
        globalInstance.set(count: count, for: id)
    }
}
//
//  PhysicsAnimation.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/14/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

public class PhysicsAnimation: NSObject, Animator {

    public enum Placement {
        case top
        case center
        case bottom
    }

    open var placement: Placement = .center

    open var showDuration: TimeInterval = 0.5

    open var hideDuration: TimeInterval = 0.15

    public var panHandler = PhysicsPanHandler()

    public weak var delegate: AnimationDelegate?
    weak var messageView: UIView?
    weak var containerView: UIView?
    var context: AnimationContext?

    public override init() {}

    init(delegate: AnimationDelegate) {
        self.delegate = delegate
    }

    public func show(context: AnimationContext, completion: @escaping AnimationCompletion) {
        NotificationCenter.default.addObserver(self, selector: #selector(adjustMargins), name: UIDevice.orientationDidChangeNotification, object: nil)
        install(context: context)
        showAnimation(context: context, completion: completion)
    }

    public func hide(context: AnimationContext, completion: @escaping AnimationCompletion) {
        NotificationCenter.default.removeObserver(self)
        if panHandler.isOffScreen {
            context.messageView.alpha = 0
            panHandler.state?.stop()
        }
        let view = context.messageView
        self.context = context
        CATransaction.begin()
        CATransaction.setCompletionBlock {
            view.alpha = 1
            view.transform = CGAffineTransform.identity
            completion(true)
        }
        UIView.animate(withDuration: hideDuration, delay: 0, options: [.beginFromCurrentState, .curveEaseIn, .allowUserInteraction], animations: {
            view.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)
        }, completion: nil)
        UIView.animate(withDuration: hideDuration, delay: 0, options: [.beginFromCurrentState, .curveEaseIn, .allowUserInteraction], animations: {
            view.alpha = 0
        }, completion: nil)
        CATransaction.commit()
    }

    func install(context: AnimationContext) {
        let view = context.messageView
        let container = context.containerView
        messageView = view
        containerView = container
        self.context = context
        view.translatesAutoresizingMaskIntoConstraints = false
        container.addSubview(view)
        switch placement {
        case .center:
            view.centerYAnchor.constraint(equalTo: container.centerYAnchor).with(priority: UILayoutPriority(200)).isActive = true
        case .top:
            view.topAnchor.constraint(equalTo: container.topAnchor).with(priority: UILayoutPriority(200)).isActive = true
        case .bottom:
            view.bottomAnchor.constraint(equalTo: container.bottomAnchor).with(priority: UILayoutPriority(200)).isActive = true
        }
        NSLayoutConstraint(item: view, attribute: .leading, relatedBy: .equal, toItem: container, attribute: .leading, multiplier: 1, constant: 0).isActive = true
        NSLayoutConstraint(item: view, attribute: .trailing, relatedBy: .equal, toItem: container, attribute: .trailing, multiplier: 1, constant: 0).isActive = true
        // Important to layout now in order to get the right safe area insets
        container.layoutIfNeeded()
        adjustMargins()
        container.layoutIfNeeded()
        installInteractive(context: context)
    }

    @objc public func adjustMargins() {
        guard let adjustable = messageView as? MarginAdjustable & UIView,
            let context = context else { return }
        adjustable.preservesSuperviewLayoutMargins = false
        if #available(iOS 11, *) {
            adjustable.insetsLayoutMarginsFromSafeArea = false
        }
        adjustable.layoutMargins = adjustable.defaultMarginAdjustment(context: context)
    }

    func showAnimation(context: AnimationContext, completion: @escaping AnimationCompletion) {
        let view = context.messageView
        view.alpha = 0.25
        view.transform = CGAffineTransform(scaleX: 0.6, y: 0.6)
        CATransaction.begin()
        CATransaction.setCompletionBlock {
            completion(true)
        }
        UIView.animate(withDuration: showDuration, delay: 0, usingSpringWithDamping: 0.6, initialSpringVelocity: 0, options: [.beginFromCurrentState, .curveLinear, .allowUserInteraction], animations: {
            view.transform = CGAffineTransform.identity
        }, completion: nil)
        UIView.animate(withDuration: 0.3 * showDuration, delay: 0, options: [.beginFromCurrentState, .curveLinear, .allowUserInteraction], animations: {
            view.alpha = 1
        }, completion: nil)
        CATransaction.commit()
    }

    func installInteractive(context: AnimationContext) {
        guard context.interactiveHide else { return }
        panHandler.configure(context: context, animator: self)
    }
}


//
//  UIEdgeInsets+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 5/23/18.
//  Copyright © 2018 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension UIEdgeInsets {
    public static func +(left: UIEdgeInsets, right: UIEdgeInsets) -> UIEdgeInsets {
        let topSum = left.top + right.top
        let leftSum = left.left + right.left
        let bottomSum = left.bottom + right.bottom
        let rightSum = left.right + right.right
        return UIEdgeInsets(top: topSum, left: leftSum, bottom: bottomSum, right: rightSum)
    }

    public static func -(left: UIEdgeInsets, right: UIEdgeInsets) -> UIEdgeInsets {
        let topSum = left.top - right.top
        let leftSum = left.left - right.left
        let bottomSum = left.bottom - right.bottom
        let rightSum = left.right - right.right
        return UIEdgeInsets(top: topSum, left: leftSum, bottom: bottomSum, right: rightSum)
    }
}
//
//  AccessibleMessage.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 3/11/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import Foundation

/**
 Message views that `AccessibleMessage`, as `MessageView` does will
 have proper accessibility behavior when displaying messages.
 `MessageView` implements this protocol.
 */
public protocol AccessibleMessage {
    var accessibilityMessage: String? { get }
    var accessibilityElement: NSObject? { get }
    var additionalAccessibilityElements: [NSObject]? { get }
}
//
//  Error.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/7/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import Foundation

/**
 The `SwiftMessagesError` enum contains the errors thrown by SwiftMessages.
 */
enum SwiftMessagesError: Error {
    case cannotLoadViewFromNib(nibName: String)
    case noRootViewController
}
//
//  PassthroughView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/5/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

class PassthroughView: UIControl {

    var tappedHander: (() -> Void)?

    override init(frame: CGRect) {
        super.init(frame: frame)
        initCommon()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        initCommon()
    }

    private func initCommon() {
        addTarget(self, action: #selector(tapped), for: .touchUpInside)
    }

    @objc func tapped() {
        tappedHander?()
    }
    
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        let view = super.hitTest(point, with: event)
        return view == self && tappedHander == nil ? nil : view
    }
}
//
//  WindowViewController.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/1/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

open class WindowViewController: UIViewController
{
    override open var shouldAutorotate: Bool {
        return config.shouldAutorotate
    }

    convenience public init() {
        self.init(config: SwiftMessages.Config())
    }

    public init(config: SwiftMessages.Config) {
        self.config = config
        let view = PassthroughView()
        let window = PassthroughWindow(hitTestView: view)
        self.window = window
        super.init(nibName: nil, bundle: nil)
        self.view = view
        window.rootViewController = self
        window.windowLevel = config.windowLevel ?? UIWindow.Level.normal
        if #available(iOS 13, *) {
            window.overrideUserInterfaceStyle = config.overrideUserInterfaceStyle
        }
    }

    func install() {
        if #available(iOS 13, *) {
            window?.windowScene = config.windowScene
            #if !SWIFTMESSAGES_APP_EXTENSIONS
            previousKeyWindow = UIWindow.keyWindow
            #endif
            show(
                becomeKey: config.shouldBecomeKeyWindow,
                frame: config.windowScene?.coordinateSpace.bounds
            )
        } else {
            show(becomeKey: config.shouldBecomeKeyWindow)
        }
    }

    private func show(becomeKey: Bool, frame: CGRect? = nil) {
        guard let window = window else { return }
        window.frame = frame ?? UIScreen.main.bounds
        if becomeKey {
            window.makeKeyAndVisible()
        } else {
            window.isHidden = false
        }
    }
    
    func uninstall() {
        if window?.isKeyWindow == true {
            previousKeyWindow?.makeKey()
        }
        if #available(iOS 13, *) {
            window?.windowScene = nil
        }
        window?.isHidden = true
        window = nil
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override open var preferredStatusBarStyle: UIStatusBarStyle {
        return config.preferredStatusBarStyle ?? super.preferredStatusBarStyle
    }

    open override var prefersStatusBarHidden: Bool {
        return config.prefersStatusBarHidden ?? super.prefersStatusBarHidden
    }

    // MARK: - Variables

    private var window: UIWindow?
    private weak var previousKeyWindow: UIWindow?

    let config: SwiftMessages.Config
}

extension WindowViewController {
    static func newInstance(config: SwiftMessages.Config) -> WindowViewController {
        return config.windowViewController?(config) ?? WindowViewController(config: config)
    }
}
//
//  MarginAdjustable+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 11/5/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension MarginAdjustable where Self: UIView {
    public func defaultMarginAdjustment(context: AnimationContext) -> UIEdgeInsets {
        var layoutMargins: UIEdgeInsets = layoutMarginAdditions
        var safeAreaInsets: UIEdgeInsets = {
            guard respectSafeArea else { return .zero }
            if #available(iOS 11, *) {
                insetsLayoutMarginsFromSafeArea = false
                return self.safeAreaInsets
            } else {
                #if SWIFTMESSAGES_APP_EXTENSIONS
                let application: UIApplication? = nil
                #else
                let application: UIApplication? = UIApplication.shared
                #endif
                if !context.safeZoneConflicts.isDisjoint(with: [.statusBar]),
                   let app = application,
                   app.statusBarOrientation == .portrait || app.statusBarOrientation == .portraitUpsideDown {
                    let frameInWindow = convert(bounds, to: window)
                    let top = max(0, 20 - frameInWindow.minY)
                    return UIEdgeInsets(top: top, left: 0, bottom: 0, right: 0)
                } else {
                    return .zero
                }
            }
        }()
        if !context.safeZoneConflicts.isDisjoint(with: .overStatusBar) {
            safeAreaInsets.top = 0
        }
        layoutMargins = collapseLayoutMarginAdditions
            ? layoutMargins.collapse(toInsets: safeAreaInsets)
            : layoutMargins + safeAreaInsets
        return layoutMargins
    }
}

extension UIEdgeInsets {
    func collapse(toInsets insets: UIEdgeInsets) -> UIEdgeInsets {
        let top = self.top.collapse(toInset: insets.top)
        let left = self.left.collapse(toInset: insets.left)
        let bottom = self.bottom.collapse(toInset: insets.bottom)
        let right = self.right.collapse(toInset: insets.right)
        return UIEdgeInsets(top: top, left: left, bottom: bottom, right: right)
    }
}

extension CGFloat {
    func collapse(toInset inset: CGFloat) -> CGFloat {
        return Swift.max(self, inset)
    }
}
//
//  MarginAdjustable.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/5/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/*
 Message views that implement the `MarginAdjustable` protocol will have their
 `layoutMargins` adjusted by SwiftMessages to account for the height of the
 status bar (when displayed under the status bar) and a small amount of
 overshoot in the bounce animation. `MessageView` implements this protocol
 by way of its parent class `BaseView`.
 
 For the effect of this protocol to work, subviews should be pinned to the
 message view's margins and the `layoutMargins` property should not be modified.
 
 This protocol is optional. A message view that doesn't implement `MarginAdjustable`
 is responsible for setting is own internal margins appropriately.
 */
public protocol MarginAdjustable {

    /// The amount to add to the safe area insets in calculating
    /// the layout margins.
    var layoutMarginAdditions: UIEdgeInsets { get }

    /// When `true`, SwiftMessages automatically collapses layout margin additions (topLayoutMarginAddition, etc.)
    /// when the default layout margins are greater than zero. This is typically used when a margin addition is only
    /// needed when the safe area inset is zero for a given edge. When the safe area inset for a given edge is non-zero,
    /// the additional margin is not added.
    var collapseLayoutMarginAdditions: Bool { get set }


    /// Start margins from the safe area.
    var respectSafeArea: Bool { get set }

    var bounceAnimationOffset: CGFloat { get set }
}

//
//  NSLayoutConstraint+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 5/18/19.
//  Copyright © 2019 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension NSLayoutConstraint {
    func with(priority: UILayoutPriority) -> NSLayoutConstraint {
        self.priority = priority
        return self
    }
}
//
//  CornerRoundingView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 7/28/18.
//  Copyright © 2018 SwiftKick Mobile. All rights reserved.
//

import UIKit

/// A background view that messages can use for rounding all or a subset of corners with squircles
/// (the smoother method of rounding corners that you see on app icons).
open class CornerRoundingView: UIView {

    /// Specifies the corner radius to use.
    @IBInspectable
    open var cornerRadius: CGFloat = 0 {
        didSet {
            updateMaskPath()
        }
    }

    /// Set to `true` for layouts where only the leading corners should be
    /// rounded. For example, the layout in TabView.xib rounds the bottom corners
    /// when displayed from the top and the top corners when displayed from the bottom.
    /// When this property is `true`, the `roundedCorners` property will be overwritten
    /// by relevant animators (e.g. `TopBottomAnimation`).
    @IBInspectable
    open var roundsLeadingCorners: Bool = false

    /// Specifies which corners should be rounded. When `roundsLeadingCorners = true`, relevant
    /// relevant animators (e.g. `TopBottomAnimation`) will overwrite the value of this property.
    open var roundedCorners: UIRectCorner = [.allCorners] {
        didSet {
            updateMaskPath()
        }
    }

    override public init(frame: CGRect) {
        super.init(frame: frame)
        sharedInit()
    }

    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        sharedInit()
    }

    private func sharedInit() {
        layer.mask = shapeLayer
    }

    private let shapeLayer = CAShapeLayer()

    override open func layoutSubviews() {
        super.layoutSubviews()
        updateMaskPath()
    }

    private func updateMaskPath() {
        let newPath = UIBezierPath(roundedRect: layer.bounds, byRoundingCorners: roundedCorners, cornerRadii: cornerRadii).cgPath
        // Update the `shapeLayer's` path with animation if we detect our `layer's` size is being animated.
        // This is a workaround needed for smooth rotation animations.
        if let foundAnimation = layer.findAnimation(forKeyPath: "bounds.size") {
            // Update the `shapeLayer's` path with animation, copying the relevant properties
            // from the found animation.
            let animation = CABasicAnimation(keyPath: "path")
            animation.duration = foundAnimation.duration
            animation.timingFunction = foundAnimation.timingFunction
            animation.fromValue = shapeLayer.path
            animation.toValue = newPath
            shapeLayer.add(animation, forKey: "path")
            shapeLayer.path = newPath
        } else {
            // Update the `shapeLayer's` path  without animation
            shapeLayer.path = newPath
        }
    }

    private var cornerRadii: CGSize {
        return CGSize(width: cornerRadius, height: cornerRadius)
    }
}
//
//  Animator.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/4/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

public typealias AnimationCompletion = (_ completed: Bool) -> Void

public protocol AnimationDelegate: AnyObject {
    func hide(animator: Animator)
    func panStarted(animator: Animator)
    func panEnded(animator: Animator)
}

/**
 An option set representing the known types of safe area conflicts
 that could require margin adjustments on the message view in order to
 get the layouts to look right.
 */
public struct SafeZoneConflicts: OptionSet {
    public let rawValue: Int

    public init(rawValue: Int) {
        self.rawValue = rawValue
    }

    /// Message view behind status bar
    public static let statusBar = SafeZoneConflicts(rawValue: 1 << 0)

    /// Message view behind the sensor notch on iPhone X
    public static let sensorNotch = SafeZoneConflicts(rawValue: 1 << 1)

    /// Message view behind home indicator on iPhone X
    public static let homeIndicator = SafeZoneConflicts(rawValue: 1 << 2)

    /// Message view is over the status bar on an iPhone 8 or lower. This is a special
    /// case because we logically expect the top safe area to be zero, but it is reported as 20
    /// (which seems like an iOS bug). We use the `overStatusBar` to indicate this special case.
    public static let overStatusBar = SafeZoneConflicts(rawValue: 1 << 3)
}

public class AnimationContext {

    public let messageView: UIView
    public let containerView: UIView
    public let safeZoneConflicts: SafeZoneConflicts
    public let interactiveHide: Bool

    init(messageView: UIView, containerView: UIView, safeZoneConflicts: SafeZoneConflicts, interactiveHide: Bool) {
        self.messageView = messageView
        self.containerView = containerView
        self.safeZoneConflicts = safeZoneConflicts
        self.interactiveHide = interactiveHide
    }
}

public protocol Animator: AnyObject {

    /// Adopting classes should declare as `weak`.
    var delegate: AnimationDelegate? { get set }

    func show(context: AnimationContext, completion: @escaping AnimationCompletion)

    func hide(context: AnimationContext, completion: @escaping AnimationCompletion)

    /// The show animation duration. If the animation duration is unknown, such as if using `UIDynamicAnimator`,
    /// then provide an estimate. This value is used by `SwiftMessagesSegue`.
    var showDuration: TimeInterval { get }

    /// The hide animation duration. If the animation duration is unknown, such as if using `UIDynamicAnimator`,
    /// then provide an estimate. This value is used by `SwiftMessagesSegue`.
    var hideDuration: TimeInterval { get }
}

//
//  BackgroundViewable.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/15/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/**
 Message views that implement the `BackgroundViewable` protocol will have the
 pan-to-hide gesture recognizer installed in the `backgroundView`. Message views
 always span the full width of the containing view. Typically, the `backgroundView`
 property defines the message view's visible region, allowing for card-style views
 where the message view background is transparent and the background view is inset
 from by some amount. See CardView.nib, for example.
 
 This protocol is optional. Message views that don't implement `BackgroundViewable`
 will have the pan-to-hide gesture installed in the message view itself.
 */
public protocol BackgroundViewable {
    var backgroundView: UIView! { get }
}//
//  UIWindow+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 3/11/21.
//  Copyright © 2021 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension UIWindow {
    #if !SWIFTMESSAGES_APP_EXTENSIONS
    static var keyWindow: UIWindow? {
        if #available(iOS 13.0, *) {
            return UIApplication.shared.connectedScenes
                .sorted { $0.activationState.sortPriority < $1.activationState.sortPriority }
                .compactMap { $0 as? UIWindowScene }
                .compactMap { $0.windows.first { $0.isKeyWindow } }
                .first
        } else {
            return UIApplication.shared.keyWindow
        }
    }
    #endif
}

@available(iOS 13.0, *)
private extension UIScene.ActivationState {
    var sortPriority: Int {
        switch self {
        case .foregroundActive: return 1
        case .foregroundInactive: return 2
        case .background: return 3
        case .unattached: return 4
        @unknown default: return 5
        }
    }
}
//
//  MessagePresenter.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 7/30/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

protocol PresenterDelegate: AnimationDelegate {
    func hide(presenter: Presenter)
}

class Presenter: NSObject {

    // MARK: - API

    init(config: SwiftMessages.Config, view: UIView, delegate: PresenterDelegate) {
        self.config = config
        self.view = view
        self.delegate = delegate
        self.animator = Presenter.animator(forPresentationStyle: config.presentationStyle, delegate: delegate)
        if let identifiable = view as? Identifiable {
            id = identifiable.id
        } else {
            var mutableView = view
            id = withUnsafePointer(to: &mutableView) { "\($0)" }
        }

        super.init()
    }
    
    var id: String
    var config: SwiftMessages.Config
    let maskingView = MaskingView()
    let animator: Animator
    var isHiding = false
    let view: UIView

    var delayShow: TimeInterval? {
        if case .indefinite(let delay, _) = config.duration { return delay }
        return nil
    }

    var showDate: CFTimeInterval?

    /// Returns the required delay for hiding based on time shown
    var delayHide: TimeInterval? {
        if interactivelyHidden { return 0 }
        if case .indefinite(_, let minimum) = config.duration, let showDate = showDate {
            let timeIntervalShown = CACurrentMediaTime() - showDate
            return max(0, minimum - timeIntervalShown)
        }
        return nil
    }

    var pauseDuration: TimeInterval? {
        let duration: TimeInterval?
        switch self.config.duration {
        case .automatic:
            duration = 2
        case .seconds(let seconds):
            duration = seconds
        case .forever, .indefinite:
            duration = nil
        }
        return duration
    }

    // MARK: - Constants

    enum PresentationContext {
        case viewController(_: Weak<UIViewController>)
        case view(_: Weak<UIView>)
        
        func viewControllerValue() -> UIViewController? {
            switch self {
            case .viewController(let weak):
                return weak.value
            case .view:
                return nil
            }
        }
        
        func viewValue() -> UIView? {
            switch self {
            case .viewController(let weak):
                return weak.value?.view
            case .view(let weak):
                return weak.value
            }
        }
    }

    // MARK: - Variables

    private weak var delegate: PresenterDelegate?
    private var presentationContext = PresentationContext.viewController(Weak<UIViewController>(value: nil))

    private var interactivelyHidden = false;

    // MARK: - Showing and hiding

    private static func animator(forPresentationStyle style: SwiftMessages.PresentationStyle, delegate: AnimationDelegate) -> Animator {
        switch style {
        case .top:
            return TopBottomAnimation(style: .top, delegate: delegate)
        case .bottom:
            return TopBottomAnimation(style: .bottom, delegate: delegate)
        case .center:
            return PhysicsAnimation(delegate: delegate)
        case .custom(let animator):
            animator.delegate = delegate
            return animator
        }
    }

    func show(completion: @escaping AnimationCompletion) throws {
        try presentationContext = getPresentationContext()
        install()
        self.config.eventListeners.forEach { $0(.willShow(self.view)) }
        showAnimation() { completed in
            completion(completed)
            if completed {
                if self.config.dimMode.modal {
                    self.showAccessibilityFocus()
                } else {
                    self.showAccessibilityAnnouncement()
                }
                self.config.eventListeners.forEach { $0(.didShow(self.view)) }
            }
        }
    }

    private func showAnimation(completion: @escaping AnimationCompletion) {

        func dim(_ color: UIColor) {
            self.maskingView.backgroundColor = UIColor.clear
            UIView.animate(withDuration: 0.2, animations: {
                self.maskingView.backgroundColor = color
            })
        }

        func blur(style: UIBlurEffect.Style, alpha: CGFloat) {
            let blurView = UIVisualEffectView(effect: nil)
            blurView.alpha = alpha
            maskingView.backgroundView = blurView
            UIView.animate(withDuration: 0.3) {
                blurView.effect = UIBlurEffect(style: style)
            }
        }

        let context = animationContext()
        animator.show(context: context) { (completed) in
            completion(completed)
        }
        switch config.dimMode {
        case .none:
            break
        case .gray:
            dim(UIColor(white: 0, alpha: 0.3))
        case .color(let color, _):
            dim(color)
        case .blur(let style, let alpha, _):
            blur(style: style, alpha: alpha)
        }
    }

    private func showAccessibilityAnnouncement() {
        guard let accessibleMessage = view as? AccessibleMessage,
            let message = accessibleMessage.accessibilityMessage else { return }
        UIAccessibility.post(notification: UIAccessibility.Notification.announcement, argument: message)
    }

    private func showAccessibilityFocus() {
        guard let accessibleMessage = view as? AccessibleMessage,
            let focus = accessibleMessage.accessibilityElement ?? accessibleMessage.additionalAccessibilityElements?.first else { return }
        UIAccessibility.post(notification: UIAccessibility.Notification.layoutChanged, argument: focus)
    }

    func hide(animated: Bool, completion: @escaping AnimationCompletion) {
        isHiding = true
        self.config.eventListeners.forEach { $0(.willHide(self.view)) }
        let context = animationContext()
        let action = {
            if let viewController = self.presentationContext.viewControllerValue() as? WindowViewController {
                viewController.uninstall()
            }
            self.maskingView.removeFromSuperview()
            completion(true)
            self.config.eventListeners.forEach { $0(.didHide(self.view)) }
        }
        guard animated else {
            action()
            return
        }
        animator.hide(context: context) { (completed) in
            action()
        }

        func undim() {
            UIView.animate(withDuration: 0.2, delay: 0, options: .beginFromCurrentState, animations: {
                self.maskingView.backgroundColor = UIColor.clear
            }, completion: nil)
        }

        func unblur() {
            guard let view = maskingView.backgroundView as? UIVisualEffectView else { return }
            UIView.animate(withDuration: 0.2, delay: 0, options: .beginFromCurrentState, animations: { 
                view.effect = nil
            }, completion: nil)
        }
        
        switch config.dimMode {
        case .none:
            break
        case .gray:
            undim()
        case .color:
            undim()
        case .blur:
            unblur()
        }
    }

    private func animationContext() -> AnimationContext {
        return AnimationContext(messageView: view, containerView: maskingView, safeZoneConflicts: safeZoneConflicts(), interactiveHide: config.interactiveHide)
    }

    private func safeZoneConflicts() -> SafeZoneConflicts {
        guard let window = maskingView.window else { return [] }
        let windowLevel: UIWindow.Level = {
            if let vc = presentationContext.viewControllerValue() as? WindowViewController {
                return vc.config.windowLevel ?? .normal
            }
            return .normal
        }()
        // `underNavigationBar` and `underTabBar` should look up the presentation context's hierarchy
        // for cases where both should be true (probably not an issue for typical height messages, though).
        let underNavigationBar: Bool = {
            if let vc = presentationContext.viewControllerValue() as? UINavigationController { return vc.sm_isVisible(view: vc.navigationBar) }
            return false
        }()
        let underTabBar: Bool = {
            if let vc = presentationContext.viewControllerValue() as? UITabBarController { return vc.sm_isVisible(view: vc.tabBar) }
            return false
        }()
        if #available(iOS 11, *) {
            if windowLevel > .normal {
                // seeing `maskingView.safeAreaInsets.top` value of 20 on
                // iPhone 8 with status bar window level. This seems like an iOS bug since
                // the message view's window is above the status bar. Applying a special rule
                // to allow the animator to revove this amount from the layout margins if needed.
                // This may need to be reworked if any future device has a legitimate 20pt top safe area,
                // such as with a potentially smaller notch.
                if maskingView.safeAreaInsets.top == 20 {
                    return [.overStatusBar]
                } else {
                    var conflicts: SafeZoneConflicts = []
                    if maskingView.safeAreaInsets.top > 0 {
                        conflicts.formUnion(.sensorNotch)
                    }
                    if maskingView.safeAreaInsets.bottom > 0 {
                        conflicts.formUnion(.homeIndicator)
                    }
                    return conflicts
                }
            }
            var conflicts: SafeZoneConflicts = []
            if !underNavigationBar {
                conflicts.formUnion(.sensorNotch)
            }
            if !underTabBar {
                conflicts.formUnion(.homeIndicator)
            }
            return conflicts
        } else {
            #if SWIFTMESSAGES_APP_EXTENSIONS
            return []
            #else
            if UIApplication.shared.isStatusBarHidden { return [] }
            if (windowLevel > UIWindow.Level.normal) || underNavigationBar { return [] }
            let statusBarFrame = UIApplication.shared.statusBarFrame
            let statusBarWindowFrame = window.convert(statusBarFrame, from: nil)
            let statusBarViewFrame = maskingView.convert(statusBarWindowFrame, from: nil)
            return statusBarViewFrame.intersects(maskingView.bounds) ? SafeZoneConflicts.statusBar : []
            #endif
        }
    }

    private func getPresentationContext() throws -> PresentationContext {

        func newWindowViewController() -> UIViewController {
            let viewController = WindowViewController.newInstance(config: config)
            return viewController
        }

        switch config.presentationContext {
        case .automatic:
            #if SWIFTMESSAGES_APP_EXTENSIONS
            throw SwiftMessagesError.noRootViewController
            #else
            if let rootViewController = UIWindow.keyWindow?.rootViewController {
                let viewController = rootViewController.sm_selectPresentationContextTopDown(config)
                return .viewController(Weak(value: viewController))
            } else {
                throw SwiftMessagesError.noRootViewController
            }
            #endif
        case .window:
            let viewController = newWindowViewController()
            return .viewController(Weak(value: viewController))
        case .windowScene:
            let viewController = newWindowViewController()
            return .viewController(Weak(value: viewController))
        case .viewController(let viewController):
            let viewController = viewController.sm_selectPresentationContextBottomUp(config)
            return .viewController(Weak(value: viewController))
        case .view(let view):
            return .view(Weak(value: view))
        }
    }

    /*
     MARK: - Installation
     */

    func install() {

        func topLayoutConstraint(view: UIView, containerView: UIView, viewController: UIViewController?) -> NSLayoutConstraint {
            if case .top = config.presentationStyle.topBottomStyle, let nav = viewController as? UINavigationController, nav.sm_isVisible(view: nav.navigationBar) {
                return NSLayoutConstraint(item: view, attribute: .top, relatedBy: .equal, toItem: nav.navigationBar, attribute: .bottom, multiplier: 1.00, constant: 0.0)
            }
            return NSLayoutConstraint(item: view, attribute: .top, relatedBy: .equal, toItem: containerView, attribute: .top, multiplier: 1.00, constant: 0.0)
        }

        func bottomLayoutConstraint(view: UIView, containerView: UIView, viewController: UIViewController?) -> NSLayoutConstraint {
            if case .bottom = config.presentationStyle.topBottomStyle, let tab = viewController as? UITabBarController, tab.sm_isVisible(view: tab.tabBar) {
                return NSLayoutConstraint(item: view, attribute: .bottom, relatedBy: .equal, toItem: tab.tabBar, attribute: .top, multiplier: 1.00, constant: 0.0)
            }
            return NSLayoutConstraint(item: view, attribute: .bottom, relatedBy: .equal, toItem: containerView, attribute: .bottom, multiplier: 1.00, constant: 0.0)
        }

        func installMaskingView(containerView: UIView) {
            maskingView.translatesAutoresizingMaskIntoConstraints = false
            if let nav = presentationContext.viewControllerValue() as? UINavigationController {
                containerView.insertSubview(maskingView, belowSubview: nav.navigationBar)
            } else if let tab = presentationContext.viewControllerValue() as? UITabBarController {
                containerView.insertSubview(maskingView, belowSubview: tab.tabBar)
            } else {
                containerView.addSubview(maskingView)
            }
            maskingView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor).isActive = true
            maskingView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor).isActive = true
            topLayoutConstraint(view: maskingView, containerView: containerView, viewController: presentationContext.viewControllerValue()).isActive = true
            bottomLayoutConstraint(view: maskingView, containerView: containerView, viewController: presentationContext.viewControllerValue()).isActive = true
            if let keyboardTrackingView = config.keyboardTrackingView {
                maskingView.install(keyboardTrackingView: keyboardTrackingView)
            }
            // Update the container view's layout in order to know the masking view's frame
            containerView.layoutIfNeeded()
        }

        func installInteractive() {
            guard config.dimMode.modal else { return }
            if config.dimMode.interactive {
                maskingView.tappedHander = { [weak self] in
                    guard let strongSelf = self else { return }
                    strongSelf.interactivelyHidden = true
                    strongSelf.delegate?.hide(presenter: strongSelf)
                }
            } else {
                // There's no action to take, but the presence of
                // a tap handler prevents interaction with underlying views.
                maskingView.tappedHander = { }
            }
        }

        func installAccessibility() {
            var elements: [NSObject] = []
            if let accessibleMessage = view as? AccessibleMessage {
                if let message = accessibleMessage.accessibilityMessage {
                    let element = accessibleMessage.accessibilityElement ?? view
                    element.isAccessibilityElement = true
                    if element.accessibilityLabel == nil {
                        element.accessibilityLabel = message
                    }
                    elements.append(element)
                }
                if let additional = accessibleMessage.additionalAccessibilityElements {
                    elements += additional
                }
            } else {
                    elements += [view]
            }
            if config.dimMode.interactive {
                let dismissView = UIView(frame: maskingView.bounds)
                dismissView.translatesAutoresizingMaskIntoConstraints = true
                dismissView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
                maskingView.addSubview(dismissView)
                maskingView.sendSubviewToBack(dismissView)
                dismissView.isUserInteractionEnabled = false
                dismissView.isAccessibilityElement = true
                dismissView.accessibilityLabel = config.dimModeAccessibilityLabel
                dismissView.accessibilityTraits = UIAccessibilityTraits.button
                elements.append(dismissView)
            }
            if config.dimMode.modal {
                maskingView.accessibilityViewIsModal = true
            }
            maskingView.accessibleElements = elements
        }

        guard let containerView = presentationContext.viewValue() else { return }
        (presentationContext.viewControllerValue() as? WindowViewController)?.install()
        installMaskingView(containerView: containerView)
        installInteractive()
        installAccessibility()
    }
}


//
//  NSBundle+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/8/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import Foundation

private class BundleToken {}

extension Bundle {
    // This is copied method from SPM generated Bundle.module for CocoaPods support
    static func sm_frameworkBundle() -> Bundle {

        let candidates = [
            // Bundle should be present here when the package is linked into an App.
            Bundle.main.resourceURL,

            // Bundle should be present here when the package is linked into a framework.
            Bundle(for: BundleToken.self).resourceURL,

            // For command-line tools.
            Bundle.main.bundleURL,
        ]

        let bundleNames = [
            // For Swift Package Manager
            "SwiftMessages_SwiftMessages",

            // For Carthage
            "SwiftMessages",
        ]

        for bundleName in bundleNames {
            for candidate in candidates {
                let bundlePath = candidate?.appendingPathComponent(bundleName + ".bundle")
                if let bundle = bundlePath.flatMap(Bundle.init(url:)) {
                    return bundle
                }
            }
        }

        // Return whatever bundle this code is in as a last resort.
        return Bundle(for: BundleToken.self)
    }
}
//
//  CALayer+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/3/18.
//  Copyright © 2018 SwiftKick Mobile. All rights reserved.
//

import QuartzCore

extension CALayer {
    func findAnimation(forKeyPath keyPath: String) -> CABasicAnimation? {
        return animationKeys()?
            .compactMap({ animation(forKey: $0) as? CABasicAnimation })
            .filter({ $0.keyPath == keyPath })
            .first
    }
}
//
//  Identifiable.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/1/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import Foundation

/**
 Message views that adopt the `Identifiable` protocol will have duplicate messages
 removed from the `MessageView` queue. Typically, the `id` would be set to a string
 representation of the content of the message view. For example, `MessageView`, combines
 the title and message body text.
 
 This protocol is optional. Message views that don't adopt `Identifiable` will not
 have duplicates removed.
 */
public protocol Identifiable {
    var id: String { get }
}
import Foundation
import UIKit

/// A workaround for the change in Xcode 13 that prevents using `@availability` attribute
/// with `enum` cases containing associated values.
public protocol WindowScene {}

@available(iOS 13.0, *)
extension UIWindowScene: WindowScene {}
//
//  Theme.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/7/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/// The theme enum specifies the built-in theme options
public enum Theme {
    case info
    case success
    case warning
    case error
}

/// The Icon enum provides type-safe access to the included icons.
public enum Icon: String {
    
    case error = "errorIcon"
    case warning = "warningIcon"
    case success = "successIcon"
    case info = "infoIcon"
    case errorLight = "errorIconLight"
    case warningLight = "warningIconLight"
    case successLight = "successIconLight"
    case infoLight = "infoIconLight"
    case errorSubtle = "errorIconSubtle"
    case warningSubtle = "warningIconSubtle"
    case successSubtle = "successIconSubtle"
    case infoSubtle = "infoIconSubtle"
    
    /// Returns the associated image.
    public var image: UIImage {
        return UIImage(named: rawValue, in: Bundle.sm_frameworkBundle(), compatibleWith: nil)!.withRenderingMode(.alwaysTemplate)
    }
}

/// The IconStyle enum specifies the different variations of the included icons.
public enum IconStyle {
    
    case `default`
    case light
    case subtle
    case none
    
    /// Returns the image for the given theme
    public func image(theme: Theme) -> UIImage? {
        switch (theme, self) {
        case (.info, .default): return Icon.info.image
        case (.info, .light): return Icon.infoLight.image
        case (.info, .subtle): return Icon.infoSubtle.image
        case (.success, .default): return Icon.success.image
        case (.success, .light): return Icon.successLight.image
        case (.success, .subtle): return Icon.successSubtle.image
        case (.warning, .default): return Icon.warning.image
        case (.warning, .light): return Icon.warningLight.image
        case (.warning, .subtle): return Icon.warningSubtle.image
        case (.error, .default): return Icon.error.image
        case (.error, .light): return Icon.errorLight.image
        case (.error, .subtle): return Icon.errorSubtle.image
        default: return nil
        }
    }
}
//
//  PassthroughWindow.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/5/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

class PassthroughWindow: UIWindow {

    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        // iOS has started embedding the SwiftMessages view in private views that block
        // interaction with views underneath, essentially making the window behave like a modal.
        // To work around this, we'll ignore hit test results on these views.
        let view = super.hitTest(point, with: event)
        if let view = view,
            let hitTestView = hitTestView,
            hitTestView.isDescendant(of: view) && hitTestView != view {
            return nil
        }
        return view
    }

    init(hitTestView: UIView) {
        self.hitTestView = hitTestView
        super.init(frame: .zero)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    private weak var hitTestView: UIView?
}
//
//  PhysicsPanHandler.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/25/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

open class PhysicsPanHandler {

    public var hideDelay: TimeInterval = 0.2

    public struct MotionSnapshot {
        var angle: CGFloat
        var time: CFAbsoluteTime
    }

    public final class State {

        weak var messageView: UIView?
        weak var containerView: UIView?
        var dynamicAnimator: UIDynamicAnimator
        var itemBehavior: UIDynamicItemBehavior
        var attachmentBehavior: UIAttachmentBehavior? {
            didSet {
                if let oldValue = oldValue {
                    dynamicAnimator.removeBehavior(oldValue)
                }
                if let attachmentBehavior = attachmentBehavior {
                    dynamicAnimator.addBehavior(attachmentBehavior)
                    addSnapshot()
                }
            }
        }
        var snapshots: [MotionSnapshot] = []

        public init(messageView: UIView, containerView: UIView) {
            self.messageView = messageView
            self.containerView = containerView
            let dynamicAnimator = UIDynamicAnimator(referenceView: containerView)
            let itemBehavior = UIDynamicItemBehavior(items: [messageView])
            itemBehavior.allowsRotation = true
            dynamicAnimator.addBehavior(itemBehavior)
            self.itemBehavior = itemBehavior
            self.dynamicAnimator = dynamicAnimator
        }

        func update(attachmentAnchorPoint anchorPoint: CGPoint) {
            addSnapshot()
            attachmentBehavior?.anchorPoint = anchorPoint
        }

        func addSnapshot() {
            let angle = messageView?.angle ?? snapshots.last?.angle ?? 0
            let time = CFAbsoluteTimeGetCurrent()
            snapshots.append(MotionSnapshot(angle: angle, time: time))
        }

        public func stop() {
            guard let messageView = messageView else {
                dynamicAnimator.removeAllBehaviors()
                return
            }
            let center = messageView.center
            let transform = messageView.transform
            dynamicAnimator.removeAllBehaviors()
            messageView.center = center
            messageView.transform = transform
        }

        public var angularVelocity: CGFloat {
            guard let last = snapshots.last else { return 0 }
            for previous in snapshots.reversed() {
                // Ignore snapshots where the angle or time hasn't changed to avoid degenerate cases.
                if previous.angle != last.angle && previous.time != last.time {
                    return (last.angle - previous.angle) / CGFloat(last.time - previous.time)
                }
            }
            return 0
        }
    }

    weak var animator: Animator?
    weak var messageView: UIView?
    weak var containerView: UIView?
    private(set) public var state: State?
    private(set) public var isOffScreen = false
    private var restingCenter: CGPoint?

    public init() {}

    public private(set) lazy var pan: UIPanGestureRecognizer = {
        let pan = UIPanGestureRecognizer()
        pan.addTarget(self, action: #selector(pan(_:)))
        return pan
    }()

    func configure(context: AnimationContext, animator: Animator) {
        if let oldView = (messageView as? BackgroundViewable)?.backgroundView ?? messageView {
            oldView.removeGestureRecognizer(pan)
        }
        messageView = context.messageView
        let view = (messageView as? BackgroundViewable)?.backgroundView ?? messageView
        view?.addGestureRecognizer(pan)
        containerView = context.containerView
        self.animator = animator
    }

    @objc func pan(_ pan: UIPanGestureRecognizer) {
        guard let messageView = messageView, let containerView = containerView, let animator = animator else { return }
        let anchorPoint = pan.location(in: containerView)
        switch pan.state {
        case .began:
            animator.delegate?.panStarted(animator: animator)
            let state = State(messageView: messageView, containerView: containerView)
            self.state = state
            let center = messageView.center
            restingCenter = center
            let offset = UIOffset(horizontal: anchorPoint.x - center.x, vertical: anchorPoint.y - center.y)
            let attachmentBehavior = UIAttachmentBehavior(item: messageView, offsetFromCenter: offset, attachedToAnchor: anchorPoint)
            state.attachmentBehavior = attachmentBehavior
            state.itemBehavior.action = { [weak self, weak messageView, weak containerView] in
                guard let self = self, !self.isOffScreen, let messageView = messageView, let containerView = containerView, let animator = self.animator else { return }
                let view = (messageView as? BackgroundViewable)?.backgroundView ?? messageView
                let frame = containerView.convert(view.bounds, from: view)
                if !containerView.bounds.intersects(frame) {
                    self.isOffScreen = true
                    DispatchQueue.main.asyncAfter(deadline: .now() + self.hideDelay) {
                        animator.delegate?.hide(animator: animator)
                    }
                }
            }
        case .changed:
            guard let state = state else { return }
            state.update(attachmentAnchorPoint: anchorPoint)
        case .ended, .cancelled:
            guard let state = state else { return }
            state.update(attachmentAnchorPoint: anchorPoint)
            let velocity = pan.velocity(in: containerView)
            let angularVelocity = state.angularVelocity
            let speed = sqrt(pow(velocity.x, 2) + pow(velocity.y, 2))
            // The multiplier on angular velocity was determined by hand-tuning
            let energy = sqrt(pow(speed, 2) + pow(angularVelocity * 75, 2))
            if energy > 200 && speed > 600 {
                // Limit the speed and angular velocity to reasonable values
                let speedScale = speed > 0 ? min(1, 1800 / speed) : 1
                let escapeVelocity = CGPoint(x: velocity.x * speedScale, y: velocity.y * speedScale)
                let angularSpeedScale = min(1, 10 / abs(angularVelocity))
                let escapeAngularVelocity = angularVelocity * angularSpeedScale
                state.itemBehavior.addLinearVelocity(escapeVelocity, for: messageView)
                state.itemBehavior.addAngularVelocity(escapeAngularVelocity, for: messageView)
                state.attachmentBehavior = nil
            } else {
                state.stop()
                self.state = nil
                animator.delegate?.panEnded(animator: animator)
                UIView.animate(withDuration: 0.5, delay: 0, usingSpringWithDamping: 0.65, initialSpringVelocity: 0, options: .beginFromCurrentState, animations: {
                    messageView.center = self.restingCenter ?? CGPoint(x: containerView.bounds.width / 2, y: containerView.bounds.height / 2)
                    messageView.transform = CGAffineTransform.identity
                }, completion: nil)
            }
        default:
            break
        }
    }
}

extension UIView {
    var angle: CGFloat {
        // http://stackoverflow.com/a/2051861/1271826
        return atan2(transform.b, transform.a)
    }
}
//
//  SwiftMessages.Config+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 12/26/20.
//  Copyright © 2020 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension SwiftMessages.Config {
    var windowLevel: UIWindow.Level? {
        switch presentationContext {
        case .window(let level): return level
        case .windowScene(_, let level): return level
        default: return nil
        }
    }

    @available (iOS 13.0, *)
    var windowScene: UIWindowScene? {
        switch presentationContext {
        case .windowScene(let scene, _): return scene as? UIWindowScene
        default:
            #if SWIFTMESSAGES_APP_EXTENSIONS
            return nil
            #else
            return UIWindow.keyWindow?.windowScene
            #endif
        }
    }

    var shouldBecomeKeyWindow: Bool {
        if let becomeKeyWindow = becomeKeyWindow { return becomeKeyWindow }
        switch dimMode {
        case .gray, .color, .blur:
            // Should become key window in modal presentation style
            // for proper VoiceOver handling.
            return true
        case .none:
            return false
        }
    }
}
//
//  TopBottomAnimation.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/4/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

public class TopBottomAnimation: NSObject, Animator {

    public enum Style {
        case top
        case bottom
    }

    public weak var delegate: AnimationDelegate?

    public let style: Style

    public var showDuration: TimeInterval = 0.4

    public var hideDuration: TimeInterval = 0.2

    public var springDamping: CGFloat = 0.8

    public var closeSpeedThreshold: CGFloat = 750.0;

    public var closePercentThreshold: CGFloat = 0.33;

    public var closeAbsoluteThreshold: CGFloat = 75.0;

    public private(set) lazy var panGestureRecognizer: UIPanGestureRecognizer = {
        let pan = UIPanGestureRecognizer()
        pan.addTarget(self, action: #selector(pan(_:)))
        return pan
    }()

    weak var messageView: UIView?
    weak var containerView: UIView?
    var context: AnimationContext?

    public init(style: Style) {
        self.style = style
    }

    init(style: Style, delegate: AnimationDelegate) {
        self.style = style
        self.delegate = delegate
    }

    public func show(context: AnimationContext, completion: @escaping AnimationCompletion) {
        NotificationCenter.default.addObserver(self, selector: #selector(adjustMargins), name: UIDevice.orientationDidChangeNotification, object: nil)
        install(context: context)
        showAnimation(completion: completion)
    }

    public func hide(context: AnimationContext, completion: @escaping AnimationCompletion) {
        NotificationCenter.default.removeObserver(self)
        let view = context.messageView
        self.context = context
        UIView.animate(withDuration: hideDuration, delay: 0, options: [.beginFromCurrentState, .curveEaseIn], animations: {
            switch self.style {
            case .top:
                view.transform = CGAffineTransform(translationX: 0, y: -view.frame.height)
            case .bottom:
                view.transform = CGAffineTransform(translationX: 0, y: view.frame.maxY + view.frame.height)
            }
        }, completion: { completed in
            #if SWIFTMESSAGES_APP_EXTENSIONS
            completion(completed)
            #else
            // Fix #131 by always completing if application isn't active.
            completion(completed || UIApplication.shared.applicationState != .active)
            #endif
        })
    }

    func install(context: AnimationContext) {
        let view = context.messageView
        let container = context.containerView
        messageView = view
        containerView = container
        self.context = context
        if let adjustable = context.messageView as? MarginAdjustable {
            bounceOffset = adjustable.bounceAnimationOffset
        }
        view.translatesAutoresizingMaskIntoConstraints = false
        container.addSubview(view)
        view.leadingAnchor.constraint(equalTo: container.leadingAnchor).isActive = true
        view.trailingAnchor.constraint(equalTo: container.trailingAnchor).isActive = true
        switch style {
        case .top:
            view.topAnchor.constraint(equalTo: container.topAnchor, constant: -bounceOffset).with(priority: UILayoutPriority(200)).isActive = true
        case .bottom:
            view.bottomAnchor.constraint(equalTo: container.bottomAnchor, constant: bounceOffset).with(priority: UILayoutPriority(200)).isActive = true
        }
        // Important to layout now in order to get the right safe area insets
        container.layoutIfNeeded()
        adjustMargins()
        container.layoutIfNeeded()
        let animationDistance = view.frame.height
        switch style {
        case .top:
            view.transform = CGAffineTransform(translationX: 0, y: -animationDistance)
        case .bottom:
            view.transform = CGAffineTransform(translationX: 0, y: animationDistance)
        }
        if context.interactiveHide {
            if let view = view as? BackgroundViewable {
                view.backgroundView.addGestureRecognizer(panGestureRecognizer)
            } else {
                view.addGestureRecognizer(panGestureRecognizer)
            }
        }
        if let view = view as? BackgroundViewable,
            let cornerRoundingView = view.backgroundView as? CornerRoundingView,
            cornerRoundingView.roundsLeadingCorners {
            switch style {
            case .top:
                cornerRoundingView.roundedCorners = [.bottomLeft, .bottomRight]
            case .bottom:
                cornerRoundingView.roundedCorners = [.topLeft, .topRight]
            }
        }
    }

    @objc public func adjustMargins() {
        guard let adjustable = messageView as? MarginAdjustable & UIView,
            let context = context else { return }
        adjustable.preservesSuperviewLayoutMargins = false
        if #available(iOS 11, *) {
            adjustable.insetsLayoutMarginsFromSafeArea = false
        }
        var layoutMargins = adjustable.defaultMarginAdjustment(context: context)
        switch style {
        case .top:
            layoutMargins.top += bounceOffset
        case .bottom:
            layoutMargins.bottom += bounceOffset
        }
        adjustable.layoutMargins = layoutMargins
    }

    func showAnimation(completion: @escaping AnimationCompletion) {
        guard let view = messageView else {
            completion(false)
            return
        }
        let animationDistance = abs(view.transform.ty)
        // Cap the initial velocity at zero because the bounceOffset may not be great
        // enough to allow for greater bounce induced by a quick panning motion.
        let initialSpringVelocity = animationDistance == 0.0 ? 0.0 : min(0.0, closeSpeed / animationDistance)
        UIView.animate(withDuration: showDuration, delay: 0.0, usingSpringWithDamping: springDamping, initialSpringVelocity: initialSpringVelocity, options: [.beginFromCurrentState, .curveLinear, .allowUserInteraction], animations: {
            view.transform = .identity
        }, completion: { completed in
            // Fix #131 by always completing if application isn't active.
            #if SWIFTMESSAGES_APP_EXTENSIONS
            completion(completed)
            #else
            completion(completed || UIApplication.shared.applicationState != .active)
            #endif
        })
    }

    fileprivate var bounceOffset: CGFloat = 5

    /*
     MARK: - Pan to close
     */

    fileprivate var closing = false
    fileprivate var rubberBanding = false
    fileprivate var closeSpeed: CGFloat = 0.0
    fileprivate var closePercent: CGFloat = 0.0
    fileprivate var panTranslationY: CGFloat = 0.0

    @objc func pan(_ pan: UIPanGestureRecognizer) {
        switch pan.state {
        case .changed:
            guard let view = messageView else { return }
            let height = view.bounds.height - bounceOffset
            if height <= 0 { return }
            var velocity = pan.velocity(in: view)
            var translation = pan.translation(in: view)
            if case .top = style {
                velocity.y *= -1.0
                translation.y *= -1.0
            }
            var translationAmount = translation.y >= 0 ? translation.y : -pow(abs(translation.y), 0.7)
            if !closing {
                // Turn on rubber banding if background view is inset from message view.
                if let background = (messageView as? BackgroundViewable)?.backgroundView, background != view {
                    switch style {
                    case .top:
                        rubberBanding = background.frame.minY > 0
                    case .bottom:
                        rubberBanding = background.frame.maxY < view.bounds.height
                    }
                }
                if !rubberBanding && translationAmount < 0 { return }
                closing = true
                delegate?.panStarted(animator: self)
            }
            if !rubberBanding && translationAmount < 0 { translationAmount = 0 }
            switch style {
            case .top:
                view.transform = CGAffineTransform(translationX: 0, y: -translationAmount)
            case .bottom:
                view.transform = CGAffineTransform(translationX: 0, y: translationAmount)
            }
            closeSpeed = velocity.y
            closePercent = translation.y / height
            panTranslationY = translation.y
        case .ended, .cancelled:
            if closeSpeed > closeSpeedThreshold || closePercent > closePercentThreshold || panTranslationY > closeAbsoluteThreshold {
                delegate?.hide(animator: self)
            } else {
                closing = false
                rubberBanding = false
                closeSpeed = 0.0
                closePercent = 0.0
                panTranslationY = 0.0
                showAnimation(completion: { (completed) in
                    self.delegate?.panEnded(animator: self)
                })
            }
        default:
            break
        }
    }
}

//
//  BaseView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/17/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/**
 The `BaseView` class is a reusable message view base class that implements some
 of the optional SwiftMessages protocols and provides some convenience functions
 and a configurable tap handler. Message views do not need to inherit from `BaseVew`.
 */
open class BaseView: UIView, BackgroundViewable, MarginAdjustable {

    /*
     MARK: - IB outlets
     */

    /**
     Fulfills the `BackgroundViewable` protocol and is the target for
     the optional `tapHandler` block. Defaults to `self`.
     */
    @IBOutlet open weak var backgroundView: UIView! {
        didSet {
            if let old = oldValue {
                old.removeGestureRecognizer(tapRecognizer)
            }
            installTapRecognizer()
            updateBackgroundHeightConstraint()
        }
    }

    // The `contentView` property was removed because it no longer had any functionality
    // in the framework. This is a minor backwards incompatible change. If you've copied
    // one of the included nib files from a previous release, you may get a key-value
    // coding runtime error related to contentView, in which case you can subclass the
    // view and add a `contentView` property or you can remove the outlet connection in
    // Interface Builder.
    // @IBOutlet public var contentView: UIView!

    /*
     MARK: - Initialization
     */

    public required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        backgroundView = self
        layoutMargins = UIEdgeInsets.zero
    }

    public override init(frame: CGRect) {
        super.init(frame: frame)
        backgroundView = self
        layoutMargins = UIEdgeInsets.zero
    }

    /*
     MARK: - Installing background and content
     */

    /**
     A convenience function for installing a content view as a subview of `backgroundView`
     and pinning the edges to `backgroundView` with the specified `insets`.

     - Parameter contentView: The view to be installed into the background view
       and assigned to the `contentView` property.
     - Parameter insets: The amount to inset the content view from the background view.
       Default is zero inset.
     */
    open func installContentView(_ contentView: UIView, insets: UIEdgeInsets = UIEdgeInsets.zero) {
        contentView.translatesAutoresizingMaskIntoConstraints = false
        backgroundView.addSubview(contentView)
        contentView.topAnchor.constraint(equalTo: backgroundView.topAnchor, constant: insets.top).isActive = true
        contentView.bottomAnchor.constraint(equalTo: backgroundView.bottomAnchor, constant: -insets.bottom).isActive = true
        contentView.leftAnchor.constraint(equalTo: backgroundView.leftAnchor, constant: insets.left).isActive = true
        contentView.rightAnchor.constraint(equalTo: backgroundView.rightAnchor, constant: -insets.right).isActive = true
        contentView.heightAnchor.constraint(equalToConstant: 350).with(priority: UILayoutPriority(rawValue: 200)).isActive = true
    }

    /**
     A convenience function for installing a background view and pinning to the layout margins.
     This is useful for creating programatic layouts where the background view needs to be
     inset from the message view's edges (like a card-style layout).

     - Parameter backgroundView: The view to be installed as a subview and
       assigned to the `backgroundView` property.
     - Parameter insets: The amount to inset the content view from the margins. Default is zero inset.
     */
    open func installBackgroundView(_ backgroundView: UIView, insets: UIEdgeInsets = UIEdgeInsets.zero) {
        backgroundView.translatesAutoresizingMaskIntoConstraints = false
        if backgroundView != self {
            backgroundView.removeFromSuperview()
        }
        addSubview(backgroundView)
        self.backgroundView = backgroundView
        backgroundView.centerXAnchor.constraint(equalTo: centerXAnchor).with(priority: UILayoutPriority(rawValue: 950)).isActive = true
        backgroundView.topAnchor.constraint(equalTo: layoutMarginsGuide.topAnchor, constant: insets.top).with(priority: UILayoutPriority(rawValue: 900)).isActive = true
        backgroundView.bottomAnchor.constraint(equalTo: layoutMarginsGuide.bottomAnchor, constant: -insets.bottom).with(priority: UILayoutPriority(rawValue: 900)).isActive = true
        backgroundView.heightAnchor.constraint(equalToConstant: 350).with(priority: UILayoutPriority(rawValue: 200)).isActive = true
        layoutConstraints = [
            backgroundView.leftAnchor.constraint(equalTo: layoutMarginsGuide.leftAnchor, constant: insets.left).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.rightAnchor.constraint(equalTo: layoutMarginsGuide.rightAnchor, constant: -insets.right).with(priority: UILayoutPriority(rawValue: 900)),
        ]
        regularWidthLayoutConstraints = [
            backgroundView.leftAnchor.constraint(greaterThanOrEqualTo: layoutMarginsGuide.leftAnchor, constant: insets.left).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.rightAnchor.constraint(lessThanOrEqualTo: layoutMarginsGuide.rightAnchor, constant: -insets.right).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.widthAnchor.constraint(lessThanOrEqualToConstant: 500).with(priority: UILayoutPriority(rawValue: 950)),
            backgroundView.widthAnchor.constraint(equalToConstant: 500).with(priority: UILayoutPriority(rawValue: 200)),
        ]
        installTapRecognizer()
    }

    /**
     A convenience function for installing a background view and pinning to the horizontal
     layout margins and to the vertical edges. This is useful for creating programatic layouts where
     the background view needs to be inset from the message view's horizontal edges (like a tab-style layout).

     - Parameter backgroundView: The view to be installed as a subview and
       assigned to the `backgroundView` property.
     - Parameter insets: The amount to inset the content view from the horizontal margins and vertical edges.
       Default is zero inset.
     */
    open func installBackgroundVerticalView(_ backgroundView: UIView, insets: UIEdgeInsets = UIEdgeInsets.zero) {
        backgroundView.translatesAutoresizingMaskIntoConstraints = false
        if backgroundView != self {
            backgroundView.removeFromSuperview()
        }
        addSubview(backgroundView)
        self.backgroundView = backgroundView
        backgroundView.centerXAnchor.constraint(equalTo: centerXAnchor).with(priority: UILayoutPriority(rawValue: 950)).isActive = true
        backgroundView.topAnchor.constraint(equalTo: topAnchor, constant: insets.top).with(priority: UILayoutPriority(rawValue: 1000)).isActive = true
        backgroundView.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -insets.bottom).with(priority: UILayoutPriority(rawValue: 1000)).isActive = true
        backgroundView.heightAnchor.constraint(equalToConstant: 350).with(priority: UILayoutPriority(rawValue: 200)).isActive = true
        layoutConstraints = [
            backgroundView.leftAnchor.constraint(equalTo: layoutMarginsGuide.leftAnchor, constant: insets.left).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.rightAnchor.constraint(equalTo: layoutMarginsGuide.rightAnchor, constant: -insets.right).with(priority: UILayoutPriority(rawValue: 900)),
        ]
        regularWidthLayoutConstraints = [
            backgroundView.leftAnchor.constraint(greaterThanOrEqualTo: layoutMarginsGuide.leftAnchor, constant: insets.left).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.rightAnchor.constraint(lessThanOrEqualTo: layoutMarginsGuide.rightAnchor, constant: -insets.right).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.widthAnchor.constraint(lessThanOrEqualToConstant: 500).with(priority: UILayoutPriority(rawValue: 950)),
            backgroundView.widthAnchor.constraint(equalToConstant: 500).with(priority: UILayoutPriority(rawValue: 200)),
        ]
        installTapRecognizer()
    }

    /*
     MARK: - Tap handler
     */

    /**
     An optional tap handler that will be called when the `backgroundView` is tapped.
     */
    open var tapHandler: ((_ view: BaseView) -> Void)? {
        didSet {
            installTapRecognizer()
        }
    }

    fileprivate lazy var tapRecognizer: UITapGestureRecognizer = {
        let tapRecognizer = UITapGestureRecognizer(target: self, action: #selector(MessageView.tapped))
        return tapRecognizer
    }()

    @objc func tapped() {
        tapHandler?(self)
    }

    fileprivate func installTapRecognizer() {
        guard let backgroundView = backgroundView else { return }
        removeGestureRecognizer(tapRecognizer)
        backgroundView.removeGestureRecognizer(tapRecognizer)
        if tapHandler != nil {
            // Only install the tap recognizer if there is a tap handler,
            // which makes it slightly nicer if one wants to install
            // a custom gesture recognizer.
            backgroundView.addGestureRecognizer(tapRecognizer)
        }
    }

    open override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
        if backgroundView != self {
            let backgroundViewPoint = convert(point, to: backgroundView)
            return backgroundView.point(inside: backgroundViewPoint, with: event)
        }
        return super.point(inside: point, with: event)
    }

    /*
     MARK: - MarginAdjustable

     These properties fulfill the `MarginAdjustable` protocol and are exposed
     as `@IBInspectables` so that they can be adjusted directly in nib files
     (see MessageView.nib).
     */

    public var layoutMarginAdditions: UIEdgeInsets {
        get {
            return UIEdgeInsets(top: topLayoutMarginAddition, left: leftLayoutMarginAddition, bottom: bottomLayoutMarginAddition, right: rightLayoutMarginAddition)
        }
        set {
            topLayoutMarginAddition = newValue.top
            leftLayoutMarginAddition = newValue.left
            bottomLayoutMarginAddition = newValue.bottom
            rightLayoutMarginAddition = newValue.right
        }
    }

    /// Start margins from the safe area.
    open var respectSafeArea: Bool = true

    /// IBInspectable access to layoutMarginAdditions.top
    open var topLayoutMarginAddition: CGFloat = 0

    /// IBInspectable access to layoutMarginAdditions.left
    open var leftLayoutMarginAddition: CGFloat = 0

    /// IBInspectable access to layoutMarginAdditions.bottom
    open var bottomLayoutMarginAddition: CGFloat = 0

    /// IBInspectable access to layoutMarginAdditions.right
    open var rightLayoutMarginAddition: CGFloat = 0

    open var collapseLayoutMarginAdditions: Bool = true

    open var bounceAnimationOffset: CGFloat = 5

    /*
     MARK: - Setting the height
     */

    /**
     An optional explicit height for the background view, which can be used if
     the message view's intrinsic content size does not produce the desired height.
     */
    open var backgroundHeight: CGFloat? {
        didSet {
            updateBackgroundHeightConstraint()
        }
    }

    private func updateBackgroundHeightConstraint() {
        if let existing = backgroundHeightConstraint {
            let view = existing.firstItem as! UIView
            view.removeConstraint(existing)
            backgroundHeightConstraint = nil
        }
        if let height = backgroundHeight, let backgroundView = backgroundView {
            let constraint = NSLayoutConstraint(item: backgroundView, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1, constant: height)
            backgroundView.addConstraint(constraint)
            backgroundHeightConstraint = constraint
        }
    }

    private var backgroundHeightConstraint: NSLayoutConstraint?

    /*
     Mark: - Layout
    */

    open override func updateConstraints() {
        super.updateConstraints()
        let on: [NSLayoutConstraint]
        let off: [NSLayoutConstraint]
        switch traitCollection.horizontalSizeClass {
        case .regular:
            on = regularWidthLayoutConstraints
            off = layoutConstraints
        default:
            on = layoutConstraints
            off = regularWidthLayoutConstraints
        }
        on.forEach { $0.isActive = true }
        off.forEach { $0.isActive = false }
    }

    private var layoutConstraints: [NSLayoutConstraint] = []
    private var regularWidthLayoutConstraints: [NSLayoutConstraint] = []
}

/*
 MARK: - Theming
 */

extension BaseView {

    /// A convenience function to configure a default drop shadow effect.
    /// The shadow is to this view's layer instead of that of the background view
    /// because the background view may be masked. So, when modifying the drop shadow,
    /// be sure to set the shadow properties of this view's layer. The shadow path is
    /// updated for you automatically.
    open func configureDropShadow() {
        layer.shadowColor = UIColor.black.cgColor
        layer.shadowOffset = CGSize(width: 0.0, height: 2.0)
        layer.shadowRadius = 6.0
        layer.shadowOpacity = 0.4
        layer.masksToBounds = false
        updateShadowPath()
    }

    /// A convenience function to turn off drop shadow
    open func configureNoDropShadow() {
        layer.shadowOpacity = 0
    }

    private func updateShadowPath() {
        backgroundView?.layoutIfNeeded()
        let shadowLayer = backgroundView?.layer ?? layer
        let shadowRect = layer.convert(shadowLayer.bounds, from: shadowLayer)
        let shadowPath: CGPath?
        if let backgroundMaskLayer = shadowLayer.mask as? CAShapeLayer,
            let backgroundMaskPath = backgroundMaskLayer.path {
            var transform = CGAffineTransform(translationX: shadowRect.minX, y: shadowRect.minY)
            shadowPath = backgroundMaskPath.copy(using: &transform)
        } else {
            shadowPath = UIBezierPath(roundedRect: shadowRect, cornerRadius: shadowLayer.cornerRadius).cgPath
        }
        // This is a workaround needed for smooth rotation animations.
        if let foundAnimation = layer.findAnimation(forKeyPath: "bounds.size") {
            // Update the layer's `shadowPath` with animation, copying the relevant properties
            // from the found animation.
            let animation = CABasicAnimation(keyPath: "shadowPath")
            animation.duration = foundAnimation.duration
            animation.timingFunction = foundAnimation.timingFunction
            animation.fromValue = layer.shadowPath
            animation.toValue = shadowPath
            layer.add(animation, forKey: "shadowPath")
            layer.shadowPath = shadowPath
        } else {
            // Update the layer's `shadowPath` without animation
            layer.shadowPath = shadowPath        }
    }

    open override func layoutSubviews() {
        super.layoutSubviews()
        updateShadowPath()
    }
}

/*
 MARK: - Configuring the width

 This extension provides a few convenience functions for configuring the
 background view's width. You are encouraged to write your own such functions
 if these don't exactly meet your needs.
 */

extension BaseView {

    /**
     A shortcut for configuring the left and right layout margins. For views that
     have `backgroundView` as a subview of `MessageView`, the background view should
     be pinned to the left and right `layoutMargins` in order for this configuration to work.
     */
    public func configureBackgroundView(sideMargin: CGFloat) {
        layoutMargins.left = sideMargin
        layoutMargins.right = sideMargin
    }

    /**
     A shortcut for adding a width constraint to the `backgroundView`. When calling this
     method, it is important to ensure that the width constraint doesn't conflict with
     other constraints. The CardView.nib and TabView.nib layouts are compatible with
     this method.
     */
    public func configureBackgroundView(width: CGFloat) {
        guard let backgroundView = backgroundView else { return }
        let constraint = NSLayoutConstraint(item: backgroundView, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1, constant: width)
        backgroundView.addConstraint(constraint)
    }
}
//
//  Weak.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/4/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import Foundation

public class Weak<T: AnyObject> {
    public weak var value : T?
    public init(value: T?) {
        self.value = value
    }
}
//
//  SwiftMessagesSegue.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 5/30/18.
//  Copyright © 2018 SwiftKick Mobile. All rights reserved.
//

import UIKit

/**
 `SwiftMessagesSegue` is a configurable subclass of `UIStoryboardSegue` that utilizes
 SwiftMessages to present and dismiss modal view controllers. It performs these transitions by
 becoming your view controller's `transitioningDelegate` and calling SwiftMessage's `show()`
 and `hide()` under the hood.

 To use `SwiftMessagesSegue` with Interface Builder, control-drag a segue, then select
 "swift messages" from the Segue Type dialog. This configures a default transition. There are
 two suggested ways to further configure the transition by setting options on `SwiftMessagesSegue`.
 First, and recommended, you may subclass `SwiftMessagesSegue` and override `init(identifier:source:destination:)`.
 Subclasses will automatically appear in the segue type dialog using an auto-generated name (for example, the
 name for "VeryNiceSegue" would be "very nice"). Second, you may override `prepare(for:sender:)` in the
 presenting view controller and downcast the segue to `SwiftMessagesSegue`.

 `SwiftMessagesSegue` can be used without an associated storyboard or segue by doing the following in
 the presenting view controller.

     let destinationVC = ... // make a reference to a destination view controller
     let segue = SwiftMessagesSegue(identifier: nil, source: self, destination: destinationVC)
     ... // do any configuration here
     segue.perform()

 To dismiss, call the UIKit API on the presenting view controller:

     dismiss(animated: true, completion: nil)

 It is not necessary to retain `segue` because it retains itself until dismissal. However, you can
 retain it if you plan to `perform()` more than once.

 #### Present the controller on top of all controllers

 If you don't know the presenter or you don't want to pass it as a source, like when you
 have a completely separated message controller, you can pass a `WindowViewController`
 as the `source` argument of the segue's initializer.

 By default, the window will be shown in the current window scene at `.normal` window level.
 However, these parameters can be customized by initializing the view controller with a `SwiftMessages.Config` that has the `SwiftMessages.Config.presentationContext` set to either `.window` or `.windowScene`:

 + note: Some additional details:
 1. Your view controller's view will be embedded in a `SwiftMessages.BaseView` in order to
 utilize some SwiftMessages features. This view can be accessed and configured via the
 `SwiftMessagesSegue.messageView` property. For example, you may configure a default drop
 shadow by calling `segue.messageView.configureDropShadow()`.
 2. SwiftMessagesSegue provides static default view controller sizing based on device.
 However, it is recommended that you specify sizing appropriate for your content using
 one of the following methods.
    1. Define sufficient width and height constraints in your view controller.
    2. Set `preferredContentSize` (a.k.a "Use Preferred Explicit Size" in Interface Builder's
       attribute inspector). Zeros are ignored, e.g. `CGSize(width: 0, height: 350)` only
       affects the height.
    3. Add explicit width and/or height constraints to `segue.messageView.backgroundView`.
    Note that `Layout.topMessage` and `Layout.bottomMessage` are always full screen width.
    For other layouts, the there is a maximum 500pt width on iPad (regular horizontal size class)
    at 950 priority, which can be overridden by adding higher-priority constraints.
 
 See the "View Controllers" selection in the Demo app for examples.
 */

open class SwiftMessagesSegue: UIStoryboardSegue {

    /**
     Specifies one of the pre-defined layouts, mirroring a subset of `MessageView.Layout`.
     */
    public enum Layout {

        /// The standard message view layout on top.
        case topMessage

        /// The standard message view layout on bottom.
        case bottomMessage

        /// A floating card-style view with rounded corners on top
        case topCard

        /// A floating tab-style view with rounded corners on bottom
        case topTab

        /// A floating card-style view with rounded corners on bottom
        case bottomCard

        /// A floating tab-style view with rounded corners on top
        case bottomTab

        /// A floating card-style view typically used with `.center` presentation style.
        case centered
    }

    /**
     Specifies how the view controller's view is installed into the
     containing message view.
     */
    public enum Containment {

        /**
         The view controller's view is installed for edge-to-edge display, extending into the safe areas
         to the device edges. This is done by calling `messageView.installContentView(:insets:)`
         See that method's documentation for additional details.
        */
        case content

        /**
         The view controller's view is installed for card-style layouts, inset from the margins
         and avoiding safe areas. This is done by calling `messageView.installBackgroundView(:insets:)`.
         See that method's documentation for details.
        */
        case background

        /**
         The view controller's view is installed for tab-style layouts, inset from the side margins, but extending
         to the device edge on the top or bottom. This is done by calling `messageView.installBackgroundVerticalView(:insets:)`.
         See that method's documentation for details.
         */
        case backgroundVertical
    }

    /// The presentation style to use. See the SwiftMessages.PresentationStyle for details.
    public var presentationStyle: SwiftMessages.PresentationStyle {
        get { return messenger.defaultConfig.presentationStyle }
        set { messenger.defaultConfig.presentationStyle = newValue }
    }

    /// The dim mode to use. See the SwiftMessages.DimMode for details.
    public var dimMode: SwiftMessages.DimMode {
        get { return messenger.defaultConfig.dimMode}
        set { messenger.defaultConfig.dimMode = newValue }
    }
    
    // duration
    public var duration: SwiftMessages.Duration {
        get { return messenger.defaultConfig.duration}
        set { messenger.defaultConfig.duration = newValue }
    }

    /// Specifies whether or not the interactive pan-to-hide gesture is enabled
    /// on the message view. The default value is `true`, but may not be appropriate
    /// for view controllers that use swipe or pan gestures.
    public var interactiveHide: Bool {
        get { return messenger.defaultConfig.interactiveHide }
        set { messenger.defaultConfig.interactiveHide = newValue }
    }

    /// Specifies an optional array of event listeners.
    public var eventListeners: [SwiftMessages.EventListener] {
        get { return messenger.defaultConfig.eventListeners }
        set { messenger.defaultConfig.eventListeners = newValue }
    }

    /**
     Normally, the destination view controller's `modalPresentationStyle` is changed
     to `.custom` in the `perform()` function. Set this property to `false` to prevent it from
     being overridden.
    */
    public var overrideModalPresentationStyle: Bool = true

    /**
     The view that is passed to `SwiftMessages.show(config:view:)` during presentation.
     The view controller's view is installed into `containerView`, which is itself installed
     into `messageView`. `SwiftMessagesSegue` does this installation automatically based on the
     value of the `containment` property. `BaseView` is the parent of `MessageView` and provides a
     number of configuration options that you may use. For example, you may configure a default drop
     shadow by calling `messageView.configureDropShadow()`.
     */
    public var messageView = BaseView()

    /**
     The view controller's view is embedded in `containerView` before being installed into
     `messageView`. This view provides configurable squircle (round) corners (see the parent
     class `CornerRoundingView`).
    */
    public var containerView: CornerRoundingView = CornerRoundingView()

    /**
     Specifies how the view controller's view is installed into the
     containing message view. See `Containment` for details.
     */
    public var containment: Containment = .content

    /**
     Supply an instance of `KeyboardTrackingView` to have the message view avoid the keyboard.
     */
    public var keyboardTrackingView: KeyboardTrackingView? {
        get {
            return messenger.defaultConfig.keyboardTrackingView
        }
        set {
            messenger.defaultConfig.keyboardTrackingView = newValue
        }
    }

    private var messenger = SwiftMessages()
    private var selfRetainer: SwiftMessagesSegue? = nil
    private lazy var hider = { return TransitioningDismisser(segue: self) }()

    private lazy var presenter = {
        return Presenter(config: messenger.defaultConfig, view: messageView, delegate: messenger)
    }()

    override open func perform() {
        (source as? WindowViewController)?.install()
        selfRetainer = self
        if overrideModalPresentationStyle {
            destination.modalPresentationStyle = .custom
        }
        destination.transitioningDelegate = self
        source.present(destination, animated: true, completion: nil)
    }

    override public init(identifier: String?, source: UIViewController, destination: UIViewController) {
        super.init(identifier: identifier, source: source, destination: destination)
        dimMode = .gray(interactive: true)
        messenger.defaultConfig.duration = .forever
    }

    fileprivate let safeAreaWorkaroundViewController = UIViewController()
}

extension SwiftMessagesSegue {
    /// A convenience method for configuring some pre-defined layouts that mirror a subset of `MessageView.Layout`.
    public func configure(layout: Layout) {
        messageView.bounceAnimationOffset = 0
        containment = .content
        containerView.cornerRadius = 0
        containerView.roundsLeadingCorners = false
        messageView.configureDropShadow()
        switch layout {
        case .topMessage:
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)
            messageView.collapseLayoutMarginAdditions = false
            let animation = TopBottomAnimation(style: .top)
            animation.springDamping = 1
            presentationStyle = .custom(animator: animation)
        case .bottomMessage:
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)
            messageView.collapseLayoutMarginAdditions = false
            let animation = TopBottomAnimation(style: .bottom)
            animation.springDamping = 1
            presentationStyle = .custom(animator: animation)
        case .topCard:
            containment = .background
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            presentationStyle = .top
        case .bottomCard:
            containment = .background
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            presentationStyle = .bottom
        case .topTab:
            containment = .backgroundVertical
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 20, left: 10, bottom: 20, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            containerView.roundsLeadingCorners = true
            let animation = TopBottomAnimation(style: .top)
            animation.springDamping = 1
            presentationStyle = .custom(animator: animation)
        case .bottomTab:
            containment = .backgroundVertical
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 20, left: 10, bottom: 20, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            containerView.roundsLeadingCorners = true
            let animation = TopBottomAnimation(style: .bottom)
            animation.springDamping = 1
            presentationStyle = .custom(animator: animation)
        case .centered:
            containment = .background
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            presentationStyle = .center
        }
    }
}

extension SwiftMessagesSegue: UIViewControllerTransitioningDelegate {
    public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        let shower = TransitioningPresenter(segue: self)
        messenger.defaultConfig.eventListeners.append { [unowned self] in
            switch $0 {
            case .didShow:
                shower.completeTransition?(true)
            case .didHide:
                if let completeTransition = self.hider.completeTransition {
                    completeTransition(true)
                } else {
                    // Case where message is internally hidden by SwiftMessages, such as with a
                    // dismiss gesture, rather than by view controller dismissal.
                    source.dismiss(animated: false, completion: nil)
                }
                (source as? WindowViewController)?.uninstall()
                self.selfRetainer = nil
            default: break
            }
        }
        return shower
    }

    public func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        return hider
    }
}

extension SwiftMessagesSegue {
    private class TransitioningPresenter: NSObject, UIViewControllerAnimatedTransitioning {

        fileprivate private(set) var completeTransition: ((Bool) -> Void)?
        private weak var segue: SwiftMessagesSegue?

        fileprivate init(segue: SwiftMessagesSegue) {
            self.segue = segue
        }

        func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
            return segue?.presenter.animator.showDuration ?? 0.5
        }

        func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
            guard let segue = segue,
                let toView = transitionContext.view(forKey: .to) else {
                transitionContext.completeTransition(false)
                return
            }
            if #available(iOS 12, *) {}
            else if #available(iOS 11.0, *) {
                // This works around a bug in iOS 11 where the safe area of `messageView` (
                // and all ancestor views) is not set except on iPhone X. By assigning `messageView`
                // to a view controller, its safe area is set consistently. This bug has been resolved as
                // of Xcode 10 beta 2.
                segue.safeAreaWorkaroundViewController.view = segue.presenter.maskingView
            }
            completeTransition = transitionContext.completeTransition
            let transitionContainer = transitionContext.containerView
            toView.translatesAutoresizingMaskIntoConstraints = false
            segue.containerView.addSubview(toView)
            segue.containerView.topAnchor.constraint(equalTo: toView.topAnchor).isActive = true
            segue.containerView.bottomAnchor.constraint(equalTo: toView.bottomAnchor).isActive = true
            segue.containerView.leadingAnchor.constraint(equalTo: toView.leadingAnchor).isActive = true
            segue.containerView.trailingAnchor.constraint(equalTo: toView.trailingAnchor).isActive = true
            // Install the `toView` into the message view.
            switch segue.containment {
            case .content:
                segue.messageView.installContentView(segue.containerView)
            case .background:
                segue.messageView.installBackgroundView(segue.containerView)
            case .backgroundVertical:
                segue.messageView.installBackgroundVerticalView(segue.containerView)
            }
            let toVC = transitionContext.viewController(forKey: .to)
            if let preferredHeight = toVC?.preferredContentSize.height,
                preferredHeight > 0 {
                segue.containerView.heightAnchor.constraint(equalToConstant: preferredHeight).with(priority: UILayoutPriority(rawValue: 951)).isActive = true
            }
            if let preferredWidth = toVC?.preferredContentSize.width,
                preferredWidth > 0 {
                segue.containerView.widthAnchor.constraint(equalToConstant: preferredWidth).with(priority: UILayoutPriority(rawValue: 951)).isActive = true
            }
            segue.presenter.config.presentationContext = .view(transitionContainer)
            segue.messenger.show(presenter: segue.presenter)
        }
    }
}

extension SwiftMessagesSegue {
    private class TransitioningDismisser: NSObject, UIViewControllerAnimatedTransitioning {

        fileprivate private(set) var completeTransition: ((Bool) -> Void)?
        private weak var segue: SwiftMessagesSegue?

        fileprivate init(segue: SwiftMessagesSegue) {
            self.segue = segue
        }

        func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
            return segue?.presenter.animator.hideDuration ?? 0.5
        }

        func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
            guard let messenger = segue?.messenger else {
                transitionContext.completeTransition(false)
                return
            }
            completeTransition = transitionContext.completeTransition
            messenger.hide()
        }
    }
}
//
//  MessageView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 7/30/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/*
 */
open class MessageView: BaseView, Identifiable, AccessibleMessage {
    
    /*
     MARK: - Button tap handler
     */
    
    /// An optional button tap handler. The `button` is automatically
    /// configured to call this tap handler on `.TouchUpInside`.
    open var buttonTapHandler: ((_ button: UIButton) -> Void)?
    
    @objc func buttonTapped(_ button: UIButton) {
        buttonTapHandler?(button)
    }

    /*
     MARK: - Touch handling
     */

    open override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
        // Only accept touches within the background view. Anything outside of the
        // background view's bounds should be transparent and does not need to receive
        // touches. This helps with tap dismissal when using `DimMode.gray` and `DimMode.color`.
        return backgroundView == self
            ? super.point(inside: point, with: event)
            : backgroundView.point(inside: convert(point, to: backgroundView), with: event)
    }

    /*
     MARK: - IB outlets
     */
    
    /// An optional title label.
    @IBOutlet open var titleLabel: UILabel?
    
    /// An optional body text label.
    @IBOutlet open var bodyLabel: UILabel?
    
    /// An optional icon image view.
    @IBOutlet open var iconImageView: UIImageView?
    
    /// An optional icon label (e.g. for emoji character, icon font, etc.).
    @IBOutlet open var iconLabel: UILabel?
    
    /// An optional button. This buttons' `.TouchUpInside` event will automatically
    /// invoke the optional `buttonTapHandler`, but its fine to add other target
    /// action handlers can be added.
    @IBOutlet open var button: UIButton? {
        didSet {
            if let old = oldValue {
                old.removeTarget(self, action: #selector(MessageView.buttonTapped(_:)), for: .touchUpInside)
            }
            if let button = button {
                button.addTarget(self, action: #selector(MessageView.buttonTapped(_:)), for: .touchUpInside)
            }
        }
    }
    
    /*
     MARK: - Identifiable
     */
    
    open var id: String {
        get {
            return customId ?? "MessageView:title=\(String(describing: titleLabel?.text)), body=\(String(describing: bodyLabel?.text))"
        }
        set {
            customId = newValue
        }
    }
    
    private var customId: String?

    /*
     MARK: - AccessibleMessage
     */

    /**
     An optional prefix for the `accessibilityMessage` that can
     be used to further clarify the message for VoiceOver. For example,
     the view's background color or icon might convey that a message is
     a warning, in which case one may specify the value "warning".
     */
    open var accessibilityPrefix: String?

    open var accessibilityMessage: String? {
        #if swift(>=4.1)
        let components = [accessibilityPrefix, titleLabel?.text, bodyLabel?.text].compactMap { $0 }
        #else
        let components = [accessibilityPrefix, titleLabel?.text, bodyLabel?.text].flatMap { $0 }
        #endif
        guard components.count > 0 else { return nil }
        return components.joined(separator: ", ")
    }

    public var accessibilityElement: NSObject? {
        return backgroundView
    }

    open var additionalAccessibilityElements: [NSObject]? {
        var elements: [NSObject] = []
        func getAccessibleSubviews(view: UIView) {
            for subview in view.subviews {
                if subview.isAccessibilityElement {
                    elements.append(subview)
                } else {
                    // Only doing this for non-accessible `subviews`, which avoids
                    // including button labels, etc.
                    getAccessibleSubviews(view: subview)
                }
            }
        }
        getAccessibleSubviews(view: self.backgroundView)
        return elements
    }
}

/*
 MARK: - Creating message views
 
 This extension provides several convenience functions for instantiating
 `MessageView` from the included nib files in a type-safe way. These nib 
 files can be found in the Resources folder and can be drag-and-dropped 
 into a project and modified. You may still use these APIs if you've
 copied the nib files because SwiftMessages looks for them in the main
 bundle first. See `SwiftMessages` for additional nib loading options.
 */

extension MessageView {
    
    /**
     Specifies one of the nib files included in the Resources folders.
     */
    public enum Layout: String {
        
        /**
         The standard message view that stretches across the full width of the
         container view.
         */
        case messageView = "MessageView"
        
        /**
         A floating card-style view with rounded corners.
         */
        case cardView = "CardView"

        /**
         Like `CardView` with one end attached to the super view.
         */
        case tabView = "TabView"

        /**
         A 20pt tall view that can be used to overlay the status bar.
         Note that this layout will automatically grow taller if displayed
         directly under the status bar (see the `ContentInsetting` protocol).
         */
        case statusLine = "StatusLine"

        /**
         A floating card-style view with elements centered and arranged vertically.
         This view is typically used with `.center` presentation style.         
         */
        case centeredView = "CenteredView"
    }
    
    /**
     Loads the nib file associated with the given `Layout` and returns the first
     view found in the nib file with the matching type `T: MessageView`.
     
     - Parameter layout: The `Layout` option to use.
     - Parameter filesOwner: An optional files owner.
     
     - Returns: An instance of generic view type `T: MessageView`.
     */
    public static func viewFromNib<T: MessageView>(layout: Layout, filesOwner: AnyObject = NSNull.init()) -> T {
        return try! SwiftMessages.viewFromNib(named: layout.rawValue)
    }
    
    /**
     Loads the nib file associated with the given `Layout` from
     the given bundle and returns the first view found in the nib
     file with the matching type `T: MessageView`.
     
     - Parameter layout: The `Layout` option to use.
     - Parameter bundle: The name of the bundle containing the nib file.
     - Parameter filesOwner: An optional files owner.
     
     - Returns: An instance of generic view type `T: MessageView`.
     */
    public static func viewFromNib<T: MessageView>(layout: Layout, bundle: Bundle, filesOwner: AnyObject = NSNull.init()) -> T {
        return try! SwiftMessages.viewFromNib(named: layout.rawValue, bundle: bundle, filesOwner: filesOwner)
    }
}

/*
 MARK: - Layout adjustments

 This extension provides a few convenience functions for adjusting the layout.
 */

extension MessageView {
    /**
     Constrains the image view to a specified size. By default, the size of the
     image view is determined by its `intrinsicContentSize`.
     
     - Parameter size: The size to be translated into Auto Layout constraints.
     - Parameter contentMode: The optional content mode to apply.
     */
    public func configureIcon(withSize size: CGSize, contentMode: UIView.ContentMode? = nil) {
        var views: [UIView] = []
        if let iconImageView = iconImageView { views.append(iconImageView) }
        if let iconLabel = iconLabel { views.append(iconLabel) }
        views.forEach {
            let constraints = [$0.heightAnchor.constraint(equalToConstant: size.height),
                               $0.widthAnchor.constraint(equalToConstant: size.width)]
            constraints.forEach { $0.priority = UILayoutPriority(999.0) }
            $0.addConstraints(constraints)
            if let contentMode = contentMode {
                $0.contentMode = contentMode
            }
        }
    }
}

/*
 MARK: - Theming
 
 This extension provides a few convenience functions for setting styles,
 colors and icons. You are encouraged to write your own such functions
 if these don't exactly meet your needs.
 */

extension MessageView {
    
    /**
     A convenience function for setting some pre-defined colors and icons.
     
     - Parameter theme: The theme type to use.
     - Parameter iconStyle: The icon style to use. Defaults to `.Default`.
     */
    public func configureTheme(_ theme: Theme, iconStyle: IconStyle = .default) {
        let iconImage = iconStyle.image(theme: theme)
        let backgroundColor: UIColor
        let foregroundColor: UIColor
        let defaultBackgroundColor: UIColor
        let defaultForegroundColor: UIColor
        switch theme {
        case .info:
            defaultBackgroundColor = UIColor(red: 225.0/255.0, green: 225.0/255.0, blue: 225.0/255.0, alpha: 1.0)
            defaultForegroundColor = UIColor.darkText
        case .success:
            defaultBackgroundColor = UIColor(red: 97.0/255.0, green: 161.0/255.0, blue: 23.0/255.0, alpha: 1.0)
            defaultForegroundColor = UIColor.white
        case .warning:
            defaultBackgroundColor = UIColor(red: 246.0/255.0, green: 197.0/255.0, blue: 44.0/255.0, alpha: 1.0)
            defaultForegroundColor = UIColor.white
        case .error:
            defaultBackgroundColor = UIColor(red: 249.0/255.0, green: 66.0/255.0, blue: 47.0/255.0, alpha: 1.0)
            defaultForegroundColor = UIColor.white
        }
        if #available(iOS 13.0, *) {
            switch theme {
            case .info:
                backgroundColor = UIColor {
                    switch $0.userInterfaceStyle {
                    case .dark, .unspecified: return UIColor(red: 125/255.0, green: 125/255.0, blue: 125/255.0, alpha: 1.0)
                    case .light: fallthrough
                    @unknown default:
                        return defaultBackgroundColor
                    }
                }
                foregroundColor = .label
            case .success:
                backgroundColor = UIColor {
                    switch $0.userInterfaceStyle {
                    case .dark, .unspecified: return UIColor(red: 55/255.0, green: 122/255.0, blue: 0/255.0, alpha: 1.0)
                    case .light: fallthrough
                    @unknown default:
                        return defaultBackgroundColor
                    }
                }
                foregroundColor = .white
            case .warning:
                backgroundColor = UIColor {
                    switch $0.userInterfaceStyle {
                    case .dark, .unspecified: return UIColor(red: 239/255.0, green: 184/255.0, blue: 10/255.0, alpha: 1.0)
                    case .light: fallthrough
                    @unknown default:
                        return defaultBackgroundColor
                    }
                }
                foregroundColor = .white
            case .error:
                backgroundColor = UIColor {
                    switch $0.userInterfaceStyle {
                    case .dark, .unspecified: return UIColor(red: 195/255.0, green: 12/255.0, blue: 12/255.0, alpha: 1.0)
                    case .light: fallthrough
                    @unknown default:
                        return defaultBackgroundColor
                    }
                }
                foregroundColor = .white
            }
        } else {
            backgroundColor = defaultBackgroundColor
            foregroundColor = defaultForegroundColor
        }
        configureTheme(backgroundColor: backgroundColor, foregroundColor: foregroundColor, iconImage: iconImage)
    }
    
    /**
     A convenience function for setting a foreground and background color.
     Note that images will only display the foreground color if they're
     configured with UIImageRenderingMode.AlwaysTemplate.
     
     - Parameter backgroundColor: The background color to use.
     - Parameter foregroundColor: The foreground color to use.
     */
    public func configureTheme(backgroundColor: UIColor, foregroundColor: UIColor, iconImage: UIImage? = nil, iconText: String? = nil) {
        iconImageView?.image = iconImage
        iconLabel?.text = iconText
        iconImageView?.tintColor = foregroundColor
        let backgroundView = self.backgroundView ?? self
        backgroundView.backgroundColor = backgroundColor
        iconLabel?.textColor = foregroundColor
        titleLabel?.textColor = foregroundColor
        bodyLabel?.textColor = foregroundColor
        button?.backgroundColor = foregroundColor
        button?.tintColor = backgroundColor
        button?.contentEdgeInsets = UIEdgeInsets(top: 7.0, left: 7.0, bottom: 7.0, right: 7.0)
        button?.layer.cornerRadius = 5.0
        iconImageView?.isHidden = iconImageView?.image == nil
        iconLabel?.isHidden = iconLabel?.text == nil
    }
}

/*
 MARK: - Configuring the content
 
 This extension provides a few convenience functions for configuring the
 message content. You are encouraged to write your own such functions
 if these don't exactly meet your needs.
 
 SwiftMessages does not try to be clever by adjusting the layout based on 
 what content you configure. All message elements are optional and it is
 up to you to hide or remove elements you don't need. The easiest way to
 remove unwanted elements is to drag-and-drop one of the included nib
 files into your project as a starting point and make changes.
 */

extension MessageView {
    
    /**
     Sets the message body text.
     
     - Parameter body: The message body text to use.
     */
    public func configureContent(body: String) {
        bodyLabel?.text = body
    }
    
    /**
     Sets the message title and body text.
     
     - Parameter title: The message title to use.
     - Parameter body: The message body text to use.
     */
    public func configureContent(title: String, body: String) {
        configureContent(body: body)
        titleLabel?.text = title
    }
    
    /**
     Sets the message title, body text and icon image. Also hides the
     `iconLabel`.
     
     - Parameter title: The message title to use.
     - Parameter body: The message body text to use.
     - Parameter iconImage: The icon image to use.
     */
    public func configureContent(title: String, body: String, iconImage: UIImage) {
        configureContent(title: title, body: body)
        iconImageView?.image = iconImage
        iconImageView?.isHidden = false
        iconLabel?.text = nil
        iconLabel?.isHidden = true
    }
    
    /**
     Sets the message title, body text and icon text (e.g. an emoji).
     Also hides the `iconImageView`.
     
     - Parameter title: The message title to use.
     - Parameter body: The message body text to use.
     - Parameter iconText: The icon text to use (e.g. an emoji).
     */
    public func configureContent(title: String, body: String, iconText: String) {
        configureContent(title: title, body: body)
        iconLabel?.text = iconText
        iconLabel?.isHidden = false
        iconImageView?.isHidden = true
        iconImageView?.image = nil
    }
    
    /**
     Sets all configurable elements.
     
     - Parameter title: The message title to use.
     - Parameter body: The message body text to use.
     - Parameter iconImage: The icon image to use.
     - Parameter iconText: The icon text to use (e.g. an emoji).
     - Parameter buttonImage: The button image to use.
     - Parameter buttonTitle: The button title to use.
     - Parameter buttonTapHandler: The button tap handler block to use.
     */
    public func configureContent(title: String?, body: String?, iconImage: UIImage?, iconText: String?, buttonImage: UIImage?, buttonTitle: String?, buttonTapHandler: ((_ button: UIButton) -> Void)?) {
        titleLabel?.text = title
        bodyLabel?.text = body
        iconImageView?.image = iconImage
        iconLabel?.text = iconText
        button?.setImage(buttonImage, for: .normal)
        button?.setTitle(buttonTitle, for: .normal)
        self.buttonTapHandler = buttonTapHandler
        iconImageView?.isHidden = iconImageView?.image == nil
        iconLabel?.isHidden = iconLabel?.text == nil
    }
}


//
//  MarqueeLabel.swift
//
//  Created by Charles Powell on 8/6/14.
//  Copyright (c) 2015 Charles Powell. All rights reserved.
//

import UIKit
import QuartzCore

@IBDesignable

open class MarqueeLabel: UILabel, CAAnimationDelegate {
    
    /**
     An enum that defines the types of `MarqueeLabel` scrolling
     
     - Left: Scrolls left after the specified delay, and does not return to the original position.
     - LeftRight: Scrolls left first, then back right to the original position.
     - Right: Scrolls right after the specified delay, and does not return to the original position.
     - RightLeft: Scrolls right first, then back left to the original position.
     - Continuous: Continuously scrolls left (with a pause at the original position if animationDelay is set).
     - ContinuousReverse: Continuously scrolls right (with a pause at the original position if animationDelay is set).
     */
    public enum MarqueeType: CaseIterable {
        case left
        case leftRight
        case right
        case rightLeft
        case continuous
        case continuousReverse
    }
    
    //
    // MARK: - Public properties
    //
    
    /**
     Defines the direction and method in which the `MarqueeLabel` instance scrolls.
     `MarqueeLabel` supports six default types of scrolling: `Left`, `LeftRight`, `Right`, `RightLeft`, `Continuous`, and `ContinuousReverse`.
     
     Given the nature of how text direction works, the options for the `type` property require specific text alignments
     and will set the textAlignment property accordingly.
     
     - `LeftRight` and `Left` types are ONLY compatible with a label text alignment of `NSTextAlignment.left`.
     - `RightLeft` and `Right` types are ONLY compatible with a label text alignment of `NSTextAlignment.right`.
     - `Continuous` and `ContinuousReverse` allow the use of `NSTextAlignment.left`, `.right`, or `.center` alignments,
        however the text alignment only has an effect when label text is short enough that scrolling is not required.
        When scrolling, the labels are effectively center-aligned.
     
     Defaults to `Continuous`.
     
     - Note: Note that any `leadingBuffer` value will affect the text alignment location relative to the frame position,
     including  with `.center` alignment, where the center alignment location will be shifted left (for `.continuous`) or
     right (for `.continuousReverse`) by one-half (1/2) the `.leadingBuffer` amount. Use the `.trailingBuffer` property to
     add a buffer between text "loops" without affecting alignment location.
     
     - SeeAlso: textAlignment
     - SeeAlso: leadingBuffer
     */
    open var type: MarqueeType = .continuous {
        didSet {
            if type == oldValue {
                return
            }
            updateAndScroll()
        }
    }
    
    /**
     An optional custom scroll "sequence", defined by an array of `ScrollStep` or `FadeStep` instances. A sequence
     defines a single scroll/animation loop, which will continue to be automatically repeated like the default types.
     
     A `type` value is still required when using a custom sequence. The `type` value defines the `home` and `away`
     values used in the `ScrollStep` instances, and the `type` value determines which way the label will scroll.
     
     When a custom sequence is not supplied, the default sequences are used per the defined `type`.
     
     `ScrollStep` steps are the primary step types, and define the position of the label at a given time in the sequence.
     `FadeStep` steps are secondary steps that define the edge fade state (leading, trailing, or both) around the `ScrollStep`
     steps.
     
     Defaults to nil.
     
     - Attention: Use of the `scrollSequence` property requires understanding of how MarqueeLabel works for effective
     use. As a reference, it is suggested to review the methodology used to build the sequences for the default types.
     
     - SeeAlso: type
     - SeeAlso: ScrollStep
     - SeeAlso: FadeStep
     */
    open var scrollSequence: [MarqueeStep]?

    /**
     Specifies the animation curve used in the scrolling motion of the labels.
     Allowable options:
     
     - `UIViewAnimationOptionCurveEaseInOut`
     - `UIViewAnimationOptionCurveEaseIn`
     - `UIViewAnimationOptionCurveEaseOut`
     - `UIViewAnimationOptionCurveLinear`
     
     Defaults to `UIViewAnimationOptionCurveEaseInOut`.
     */
    open var animationCurve: UIView.AnimationCurve = .linear
    
    /**
     A boolean property that sets whether the `MarqueeLabel` should behave like a normal `UILabel`.
     
     When set to `true` the `MarqueeLabel` will behave and look like a normal `UILabel`, and  will not begin any scrolling animations.
     Changes to this property take effect immediately, removing any in-flight animation as well as any edge fade. Note that `MarqueeLabel`
     will respect the current values of the `lineBreakMode` and `textAlignment`properties while labelized.
     
     To simply prevent automatic scrolling, use the `holdScrolling` property.
     
     Defaults to `false`.
     
     - SeeAlso: holdScrolling
     - SeeAlso: lineBreakMode
     - Note: The label will not automatically scroll when this property is set to `true`.
     - Warning: The UILabel default setting for the `lineBreakMode` property is `NSLineBreakByTruncatingTail`, which truncates
     the text adds an ellipsis glyph (...). Set the `lineBreakMode` property to `NSLineBreakByClipping` in order to avoid the
     ellipsis, especially if using an edge transparency fade.
     */
    open var labelize: Bool = false {
        didSet {
            if labelize != oldValue {
                updateAndScroll()
            }
        }
    }
    
    /**
     A boolean property that sets whether the `MarqueeLabel` should hold (prevent) automatic label scrolling.
     
     When set to `true`, `MarqueeLabel` will not automatically scroll even its text is larger than the specified frame,
     although the specified edge fades will remain.
     
     To set `MarqueeLabel` to act like a normal UILabel, use the `labelize` property.
     
     Defaults to `false`.
     
     - Note: The label will not automatically scroll when this property is set to `true`.
     - SeeAlso: labelize
     */
    open var holdScrolling: Bool = false {
        didSet {
            if holdScrolling != oldValue {
                if oldValue == true && !(awayFromHome || labelize ) && labelShouldScroll() {
                    updateAndScroll()
                }
            }
        }
    }
    
    /**
     A boolean property that sets whether the `MarqueeLabel` should scroll, even if the specificed test string
     can be fully contained within the label frame.
     
     If this property is set to `true`, the `MarqueeLabel` will automatically scroll regardless of text string
     length, although this can still be overridden by the `tapToScroll` and `holdScrolling` properties.
     
     Defaults to `false`.
     
     - Warning: Forced scrolling may have unexpected edge cases or have unusual characteristics compared to the
     'normal' scrolling feature.
     
     - SeeAlso: holdScrolling
     - SeeAlso: tapToScroll
     */
    public var forceScrolling: Bool = false {
        didSet {
            if forceScrolling != oldValue {
                if !(awayFromHome || holdScrolling || tapToScroll ) && labelShouldScroll() {
                    updateAndScroll()
                }
            }
        }
    }
	
    /**
     A boolean property that sets whether the `MarqueeLabel` should only begin a scroll when tapped.
     
     If this property is set to `true`, the `MarqueeLabel` will only begin a scroll animation cycle when tapped. The label will
     not automatically being a scroll. This setting overrides the setting of the `holdScrolling` property.
     
     Defaults to `false`.
     
     - Note: The label will not automatically scroll when this property is set to `false`.
     - SeeAlso: holdScrolling
     */
    open var tapToScroll: Bool = false {
        didSet {
            if tapToScroll != oldValue {
                if tapToScroll {
                    let tapRecognizer = UITapGestureRecognizer(target: self, action: #selector(MarqueeLabel.labelWasTapped(_:)))
                    self.addGestureRecognizer(tapRecognizer)
                    isUserInteractionEnabled = true
                } else {
                    if let recognizer = self.gestureRecognizers!.first as UIGestureRecognizer? {
                        self.removeGestureRecognizer(recognizer)
                    }
                    isUserInteractionEnabled = false
                }
            }
        }
    }
    
    /**
     A read-only boolean property that indicates if the label's scroll animation has been paused.
     
     - SeeAlso: pauseLabel
     - SeeAlso: unpauseLabel
     */
    open var isPaused: Bool {
        return (sublabel.layer.speed == 0.0)
    }
    
    /**
     A boolean property that indicates if the label is currently away from the home location.
     
     The "home" location is the traditional location of `UILabel` text. This property essentially reflects if a scroll animation is underway.
     */
    open var awayFromHome: Bool {
        if let presentationLayer = sublabel.layer.presentation() {
            return !(presentationLayer.position.x == homeLabelFrame.origin.x)
        }
        
        return false
    }
    
    /**
     An optional CGFloat computed value that provides the current scroll animation position, as a value between
     0.0 and 1.0. A value of 0.0 indicates the label is "at home" (`awayFromHome` will be false). A value
     of 1.0 indicates the label is at the "away" position (and `awayFromHome` will be true).
     
     Will return nil when the label presentation layer is nil.
     
     - Note: For `leftRight` and `rightLeft` type labels this value will increase and reach 1.0 when the label animation reaches the
     maximum displacement, as the left or right edge of the label (respectively) is shown. As the scroll reverses,
     the value will decrease back to 0.0.
     
     - Note: For `continuous` and`continuousReverse` type labels, this value will increase from 0.0 and reach 1.0 just as the
     label loops around and comes to a stop at the original home position. When that position is reached, the value will
     jump from 1.0 directly to 0.0 and begin to increase from 0.0 again.
     */
    open var animationPosition: CGFloat? {
        guard let presentationLayer = sublabel.layer.presentation() else {
            return nil
        }
        
        // No dividing by zero!
        if awayOffset == 0.0 {
            return 0.0
        }
        
        let progressFraction = abs((presentationLayer.position.x - homeLabelFrame.origin.x) / awayOffset)
        return progressFraction
    }
    
    /**
     The `MarqueeLabel` scrolling speed may be defined by one of two ways:
     - Rate(CGFloat): The speed is defined by a rate of motion, in units of points per second.
     - Duration(CGFloat): The speed is defined by the time to complete a scrolling animation cycle, in units of seconds.
     
     Each case takes an associated `CGFloat` value, which is the rate/duration desired.
     */
    public enum SpeedLimit {
        case rate(CGFloat)
        case duration(CGFloat)
        
        var value: CGFloat {
            switch self {
            case .rate(let rate):
                return rate
            case .duration(let duration):
                return duration
            }
        }
    }
    
    /**
     Defines the speed of the `MarqueeLabel` scrolling animation.
     
     The speed is set by specifying a case of the `SpeedLimit` enum along with an associated value.
     
     - SeeAlso: SpeedLimit
     */
    open var speed: SpeedLimit = .duration(7.0) {
        didSet {
            switch (speed, oldValue) {
            case (.rate(let a), .rate(let b)) where a == b:
                return
            case (.duration(let a), .duration(let b)) where a == b:
                return
            default:
                updateAndScroll()
            }
        }
    }
    
    @available(*, deprecated, message: "Use speed property instead")
    open var scrollDuration: CGFloat {
        get {
            switch speed {
            case .duration(let duration): return duration
            case .rate(_): return 0.0
            }
        }
        set {
            speed = .duration(newValue)
        }
    }
    
    @available(*, deprecated, message : "Use speed property instead")
    open var scrollRate: CGFloat {
        get {
            switch speed {
            case .duration(_): return 0.0
            case .rate(let rate): return rate
            }
        }
        set {
            speed = .rate(newValue)
        }
    }

    
    /**
     A buffer (offset) between the leading edge of the label text and the label frame.
     
     This property adds additional space between the leading edge of the label text and the label frame. The
     leading edge is the edge of the label text facing the direction of scroll (i.e. the edge that animates
     offscreen first during scrolling).
     
     Defaults to `0`.
     
     - Note: The value set to this property affects label positioning at all times (including when `labelize` is set to `true`),
     including when the text string length is short enough that the label does not need to scroll.
     - Note: For Continuous-type labels, the smallest value of `leadingBuffer`, `trailingBuffer`, and `fadeLength`
     is used as spacing between the two label instances. Zero is an allowable value for all three properties.
     
     - SeeAlso: trailingBuffer
     */
    open var leadingBuffer: CGFloat = 0.0 {
        didSet {
            if leadingBuffer != oldValue {
                updateAndScroll()
            }
        }
    }
    
    /**
     A buffer (offset) between the trailing edge of the label text and the label frame.
     
     This property adds additional space (buffer) between the trailing edge of the label text and the label frame. The
     trailing edge is the edge of the label text facing away from the direction of scroll (i.e. the edge that animates
     offscreen last during scrolling).
     
     Defaults to `0`.
     
     - Note: The value set to this property has no effect when the `labelize` property is set to `true`.
     
     - Note: For Continuous-type labels, the smallest value of `leadingBuffer`, `trailingBuffer`, and `fadeLength`
     is used as spacing between the two label instances. Zero is an allowable value for all three properties.
     
     - SeeAlso: leadingBuffer
     */
    open var trailingBuffer: CGFloat = 0.0 {
        didSet {
            if trailingBuffer != oldValue {
                updateAndScroll()
            }
        }
    }
    
    /**
     The length of transparency fade at the left and right edges of the frame.
     
     This propery sets the size (in points) of the view edge transparency fades on the left and right edges of a `MarqueeLabel`. The
     transparency fades from an alpha of 1.0 (fully visible) to 0.0 (fully transparent) over this distance. Values set to this property
     will be sanitized to prevent a fade length greater than 1/2 of the frame width.
     
     Defaults to `0`.
     */
    open var fadeLength: CGFloat = 0.0 {
        didSet {
            if fadeLength != oldValue {
                applyGradientMask(fadeLength, animated: true)
                updateAndScroll()
            }
        }
    }
    
    
    /**
     The length of delay in seconds that the label pauses at the completion of a scroll.
     */
    open var animationDelay: CGFloat = 1.0
    
    
    /** The read-only/computed duration of the scroll animation (not including delay).
     
     The value of this property is calculated from the value set to the `speed` property. If a duration-type speed is
     used to set the label animation speed, `animationDuration` will be equivalent to that value.
     */
    public var animationDuration: CGFloat {
        switch self.speed {
        case .rate(let rate):
            return CGFloat(abs(self.awayOffset) / rate)
        case .duration(let duration):
            return duration
        }
    }
    
    //
    // MARK: - Class Functions and Helpers
    //
    
    /**
     Convenience method to restart all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
    
     - Parameter controller: The view controller for which to restart all `MarqueeLabel` instances.
    
     - Warning: View controllers that appear with animation (such as from underneath a modal-style controller) can cause some `MarqueeLabel` text
     position "jumping" when this method is used in `viewDidAppear` if scroll animations are already underway. Use this method inside `viewWillAppear:`
     instead to avoid this problem.
    
     - Warning: This method may not function properly if passed the parent view controller when using view controller containment.
    
     - SeeAlso: restartLabel
     - SeeAlso: controllerViewDidAppear:
     - SeeAlso: controllerViewWillAppear:
     */
    open class func restartLabelsOfController(_ controller: UIViewController) {
        MarqueeLabel.notifyController(controller, message: .Restart)
    }
    
    /**
     Convenience method to restart all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
     
     Alternative to `restartLabelsOfController`. This method is retained for backwards compatibility and future enhancements.
     
     - Parameter controller: The view controller that will appear.
     - SeeAlso: restartLabel
     - SeeAlso: controllerViewDidAppear
     */
    open class func controllerViewWillAppear(_ controller: UIViewController) {
        MarqueeLabel.restartLabelsOfController(controller)
    }
    
    /**
     Convenience method to restart all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
     
     Alternative to `restartLabelsOfController`. This method is retained for backwards compatibility and future enhancements.
     
     - Parameter controller: The view controller that did appear.
     - SeeAlso: restartLabel
     - SeeAlso: controllerViewWillAppear
     */
    open class func controllerViewDidAppear(_ controller: UIViewController) {
        MarqueeLabel.restartLabelsOfController(controller)
    }
    
    /**
     Labelizes all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
    
     The `labelize` property of all recognized `MarqueeLabel` instances will be set to `true`.
     
     - Parameter controller: The view controller for which all `MarqueeLabel` instances should be labelized.
     - SeeAlso: labelize
     */
    open class func controllerLabelsLabelize(_ controller: UIViewController) {
        MarqueeLabel.notifyController(controller, message: .Labelize)
    }
    
    /**
     De-labelizes all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
     
     The `labelize` property of all recognized `MarqueeLabel` instances will be set to `false`.
     
     - Parameter controller: The view controller for which all `MarqueeLabel` instances should be de-labelized.
     - SeeAlso: labelize
     */
    open class func controllerLabelsAnimate(_ controller: UIViewController) {
        MarqueeLabel.notifyController(controller, message: .Animate)
    }

    
    //
    // MARK: - Initialization
    //
    
    /**
     Returns a newly initialized `MarqueeLabel` instance with the specified scroll rate and edge transparency fade length.
    
     - Parameter frame: A rectangle specifying the initial location and size of the view in its superview's coordinates. Text (for the given font, font size, etc.) that does not fit in this frame will automatically scroll.
     - Parameter pixelsPerSec: A rate of scroll for the label scroll animation. Must be non-zero. Note that this will be the peak (mid-transition) rate for ease-type animation.
     - Parameter fadeLength: A length of transparency fade at the left and right edges of the `MarqueeLabel` instance's frame.
     - Returns: An initialized `MarqueeLabel` object or nil if the object couldn't be created.
     - SeeAlso: fadeLength
     */
    public init(frame: CGRect, rate: CGFloat, fadeLength fade: CGFloat) {
        speed = .rate(rate)
        fadeLength = CGFloat(min(fade, frame.size.width/2.0))
        super.init(frame: frame)
        setup()
    }
    
    /**
     Returns a newly initialized `MarqueeLabel` instance with the specified scroll rate and edge transparency fade length.
     
     - Parameter frame: A rectangle specifying the initial location and size of the view in its superview's coordinates. Text (for the given font, font size, etc.) that does not fit in this frame will automatically scroll.
     - Parameter scrollDuration: A scroll duration the label scroll animation. Must be non-zero. This will be the duration that the animation takes for one-half of the scroll cycle in the case of left-right and right-left marquee types, and for one loop of a continuous marquee type.
     - Parameter fadeLength: A length of transparency fade at the left and right edges of the `MarqueeLabel` instance's frame.
     - Returns: An initialized `MarqueeLabel` object or nil if the object couldn't be created.
     - SeeAlso: fadeLength
     */
    public init(frame: CGRect, duration: CGFloat, fadeLength fade: CGFloat) {
        speed = .duration(duration)
        fadeLength = CGFloat(min(fade, frame.size.width/2.0))
        super.init(frame: frame)
        setup()
    }
    
    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    /**
     Returns a newly initialized `MarqueeLabel` instance.
     
     The default scroll duration of 7.0 seconds and fade length of 0.0 are used.
     
     - Parameter frame: A rectangle specifying the initial location and size of the view in its superview's coordinates. Text (for the given font, font size, etc.) that does not fit in this frame will automatically scroll.
     - Returns: An initialized `MarqueeLabel` object or nil if the object couldn't be created.
    */
    convenience public override init(frame: CGRect) {
        self.init(frame: frame, duration:7.0, fadeLength:0.0)
    }
    
    private func setup() {
        // Create sublabel
        sublabel = UILabel(frame: self.bounds)
        sublabel.tag = 700
        sublabel.layer.anchorPoint = CGPoint.zero

        // Add sublabel
        addSubview(sublabel)
        
        // Configure self
        super.clipsToBounds = true
        super.numberOfLines = 1
        
        // Add notification observers
        // Custom class notifications
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.restartForViewController(_:)), name: NSNotification.Name(rawValue: MarqueeKeys.Restart.rawValue), object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.labelizeForController(_:)), name: NSNotification.Name(rawValue: MarqueeKeys.Labelize.rawValue), object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.animateForController(_:)), name: NSNotification.Name(rawValue: MarqueeKeys.Animate.rawValue), object: nil)
        // UIApplication state notifications
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.restartLabel), name: UIApplication.didBecomeActiveNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.shutdownLabel), name: UIApplication.didEnterBackgroundNotification, object: nil)
    }
    
    override open func awakeFromNib() {
        super.awakeFromNib()
        forwardPropertiesToSublabel()
    }
    
    @available(iOS 8.0, *)
    override open func prepareForInterfaceBuilder() {
        super.prepareForInterfaceBuilder()
        forwardPropertiesToSublabel()
    }
    
    private func forwardPropertiesToSublabel() {
        /*
        Note that this method is currently ONLY called from awakeFromNib, i.e. when
        text properties are set via a Storyboard. As the Storyboard/IB doesn't currently
        support attributed strings, there's no need to "forward" the super attributedString value.
        */
        
        // Since we're a UILabel, we actually do implement all of UILabel's properties.
        // We don't care about these values, we just want to forward them on to our sublabel.
        let properties = ["baselineAdjustment", "enabled", "highlighted", "highlightedTextColor",
                          "minimumFontSize", "shadowOffset", "textAlignment",
                          "userInteractionEnabled", "adjustsFontSizeToFitWidth", "minimumScaleFactor",
                          "lineBreakMode", "numberOfLines", "contentMode"]
        
        // Iterate through properties
        sublabel.text = super.text
        sublabel.font = super.font
        sublabel.textColor = super.textColor
        sublabel.backgroundColor = super.backgroundColor ?? UIColor.clear
        sublabel.shadowColor = super.shadowColor
        sublabel.shadowOffset = super.shadowOffset
        for prop in properties {
            let value = super.value(forKey: prop)
            sublabel.setValue(value, forKeyPath: prop)
        }
    }
    
    //
    // MARK: - MarqueeLabel Heavy Lifting
    //

    override open func layoutSubviews() {
        super.layoutSubviews()
        
        updateAndScroll()
    }

    override open func willMove(toWindow newWindow: UIWindow?) {
        if newWindow == nil {
            shutdownLabel()
        }
    }
    
    override open func didMoveToWindow() {
        if self.window == nil {
            shutdownLabel()
        } else {
            updateAndScroll()
        }
    }
    
    private func updateAndScroll() {
        // Do not automatically begin scroll if tapToScroll is true
        updateAndScroll(overrideHold: false)
    }
    
    private func updateAndScroll(overrideHold: Bool) {
        // Check if scrolling can occur
        if !labelReadyForScroll() {
            return
        }
        
        // Calculate expected size
        let expectedLabelSize = sublabel.desiredSize()
        
        // Invalidate intrinsic size
        invalidateIntrinsicContentSize()
        
        // Move label to home
        returnLabelToHome()
        
        // Check if label should scroll
        // Note that the holdScrolling propery does not affect this
        if !labelShouldScroll() {
            // Set text alignment and break mode to act like a normal label
            sublabel.textAlignment = super.textAlignment
            sublabel.lineBreakMode = super.lineBreakMode
            sublabel.adjustsFontSizeToFitWidth = super.adjustsFontSizeToFitWidth
            sublabel.minimumScaleFactor = super.minimumScaleFactor
            
            let labelFrame: CGRect
            switch type {
            case .continuousReverse, .rightLeft:
                labelFrame = bounds.divided(atDistance: leadingBuffer, from: CGRectEdge.maxXEdge).remainder.integral
            default:
                labelFrame = CGRect(x: leadingBuffer, y: 0.0, width: bounds.size.width - leadingBuffer, height: bounds.size.height).integral
            }
            
            homeLabelFrame = labelFrame
            awayOffset = 0.0
            
            // Remove any additional sublabels (for continuous types)
            repliLayer?.instanceCount = 1

            // Set the sublabel frame to calculated labelFrame
            sublabel.frame = labelFrame
            
            // Remove fade, as by definition none is needed in this case
            removeGradientMask()
            
            return
        }
        
        // Label DOES need to scroll
        
        // Reset font scaling to off for scrolling
        sublabel.adjustsFontSizeToFitWidth = false
        sublabel.minimumScaleFactor = 0.0
        
        // Spacing between primary and second sublabel must be at least equal to leadingBuffer, and at least equal to the fadeLength
        let minTrailing = minimumTrailingDistance
        
        // Determine positions and generate scroll steps
        let sequence: [MarqueeStep]
        
        switch type {
        case .continuous, .continuousReverse:
            if type == .continuous {
                homeLabelFrame = CGRect(x: leadingBuffer, y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral
                awayOffset = -(homeLabelFrame.size.width + minTrailing)
            } else { // .ContinuousReverse
                homeLabelFrame = CGRect(x: bounds.size.width - (expectedLabelSize.width + leadingBuffer), y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral
                awayOffset = (homeLabelFrame.size.width + minTrailing)
            }
            
            // Find when the lead label will be totally offscreen
            let offsetDistance = awayOffset
            let offscreenAmount = homeLabelFrame.size.width
            let startFadeFraction = abs(offscreenAmount / offsetDistance)
            // Find when the animation will hit that point
            let startFadeTimeFraction = timingFunctionForAnimationCurve(animationCurve).durationPercentageForPositionPercentage(startFadeFraction, duration: (animationDelay + animationDuration))
            let startFadeTime = startFadeTimeFraction * animationDuration
            
            sequence = scrollSequence ?? [
                ScrollStep(timeStep: 0.0, position: .home, edgeFades: .trailing),                   // Starting point, at home, with trailing fade
                ScrollStep(timeStep: animationDelay, position: .home, edgeFades: .trailing),        // Delay at home, maintaining fade state
                FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                          // 0.2 sec after scroll start, fade leading edge in as well
                FadeStep(timeStep: (startFadeTime - animationDuration),                             // Maintain fade state until just before reaching end of scroll animation
                         edgeFades: [.leading, .trailing]),
                ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,             // Ending point (back at home), with animationCurve transition, with trailing fade
                           position: .away, edgeFades: .trailing)
            ]
            
            // Set frame and text
            sublabel.frame = homeLabelFrame
            
            // Configure replication
            // Determine replication count required
            let fitFactor: CGFloat = bounds.size.width/(expectedLabelSize.width + leadingBuffer)
            let repliCount = 1 + Int(ceil(fitFactor))
            repliLayer?.instanceCount = repliCount
            repliLayer?.instanceTransform = CATransform3DMakeTranslation(-awayOffset, 0.0, 0.0)
            
        case .leftRight, .left, .rightLeft, .right:
            if type == .leftRight || type == .left {
                homeLabelFrame = CGRect(x: leadingBuffer, y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral
                awayOffset = bounds.size.width - (expectedLabelSize.width + leadingBuffer + trailingBuffer)
                // Enforce text alignment for this type
                sublabel.textAlignment = NSTextAlignment.left
            } else {
                homeLabelFrame = CGRect(x: bounds.size.width - (expectedLabelSize.width + leadingBuffer), y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral
                awayOffset = (expectedLabelSize.width + trailingBuffer + leadingBuffer) - bounds.size.width
                // Enforce text alignment for this type
                sublabel.textAlignment = NSTextAlignment.right
            }
            // Set frame and text
            sublabel.frame = homeLabelFrame
            
            // Remove any replication
            repliLayer?.instanceCount = 1

            if type == .leftRight || type == .rightLeft {
                sequence = scrollSequence ?? [
                    ScrollStep(timeStep: 0.0, position: .home, edgeFades: .trailing),               // Starting point, at home, with trailing fade
                    ScrollStep(timeStep: animationDelay, position: .home, edgeFades: .trailing),    // Delay at home, maintaining fade state
                    FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                      // 0.2 sec after delay ends, fade leading edge in as well
                    FadeStep(timeStep: -0.2, edgeFades: [.leading, .trailing]),                     // Maintain fade state until 0.2 sec before reaching away position
                    ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,         // Away position, using animationCurve transition, with only leading edge faded in
                        position: .away, edgeFades: .leading),
                    ScrollStep(timeStep: animationDelay, position: .away, edgeFades: .leading),     // Delay at away, maintaining fade state (leading only)
                    FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                      // 0.2 sec after delay ends, fade trailing edge back in as well
                    FadeStep(timeStep: -0.2, edgeFades: [.leading, .trailing]),                     // Maintain fade state until 0.2 sec before reaching home position
                    ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,         // Ending point, back at home, with only trailing fade
                        position: .home, edgeFades: .trailing)
                ]
            } else { // .left or .right
                sequence = scrollSequence ?? [
                    ScrollStep(timeStep: 0.0, position: .home, edgeFades: .trailing),               // Starting point, at home, with trailing fade
                    ScrollStep(timeStep: animationDelay, position: .home, edgeFades: .trailing),    // Delay at home, maintaining fade state
                    FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                      // 0.2 sec after delay ends, fade leading edge in as well
                    FadeStep(timeStep: -0.2, edgeFades: [.leading, .trailing]),                     // Maintain fade state until 0.2 sec before reaching away position
                    ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,         // Away position, using animationCurve transition, with only leading edge faded in
                        position: .away, edgeFades: .leading),
                    ScrollStep(timeStep: animationDelay, position: .away, edgeFades: .leading),     // "Delay" at away, maintaining fade state
                ]
            }
        }
        
        
        
        // Configure gradient for current condition
        applyGradientMask(fadeLength, animated: !self.labelize)
        
        if overrideHold || (!holdScrolling && !overrideHold) {
            beginScroll(sequence)
        }
    }
    
    override open func sizeThatFits(_ size: CGSize) -> CGSize {
        return sizeThatFits(size, withBuffers: true)
    }
    
    open func sizeThatFits(_ size: CGSize, withBuffers: Bool) -> CGSize {
        var fitSize = sublabel.sizeThatFits(size)
        if withBuffers {
            fitSize.width += leadingBuffer
        }
        return fitSize
    }
    
    /**
     Returns the unconstrained size of the specified label text (for a single line).
    */
    open func textLayoutSize() -> CGSize {
        return sublabel.desiredSize()
    }
    
    //
    // MARK: - Animation Handling
    //
    
    open func labelShouldScroll() -> Bool {
        // Check for nil string
        guard sublabel.text != nil else {
            return false
        }
        
        // Check for empty string
        guard !sublabel.text!.isEmpty else {
            return false
        }
        
        var labelTooLarge = false
        if !super.adjustsFontSizeToFitWidth {
            // Usual logic to check if the label string fits
            labelTooLarge = (sublabel.desiredSize().width + leadingBuffer) > self.bounds.size.width + CGFloat.ulpOfOne
        } else {
            // Logic with auto-scale support
            // Create mutable attributed string to modify font sizes in-situ
            let resizedString = NSMutableAttributedString.init(attributedString: sublabel.attributedText!)
            resizedString.beginEditing()
            // Enumerate all font attributes of attributed string
            resizedString.enumerateAttribute(.font, in: NSRange(0..<sublabel.attributedText!.length)) { val, rng, stop in
                if let originalFont = val as? UIFont {
                    // Calculate minimum-factor font size
                    let resizedFontSize = originalFont.pointSize * super.minimumScaleFactor
                    // Create and apply new font attribute to string
                    if let resizedFont = UIFont.init(name: originalFont.fontName, size: resizedFontSize) {
                        resizedString.addAttribute(.font, value: resizedFont, range: rng)
                    }
                }
            }
            resizedString.endEditing()
            
            // Get new expected minimum size
            let expectedMinimumTextSize = resizedString.size()
            
            // If even after shrinking it's too wide, consider the label too large and in need of scrolling
            labelTooLarge = self.bounds.size.width < ceil(expectedMinimumTextSize.width) + CGFloat.ulpOfOne
            
            // Set scale factor on sublabel dependent on result, back to 1.0 if too big to prevent
            // sublabel from shrinking AND scrolling
            sublabel.minimumScaleFactor = labelTooLarge ? 1.0 : super.minimumScaleFactor
        }

        let animationHasDuration = speed.value > 0.0
        return (!labelize && (forceScrolling || labelTooLarge) && animationHasDuration)
    }
    
    private func labelReadyForScroll() -> Bool {
        // Check if we have a superview
        if superview == nil {
            return false
        }
        
        // Check if we are attached to a window
        if window == nil {
            return false
        }
        
        // Check if our view controller is ready
        let viewController = firstAvailableViewController()
        if viewController != nil {
            if !viewController!.isViewLoaded {
                return false
            }
        }
        
        return true
    }
    
    private func returnLabelToHome() {
        // Store if label is away from home at time of call
        let away = awayFromHome
        
        // Remove any gradient animation
        maskLayer?.removeAllAnimations()
        
        // Remove all sublabel position animations
        sublabel.layer.removeAllAnimations()
        
        // Fire completion block if appropriate
        if away {
            // If label was away when this was called, animation did NOT finish
            scrollCompletionBlock?(!away)
        }
        
        // Remove completion block
        scrollCompletionBlock = nil
    }
    
    private func beginScroll(_ sequence: [MarqueeStep]) {
        let scroller = generateScrollAnimation(sequence)
        let fader = generateGradientAnimation(sequence, totalDuration: scroller.duration)
        
        scroll(scroller, fader: fader)
    }
    
    private func scroll(_ scroller: MLAnimation, fader: MLAnimation?) {
        // Check for conditions which would prevent scrolling
        if !labelReadyForScroll() {
            return
        }
        // Convert fader to var
        var fader = fader
        
        // Call pre-animation hook
        labelWillBeginScroll()
        
        // Start animation transactions
        CATransaction.begin()
        CATransaction.setAnimationDuration(TimeInterval(scroller.duration))
        
        // Create gradient animation, if needed
        let gradientAnimation: CAKeyframeAnimation?
        // Check for IBDesignable
        #if !TARGET_INTERFACE_BUILDER
            if fadeLength > 0.0 {
                // Remove any setup animation, but apply final values
                if let setupAnim = maskLayer?.animation(forKey: "setupFade") as? CABasicAnimation, let finalColors = setupAnim.toValue as? [CGColor] {
                    maskLayer?.colors = finalColors
                }
                maskLayer?.removeAnimation(forKey: "setupFade")
                
                // Generate animation if needed
                if let previousAnimation = fader?.anim {
                    gradientAnimation = previousAnimation
                } else {
                    gradientAnimation = nil
                }
                
                // Apply fade animation
                maskLayer?.add(gradientAnimation!, forKey: "gradient")
            } else {
                // No animation needed
                fader = nil
            }
        #else
            fader = nil
        #endif

        scrollCompletionBlock = { [weak self] (finished: Bool) in
            guard self != nil else {
                return
            }
            
            // Call returned home function
            self!.labelReturnedToHome(finished)
            
            // Check to ensure that:
            
            // 1) The instance is still attached to a window - this completion block is called for
            //    many reasons, including if the animation is removed due to the view being removed
            //    from the UIWindow (typically when the view controller is no longer the "top" view)
            guard self!.window != nil else {
                return
            }
            // 2) We don't double fire if an animation already exists
            guard self!.sublabel.layer.animation(forKey: "position") == nil else {
                return
            }
            // 3) We don't start automatically if the animation was unexpectedly interrupted
            guard finished else {
                // Do not continue into the next loop
                return
            }
            // 4) A completion block still exists for the NEXT loop. A notable case here is if
            // returnLabelToHome() was called during a subclass's labelReturnToHome() function
            guard self!.scrollCompletionBlock != nil else {
                return
            }
            
            // Begin again, if conditions met
            if self!.labelShouldScroll() && !self!.tapToScroll && !self!.holdScrolling {
                // Perform completion callback
                self!.scroll(scroller, fader: fader)
            }
        }
        
        // Perform scroll animation
        scroller.anim.setValue(true, forKey: MarqueeKeys.CompletionClosure.rawValue)
        scroller.anim.delegate = self
        if type == .left || type == .right {
            // Make it stay at away permanently
            scroller.anim.isRemovedOnCompletion = false
            scroller.anim.fillMode = .forwards
        }
        sublabel.layer.add(scroller.anim, forKey: "position")
        
        CATransaction.commit()
    }
    
    private func generateScrollAnimation(_ sequence: [MarqueeStep]) -> MLAnimation {
        // Create scroller, which defines the animation to perform
        let homeOrigin = homeLabelFrame.origin
        let awayOrigin = offsetCGPoint(homeLabelFrame.origin, offset: awayOffset)
        
        let scrollSteps = sequence.filter({ $0 is ScrollStep }) as! [ScrollStep]
        let totalDuration = scrollSteps.reduce(0.0) { $0 + $1.timeStep }
        
        // Build scroll data
        var totalTime: CGFloat = 0.0
        var scrollKeyTimes = [NSNumber]()
        var scrollKeyValues = [NSValue]()
        var scrollTimingFunctions = [CAMediaTimingFunction]()
        
        for (offset, step) in scrollSteps.enumerated() {
            // Scroll Times
            totalTime += step.timeStep
            scrollKeyTimes.append(NSNumber(value:Float(totalTime/totalDuration)))
            
            // Scroll Values
            let scrollPosition: CGPoint
            switch step.position {
            case .home:
                scrollPosition = homeOrigin
            case .away:
                scrollPosition = awayOrigin
            case .partial(let frac):
                scrollPosition = offsetCGPoint(homeOrigin, offset: awayOffset*frac)
            }
            scrollKeyValues.append(NSValue(cgPoint:scrollPosition))
            
            // Scroll Timing Functions
            // Only need n-1 timing functions, so discard the first value as it's unused
            if offset == 0 { continue }
            scrollTimingFunctions.append(timingFunctionForAnimationCurve(step.timingFunction))
        }
        
        // Create animation
        let animation = CAKeyframeAnimation(keyPath: "position")
        // Set values
        animation.keyTimes = scrollKeyTimes
        animation.values = scrollKeyValues
        animation.timingFunctions = scrollTimingFunctions
        
        return (anim: animation, duration: totalDuration)
    }
    
    private func generateGradientAnimation(_ sequence: [MarqueeStep], totalDuration: CGFloat) -> MLAnimation {
        // Setup
        var totalTime: CGFloat = 0.0
        var stepTime: CGFloat = 0.0
        var fadeKeyValues = [[CGColor]]()
        var fadeKeyTimes = [NSNumber]()
        var fadeTimingFunctions = [CAMediaTimingFunction]()
        let transp = UIColor.clear.cgColor
        let opaque = UIColor.black.cgColor
        
        // Filter to get only scroll steps and valid precedent/subsequent fade steps
        let fadeSteps = sequence.enumerated().filter { (arg: (offset: Int, element: MarqueeStep)) -> Bool in
            let (offset, element) = arg
            
            // Include all Scroll Steps
            if element is ScrollStep { return true }
            
            // Include all Fade Steps that have a directly preceding or subsequent Scroll Step
            // Exception: Fade Step cannot be first step
            if offset == 0 { return false }
            
            // Subsequent step if 1) positive/zero time step and 2) follows a Scroll Step
            let subsequent = element.timeStep >= 0 && (sequence[max(0, offset - 1)] is ScrollStep)
            // Precedent step if 1) negative time step and 2) precedes a Scroll Step
            let precedent = element.timeStep < 0 && (sequence[min(sequence.count - 1, offset + 1)] is ScrollStep)
            
            return (precedent || subsequent)
        }
        
        for (offset, step) in fadeSteps {
            // Fade times
            if step is ScrollStep {
                totalTime += step.timeStep
                stepTime = totalTime
            } else {
                if step.timeStep >= 0 {
                    // Is a Subsequent
                    stepTime = totalTime + step.timeStep
                } else {
                    // Is a Precedent, grab next step
                    stepTime = totalTime + fadeSteps[offset + 1].element.timeStep + step.timeStep
                }
            }
            fadeKeyTimes.append(NSNumber(value:Float(stepTime/totalDuration)))
            
            // Fade Values
            let values: [CGColor]
            let leading = step.edgeFades.contains(.leading) ? transp : opaque
            let trailing = step.edgeFades.contains(.trailing) ? transp : opaque
            switch type {
            case .leftRight, .left, .continuous:
                values = [leading, opaque, opaque, trailing]
            case .rightLeft, .right, .continuousReverse:
                values = [trailing, opaque, opaque, leading]
            }
            fadeKeyValues.append(values)
            
            // Fade Timing Function
            // Only need n-1 timing functions, so discard the first value as it's unused
            if offset == 0 { continue }
            fadeTimingFunctions.append(timingFunctionForAnimationCurve(step.timingFunction))
        }
        
        // Create new animation
        let animation = CAKeyframeAnimation(keyPath: "colors")
        
        animation.values = fadeKeyValues
        animation.keyTimes = fadeKeyTimes
        animation.timingFunctions = fadeTimingFunctions

        return (anim: animation, duration: max(totalTime, totalDuration))
    }
    
    private func applyGradientMask(_ fadeLength: CGFloat, animated: Bool, firstStep: MarqueeStep? = nil) {
        // Remove any in-flight animations
        maskLayer?.removeAllAnimations()
        
        // Check for zero-length fade
        if fadeLength <= 0.0 {
            removeGradientMask()
            return
        }
        
        // Configure gradient mask without implicit animations
        CATransaction.begin()
        CATransaction.setDisableActions(true)
        
        // Determine if gradient mask needs to be created
        let gradientMask: CAGradientLayer
        if let currentMask = self.maskLayer {
            // Mask layer already configured
            gradientMask = currentMask
        } else {
            // No mask exists, create new mask
            gradientMask = CAGradientLayer()
            gradientMask.shouldRasterize = true
            gradientMask.rasterizationScale = UIScreen.main.scale
            gradientMask.startPoint = CGPoint(x:0.0, y:0.5)
            gradientMask.endPoint = CGPoint(x:1.0, y:0.5)
        }
        
        // Check if there is a mask to layer size mismatch
        if gradientMask.bounds != self.layer.bounds {
            // Adjust stops based on fade length
            let leftFadeStop = fadeLength/self.bounds.size.width
            let rightFadeStop = 1.0 - fadeLength/self.bounds.size.width
            gradientMask.locations = [0.0, leftFadeStop, rightFadeStop, 1.0].map { NSNumber(value: Float($0)) }
        }
        
        gradientMask.bounds = self.layer.bounds
        gradientMask.position = CGPoint(x:self.bounds.midX, y:self.bounds.midY)
        
        // Set up colors
        let transparent = UIColor.clear.cgColor
        let opaque = UIColor.black.cgColor
        
        // Set mask
        self.layer.mask = gradientMask
        
        // Determine colors for non-scrolling label (i.e. at home)
        let adjustedColors: [CGColor]
        let trailingFadeNeeded = self.labelShouldScroll()

        switch type {
        case .continuousReverse, .rightLeft:
            adjustedColors = [(trailingFadeNeeded ? transparent : opaque), opaque, opaque, opaque]
        
        // .Continuous, .LeftRight
        default:
            adjustedColors = [opaque, opaque, opaque, (trailingFadeNeeded ? transparent : opaque)]
        }
        
        // Check for IBDesignable
        #if TARGET_INTERFACE_BUILDER
            gradientMask.colors = adjustedColors
            CATransaction.commit()
        #else
            if animated {
                // Finish transaction
                CATransaction.commit()
                
                // Create animation for color change
                let colorAnimation = GradientSetupAnimation(keyPath: "colors")
                colorAnimation.fromValue = gradientMask.colors
                colorAnimation.toValue = adjustedColors
                colorAnimation.fillMode = .forwards
                colorAnimation.isRemovedOnCompletion = false
                colorAnimation.delegate = self
                gradientMask.add(colorAnimation, forKey: "setupFade")
            } else {
                gradientMask.colors = adjustedColors
                CATransaction.commit()
            }
        #endif
    }
    
    private func removeGradientMask() {
        self.layer.mask = nil
    }
    
    private func timingFunctionForAnimationCurve(_ curve: UIView.AnimationCurve) -> CAMediaTimingFunction {
        let timingFunction: CAMediaTimingFunctionName?
        
        switch curve {
        case .easeIn:
            timingFunction = .easeIn
        case .easeInOut:
            timingFunction = .easeInEaseOut
        case .easeOut:
            timingFunction = .easeOut
        default:
            timingFunction = .linear
        }
        
        return CAMediaTimingFunction(name: timingFunction!)
    }
    
    private func transactionDurationType(_ labelType: MarqueeType, interval: CGFloat, delay: CGFloat) -> TimeInterval {
        switch labelType {
        case .leftRight, .rightLeft:
            return TimeInterval(2.0 * (delay + interval))
        default:
            return TimeInterval(delay + interval)
        }
    }
    
    public func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {
        if let setupAnim = anim as? GradientSetupAnimation {
            if let finalColors = setupAnim.toValue as? [CGColor] {
                maskLayer?.colors = finalColors
            }
            // Remove regardless, since we set removeOnCompletion = false
            maskLayer?.removeAnimation(forKey: "setupFade")
        } else {
            scrollCompletionBlock?(flag)
        }
    }
    
    
    //
    // MARK: - Private details
    //
    
    private var sublabel = UILabel()
    
    fileprivate var homeLabelFrame = CGRect.zero
    fileprivate var awayOffset: CGFloat = 0.0
    
    override open class var layerClass: AnyClass {
        return CAReplicatorLayer.self
    }
    
    fileprivate weak var repliLayer: CAReplicatorLayer? {
        return self.layer as? CAReplicatorLayer
    }
    
    fileprivate weak var maskLayer: CAGradientLayer? {
        return self.layer.mask as! CAGradientLayer?
    }
    
    fileprivate var scrollCompletionBlock: MLAnimationCompletionBlock?
    
    override open func draw(_ layer: CALayer, in ctx: CGContext) {
        // Do NOT call super, to prevent UILabel superclass from drawing into context
        // Label drawing is handled by sublabel and CAReplicatorLayer layer class
        
        // Draw only background color
        if let bgColor = backgroundColor {
            ctx.setFillColor(bgColor.cgColor)
            ctx.fill(layer.bounds)
        }
    }
    
    private var minimumTrailingDistance: CGFloat {
        // Spacing between primary and second sublabel must be at least equal to leadingBuffer, and at least equal to the fadeLengt
        return max(max(leadingBuffer, trailingBuffer), fadeLength)
    }
    
    fileprivate enum MarqueeKeys: String {
        case Restart = "MLViewControllerRestart"
        case Labelize = "MLShouldLabelize"
        case Animate = "MLShouldAnimate"
        case CompletionClosure = "MLAnimationCompletion"
    }
    
    class fileprivate func notifyController(_ controller: UIViewController, message: MarqueeKeys) {
        NotificationCenter.default.post(name: Notification.Name(rawValue: message.rawValue), object: nil, userInfo: ["controller" : controller])
    }
    
    @objc public func restartForViewController(_ notification: Notification) {
        if let controller = (notification as NSNotification).userInfo?["controller"] as? UIViewController {
            if controller === self.firstAvailableViewController() {
                self.restartLabel()
            }
        }
    }
    
    @objc public func labelizeForController(_ notification: Notification) {
        if let controller = (notification as NSNotification).userInfo?["controller"] as? UIViewController {
            if controller === self.firstAvailableViewController() {
                self.labelize = true
            }
        }
    }
    
    @objc public func animateForController(_ notification: Notification) {
        if let controller = (notification as NSNotification).userInfo?["controller"] as? UIViewController {
            if controller === self.firstAvailableViewController() {
                self.labelize = false
            }
        }
    }
    
    
    //
    // MARK: - Label Control
    //
    
    /**
     Overrides any non-size condition which is preventing the receiver from automatically scrolling, and begins a scroll animation.
    
     Currently the only non-size conditions which can prevent a label from scrolling are the `tapToScroll` and `holdScrolling` properties. This
     method will not force a label with a string that fits inside the label bounds (i.e. that would not automatically scroll) to begin a scroll
     animation.
    
     Upon the completion of the first forced scroll animation, the receiver will not automatically continue to scroll unless the conditions
     preventing scrolling have been removed.
    
     - Note: This method has no effect if called during an already in-flight scroll animation.
    
     - SeeAlso: restartLabel
    */
    public func triggerScrollStart() {
        if labelShouldScroll() && !awayFromHome {
            updateAndScroll(overrideHold: true)
        }
    }
    
    /**
     Immediately resets the label to the home position, cancelling any in-flight scroll animation, and restarts the scroll animation if the appropriate conditions are met.
     
     - SeeAlso: resetLabel
     - SeeAlso: triggerScrollStart
     */
    @objc public func restartLabel() {
        // Shutdown the label
        shutdownLabel()
        // Restart scrolling if appropriate
        if labelShouldScroll() && !tapToScroll && !holdScrolling {
            updateAndScroll()
        }
    }
    
    /**
     Resets the label text, recalculating the scroll animation.
     
     The text is immediately returned to the home position, and the scroll animation positions are cleared. Scrolling will not resume automatically after
     a call to this method. To re-initiate scrolling, use either a call to `restartLabel` or make a change to a UILabel property such as text, bounds/frame,
     font, font size, etc.
     
     - SeeAlso: restartLabel
     */
    @available(*, deprecated, message : "Use the shutdownLabel function instead")
    public func resetLabel() {
        returnLabelToHome()
        homeLabelFrame = CGRect.null
        awayOffset = 0.0
    }
    
    /**
     Immediately resets the label to the home position, cancelling any in-flight scroll animation.
     
     The text is immediately returned to the home position. Scrolling will not resume automatically after a call to this method.
     To re-initiate scrolling use a call to `restartLabel` or `triggerScrollStart`, or make a change to a UILabel property such as text, bounds/frame,
     font, font size, etc.
     
     - SeeAlso: restartLabel
     - SeeAlso: triggerScrollStart
     */
    @objc public func shutdownLabel() {
        // Bring label to home location
        returnLabelToHome()
        // Apply gradient mask for home location
        applyGradientMask(fadeLength, animated: false)
    }
    
    /**
     Pauses the text scrolling animation, at any point during an in-progress animation.
     
     - Note: This method has no effect if a scroll animation is NOT already in progress. To prevent automatic scrolling on a newly-initialized label prior to its presentation onscreen, see the `holdScrolling` property.
     
     - SeeAlso: holdScrolling
     - SeeAlso: unpauseLabel
     */
    public func pauseLabel() {
        // Prevent pausing label while not in scrolling animation, or when already paused
        guard !isPaused && awayFromHome else {
            return
        }
        
        // Pause sublabel position animations
        let labelPauseTime = sublabel.layer.convertTime(CACurrentMediaTime(), from: nil)
        sublabel.layer.speed = 0.0
        sublabel.layer.timeOffset = labelPauseTime
        
        // Pause gradient fade animation
        let gradientPauseTime = maskLayer?.convertTime(CACurrentMediaTime(), from:nil)
        maskLayer?.speed = 0.0
        maskLayer?.timeOffset = gradientPauseTime!
    }
    
    /**
     Un-pauses a previously paused text scrolling animation. This method has no effect if the label was not previously paused using `pauseLabel`.
     
     - SeeAlso: pauseLabel
     */
    public func unpauseLabel() {
        // Only unpause if label was previously paused
        guard isPaused else {
            return
        }
        
        // Unpause sublabel position animations
        let labelPausedTime = sublabel.layer.timeOffset
        sublabel.layer.speed = 1.0
        sublabel.layer.timeOffset = 0.0
        sublabel.layer.beginTime = 0.0
        sublabel.layer.beginTime = sublabel.layer.convertTime(CACurrentMediaTime(), from:nil) - labelPausedTime
        
        // Unpause gradient fade animation
        let gradientPauseTime = maskLayer?.timeOffset
        maskLayer?.speed = 1.0
        maskLayer?.timeOffset = 0.0
        maskLayer?.beginTime = 0.0
        maskLayer?.beginTime = maskLayer!.convertTime(CACurrentMediaTime(), from:nil) - gradientPauseTime!
    }
    
    @objc public func labelWasTapped(_ recognizer: UIGestureRecognizer) {
        if labelShouldScroll() && !awayFromHome {
            // Set shouldBeginScroll to true to begin single scroll due to tap
            updateAndScroll(overrideHold: true)
        }
    }
    
    /**
     Function to convert a point from the label view frame coordinates to "text" coordinates, i.e. the equivalent
     position in the (possibly) scrolling label. For example, it can be used to convert the coordinates
     of a tap point on the MarqueeLabel view into that of the scrolling label, in order to determine the
     word or character under the tap point.
     
     If the specified point does not fall inside the bounds of the scrolling label, such as if on a leading
     or trailing buffer area, the function will return nil.
     */
    open func textCoordinateForFramePoint(_ point:CGPoint) -> CGPoint? {
        // Check for presentation layer, if none return input point
        guard let presentationLayer = sublabel.layer.presentation() else { return point }
        // Convert point from MarqueeLabel main layer to sublabel's presentationLayer
        let presentationPoint = presentationLayer.convert(point, from: self.layer)
        // Check if point overlaps into 2nd instance of a continuous type label
        let textPoint: CGPoint?
        let presentationX = presentationPoint.x
        let labelWidth = sublabel.frame.size.width
        
        var containers: [Range<CGFloat>] = []
        switch type {
        case .continuous:
            // First label frame range
            let firstLabel = 0.0 ..< sublabel.frame.size.width
            // Range from end of first label to the minimum trailining distance (i.e. the separator)
            let minTrailing = firstLabel.rangeForExtension(minimumTrailingDistance)
            // Range of second label instance, from end of separator to length
            let secondLabel = minTrailing.rangeForExtension(labelWidth)
            // Add valid ranges to array to check
            containers += [firstLabel, secondLabel]
        case .continuousReverse:
            // First label frame range
            let firstLabel = 0.0 ..< sublabel.frame.size.width
            // Range of second label instance, from end of separator to length
            let secondLabel = -sublabel.frame.size.width ..< -minimumTrailingDistance
            // Add valid ranges to array to check
            containers += [firstLabel, secondLabel]
        case .left, .leftRight, .right, .rightLeft:
            // Only label frame range
            let firstLabel = 0.0 ..< sublabel.frame.size.width
            containers.append(firstLabel)
        }
        
        // Determine which range contains the point, or return nil if in a buffer/margin area
        guard let container = containers.filter({ (rng) -> Bool in
            return rng.contains(presentationX)
        }).first else { return nil }
            
        textPoint = CGPoint(x: (presentationX - container.lowerBound), y: presentationPoint.y)
        return textPoint
    }
    
    /**
     Called when the label animation is about to begin.
     
     The default implementation of this method does nothing. Subclasses may override this method in order to perform any custom actions just as
     the label animation begins. This is only called in the event that the conditions for scrolling to begin are met.
     */
    open func labelWillBeginScroll() {
        // Default implementation does nothing - override to customize
        return
    }
    
    /**
     Called when the label animation has finished, and the label is at the home position.
     
     The default implementation of this method does nothing. Subclasses may override this method in order to perform any custom actions jas as
     the label animation completes, and before the next animation would begin (assuming the scroll conditions are met).
     
     - Parameter finished: A Boolean that indicates whether or not the scroll animation actually finished before the completion handler was called.
     
     - Warning: This method will be called, and the `finished` parameter will be `NO`, when any property changes are made that would cause the label
     scrolling to be automatically reset. This includes changes to label text and font/font size changes.
     */
    open func labelReturnedToHome(_ finished: Bool) {
        // Default implementation does nothing - override to customize
        return
    }
    
    //
    // MARK: - Modified UILabel Functions/Getters/Setters
    //
    
    #if os(iOS)
    override open func forBaselineLayout() -> UIView {
        // Use subLabel view for handling baseline layouts
        return sublabel
    }
    
    override open var forLastBaselineLayout: UIView {
        // Use subLabel view for handling baseline layouts
        return sublabel
    }
    #endif

    override open var text: String? {
        get {
            return sublabel.text
        }
        
        set {
            if sublabel.text == newValue {
                return
            }
            sublabel.text = newValue
            updateAndScroll()
            super.text = text
        }
    }
    
    override open var attributedText: NSAttributedString? {
        get {
            return sublabel.attributedText
        }
        
        set {
            if sublabel.attributedText == newValue {
                return
            }
            sublabel.attributedText = newValue
            updateAndScroll()
            super.attributedText = attributedText
        }
    }
    
    override open var font: UIFont! {
        get {
            return sublabel.font
        }
        
        set {
            if sublabel.font == newValue {
                return
            }
            sublabel.font = newValue
            super.font = newValue
            
            updateAndScroll()
        }
    }
    
    override open var textColor: UIColor! {
        get {
            return sublabel.textColor
        }
        
        set {
            sublabel.textColor = newValue
            super.textColor = newValue
        }
    }
    
    override open var backgroundColor: UIColor? {
        get {
            return sublabel.backgroundColor
        }
        
        set {
            sublabel.backgroundColor = newValue
            super.backgroundColor = newValue
        }
    }
    
    override open var shadowColor: UIColor? {
        get {
            return sublabel.shadowColor
        }
        
        set {
            sublabel.shadowColor = newValue
            super.shadowColor = newValue
        }
    }
    
    override open var shadowOffset: CGSize {
        get {
            return sublabel.shadowOffset
        }
        
        set {
            sublabel.shadowOffset = newValue
            super.shadowOffset = newValue
        }
    }
    
    override open var highlightedTextColor: UIColor? {
        get {
            return sublabel.highlightedTextColor
        }
        
        set {
            sublabel.highlightedTextColor = newValue
            super.highlightedTextColor = newValue
        }
    }
    
    override open var isHighlighted: Bool {
        get {
            return sublabel.isHighlighted
        }
        
        set {
            sublabel.isHighlighted = newValue
            super.isHighlighted = newValue
        }
    }
    
    override open var isEnabled: Bool {
        get {
            return sublabel.isEnabled
        }
        
        set {
            sublabel.isEnabled = newValue
            super.isEnabled = newValue
        }
    }
    
    override open var numberOfLines: Int {
        get {
            return super.numberOfLines
        }
        
        set {
            // By the nature of MarqueeLabel, this is 1
            super.numberOfLines = 1
        }
    }
    
    override open var baselineAdjustment: UIBaselineAdjustment {
        get {
            return sublabel.baselineAdjustment
        }
        
        set {
            sublabel.baselineAdjustment = newValue
            super.baselineAdjustment = newValue
        }
    }
    
    override open var intrinsicContentSize: CGSize {
        var content = sublabel.intrinsicContentSize
        content.width += leadingBuffer
        return content
    }
    
    override open var tintColor: UIColor! {
        get {
            return sublabel.tintColor
        }
        
        set {
            sublabel.tintColor = newValue
            super.tintColor = newValue
        }
    }
    
    override open func tintColorDidChange() {
        super.tintColorDidChange()
        sublabel.tintColorDidChange()
    }
    
    override open var contentMode: UIView.ContentMode {
        get {
            return sublabel.contentMode
        }
        
        set {
            super.contentMode = contentMode
            sublabel.contentMode = newValue
        }
    }
    
    open override var isAccessibilityElement: Bool {
        didSet {
            sublabel.isAccessibilityElement = self.isAccessibilityElement
        }
    }

    //
    // MARK: - Support
    //
    
    fileprivate func offsetCGPoint(_ point: CGPoint, offset: CGFloat) -> CGPoint {
        return CGPoint(x: point.x + offset, y: point.y)
    }
    
    //
    // MARK: - Deinit
    //
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
}


//
// MARK: - Support
//
public protocol MarqueeStep {
    var timeStep: CGFloat { get }
    var timingFunction: UIView.AnimationCurve { get }
    var edgeFades: EdgeFade { get }
}


/**
 `ScrollStep` types define the label position at a specified time delta since the last `ScrollStep` step, as well as
 the animation curve to that position and edge fade state at the position
 */
public struct ScrollStep: MarqueeStep {
    /**
     An enum that provides the possible positions defined by a ScrollStep
     - `home`: The starting, default position of the label
     - `away`: The calculated position that results in the entirety of the label scrolling past.
     - `partial(CGFloat)`: A fractional value, specified by the associated CGFloat value, between the `home` and `away` positions (must be between 0.0 and 1.0).
     
     The `away` position depends on the MarqueeLabel `type` value.
     - For `left`, `leftRight`, `right`, and `rightLeft` types, the `away` position means the trailing edge of the label
        is visible. For `leftRight` and `rightLeft` default types, the scroll animation reverses direction after reaching
        this point and returns to the `home` position.
     - For `continuous` and `continuousReverse` types, the `away` position is the location such that if the scroll is completed
        at this point (i.e. the animation is removed), there will be no visible change in the label appearance.
     */
    public enum Position {
        case home
        case away
        case partial(CGFloat)
    }
    
    /**
     The desired time between this step and the previous `ScrollStep` in a sequence.
    */
    public let timeStep: CGFloat
    
    /**
     The animation curve to utilize between the previous `ScrollStep` in a sequence and this step.
     
     - Note: The animation curve value for the first `ScrollStep` in a sequence has no effect.
     */
    public let timingFunction: UIView.AnimationCurve
    
    /**
     The position of the label for this scroll step.
     - SeeAlso: Position
     */
    public let position: Position
    
    /**
     The option set defining the edge fade state for this scroll step.
     
     Possible options include `.leading` and `.trailing`, corresponding to the leading edge of the label scrolling (i.e. 
     the direction of scroll) and trailing edge of the label.
    */
    public let edgeFades: EdgeFade
    
    public init(timeStep: CGFloat, timingFunction: UIView.AnimationCurve = .linear, position: Position, edgeFades: EdgeFade) {
        self.timeStep = timeStep
        self.position = position
        self.edgeFades = edgeFades
        self.timingFunction = timingFunction
    }
}


/**
 `FadeStep` types allow additional edge fade state definitions, around the states defined by the `ScrollStep` steps of
 a sequence. `FadeStep` steps are defined by the time delta to the preceding or subsequent `ScrollStep` step and the timing
 function to their edge fade state.
 
 - Note: A `FadeStep` cannot be the first step in a sequence. A `FadeStep` defined as such will be ignored.
 */
public struct FadeStep: MarqueeStep {
    /**
     The desired time between this `FadeStep` and the preceding or subsequent `ScrollStep` in a sequence.
     
     `FadeSteps` with a negative `timeStep` value will be associated _only_ with an immediately-subsequent `ScrollStep` step
     in the sequence.
     
     `FadeSteps` with a positive `timeStep` value will be associated _only_ with an immediately-prior `ScrollStep` step in the
     sequence.
     
     - Note: A `FadeStep` with a `timeStep` value of 0.0 will have no effect, and is the same as defining the fade state with
     a `ScrollStep`.
     */
    public let timeStep: CGFloat
    
    /**
     The animation curve to utilize between the previous fade state in a sequence and this step.
     */
    public let timingFunction: UIView.AnimationCurve
    
    /**
     The option set defining the edge fade state for this fade step.
     
     Possible options include `.leading` and `.trailing`, corresponding to the leading edge of the label scrolling (i.e.
     the direction of scroll) and trailing edge of the label.
     
     As an Option Set type, both edge fade states may be defined using an array literal: `[.leading, .trailing]`.
     */
    public let edgeFades: EdgeFade
    
    public init(timeStep: CGFloat, timingFunction: UIView.AnimationCurve = .linear, edgeFades: EdgeFade) {
        self.timeStep = timeStep
        self.timingFunction = timingFunction
        self.edgeFades = edgeFades
    }
}

public struct EdgeFade: OptionSet {
    public let rawValue: Int
    public static let leading = EdgeFade(rawValue: 1 << 0)
    public static let trailing = EdgeFade(rawValue: 1 << 1)

    public init(rawValue: Int) {
        self.rawValue = rawValue
    }
}

// Define helpful typealiases
fileprivate typealias MLAnimationCompletionBlock = (_ finished: Bool) -> Void
fileprivate typealias MLAnimation = (anim: CAKeyframeAnimation, duration: CGFloat)

fileprivate class GradientSetupAnimation: CABasicAnimation {
}

fileprivate extension UILabel {
    func desiredSize() -> CGSize {
        // Bound the expected size
        let maximumLabelSize = CGSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)
        // Calculate the expected size
        var expectedLabelSize = self.sizeThatFits(maximumLabelSize)
        
        #if os(tvOS)
            // Sanitize width to 16384.0 (largest width a UILabel will draw on tvOS)
            expectedLabelSize.width = min(expectedLabelSize.width, 16384.0)
        #else
            // Sanitize width to 5461.0 (largest width a UILabel will draw on an iPhone 6S Plus)
            expectedLabelSize.width = min(expectedLabelSize.width, 5461.0)
        #endif

        // Adjust to own height (make text baseline match normal label)
        expectedLabelSize.height = bounds.size.height
        return expectedLabelSize
    }
}

fileprivate extension Range where Bound == CGFloat {
    func rangeForExtension(_ ext: CGFloat) -> Range {
        return self.upperBound..<(self.upperBound + ext)
    }
}

fileprivate extension UIResponder {
    // Thanks to Phil M
    // http://stackoverflow.com/questions/1340434/get-to-uiviewcontroller-from-uiview-on-iphone
    
    func firstAvailableViewController() -> UIViewController? {
        // convenience function for casting and to "mask" the recursive function
        return self.traverseResponderChainForFirstViewController()
    }
    
    func traverseResponderChainForFirstViewController() -> UIViewController? {
        if let nextResponder = self.next {
            if nextResponder is UIViewController {
                return nextResponder as? UIViewController
            } else if nextResponder is UIView {
                return nextResponder.traverseResponderChainForFirstViewController()
            } else {
                return nil
            }
        }
        return nil
    }
}

fileprivate extension CAMediaTimingFunction {
    
    func durationPercentageForPositionPercentage(_ positionPercentage: CGFloat, duration: CGFloat) -> CGFloat {
        // Finds the animation duration percentage that corresponds with the given animation "position" percentage.
        // Utilizes Newton's Method to solve for the parametric Bezier curve that is used by CAMediaAnimation.
        
        let controlPoints = self.controlPoints()
        let epsilon: CGFloat = 1.0 / (100.0 * CGFloat(duration))
        
        // Find the t value that gives the position percentage we want
        let t_found = solveTforY(positionPercentage, epsilon: epsilon, controlPoints: controlPoints)
        
        // With that t, find the corresponding animation percentage
        let durationPercentage = XforCurveAt(t_found, controlPoints: controlPoints)
        
        return durationPercentage
    }
    
    func solveTforY(_ y_0: CGFloat, epsilon: CGFloat, controlPoints: [CGPoint]) -> CGFloat {
        // Use Newton's Method: http://en.wikipedia.org/wiki/Newton's_method
        // For first guess, use t = y (i.e. if curve were linear)
        var t0 = y_0
        var t1 = y_0
        var f0, df0: CGFloat
        
        for _ in 0..<15 {
            // Base this iteration of t1 calculated from last iteration
            t0 = t1
            // Calculate f(t0)
            f0 = YforCurveAt(t0, controlPoints:controlPoints) - y_0
            // Check if this is close (enough)
            if abs(f0) < epsilon {
                // Done!
                return t0
            }
            // Else continue Newton's Method
            df0 = derivativeCurveYValueAt(t0, controlPoints:controlPoints)
            // Check if derivative is small or zero ( http://en.wikipedia.org/wiki/Newton's_method#Failure_analysis )
            if abs(df0) < 1e-6 {
                break
            }
            // Else recalculate t1
            t1 = t0 - f0/df0
        }
        
        // Give up - shouldn't ever get here...I hope
        print("MarqueeLabel: Failed to find t for Y input!")
        return t0
    }

    func YforCurveAt(_ t: CGFloat, controlPoints: [CGPoint]) -> CGFloat {
        let P0 = controlPoints[0]
        let P1 = controlPoints[1]
        let P2 = controlPoints[2]
        let P3 = controlPoints[3]
        
        // Per http://en.wikipedia.org/wiki/Bezier_curve#Cubic_B.C3.A9zier_curves
        let y0 = (pow((1.0 - t), 3.0) * P0.y)
        let y1 = (3.0 * pow(1.0 - t, 2.0) * t * P1.y)
        let y2 = (3.0 * (1.0 - t) * pow(t, 2.0) * P2.y)
        let y3 = (pow(t, 3.0) * P3.y)
        
        return y0 + y1 + y2 + y3
    }
    
    func XforCurveAt(_ t: CGFloat, controlPoints: [CGPoint]) -> CGFloat {
        let P0 = controlPoints[0]
        let P1 = controlPoints[1]
        let P2 = controlPoints[2]
        let P3 = controlPoints[3]
        
        // Per http://en.wikipedia.org/wiki/Bezier_curve#Cubic_B.C3.A9zier_curves

        let x0 = (pow((1.0 - t), 3.0) * P0.x)
        let x1 = (3.0 * pow(1.0 - t, 2.0) * t * P1.x)
        let x2 = (3.0 * (1.0 - t) * pow(t, 2.0) * P2.x)
        let x3 = (pow(t, 3.0) * P3.x)
        
        return x0 + x1 + x2 + x3
    }
    
    func derivativeCurveYValueAt(_ t: CGFloat, controlPoints: [CGPoint]) -> CGFloat {
        let P0 = controlPoints[0]
        let P1 = controlPoints[1]
        let P2 = controlPoints[2]
        let P3 = controlPoints[3]
        
        let dy0 = (P0.y + 3.0 * P1.y + 3.0 * P2.y - P3.y) * -3.0
        let dy1 = t * (6.0 * P0.y + 6.0 * P2.y)
        let dy2 = (-3.0 * P0.y + 3.0 * P1.y)

        return dy0 * pow(t, 2.0) + dy1 + dy2
    }
    
    func controlPoints() -> [CGPoint] {
        // Create point array to point to
        var point: [Float] = [0.0, 0.0]
        var pointArray = [CGPoint]()
        for i in 0...3 {
            self.getControlPoint(at: i, values: &point)
            pointArray.append(CGPoint(x: CGFloat(point[0]), y: CGFloat(point[1])))
        }
        
        return pointArray
    }
}

import Security
import Foundation

/**

A collection of helper functions for saving text and data in the keychain.

*/
open class KeychainSwift {
  
  var lastQueryParameters: [String: Any]? // Used by the unit tests
  
  /// Contains result code from the last operation. Value is noErr (0) for a successful result.
  open var lastResultCode: OSStatus = noErr

  var keyPrefix = "" // Can be useful in test.
  
  /**

  Specify an access group that will be used to access keychain items. Access groups can be used to share keychain items between applications. When access group value is nil all application access groups are being accessed. Access group name is used by all functions: set, get, delete and clear.

  */
  open var accessGroup: String?
  
  
  /**
   
  Specifies whether the items can be synchronized with other devices through iCloud. Setting this property to true will
   add the item to other devices with the `set` method and obtain synchronizable items with the `get` command. Deleting synchronizable items will remove them from all devices. In order for keychain synchronization to work the user must enable "Keychain" in iCloud settings.
   
  Does not work on macOS.
   
  */
  open var synchronizable: Bool = false

  private let lock = NSLock()

  
  /// Instantiate a KeychainSwift object
  public init() { }
  
  /**
  
  - parameter keyPrefix: a prefix that is added before the key in get/set methods. Note that `clear` method still clears everything from the Keychain.

  */
  public init(keyPrefix: String) {
    self.keyPrefix = keyPrefix
  }
  
  /**
  
  Stores the text value in the keychain item under the given key.
  
  - parameter key: Key under which the text value is stored in the keychain.
  - parameter value: Text string to be written to the keychain.
  - parameter withAccess: Value that indicates when your app needs access to the text in the keychain item. By default the .AccessibleWhenUnlocked option is used that permits the data to be accessed only while the device is unlocked by the user.
   
   - returns: True if the text was successfully written to the keychain.

  */
  @discardableResult
  open func set(_ value: String, forKey key: String,
                  withAccess access: KeychainSwiftAccessOptions? = nil) -> Bool {
    
    if let value = value.data(using: String.Encoding.utf8) {
      return set(value, forKey: key, withAccess: access)
    }
    
    return false
  }

  /**
  
  Stores the data in the keychain item under the given key.
  
  - parameter key: Key under which the data is stored in the keychain.
  - parameter value: Data to be written to the keychain.
  - parameter withAccess: Value that indicates when your app needs access to the text in the keychain item. By default the .AccessibleWhenUnlocked option is used that permits the data to be accessed only while the device is unlocked by the user.
  
  - returns: True if the text was successfully written to the keychain.
  
  */
  @discardableResult
  open func set(_ value: Data, forKey key: String,
    withAccess access: KeychainSwiftAccessOptions? = nil) -> Bool {
    
    // The lock prevents the code to be run simultaneously
    // from multiple threads which may result in crashing
    lock.lock()
    defer { lock.unlock() }
    
    deleteNoLock(key) // Delete any existing key before saving it

    let accessible = access?.value ?? KeychainSwiftAccessOptions.defaultOption.value
      
    let prefixedKey = keyWithPrefix(key)
      
    var query: [String : Any] = [
      KeychainSwiftConstants.klass       : kSecClassGenericPassword,
      KeychainSwiftConstants.attrAccount : prefixedKey,
      KeychainSwiftConstants.valueData   : value,
      KeychainSwiftConstants.accessible  : accessible
    ]
      
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: true)
    lastQueryParameters = query
    
    lastResultCode = SecItemAdd(query as CFDictionary, nil)
    
    return lastResultCode == noErr
  }

  /**

  Stores the boolean value in the keychain item under the given key.

  - parameter key: Key under which the value is stored in the keychain.
  - parameter value: Boolean to be written to the keychain.
  - parameter withAccess: Value that indicates when your app needs access to the value in the keychain item. By default the .AccessibleWhenUnlocked option is used that permits the data to be accessed only while the device is unlocked by the user.

  - returns: True if the value was successfully written to the keychain.

  */
  @discardableResult
  open func set(_ value: Bool, forKey key: String,
    withAccess access: KeychainSwiftAccessOptions? = nil) -> Bool {
  
    let bytes: [UInt8] = value ? [1] : [0]
    let data = Data(bytes)

    return set(data, forKey: key, withAccess: access)
  }

  /**
  
  Retrieves the text value from the keychain that corresponds to the given key.
  
  - parameter key: The key that is used to read the keychain item.
  - returns: The text value from the keychain. Returns nil if unable to read the item.
  
  */
  open func get(_ key: String) -> String? {
    if let data = getData(key) {
      
      if let currentString = String(data: data, encoding: .utf8) {
        return currentString
      }
      
      lastResultCode = -67853 // errSecInvalidEncoding
    }

    return nil
  }

  /**
  
  Retrieves the data from the keychain that corresponds to the given key.
  
  - parameter key: The key that is used to read the keychain item.
  - parameter asReference: If true, returns the data as reference (needed for things like NEVPNProtocol).
  - returns: The text value from the keychain. Returns nil if unable to read the item.
  
  */
  open func getData(_ key: String, asReference: Bool = false) -> Data? {
    // The lock prevents the code to be run simultaneously
    // from multiple threads which may result in crashing
    lock.lock()
    defer { lock.unlock() }
    
    let prefixedKey = keyWithPrefix(key)
    
    var query: [String: Any] = [
      KeychainSwiftConstants.klass       : kSecClassGenericPassword,
      KeychainSwiftConstants.attrAccount : prefixedKey,
      KeychainSwiftConstants.matchLimit  : kSecMatchLimitOne
    ]
    
    if asReference {
      query[KeychainSwiftConstants.returnReference] = kCFBooleanTrue
    } else {
      query[KeychainSwiftConstants.returnData] =  kCFBooleanTrue
    }
    
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: false)
    lastQueryParameters = query
    
    var result: AnyObject?
    
    lastResultCode = withUnsafeMutablePointer(to: &result) {
      SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
    }
    
    if lastResultCode == noErr {
      return result as? Data
    }
    
    return nil
  }

  /**

  Retrieves the boolean value from the keychain that corresponds to the given key.

  - parameter key: The key that is used to read the keychain item.
  - returns: The boolean value from the keychain. Returns nil if unable to read the item.

  */
  open func getBool(_ key: String) -> Bool? {
    guard let data = getData(key) else { return nil }
    guard let firstBit = data.first else { return nil }
    return firstBit == 1
  }

  /**

  Deletes the single keychain item specified by the key.
  
  - parameter key: The key that is used to delete the keychain item.
  - returns: True if the item was successfully deleted.
  
  */
  @discardableResult
  open func delete(_ key: String) -> Bool {
    // The lock prevents the code to be run simultaneously
    // from multiple threads which may result in crashing
    lock.lock()
    defer { lock.unlock() }
    
    return deleteNoLock(key)
  }
  
  /**
  Return all keys from keychain
   
  - returns: An string array with all keys from the keychain.
   
  */
  public var allKeys: [String] {
    var query: [String: Any] = [
      KeychainSwiftConstants.klass : kSecClassGenericPassword,
      KeychainSwiftConstants.returnData : true,
      KeychainSwiftConstants.returnAttributes: true,
      KeychainSwiftConstants.returnReference: true,
      KeychainSwiftConstants.matchLimit: KeychainSwiftConstants.secMatchLimitAll
    ]
  
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: false)

    var result: AnyObject?

    let lastResultCode = withUnsafeMutablePointer(to: &result) {
      SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
    }
    
    if lastResultCode == noErr {
      return (result as? [[String: Any]])?.compactMap {
        $0[KeychainSwiftConstants.attrAccount] as? String } ?? []
    }
    
    return []
  }
    
  /**
   
  Same as `delete` but is only accessed internally, since it is not thread safe.
   
   - parameter key: The key that is used to delete the keychain item.
   - returns: True if the item was successfully deleted.
   
   */
  @discardableResult
  func deleteNoLock(_ key: String) -> Bool {
    let prefixedKey = keyWithPrefix(key)
    
    var query: [String: Any] = [
      KeychainSwiftConstants.klass       : kSecClassGenericPassword,
      KeychainSwiftConstants.attrAccount : prefixedKey
    ]
    
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: false)
    lastQueryParameters = query
    
    lastResultCode = SecItemDelete(query as CFDictionary)
    
    return lastResultCode == noErr
  }

  /**
  
  Deletes all Keychain items used by the app. Note that this method deletes all items regardless of the prefix settings used for initializing the class.
  
  - returns: True if the keychain items were successfully deleted.
  
  */
  @discardableResult
  open func clear() -> Bool {
    // The lock prevents the code to be run simultaneously
    // from multiple threads which may result in crashing
    lock.lock()
    defer { lock.unlock() }
    
    var query: [String: Any] = [ kSecClass as String : kSecClassGenericPassword ]
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: false)
    lastQueryParameters = query
    
    lastResultCode = SecItemDelete(query as CFDictionary)
    
    return lastResultCode == noErr
  }
  
  /// Returns the key with currently set prefix.
  func keyWithPrefix(_ key: String) -> String {
    return "\(keyPrefix)\(key)"
  }
  
  func addAccessGroupWhenPresent(_ items: [String: Any]) -> [String: Any] {
    guard let accessGroup = accessGroup else { return items }
    
    var result: [String: Any] = items
    result[KeychainSwiftConstants.accessGroup] = accessGroup
    return result
  }
  
  /**
 
  Adds kSecAttrSynchronizable: kSecAttrSynchronizableAny` item to the dictionary when the `synchronizable` property is true.
   
   - parameter items: The dictionary where the kSecAttrSynchronizable items will be added when requested.
   - parameter addingItems: Use `true` when the dictionary will be used with `SecItemAdd` method (adding a keychain item). For getting and deleting items, use `false`.
   
   - returns: the dictionary with kSecAttrSynchronizable item added if it was requested. Otherwise, it returns the original dictionary.
 
  */
  func addSynchronizableIfRequired(_ items: [String: Any], addingItems: Bool) -> [String: Any] {
    if !synchronizable { return items }
    var result: [String: Any] = items
    result[KeychainSwiftConstants.attrSynchronizable] = addingItems == true ? true : kSecAttrSynchronizableAny
    return result
  }
}
import Foundation
import Security

/// Constants used by the library
public struct KeychainSwiftConstants {
  /// Specifies a Keychain access group. Used for sharing Keychain items between apps.
  public static var accessGroup: String { return toString(kSecAttrAccessGroup) }
  
  /**
   
   A value that indicates when your app needs access to the data in a keychain item. The default value is AccessibleWhenUnlocked. For a list of possible values, see KeychainSwiftAccessOptions.
   
   */
  public static var accessible: String { return toString(kSecAttrAccessible) }
  
  /// Used for specifying a String key when setting/getting a Keychain value.
  public static var attrAccount: String { return toString(kSecAttrAccount) }

  /// Used for specifying synchronization of keychain items between devices.
  public static var attrSynchronizable: String { return toString(kSecAttrSynchronizable) }
  
  /// An item class key used to construct a Keychain search dictionary.
  public static var klass: String { return toString(kSecClass) }
  
  /// Specifies the number of values returned from the keychain. The library only supports single values.
  public static var matchLimit: String { return toString(kSecMatchLimit) }
  
  /// A return data type used to get the data from the Keychain.
  public static var returnData: String { return toString(kSecReturnData) }
  
  /// Used for specifying a value when setting a Keychain value.
  public static var valueData: String { return toString(kSecValueData) }
    
  /// Used for returning a reference to the data from the keychain
  public static var returnReference: String { return toString(kSecReturnPersistentRef) }
  
  /// A key whose value is a Boolean indicating whether or not to return item attributes
  public static var returnAttributes : String { return toString(kSecReturnAttributes) }
    
  /// A value that corresponds to matching an unlimited number of items
  public static var secMatchLimitAll : String { return toString(kSecMatchLimitAll) }
    
  static func toString(_ value: CFString) -> String {
    return value as String
  }
}


import Security

/**

These options are used to determine when a keychain item should be readable. The default value is AccessibleWhenUnlocked.

*/
public enum KeychainSwiftAccessOptions {
  
  /**
  
  The data in the keychain item can be accessed only while the device is unlocked by the user.
  
  This is recommended for items that need to be accessible only while the application is in the foreground. Items with this attribute migrate to a new device when using encrypted backups.
  
  This is the default value for keychain items added without explicitly setting an accessibility constant.
  
  */
  case accessibleWhenUnlocked
  
  /**
  
  The data in the keychain item can be accessed only while the device is unlocked by the user.
  
  This is recommended for items that need to be accessible only while the application is in the foreground. Items with this attribute do not migrate to a new device. Thus, after restoring from a backup of a different device, these items will not be present.
  
  */
  case accessibleWhenUnlockedThisDeviceOnly
  
  /**
  
  The data in the keychain item cannot be accessed after a restart until the device has been unlocked once by the user.
  
  After the first unlock, the data remains accessible until the next restart. This is recommended for items that need to be accessed by background applications. Items with this attribute migrate to a new device when using encrypted backups.
  
  */
  case accessibleAfterFirstUnlock
  
  /**
  
  The data in the keychain item cannot be accessed after a restart until the device has been unlocked once by the user.
  
  After the first unlock, the data remains accessible until the next restart. This is recommended for items that need to be accessed by background applications. Items with this attribute do not migrate to a new device. Thus, after restoring from a backup of a different device, these items will not be present.
  
  */
  case accessibleAfterFirstUnlockThisDeviceOnly

  /**
  
  The data in the keychain can only be accessed when the device is unlocked. Only available if a passcode is set on the device.
  
  This is recommended for items that only need to be accessible while the application is in the foreground. Items with this attribute never migrate to a new device. After a backup is restored to a new device, these items are missing. No items can be stored in this class on devices without a passcode. Disabling the device passcode causes all items in this class to be deleted.
  
  */
  case accessibleWhenPasscodeSetThisDeviceOnly
  
  static var defaultOption: KeychainSwiftAccessOptions {
    return .accessibleWhenUnlocked
  }
  
  var value: String {
    switch self {
    case .accessibleWhenUnlocked:
      return toString(kSecAttrAccessibleWhenUnlocked)
      
    case .accessibleWhenUnlockedThisDeviceOnly:
      return toString(kSecAttrAccessibleWhenUnlockedThisDeviceOnly)
      
    case .accessibleAfterFirstUnlock:
      return toString(kSecAttrAccessibleAfterFirstUnlock)
      
    case .accessibleAfterFirstUnlockThisDeviceOnly:
      return toString(kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly)
      
    case .accessibleWhenPasscodeSetThisDeviceOnly:
      return toString(kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly)
    }
  }
  
  func toString(_ value: CFString) -> String {
    return KeychainSwiftConstants.toString(value)
  }
}
