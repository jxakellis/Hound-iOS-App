//
//  SettingsTableViewCell.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/28/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum SettingsPages: String, CaseIterable {
    case account = "Account"
    case family = "Family"
    case subscription = "Subscription"
    case appearance = "Appearance"
    case notifications = "Notifications"
    case website = "Website"
    case feedback = "Feedback"
    case support = "Support"
    case eula = "EULA"
    case privacyPolicy = "Privacy Policy"
    case termsAndConditions = "Terms and Conditions"
    
    var url: URL? {
        switch self {
        case .account:
            return nil
        case .family:
            return nil
        case .subscription:
            return nil
        case .appearance:
            return nil
        case .notifications:
            return nil
        case .website:
            return URL(string: "https://www.houndorganizer.com")
        case .feedback:
            return nil
        case .support:
            return URL(string: "https://www.houndorganizer.com/contact")
        case .eula:
            return URL(string: "https://www.houndorganizer.com/eula")
        case .privacyPolicy:
            return URL(string: "https://www.houndorganizer.com/privacy")
        case .termsAndConditions:
            return URL(string: "https://www.houndorganizer.com/terms")
        }
    }
    
    var image: UIImage? {
        switch self {
        case .account:
            return UIImage(systemName: "person.crop.circle")
        case .family:
            return UIImage(systemName: "figure.and.child.holdinghands") ?? UIImage(systemName: "person.3")
        case .subscription:
            return UIImage(systemName: "creditcard")
        case .appearance:
            return UIImage(systemName: "textformat")
        case .notifications:
            return UIImage(systemName: "iphone.radiowaves.left.and.right")
        case .website:
            return UIImage(systemName: "globe")
        case .feedback:
            return UIImage(systemName: "square.and.pencil")
        case .support:
            return UIImage(systemName: "envelope")
        case .eula:
            return UIImage(systemName: "doc.plaintext")
        case .privacyPolicy:
            return UIImage(systemName: "shield")
        case .termsAndConditions:
            return UIImage(systemName: "text.book.closed")
        }
    }
}

final class SettingsPagesTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBlue
        return view
    }()
    
    private let pageImageButton: GeneralUIImageView = {
        let imageView = GeneralUIImageView()
        
        imageView.image = UIImage(systemName: "xmark")
        imageView.tintColor = .systemBackground
        
        return imageView
    }()
    
    private let pageTitleLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.text = "Account"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let chevonImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView()
        
        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = .systemBackground
        
        return imageView
    }()
    
    // MARK: - Properties
    
    var page: SettingsPages?
    
    static let reuseIdentifier = "SettingsPagesTVC"
    
    // MARK: - Setup
    
    func setup(forPage: SettingsPages) {
        self.page = forPage
        
        pageImageButton.image = forPage.image
        pageTitleLabel.text = forPage.rawValue
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(pageImageButton)
        containerView.addSubview(pageTitleLabel)
        containerView.addSubview(chevonImageView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // pageImageButton constraints
        let imageTop = pageImageButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 3.5)
        let imageBottomContainer = pageImageButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -3.5)
        let imageBottomTitle = pageImageButton.bottomAnchor.constraint(equalTo: pageTitleLabel.bottomAnchor)
        let imageLeading = pageImageButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 3.5)
        let imageSquare = pageImageButton.widthAnchor.constraint(equalTo: pageImageButton.heightAnchor)
        let imageHeight = pageImageButton.heightAnchor.constraint(equalToConstant: 32.5)

        // chevonImageView constraints
        let chevronLeading = chevonImageView.leadingAnchor.constraint(equalTo: pageTitleLabel.trailingAnchor, constant: 5)
        let chevronTrailing = chevonImageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -7.5)
        let chevronCenterY = chevonImageView.centerYAnchor.constraint(equalTo: containerView.centerYAnchor)
        let chevronAspect = chevonImageView.widthAnchor.constraint(equalTo: chevonImageView.heightAnchor, multiplier: 1 / 1.5)
        let chevronToTitleHeight = chevonImageView.widthAnchor.constraint(equalTo: pageTitleLabel.heightAnchor, multiplier: 10 / 35)

        // pageTitleLabel constraints
        let titleTop = pageTitleLabel.topAnchor.constraint(equalTo: pageImageButton.topAnchor)
        let titleLeading = pageTitleLabel.leadingAnchor.constraint(equalTo: pageImageButton.trailingAnchor, constant: 5)

        // containerView constraints
        let containerTop = containerView.topAnchor.constraint(equalTo: contentView.topAnchor)
        let containerBottom = containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor)
        let containerLeading = containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let containerTrailing = containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        NSLayoutConstraint.activate([
            imageTop,
            imageBottomContainer,
            imageBottomTitle,
            imageLeading,
            imageSquare,
            imageHeight,

            chevronLeading,
            chevronTrailing,
            chevronCenterY,
            chevronAspect,
            chevronToTitleHeight,

            titleTop,
            titleLeading,

            containerTop,
            containerBottom,
            containerLeading,
            containerTrailing
        ])
    }

}
//
//  SettingsSubscriptionCancelReasonView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/28/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsSubscriptionCancelReasonViewController: GeneralUIViewController, UITableViewDelegate, UITableViewDataSource, SettingsSubscriptionCancelReasonTVCDelegate, SettingsSubscriptionCancelSuggestionsViewControllerDelegate {
    
    // MARK: - SettingsSubscriptionCancelReasonTVCDelegate
    
    func didSetCustomIsSelected(forCell: SettingsSubscriptionCancelReasonTVC, forIsCustomSelected: Bool) {
        lastSelectedCell = forCell
        
        // The user can only continue if they have selected a cancellation reason
        continueButton.isEnabled = forIsCustomSelected
    }
    
    // MARK: - SettingsSubscriptionCancelSuggestionsViewControllerDelegate
    
    func didShowManageSubscriptions() {
        // Now that we have just shown the page to manage subscriptions, dismiss all these feedback pages
        settingsSubscriptionCancelSuggestionsViewController?.dismiss(animated: true, completion: {
            self.dismiss(animated: true)
        })
    }
    
    // MARK: - Elements
    
    private let tableView: GeneralUITableView = {
        let tableView = GeneralUITableView()
        tableView.bounces = false
        tableView.isScrollEnabled = false
        tableView.bouncesZoom = false
        tableView.separatorStyle = .none
        return tableView
    }()
    
    private let continueButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.setTitle("Continue", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        
        return button
    }()
    
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        scrollView.alwaysBounceVertical = true
        
        return scrollView
    }()
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        
        return view
    }()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.text = "Sorry to see you go!"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "What was wrong with your Hound+ subscription?"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBackground
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBlue
        
        button.shouldDismissParentViewController = true
        button.shouldRoundCorners = true
        return button
    }()
    
    // MARK: - Properties
    
    /// The subscription tier that is currently selected by the user. Theoretically, this shouldn't ever be nil.
    private var lastSelectedCell: SettingsSubscriptionCancelReasonTVC?
    
    private var settingsSubscriptionCancelSuggestionsViewController: SettingsSubscriptionCancelSuggestionsViewController?
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        // Continue button is disabled until the user selects a cancellation reason
        self.continueButton.isEnabled = false
        self.tableView.register(SettingsSubscriptionCancelReasonTVC.self, forCellReuseIdentifier: SettingsSubscriptionCancelReasonTVC.reuseIdentifier)
        // By default the tableView pads a header, even of height 0.0, by about 20.0 points
        self.tableView.sectionHeaderTopPadding = 0.0
    }
    
    // MARK: - Table View Data Source
    
    // Make each cell its own section, allows us to easily space the cells
    func numberOfSections(in tableView: UITableView) -> Int {
        return SubscriptionCancellationReason.allCases.count
    }
    
    // Make each cell its own section, allows us to easily space the cells
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        // Set the spacing between sections by configuring the header height
        return 12.5
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        // Make a blank headerView so that there is a header view
        return GeneralUIView()
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: SettingsSubscriptionCancelReasonTVC.reuseIdentifier, for: indexPath) as? SettingsSubscriptionCancelReasonTVC else {
            return GeneralUITableViewCell()
        }
        
        if lastSelectedCell == cell {
            // cell has been used before and lastSelectedCell is a reference to this cell. However, this cell could be changing to a different SubscriptionCancellationReason in setup, so that would invaliate lastSelectedCell. Therefore, clear lastSelectedCell
            lastSelectedCell = nil
        }
        
        let cellCancellationReason: SubscriptionCancellationReason = SubscriptionCancellationReason.allCases[indexPath.section]
        let cellIsCustomSelected: Bool = {
            // We do not want to override the lastSelectedCell as this function could be called after a user selceted a cell manually by themselves
            return lastSelectedCell?.cancellationReason == cellCancellationReason
        }()
        
        // We can only have one cell selected at once, therefore clear lastSelectedCell's selection state
        if cellIsCustomSelected == true {
            lastSelectedCell?.setCustomSelectedTableViewCell(forSelected: false, isAnimated: false)
        }
        
        cell.setup(forDelegate: self, forCancellationReason: cellCancellationReason, forIsCustomSelected: cellIsCustomSelected)
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        // Let a user select cells even if they don't have the permission to as a non-family head.
        guard let selectedCell = tableView.cellForRow(at: indexPath) as? SettingsSubscriptionCancelReasonTVC else {
            return
        }
        
        // Check if lastSelectedCell and selectedCells are actually different cells
        if let lastSelectedCell = lastSelectedCell, lastSelectedCell != selectedCell {
            // If they are different cells, then that must mean a new cell is being selected to transition into the selected state. Unselect the old cell and select the new one
            lastSelectedCell.setCustomSelectedTableViewCell(forSelected: false, isAnimated: true)
            selectedCell.setCustomSelectedTableViewCell(forSelected: true, isAnimated: true)
        }
        // We are selecting the same cell as last time. However, a cell always needs to be selected. Therefore, we cannot deselect the current cell as that would mean we would have no cell selected at all, so always select.
        else {
            selectedCell.setCustomSelectedTableViewCell(forSelected: true, isAnimated: true)
        }
        
        lastSelectedCell = selectedCell
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        scrollView.addSubview(containerView)
        containerView.addSubview(tableView)
        containerView.addSubview(continueButton)
        containerView.addSubview(headerLabel)
        containerView.addSubview(descriptionLabel)
        containerView.addSubview(backButton)
        
        let continueAction = UIAction { [weak self] _ in
            guard let self = self else { return }
            
            let vc = SettingsSubscriptionCancelSuggestionsViewController()
            self.settingsSubscriptionCancelSuggestionsViewController = vc
            vc.setup(forDelegate: self, forCancellationReason: lastSelectedCell?.cancellationReason)
            PresentationManager.enqueueViewController(vc)
        }
        continueButton.addAction(continueAction, for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // headerLabel
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 15)
        let headerLabelCenterX = headerLabel.centerXAnchor.constraint(equalTo: containerView.centerXAnchor)

        // backButton
        let backButtonTop = backButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 10)
        let backButtonLeading = backButton.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 5)
        let backButtonTrailing = backButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -10)
        let backButtonWidth = backButton.widthAnchor.constraint(equalTo: backButton.heightAnchor)
        let backButtonWidthRatio = backButton.widthAnchor.constraint(equalTo: containerView.widthAnchor, multiplier: 50.0 / 414.0)
        backButtonWidthRatio.priority = .defaultHigh
        let backButtonMinHeight = backButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 25)
        let backButtonMaxHeight = backButton.heightAnchor.constraint(lessThanOrEqualToConstant: 75)

        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 15)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // tableView
        let tableViewTop = tableView.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor, constant: 10)
        let tableViewLeading = tableView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let tableViewTrailing = tableView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // continueButton
        let continueButtonTop = continueButton.topAnchor.constraint(equalTo: tableView.bottomAnchor, constant: 35)
        let continueButtonLeading = continueButton.leadingAnchor.constraint(equalTo: tableView.leadingAnchor)
        let continueButtonWidthRatio = continueButton.createScreenWideHeightMultiplier()
        let continueButtonBottom = continueButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -15)

        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor)
        let containerViewWidth = containerView.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor)
        let viewSafeAreaBottom = view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let viewSafeAreaTrailing = view.safeAreaLayoutGuide.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)

        // scrollView
        let scrollViewTop = scrollView.topAnchor.constraint(equalTo: view.topAnchor)
        let scrollViewBottom = scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        let scrollViewLeading = scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor)
        let scrollViewTrailing = scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor)

        NSLayoutConstraint.activate([
            // headerLabel
            headerLabelTop, headerLabelCenterX,

            // backButton
            backButtonTop, backButtonLeading, backButtonTrailing,
            backButtonWidth, backButtonWidthRatio, backButtonMinHeight, backButtonMaxHeight,

            // descriptionLabel
            descriptionLabelTop, descriptionLabelLeading, descriptionLabelTrailing,

            // tableView
            tableViewTop, tableViewLeading, tableViewTrailing,

            // continueButton
            continueButtonTop, continueButtonLeading, continueButtonWidthRatio, continueButtonBottom,

            // containerView
            containerViewTop, containerViewLeading, containerViewWidth,
            viewSafeAreaBottom, viewSafeAreaTrailing,

            // scrollView
            scrollViewTop, scrollViewBottom, scrollViewLeading, scrollViewTrailing
        ])
    }

}
//
//  SettingsSubscriptionCancelReasonTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/28/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol SettingsSubscriptionCancelReasonTVCDelegate: AnyObject {
    func didSetCustomIsSelected(forCell: SettingsSubscriptionCancelReasonTVC, forIsCustomSelected: Bool)
}

final class SettingsSubscriptionCancelReasonTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        return view
    }()
    
    private let cancellationReasonLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 300)
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let checkmarkImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 270, compressionResistancePriority: 270)
        
        imageView.isHidden = true
        imageView.image = UIImage(systemName: "checkmark.circle.fill")
        imageView.tintColor = .systemGreen
        
        return imageView
    }()
    
    private let circleBehindCheckmarkImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 260, compressionResistancePriority: 260)
        
        imageView.image = UIImage(systemName: "circle")
        imageView.tintColor = .label
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsSubscriptionCancelReasonTVC"
    
    /// The cancellation reason this cell is displaying
    private(set) var cancellationReason: SubscriptionCancellationReason?
    
    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    private var isCustomSelected: Bool = false
    
    private weak var delegate: SettingsSubscriptionCancelReasonTVCDelegate?
    
    // MARK: - Setup
    
    func setup(forDelegate: SettingsSubscriptionCancelReasonTVCDelegate, forCancellationReason: SubscriptionCancellationReason, forIsCustomSelected: Bool) {
        self.delegate = forDelegate
        self.cancellationReason = forCancellationReason
        
        containerView.layer.cornerRadius = VisualConstant.LayerConstant.defaultCornerRadius
        containerView.layer.cornerCurve = .continuous
        
        setCustomSelectedTableViewCell(forSelected: forIsCustomSelected, isAnimated: false)
    }
    
    // MARK: - Functions
    
    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    func setCustomSelectedTableViewCell(forSelected: Bool, isAnimated: Bool) {
        isCustomSelected = forSelected
        
        delegate?.didSetCustomIsSelected(forCell: self, forIsCustomSelected: isCustomSelected)
        
        UIView.animate(withDuration: isAnimated ? VisualConstant.AnimationConstant.toggleSelectUIElement : 0.0) {
            self.checkmarkImageView.isHidden = !self.isCustomSelected
            
            self.containerView.layer.borderColor = self.isCustomSelected ? UIColor.systemGreen.cgColor : UIColor.label.cgColor
            self.containerView.layer.borderWidth = self.isCustomSelected ? 4.0 : 2.0
            
            self.setupCancellationLabel()
        }
    }
    
    /// Attempts to set the attributedText for cancellationReasonLabel given the cancellationReason and isCustomSelected
    private func setupCancellationLabel() {
        guard let cancellationReason = cancellationReason else {
            cancellationReasonLabel.text = VisualConstant.TextConstant.unknownText
            return
        }
        
        // If the cell isn't selected, all of the text is the tertiary label color
        let cancellationReasonTextAttributes: [NSAttributedString.Key: Any] = [
            .font: VisualConstant.FontConstant.secondaryHeaderLabel,
            .foregroundColor: UIColor.label
        ]
        
        cancellationReasonLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            // "" -> "6 months - $59.99"
            let message: NSMutableAttributedString = NSMutableAttributedString(
                string: cancellationReason.readableValue,
                attributes: cancellationReasonTextAttributes)
            
            return message
        }
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(cancellationReasonLabel)
        containerView.addSubview(checkmarkImageView)
        containerView.addSubview(circleBehindCheckmarkImageView)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // cancellationReasonLabel
        let cancellationReasonLabelTop = cancellationReasonLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 10)
        let cancellationReasonLabelBottom = cancellationReasonLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -10)
        let cancellationReasonLabelLeading = cancellationReasonLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 10)
        let cancellationReasonLabelHeight = cancellationReasonLabel.heightAnchor.constraint(equalToConstant: 25)

        // checkmarkImageView
        let checkmarkImageViewLeading = checkmarkImageView.leadingAnchor.constraint(equalTo: cancellationReasonLabel.trailingAnchor, constant: 10)
        let checkmarkImageViewTrailing = checkmarkImageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -10)
        let checkmarkImageViewWidth = checkmarkImageView.widthAnchor.constraint(equalTo: checkmarkImageView.heightAnchor)
        let checkmarkImageViewCenterY = checkmarkImageView.centerYAnchor.constraint(equalTo: containerView.centerYAnchor)

        // circleBehindCheckmarkImageView
        let circleBehindCheckmarkImageViewCenterY = circleBehindCheckmarkImageView.centerYAnchor.constraint(equalTo: checkmarkImageView.centerYAnchor)
        let circleBehindCheckmarkImageViewCenterX = circleBehindCheckmarkImageView.centerXAnchor.constraint(equalTo: checkmarkImageView.centerXAnchor)
        let circleBehindCheckmarkImageViewWidth = circleBehindCheckmarkImageView.widthAnchor.constraint(equalTo: checkmarkImageView.widthAnchor, constant: 7)
        let circleBehindCheckmarkImageViewHeight = circleBehindCheckmarkImageView.heightAnchor.constraint(equalTo: checkmarkImageView.heightAnchor, constant: 7)

        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: contentView.topAnchor)
        let containerViewBottom = containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor)
        let containerViewTrailing = containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor)

        NSLayoutConstraint.activate([
            // cancellationReasonLabel
            cancellationReasonLabelTop,
            cancellationReasonLabelBottom,
            cancellationReasonLabelLeading,
            cancellationReasonLabelHeight,

            // checkmarkImageView
            checkmarkImageViewLeading,
            checkmarkImageViewTrailing,
            checkmarkImageViewWidth,
            checkmarkImageViewCenterY,

            // circleBehindCheckmarkImageView
            circleBehindCheckmarkImageViewCenterY,
            circleBehindCheckmarkImageViewCenterX,
            circleBehindCheckmarkImageViewWidth,
            circleBehindCheckmarkImageViewHeight,

            // containerView
            containerViewTop,
            containerViewBottom,
            containerViewLeading,
            containerViewTrailing
        ])
    }

}
//
//  SettingsSubscriptionCancelSuggestionsVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/28/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol SettingsSubscriptionCancelSuggestionsViewControllerDelegate: AnyObject {
    func didShowManageSubscriptions()
}

final class SettingsSubscriptionCancelSuggestionsViewController: GeneralUIViewController, UITextViewDelegate {
    
    // MARK: - UITextViewDelegate
    
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        // Don't allow the user to add a new line. If they do, we interpret that as the user hitting the done button.
        guard text != "\n" else {
            self.dismissKeyboard()
            return false
        }
        
        // get the current text, or use an empty string if that failed
        let currentText = textView.text ?? ""
        
        // attempt to read the range they are trying to change, or exit if we can't
        guard let stringRange = Range(range, in: currentText) else { return false }
        
        // add their new text to the existing text
        let updatedText = currentText.replacingCharacters(in: stringRange, with: text)
        
        // make sure the result is under logNoteCharacterLimit
        return updatedText.count <= ClassConstant.FeedbackConstant.subscriptionCancellationSuggestionCharacterLimit
    }
    
    // MARK: - Elements
    
    private let suggestionTextView: GeneralUITextView = {
        let textView = GeneralUITextView()
        
        textView.backgroundColor = .systemBackground
        textView.textColor = .label
        textView.font = VisualConstant.FontConstant.primaryRegularLabel
        textView.borderWidth = 2
        textView.borderColor = .label
        textView.shouldRoundCorners = true
        textView.placeholder = "Share any suggestions or issues..."
        return textView
    }()
    
    private let continueButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.setTitle("Cancel Subscription", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        
        return button
    }()
    
    // MARK: - Additional UI Elements
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        scrollView.alwaysBounceVertical = true
        
        return scrollView
    }()
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        
        return view
    }()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.text = "Sorry to see you go!"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "What could we do to improve?"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBackground
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBlue
        button.shouldRoundCorners = true
        button.shouldDismissParentViewController = true
        
        return button
    }()
    @objc private func didTapContinue(_ sender: Any) {
        // The user doesn't have permission to perform this action
        guard UserInformation.isUserFamilyHead else {
            PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.notFamilyHeadInvalidPermissionTitle, forSubtitle: VisualConstant.BannerTextConstant.notFamilyHeadInvalidPermissionSubtitle, forStyle: .danger)
            return
        }
        
        // Send the survey results to the server. Hope it gets through but don't throw an error if it doesn't
        SurveyFeedbackRequest.create(forErrorAlert: .automaticallyAlertForNone, userCancellationReason: cancellationReason, userCancellationFeedback: suggestionTextView.text ?? "") { _, _ in
            return
        }
        
        InAppPurchaseManager.showManageSubscriptions()
        // Now that we have just shown the page to manage subscriptions, dismiss all these feedback pages
        self.delegate?.didShowManageSubscriptions()
        
    }
    
    // MARK: - Properties
    
    private weak var delegate: SettingsSubscriptionCancelSuggestionsViewControllerDelegate?
    
    /// The cancellationReason passed to this view controller from SettingsSubscriptionCancelReasonViewController
    private var cancellationReason: SubscriptionCancellationReason?
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        self.suggestionTextView.delegate = self
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: SettingsSubscriptionCancelSuggestionsViewControllerDelegate, forCancellationReason: SubscriptionCancellationReason?) {
        self.delegate = forDelegate
        self.cancellationReason = forCancellationReason
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        scrollView.addSubview(containerView)
        containerView.addSubview(continueButton)
        containerView.addSubview(headerLabel)
        containerView.addSubview(descriptionLabel)
        containerView.addSubview(backButton)
        containerView.addSubview(suggestionTextView)
        
        continueButton.addTarget(self, action: #selector(didTapContinue), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // headerLabel
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 15)
        let headerLabelCenterX = headerLabel.centerXAnchor.constraint(equalTo: containerView.centerXAnchor)

        // backButton
        let backButtonTop = backButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 10)
        let backButtonLeading = backButton.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 5)
        let backButtonTrailing = backButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -10)
        let backButtonWidth = backButton.widthAnchor.constraint(equalTo: backButton.heightAnchor)
        let backButtonWidthRatio = backButton.widthAnchor.constraint(equalTo: containerView.widthAnchor, multiplier: 50.0 / 414.0)
        backButtonWidthRatio.priority = .defaultHigh
        let backButtonMinHeight = backButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 25)
        let backButtonMaxHeight = backButton.heightAnchor.constraint(lessThanOrEqualToConstant: 75)

        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 15)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // suggestionTextView
        let suggestionTextViewTop = suggestionTextView.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor, constant: 25)
        let suggestionTextViewLeading = suggestionTextView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let suggestionTextViewTrailing = suggestionTextView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let suggestionTextViewHeight = suggestionTextView.heightAnchor.constraint(equalToConstant: 175)

        // continueButton
        let continueButtonTop = continueButton.topAnchor.constraint(equalTo: suggestionTextView.bottomAnchor, constant: 35)
        let continueButtonLeading = continueButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let continueButtonWidthRatio = continueButton.createScreenWideHeightMultiplier()
        let continueButtonBottom = continueButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -15)

        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor)
        let containerViewWidth = containerView.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor)
        let viewSafeAreaBottom = view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let viewSafeAreaTrailing = view.safeAreaLayoutGuide.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)

        // scrollView
        let scrollViewTop = scrollView.topAnchor.constraint(equalTo: view.topAnchor)
        let scrollViewBottom = scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        let scrollViewLeading = scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor)
        let scrollViewTrailing = scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor)

        NSLayoutConstraint.activate([
            // headerLabel
            headerLabelTop, headerLabelCenterX,

            // backButton
            backButtonTop, backButtonLeading, backButtonTrailing,
            backButtonWidth, backButtonWidthRatio, backButtonMinHeight, backButtonMaxHeight,

            // descriptionLabel
            descriptionLabelTop, descriptionLabelLeading, descriptionLabelTrailing,

            // suggestionTextView
            suggestionTextViewTop, suggestionTextViewLeading, suggestionTextViewTrailing, suggestionTextViewHeight,

            // continueButton
            continueButtonTop, continueButtonLeading, continueButtonWidthRatio, continueButtonBottom,

            // containerView
            containerViewTop, containerViewLeading, containerViewWidth, viewSafeAreaBottom, viewSafeAreaTrailing,

            // scrollView
            scrollViewTop, scrollViewBottom, scrollViewLeading, scrollViewTrailing
        ])
    }

}
//
//  SettingsSubscriptionTierTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/15/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import StoreKit
import UIKit

protocol SettingsSubscriptionTierTVCDelegate: AnyObject {
    func didSetCustomIsSelectedToTrue(forCell: SettingsSubscriptionTierTVC)
}

final class SettingsSubscriptionTierTVC: GeneralUITableViewCell {

    // MARK: - Elements

    private let savePercentLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 310, compressionResistancePriority: 310)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.backgroundColor = .systemGreen
        label.font = VisualConstant.FontConstant.emphasizedPrimaryRegularLabel
        label.textColor = .systemBackground
        label.shouldRoundCorners = true
        return label
    }()

    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.shouldRoundCorners = true
        view.backgroundColor = .systemBackground
        return view
    }()

    private let totalPriceLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 300)
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()

    private let monthlyPriceLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.weakSecondaryRegularLabel
        label.textColor = .secondaryLabel
        return label
    }()

    private let checkmarkImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 300, compressionResistancePriority: 280)
        
        imageView.isHidden = true
        imageView.image = UIImage(systemName: "checkmark.circle.fill")
        imageView.tintColor = .systemGreen
        
        return imageView
    }()
    
    private let alignmentViewForSavePercent: GeneralUIView = {
        let view = GeneralUIView()
        view.isHidden = true
        return view
    }()

    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsSubscriptionTierTVC"

    /// The SKProduct this cell is displaying
    private(set) var product: SKProduct?

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    private var isCustomSelected: Bool = false

    private weak var delegate: SettingsSubscriptionTierTVCDelegate?

    // MARK: - Setup

    func setup(forDelegate: SettingsSubscriptionTierTVCDelegate, forProduct: SKProduct, forIsCustomSelected: Bool) {
        self.delegate = forDelegate
        self.product = forProduct

        setCustomSelectedTableViewCell(forSelected: forIsCustomSelected, isAnimated: false)
    }
    
    // MARK: - Functions

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    func setCustomSelectedTableViewCell(forSelected: Bool, isAnimated: Bool) {
        isCustomSelected = forSelected

        if isCustomSelected == true {
            delegate?.didSetCustomIsSelectedToTrue(forCell: self)
        }

        UIView.animate(withDuration: isAnimated ? VisualConstant.AnimationConstant.toggleSelectUIElement : 0.0) {
            self.checkmarkImageView.isHidden = !self.isCustomSelected
            self.savePercentLabel.isHidden = !self.isCustomSelected && self.savePercentLabel.text != nil

            self.containerView.borderColor = self.isCustomSelected ? UIColor.systemGreen : UIColor.label
            self.containerView.borderWidth = self.isCustomSelected ? 4.0 : 2.0

            self.setupPriceLabels()
        }
    }

    /// Attempts to set the attributedText for totalPriceLabel and monthlyPriceLabel given the current product, productFullPrice, and isCustomSelected
    private func setupPriceLabels() {
        guard let product = product, let monthlySubscriptionPrice = product.monthlySubscriptionPrice, let unit = product.subscriptionPeriod?.unit, let numberOfUnits = product.subscriptionPeriod?.numberOfUnits else {
            totalPriceLabel.text = VisualConstant.TextConstant.unknownText
            monthlyPriceLabel.text = VisualConstant.TextConstant.unknownText
            return
        }

        // $2.99, €1.99, ¥9.99
        let totalPriceWithCurrencySymbol = "\(product.priceLocale.currencySymbol ?? "")\(product.price)"

        // Make the number more visually appealing by rounding to the nearest x.x9.
        let roundedMonthlySubscriptionPrice = (Int(ceil(monthlySubscriptionPrice * 100)) % 10) >= 5
        ? (ceil(monthlySubscriptionPrice * 10) / 10) - 0.01 // round up to nearest x.x9
        : (floor(monthlySubscriptionPrice * 10) / 10) - 0.01 // round down to nearest x.x9

        // Converts whatever the price, unit, and numberOfUnits is into an approximate monthly price: $2.99, €1.99, ¥9.99
        let roundedMonthlyPriceWithCurrencySymbol = "\(product.priceLocale.currencySymbol ?? "")\(String(format: "%.2f", roundedMonthlySubscriptionPrice))"

        // To explain the difference between discounted and full price, take for example "6 months - $59.99  $119.99". $120 is the "full" price if you used a $20 1 month subscription for 6 months and $60 is our "discounted" price for buying the 6 month subscription
        // If the cell isn't selected, all of the text is the tertiary label color
        let discountedTotalPriceTextAttributes: [NSAttributedString.Key: Any] = [
            .font: VisualConstant.FontConstant.secondaryHeaderLabel,
            .foregroundColor: isCustomSelected ? UIColor.label : UIColor.tertiaryLabel
        ]
        let fullTotalPricePrimaryTextAttributes: [NSAttributedString.Key: Any] = [
            .font: VisualConstant.FontConstant.secondaryHeaderLabel,
            .foregroundColor: isCustomSelected ? UIColor.secondaryLabel : UIColor.tertiaryLabel,
            .strikethroughStyle: NSUnderlineStyle.single.rawValue
        ]
        let monthlyPriceTextAttributes: [NSAttributedString.Key: Any] = [
            .font: VisualConstant.FontConstant.weakSecondaryRegularLabel,
            .foregroundColor: isCustomSelected ? UIColor.secondaryLabel : UIColor.tertiaryLabel
        ]

        // "" -> "6 months - $59.99"
        let precalculatedDynamicSubscriptionLengthAndPriceText = "\(convertPeriodUnit(forUnit: unit, forNumberOfUnits: numberOfUnits)) - \(totalPriceWithCurrencySymbol)"

        // "1 month - $19.99 " -> "1 months - $19.99" (NO-OP)
        // "6 months - $59.99 " -> "6 months - $59.99 $119.99"
        var precalculatedDynamicFullPriceText: String?
        if let fullPrice = product.fullPrice, fullPrice != Double(truncating: product.price) {
            // e.g. 78.5 product.price / 100.0 fullPrice -> 0.785 -> 1 - 0.785 -> 0.225 -> 0.225 * 100 -> 22.5 -> 23
            var unroundedPercentageSaved = Int(
                ceil(
                    (1 - (Double(truncating: product.price) / fullPrice)) * 100.0
                )
            )

            // Round up to the nearest 5
            // 20 -> 20, 21 -> 25, 22 -> 25, 23 -> 25, 24 -> 25, 25 -> 25
            unroundedPercentageSaved = (unroundedPercentageSaved % 5 > 0)
            ? (unroundedPercentageSaved + 5) - (unroundedPercentageSaved % 5)
            : unroundedPercentageSaved

            savePercentLabel.text = " SAVE \(unroundedPercentageSaved)%   "

            // Make the number more visually appealing by rounding up to the nearest x.99. The important calculations are done so we can perform this rounding
            let fullPriceRoundedUpToNearest99 = ceil(fullPrice) > 0.0 ? ceil(fullPrice) - 0.01 : 0.0

            precalculatedDynamicFullPriceText = "\(product.priceLocale.currencySymbol ?? "")\(fullPriceRoundedUpToNearest99)"
        }
        else {
            savePercentLabel.text = nil
        }

        totalPriceLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            // "" -> "6 months - $59.99"
            let message: NSMutableAttributedString = NSMutableAttributedString(
                string: precalculatedDynamicSubscriptionLengthAndPriceText,
                attributes: discountedTotalPriceTextAttributes)

            // "1 month - $19.99 " -> "1 months - $19.99" (NO-OP)
            // "6 months - $59.99 " -> "6 months - $59.99 $119.99"
            if let precalculatedDynamicFullPriceText = precalculatedDynamicFullPriceText {
                // We need a space between the original text and the new text
                message.append(
                    NSAttributedString(string: " ")
                )

                message.append(
                    NSAttributedString(
                    string: precalculatedDynamicFullPriceText,
                    attributes: fullTotalPricePrimaryTextAttributes
                    )
                )
            }

            return message
        }

        // If the prodcut displayed by this cell is the active subscription, have this cell also show the active subscriptions expiration date
        let activeSubscriptionExpirationText: String = {
            guard let expiresDate = FamilyInformation.familyActiveSubscription.expiresDate else {
                return ""
            }
            
            let expiresYear = Calendar.current.component(.year, from: expiresDate)
            let currentYear = Calendar.current.component(.year, from: Date())
            
            let dateFormatter = DateFormatter()
            // January 25 OR January 25, 2023
            dateFormatter.setLocalizedDateFormatFromTemplate(expiresYear == currentYear ? "MMMMd" : "MMMMdyyyy")

            guard FamilyInformation.familyActiveSubscription.productId == product.productIdentifier else {
                // This cell isn't the active subscription, however it is set to renew
                if FamilyInformation.familyActiveSubscription.autoRenewStatus == true && FamilyInformation.familyActiveSubscription.autoRenewProductId == product.productIdentifier {
                    return ", renewing \(dateFormatter.string(from: expiresDate))"
                }
                return ""
            }
            // This cell is the active subscription with an expiresDate. It could be renewing or expiring on the expiresDate

            return ", \(FamilyInformation.familyActiveSubscription.autoRenewStatus == true && FamilyInformation.familyActiveSubscription.autoRenewProductId == product.productIdentifier ? "renewing" : "expiring") \(dateFormatter.string(from: expiresDate))"
        }()

        let precalculatedDynamicMonthlyPriceText = "\(roundedMonthlyPriceWithCurrencySymbol)/month\(activeSubscriptionExpirationText)"

        monthlyPriceLabel.attributedTextClosure = {
            NSAttributedString(
                string: precalculatedDynamicMonthlyPriceText,
                attributes: monthlyPriceTextAttributes
            )
        }
    }

    /// Converts period unit and numberOfUnits into string, e.g. "3 days", "1 week", "6 months"
    private func convertPeriodUnit(forUnit unit: SKProduct.PeriodUnit, forNumberOfUnits numberOfUnits: Int) -> String {

        // Display x year as 12x months
        guard unit != .year else {
            return "\(numberOfUnits * 12) months"
        }

        var string = "\(numberOfUnits) "

        switch unit {
        case .day:
            string.append("day")
        case .week:
            string.append("week")
        case .month:
            string.append("month")
        default:
            break
        }

        if numberOfUnits > 1 {
            string.append("s")
        }

        return string
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        contentView.addSubview(savePercentLabel)
        containerView.addSubview(alignmentViewForSavePercent)
        containerView.addSubview(totalPriceLabel)
        containerView.addSubview(monthlyPriceLabel)
        containerView.addSubview(checkmarkImageView)
        
    }

    override func setupConstraints() {
        super.setupConstraints()

        // savePercentLabel
        let savePercentLabelCenterX = savePercentLabel.centerXAnchor.constraint(equalTo: alignmentViewForSavePercent.centerXAnchor)
        let savePercentLabelCenterY = savePercentLabel.centerYAnchor.constraint(equalTo: contentView.topAnchor)

        // alignmentViewForSavePercent
        let alignmentViewForSavePercentTop = alignmentViewForSavePercent.topAnchor.constraint(equalTo: containerView.topAnchor)
        let alignmentViewForSavePercentBottom = alignmentViewForSavePercent.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let alignmentViewForSavePercentLeading = alignmentViewForSavePercent.leadingAnchor.constraint(equalTo: containerView.leadingAnchor)
        let alignmentViewForSavePercentTrailing = alignmentViewForSavePercent.trailingAnchor.constraint(equalTo: containerView.centerXAnchor)

        // checkmarkImageView
        let checkmarkImageViewTop = checkmarkImageView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 15)
        let checkmarkImageViewBottom = checkmarkImageView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -15)
        let checkmarkImageViewLeading = checkmarkImageView.leadingAnchor.constraint(equalTo: totalPriceLabel.trailingAnchor, constant: 10)
        let checkmarkImageViewTrailing = checkmarkImageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -10)
        let checkmarkImageViewWidth = checkmarkImageView.widthAnchor.constraint(equalTo: checkmarkImageView.heightAnchor)

        // totalPriceLabel
        let totalPriceLabelTop = totalPriceLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 15)
        let totalPriceLabelLeading = totalPriceLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 10)
        let totalPriceLabelTrailing = totalPriceLabel.trailingAnchor.constraint(equalTo: monthlyPriceLabel.trailingAnchor)

        // monthlyPriceLabel
        let monthlyPriceLabelTop = monthlyPriceLabel.topAnchor.constraint(equalTo: totalPriceLabel.bottomAnchor, constant: 7.5)
        let monthlyPriceLabelBottom = monthlyPriceLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -15)
        let monthlyPriceLabelLeading = monthlyPriceLabel.leadingAnchor.constraint(equalTo: totalPriceLabel.leadingAnchor)

        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: contentView.topAnchor)
        let containerViewBottom = containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor)
        let containerViewTrailing = containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor)

        NSLayoutConstraint.activate([
            savePercentLabelCenterX, savePercentLabelCenterY,

            alignmentViewForSavePercentTop, alignmentViewForSavePercentBottom, alignmentViewForSavePercentLeading, alignmentViewForSavePercentTrailing,

            checkmarkImageViewTop, checkmarkImageViewBottom, checkmarkImageViewLeading, checkmarkImageViewTrailing, checkmarkImageViewWidth,

            totalPriceLabelTop, totalPriceLabelLeading, totalPriceLabelTrailing,

            monthlyPriceLabelTop, monthlyPriceLabelBottom, monthlyPriceLabelLeading,

            containerViewTop, containerViewBottom, containerViewLeading, containerViewTrailing
        ])
    }

}
//
//  SettingsSubscriptionsViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/15/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import KeychainSwift
import StoreKit
import UIKit

final class SettingsSubscriptionViewController: GeneralUIViewController, UITableViewDelegate, UITableViewDataSource, SettingsSubscriptionTierTVCDelegate {
    
    // MARK: - SettingsSubscriptionTierTableViewCellSettingsSubscriptionTierTVC
    
    func didSetCustomIsSelectedToTrue(forCell: SettingsSubscriptionTierTVC) {
        lastSelectedCell = forCell
        
        if let attributedText = continueButton.titleLabel?.attributedText {
            let mutableAttributedText = NSMutableAttributedString(attributedString: attributedText)
            let buttonTitle: String = {
                if FamilyInformation.familyActiveSubscription.autoRenewProductId == lastSelectedCell?.product?.productIdentifier {
                    return "Cancel Subscription"
                }
                
                return userPurchasedProductFromSubscriptionGroup20965379 ? "Upgrade" : "Start Free Trial"
            }()
            mutableAttributedText.mutableString.setString(buttonTitle)
            UIView.performWithoutAnimation {
                // By default it does an unnecessary, ugly animation. The combination of performWithoutAnimation and layoutIfNeeded prevents this.
                continueButton.setAttributedTitle(mutableAttributedText, for: .normal)
                continueButton.layoutIfNeeded()
            }
        }
    }
    
    // MARK: - Elements
    
    private let pawWithHands: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 290, compressionResistancePriority: 290)
        
        imageView.image = UIImage(named: "whitePawWithHands")
        
        return imageView
    }()
    
    private let tableView: GeneralUITableView = {
        let tableView = GeneralUITableView()
        tableView.bounces = false
        tableView.isScrollEnabled = false
        tableView.bouncesZoom = false
        tableView.separatorStyle = .none
        tableView.shouldAutomaticallyAdjustHeight = true
        return tableView
    }()
    
    private let freeTrialHeightConstraintConstant: CGFloat = 25
    private weak var freeTrialHeightConstraint: NSLayoutConstraint!
    private let freeTrialTopConstraintConstant: CGFloat = 10
    private weak var freeTrialTopConstraint: NSLayoutConstraint!
    private let freeTrialScaledLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Start with a 1 week free trial"
        label.textAlignment = .center
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let redeemHeightConstaintConstant: CGFloat = 20
    private weak var redeemHeightConstaint: NSLayoutConstraint!
    private let redeemBottomConstraintConstant: CGFloat = 20
    private weak var redeemBottomConstraint: NSLayoutConstraint!
    private let redeemButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.titleLabel?.font = VisualConstant.FontConstant.primaryRegularLabel
        button.setTitle("Redeem", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        
        return button
    }()
    
    @objc private func didTapRedeem(_ sender: Any) {
        InAppPurchaseManager.presentCodeRedemptionSheet()
    }
    
    private let restoreButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.titleLabel?.font = VisualConstant.FontConstant.primaryRegularLabel
        button.setTitle("Restore", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        
        return button
    }()
    
    @objc private func didTapRestoreTransactions(_ sender: Any) {
        // The user doesn't have permission to perform this action
        guard UserInformation.isUserFamilyHead else {
            PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.notFamilyHeadInvalidPermissionTitle, forSubtitle: VisualConstant.BannerTextConstant.notFamilyHeadInvalidPermissionSubtitle, forStyle: .danger)
            return
        }
        
        restoreButton.isEnabled = false
        PresentationManager.beginFetchingInformationIndicator()
        
        InAppPurchaseManager.restorePurchases { requestWasSuccessful in
            PresentationManager.endFetchingInformationIndicator {
                self.restoreButton.isEnabled = true
                guard requestWasSuccessful else {
                    return
                }
                
                PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.successRestoreTransactionsTitle, forSubtitle: VisualConstant.BannerTextConstant.successRestoreTransactionsSubtitle, forStyle: .success)
                
                // When we reload the tableView, cells are reusable.
                self.lastSelectedCell = nil
                self.tableView.reloadData()
            }
        }
    }
    
    private let continueButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.setTitle("Continue", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        
        return button
    }()
    
    @objc private func didTapContinue(_ sender: Any) {
        // The user doesn't have permission to perform this action
        guard UserInformation.isUserFamilyHead else {
            PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.notFamilyHeadInvalidPermissionTitle, forSubtitle: VisualConstant.BannerTextConstant.notFamilyHeadInvalidPermissionSubtitle, forStyle: .danger)
            return
        }
        
        // If the last selected cell contains a subscription that is going to be renewed, open the Apple menu to allow a user to edit their current subscription (e.g. cancel). If we attempt to purchase a product that is set to be renewed, we get the 'Youre already subscribed message'
        // The second case shouldn't happen. The last selected cell shouldn't be nil ever nor should a cell's product
        guard FamilyInformation.familyActiveSubscription.autoRenewProductId != lastSelectedCell?.product?.productIdentifier, let product = lastSelectedCell?.product else {
            PresentationManager.enqueueViewController(SettingsSubscriptionCancelReasonViewController())
            return
        }
        
        continueButton.isEnabled = false
        
        // Attempt to purchase the selected product
        PresentationManager.beginFetchingInformationIndicator()
        InAppPurchaseManager.purchaseProduct(forProduct: product) { productIdentifier in
            PresentationManager.endFetchingInformationIndicator {
                self.continueButton.isEnabled = true
                
                guard productIdentifier != nil else {
                    // ErrorManager already invoked by purchaseProduct
                    return
                }
                
                PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.successPurchasedSubscriptionTitle, forSubtitle: VisualConstant.BannerTextConstant.successPurchasedSubscriptionSubtitle, forStyle: .success)
                
                self.tableView.reloadData()
            }
        }
        
    }
    
    private let subscriptionDisclaimerLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Subscriptions can only be purchased by the family head. Cancel anytime."
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondarySystemBackground
        return label
    }()
    
    // MARK: - Additional UI Elements
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        scrollView.alwaysBounceVertical = true
        
        return scrollView
    }()
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        
        return view
    }()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.text = "Hound+"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = .systemFont(ofSize: 50)
        label.textColor = .systemBackground
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.text = "Grow your family with up to six members"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = .systemFont(ofSize: 30, weight: .medium)
        label.textColor = .systemBackground
        return label
    }()
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBackground
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBlue
        
        button.shouldRoundCorners = true
        button.shouldDismissParentViewController = true
        return button
    }()
    
    // MARK: - Properties
    
    private static var settingsSubscriptionViewController: SettingsSubscriptionViewController?
    
    /// The subscription tier that is currently selected by the user. Theoretically, this shouldn't ever be nil.
    private var lastSelectedCell: SettingsSubscriptionTierTVC?
    
    // if we don't have a value stored, then that means the value is false. A Bool (true) is only stored for this key in the case that a user purchases a product from subscription group 20965379
    private var userPurchasedProductFromSubscriptionGroup20965379: Bool {
        let keychain = KeychainSwift()
        return keychain.getBool(KeyConstant.userPurchasedProductFromSubscriptionGroup20965379.rawValue) ?? false
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        SettingsSubscriptionViewController.settingsSubscriptionViewController = self
        
        self.pawWithHands.image = UITraitCollection.current.userInterfaceStyle == .dark
        ? ClassConstant.DogConstant.blackPawWithHands
        : ClassConstant.DogConstant.whitePawWithHands
        
        // Depending upon whether or not the user has used their introductory offer, hide/show the label
        // If we hide the label, set all the constraints to 0.0, except for bottom
        freeTrialScaledLabel.isHidden = userPurchasedProductFromSubscriptionGroup20965379
        freeTrialHeightConstraint.constant = userPurchasedProductFromSubscriptionGroup20965379 ? 0.0 : freeTrialHeightConstraintConstant
        freeTrialTopConstraint.constant = userPurchasedProductFromSubscriptionGroup20965379 ? 0.0 : freeTrialTopConstraintConstant
        
        if let precalculatedDynamicFreeTrialText = freeTrialScaledLabel.text {
            
            freeTrialScaledLabel.attributedTextClosure = {
                // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
                let message = NSMutableAttributedString(
                    string: precalculatedDynamicFreeTrialText,
                    attributes: [
                        .font: UIFont.italicSystemFont(ofSize: 20),
                        .foregroundColor: UIColor.systemBackground
                    ]
                )
                
                return message
            }
        }
        
        self.tableView.register(SettingsSubscriptionTierTVC.self, forCellReuseIdentifier: SettingsSubscriptionTierTVC.reuseIdentifier)
        // By default the tableView pads a header, even of height 0.0, by about 20.0 points
        self.tableView.sectionHeaderTopPadding = 0.0
        
        let shouldHideRestoreAndRedeemButtons = !UserInformation.isUserFamilyHead
        restoreButton.isHidden = shouldHideRestoreAndRedeemButtons
        if let text = restoreButton.titleLabel?.text {
            let attributes: [NSAttributedString.Key: Any] = [
                .font: VisualConstant.FontConstant.primaryRegularLabel,
                .foregroundColor: UIColor.systemBackground,
                .underlineStyle: NSUnderlineStyle.single.rawValue
            ]
            restoreButton.setAttributedTitle(NSAttributedString(string: text, attributes: attributes), for: .normal)
        }
        
        redeemButton.isHidden = shouldHideRestoreAndRedeemButtons
        if let text = redeemButton.titleLabel?.text {
            let attributes: [NSAttributedString.Key: Any] = [
                .font: VisualConstant.FontConstant.primaryRegularLabel,
                .foregroundColor: UIColor.systemBackground,
                .underlineStyle: NSUnderlineStyle.single.rawValue
            ]
            redeemButton.setAttributedTitle(NSAttributedString(string: text, attributes: attributes), for: .normal)
        }
        redeemHeightConstaint.constant = shouldHideRestoreAndRedeemButtons ? 0.0 : redeemHeightConstaintConstant
        redeemBottomConstraint.constant = shouldHideRestoreAndRedeemButtons ? 0.0 : redeemBottomConstraintConstant
        
        subscriptionDisclaimerLabel.text = "Subscriptions can only be purchased by the family head"
        if let familyHeadFullName = FamilyInformation.familyMembers.first(where: { familyMember in
            return familyMember.isUserFamilyHead
        })?.displayFullName {
            subscriptionDisclaimerLabel.text?.append(" (\(familyHeadFullName))")
        }
        subscriptionDisclaimerLabel.text?.append(". Cancel anytime.")
        
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        // The manage subscriptions page could have been presented and now has disappeared.
        SettingsSubscriptionViewController.willRefreshIfNeeded()
    }
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        
        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            self.pawWithHands.image = UITraitCollection.current.userInterfaceStyle == .dark
            ? ClassConstant.DogConstant.blackPawWithHands
            : ClassConstant.DogConstant.whitePawWithHands
        }
    }
    
    // MARK: - Functions
    
    /// If a transaction was syncronized to the Hound server from the background, i.e. the system recognized there was a transaction sitting in the queue so silently contacted Hound to process it, call this function. It will refresh the page without any animations that would confuse the user
    static func willRefreshIfNeeded() {
        // If the subscriptions page is loaded and onscreen, then we reload it
        guard let settingsSubscriptionViewController = SettingsSubscriptionViewController.settingsSubscriptionViewController, settingsSubscriptionViewController.viewIfLoaded?.window != nil else {
            return
        }
        // If a transaction was syncronized to the Hound server from the background, i.e. the system recognized there was a transaction sitting in the queue so silently contacted Hound to process it, we don't want to cause any visual indicators that would confuse the user. Instead we just update the information on the server then reload the labels. No fancy animations or error messages if anything fails.
        
        TransactionsRequest.get(forErrorAlert: .automaticallyAlertForNone) { responseStatus, _ in
            guard responseStatus == .successResponse else {
                return
            }
            
            settingsSubscriptionViewController.tableView.reloadData()
        }
    }
    
    /// In order to present SettingsSubscriptionViewController, starts a fetching indicator. Then, performs a both a product and transactions request, to ensure those are both updated. If all of that completes successfully, returns the subscription view controller. Otherwise, automatically displays an error message and returns nil
    static func fetchProductsThenGetViewController(completionHandler: @escaping ((SettingsSubscriptionViewController?) -> Void)) {
        let viewController = SettingsSubscriptionViewController()
        
        PresentationManager.beginFetchingInformationIndicator()
        
        InAppPurchaseManager.fetchProducts { error  in
            guard error == nil else {
                // If the product request returned nil, meaning there was an error, then end the request indicator early and exit
                PresentationManager.endFetchingInformationIndicator(completionHandler: nil)
                error?.alert()
                completionHandler(nil)
                return
            }

            // request indictator is still active
            TransactionsRequest.get(forErrorAlert: .automaticallyAlertForAll) { responseStatus, houndError in
                PresentationManager.endFetchingInformationIndicator {
                    guard responseStatus == .successResponse else {
                        (error ?? houndError)?.alert()
                        completionHandler(nil)
                        return
                    }
                    
                    completionHandler(viewController)
                }

            }
        }
    }
    
    // MARK: - Table View Data Source
    
    // Make each cell its own section, allows us to easily space the cells
    func numberOfSections(in tableView: UITableView) -> Int {
        InAppPurchaseManager.subscriptionProducts.count
    }
    
    // Make each cell its own section, allows us to easily space the cells
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        1
    }
    
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        // Set the spacing between sections by configuring the header height
        return 15.0
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        // Make a blank headerLabel so that there is a header view
        return GeneralUIView()
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: SettingsSubscriptionTierTVC.reuseIdentifier, for: indexPath) as? SettingsSubscriptionTierTVC else {
            return GeneralUITableViewCell()
        }
        
        if lastSelectedCell == cell {
            // cell has been used before and lastSelectedCell is a reference to this cell. However, this cell could be changing to a different SKProduct in setup, so that would invaliate lastSelectedCell. Therefore, clear lastSelectedCell
            lastSelectedCell = nil
        }
        
        // If true, then one of the cells we are going to display is an active subscription, meaning its already been purchased.
        let renewingSubscriptionIsPartOfSubscriptionProducts = InAppPurchaseManager.subscriptionProducts.first { product in
            FamilyInformation.familyActiveSubscription.autoRenewProductId == product.productIdentifier
        } != nil
        
        let cellProduct: SKProduct = InAppPurchaseManager.subscriptionProducts[indexPath.section]
        let cellIsCustomSelected: Bool = {
            // We do not want to override the lastSelectedCell as this function could be called after a user selceted a cell manually by themselves
            guard lastSelectedCell == nil else {
                return lastSelectedCell?.product?.productIdentifier == cellProduct.productIdentifier
            }
            
            if renewingSubscriptionIsPartOfSubscriptionProducts {
                // One of the cells are we going to display is the active subscription, and this cell is that active subscription cell
                return cellProduct.productIdentifier == FamilyInformation.familyActiveSubscription.autoRenewProductId
            }
            else {
                // None of the cells are we going to display are the active subscription, SKProduct at index 0 is presumed to be the most important, so we select that one.
                return indexPath.section == 0
            }
        }()
        
        // We can only have one cell selected at once, therefore clear lastSelectedCell's selection state
        if cellIsCustomSelected == true {
            lastSelectedCell?.setCustomSelectedTableViewCell(forSelected: false, isAnimated: false)
        }
        
        cell.setup(forDelegate: self, forProduct: cellProduct, forIsCustomSelected: cellIsCustomSelected)
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        // Let a user select cells even if they don't have the permission to as a non-family head.
        guard let selectedCell = tableView.cellForRow(at: indexPath) as? SettingsSubscriptionTierTVC else {
            return
        }
        
        // Check if lastSelectedCell and selectedCells are actually different cells
        if let lastSelectedCell = lastSelectedCell, lastSelectedCell != selectedCell {
            // If they are different cells, then that must mean a new cell is being selected to transition into the selected state. Unselect the old cell and select the new one
            lastSelectedCell.setCustomSelectedTableViewCell(forSelected: false, isAnimated: true)
            selectedCell.setCustomSelectedTableViewCell(forSelected: true, isAnimated: true)
        }
        // We are selecting the same cell as last time. However, a cell always needs to be selected. Therefore, we cannot deselect the current cell as that would mean we would have no cell selected at all, so always select.
        else {
            selectedCell.setCustomSelectedTableViewCell(forSelected: true, isAnimated: true)
        }
        
        lastSelectedCell = selectedCell
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        scrollView.addSubview(containerView)
        containerView.addSubview(tableView)
        containerView.addSubview(continueButton)
        containerView.addSubview(pawWithHands)
        containerView.addSubview(headerLabel)
        containerView.addSubview(descriptionLabel)
        containerView.addSubview(redeemButton)
        containerView.addSubview(restoreButton)
        containerView.addSubview(freeTrialScaledLabel)
        containerView.addSubview(backButton)
        containerView.addSubview(subscriptionDisclaimerLabel)
        
        redeemButton.addTarget(self, action: #selector(didTapRedeem), for: .touchUpInside)
        restoreButton.addTarget(self, action: #selector(didTapRestoreTransactions), for: .touchUpInside)
        continueButton.addTarget(self, action: #selector(didTapContinue), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // freeTrialScaledLabel
        freeTrialHeightConstraint = freeTrialScaledLabel.heightAnchor.constraint(equalToConstant: freeTrialHeightConstraintConstant)
        freeTrialTopConstraint = freeTrialScaledLabel.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor, constant: freeTrialTopConstraintConstant)
        let freeTrialLeading = freeTrialScaledLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let freeTrialTrailing = freeTrialScaledLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // pawWithHands
        let pawWithHandsTop = pawWithHands.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 15)
        let pawWithHandsCenterX = pawWithHands.centerXAnchor.constraint(equalTo: containerView.centerXAnchor)
        let pawWithHandsWidthRatio = pawWithHands.widthAnchor.constraint(equalTo: pawWithHands.heightAnchor)
        let pawWithHandsWidthScreenRatio = pawWithHands.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 3.0 / 10.0)

        // headerLabel
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 15)
        let headerLabelCenterX = headerLabel.centerXAnchor.constraint(equalTo: containerView.centerXAnchor)

        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: pawWithHands.bottomAnchor, constant: 20)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // tableView
        let tableViewTop = tableView.topAnchor.constraint(equalTo: freeTrialScaledLabel.bottomAnchor, constant: 10)
        let tableViewLeading = tableView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 20)
        let tableViewTrailing = tableView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // continueButton
        let continueButtonTop = continueButton.topAnchor.constraint(equalTo: tableView.bottomAnchor, constant: 25)
        let continueButtonLeading = continueButton.leadingAnchor.constraint(equalTo: tableView.leadingAnchor)
        let continueButtonWidthRatio = continueButton.createScreenWideHeightMultiplier()

        // redeemButton
        redeemHeightConstaint = redeemButton.heightAnchor.constraint(equalToConstant: redeemHeightConstaintConstant)
        let redeemButtonTop = redeemButton.topAnchor.constraint(equalTo: continueButton.bottomAnchor, constant: 20)
        let redeemButtonLeading = redeemButton.leadingAnchor.constraint(equalTo: tableView.leadingAnchor)

        // restoreButton
        let restoreButtonTop = restoreButton.topAnchor.constraint(equalTo: redeemButton.topAnchor)
        let restoreButtonLeading = restoreButton.leadingAnchor.constraint(equalTo: redeemButton.trailingAnchor)
        let restoreButtonWidth = restoreButton.widthAnchor.constraint(equalTo: redeemButton.widthAnchor)
        let restoreButtonHeight = restoreButton.heightAnchor.constraint(equalTo: redeemButton.heightAnchor)

        // subscriptionDisclaimerLabel
        redeemBottomConstraint = subscriptionDisclaimerLabel.topAnchor.constraint(equalTo: redeemButton.bottomAnchor, constant: redeemBottomConstraintConstant)
        let subscriptionDisclaimerLabelLeading = subscriptionDisclaimerLabel.leadingAnchor.constraint(equalTo: tableView.leadingAnchor)
        let subscriptionDisclaimerLabelTrailing = subscriptionDisclaimerLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let subscriptionDisclaimerLabelBottom = subscriptionDisclaimerLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -15)

        // backButton
        let backButtonTop = backButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 10)
        let backButtonLeading = backButton.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 10)
        let backButtonTrailing = backButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -10)
        let backButtonWidth = backButton.widthAnchor.constraint(equalTo: backButton.heightAnchor)
        let backButtonWidthRatio = backButton.widthAnchor.constraint(equalTo: containerView.widthAnchor, multiplier: 50.0 / 414.0)
        let backButtonMinHeight = backButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 25)
        let backButtonMaxHeight = backButton.heightAnchor.constraint(lessThanOrEqualToConstant: 75)

        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor)
        let containerViewWidth = containerView.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor)
        let viewSafeAreaBottom = view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let viewSafeAreaTrailing = view.safeAreaLayoutGuide.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)

        // scrollView
        let scrollViewTop = scrollView.topAnchor.constraint(equalTo: view.topAnchor)
        let scrollViewBottom = scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        let scrollViewLeading = scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor)
        let scrollViewTrailing = scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor)

        NSLayoutConstraint.activate([
            freeTrialTopConstraint, freeTrialHeightConstraint, freeTrialLeading, freeTrialTrailing,

            pawWithHandsTop, pawWithHandsCenterX, pawWithHandsWidthRatio, pawWithHandsWidthScreenRatio,

            headerLabelTop, headerLabelCenterX,

            descriptionLabelTop, descriptionLabelLeading, descriptionLabelTrailing,

            tableViewTop, tableViewLeading, tableViewTrailing,

            continueButtonTop, continueButtonLeading, continueButtonWidthRatio,

            redeemButtonTop, redeemButtonLeading, redeemHeightConstaint,

            restoreButtonTop, restoreButtonLeading, restoreButtonWidth, restoreButtonHeight,

            redeemBottomConstraint, subscriptionDisclaimerLabelLeading, subscriptionDisclaimerLabelTrailing, subscriptionDisclaimerLabelBottom,

            backButtonTop, backButtonLeading, backButtonTrailing, backButtonWidth, backButtonWidthRatio, backButtonMinHeight, backButtonMaxHeight,

            containerViewTop, containerViewLeading, containerViewWidth, viewSafeAreaBottom, viewSafeAreaTrailing,

            scrollViewTop, scrollViewBottom, scrollViewLeading, scrollViewTrailing
        ])
    }

}
//
//  SettingsAppearanceViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/16/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsAppearanceViewController: GeneralUIViewController {
    
    // MARK: - Elements
    
    private let interfaceStyleSegmentedControl: UISegmentedControl = {
        let segmentedControl = UISegmentedControl()
        segmentedControl.contentMode = .scaleToFill
        segmentedControl.contentHorizontalAlignment = .left
        segmentedControl.contentVerticalAlignment = .top
        segmentedControl.apportionsSegmentWidthsByContent = true
        segmentedControl.selectedSegmentIndex = 2
        segmentedControl.translatesAutoresizingMaskIntoConstraints = false
        segmentedControl.selectedSegmentTintColor = .systemBlue
        
        return segmentedControl
    }()
    
    @objc private func didUpdateInterfaceStyle(_ sender: Any) {
        guard let sender = sender as? UISegmentedControl else {
            return
        }
        
        /// Assumes the segmented control is configured for interfaceStyle selection (0: light, 1: dark, 2: unspecified). Using the selectedSegmentIndex, queries the server to update the interfaceStyle UserConfiguration. If successful, then changes UI to new interface style and saves new UserConfiguration value. If unsuccessful, reverts the selectedSegmentIndex to the position before the change, doesn't change the UI interface style, and doesn't save the new UserConfiguration value
        
        let beforeUpdateInterfaceStyle = UserConfiguration.interfaceStyle
        let unconvertedNewInterfaceStyle = sender.selectedSegmentIndex
        let convertedNewInterfaceStyle = {
            switch unconvertedNewInterfaceStyle {
            case 0:
                return 1
            case 1:
                return 2
            default:
                return 0
            }
        }()
        
        UserConfiguration.interfaceStyle = UIUserInterfaceStyle(rawValue: convertedNewInterfaceStyle) ?? UserConfiguration.interfaceStyle
        
        let body = [KeyConstant.userConfigurationInterfaceStyle.rawValue: convertedNewInterfaceStyle]
        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.interfaceStyle = beforeUpdateInterfaceStyle
                
                sender.selectedSegmentIndex = {
                    switch UserConfiguration.interfaceStyle.rawValue {
                        // system/unspecified
                    case 0:
                        return 2
                        // light
                    case 1:
                        return 0
                        // dark
                    case 2:
                        return 1
                    default:
                        return 2
                    }
                }()
                return
            }
        }
    }
    
    private let measurementSystemSegmentedControl: UISegmentedControl = {
        let segmentedControl = UISegmentedControl()
        segmentedControl.contentMode = .scaleToFill
        segmentedControl.contentHorizontalAlignment = .left
        segmentedControl.contentVerticalAlignment = .top
        segmentedControl.apportionsSegmentWidthsByContent = true
        segmentedControl.selectedSegmentIndex = 2
        segmentedControl.translatesAutoresizingMaskIntoConstraints = false
        segmentedControl.selectedSegmentTintColor = .systemBlue
        
        return segmentedControl
    }()
    
    // MARK: - Additional UI Elements
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        scrollView.bounces = false
        scrollView.bouncesZoom = false
        
        return scrollView
    }()
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        
        view.backgroundColor = .systemBackground
        return view
    }()
    
    private let themeHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Theme"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 360, compressionResistancePriority: 360)
        
        button.translatesAutoresizingMaskIntoConstraints = false
        button.tintColor = .label
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        
        button.shouldDismissParentViewController = true
        return button
    }()
    
    private let appearanceHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Appearance"
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        return label
    }()
    
    private let measurementHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Measurement System"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    @objc private func didUpdateMeasurementSystem(_ sender: Any) {
        guard let sender = sender as? UISegmentedControl else {
            return
        }
        
        /// Assumes the segmented control is configured for measurementSystem selection (0: imperial, 1: metric, 2: both).
        
        let beforeUpdateMeasurementSystem = UserConfiguration.measurementSystem
        
        UserConfiguration.measurementSystem = MeasurementSystem(rawValue: sender.selectedSegmentIndex) ?? UserConfiguration.measurementSystem
        
        let body = [KeyConstant.userConfigurationMeasurementSystem.rawValue: sender.selectedSegmentIndex]
        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.measurementSystem = beforeUpdateMeasurementSystem
                sender.selectedSegmentIndex = beforeUpdateMeasurementSystem.rawValue
                return
            }
        }
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        let attributes: [NSAttributedString.Key: Any] = [.font: UIFont.systemFont(ofSize: VisualConstant.FontConstant.primaryRegularLabel.pointSize, weight: .bold), .foregroundColor: UIColor.systemBackground]
        let backgroundColor = UIColor.systemGray4
        
        // Dark Mode
        interfaceStyleSegmentedControl.setTitleTextAttributes(attributes, for: .normal)
        interfaceStyleSegmentedControl.backgroundColor = backgroundColor
        interfaceStyleSegmentedControl.selectedSegmentIndex = {
            switch UserConfiguration.interfaceStyle.rawValue {
                // system/unspecified
            case 0:
                return 2
                // light
            case 1:
                return 0
                // dark
            case 2:
                return 1
            default:
                return 2
            }
        }()
        
        measurementSystemSegmentedControl.setTitleTextAttributes(attributes, for: .normal)
        measurementSystemSegmentedControl.backgroundColor = backgroundColor
        measurementSystemSegmentedControl.selectedSegmentIndex = UserConfiguration.measurementSystem.rawValue
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        scrollView.addSubview(containerView)
        containerView.addSubview(interfaceStyleSegmentedControl)
        containerView.addSubview(themeHeaderLabel)
        containerView.addSubview(backButton)
        containerView.addSubview(appearanceHeaderLabel)
        containerView.addSubview(measurementHeaderLabel)
        containerView.addSubview(measurementSystemSegmentedControl)
        
        interfaceStyleSegmentedControl.addTarget(self, action: #selector(didUpdateInterfaceStyle), for: .valueChanged)
        measurementSystemSegmentedControl.addTarget(self, action: #selector(didUpdateMeasurementSystem), for: .valueChanged)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // appearanceHeaderLabel (Top of page)
        let appearanceHeaderLabelTop = appearanceHeaderLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let appearanceHeaderLabelLeading = appearanceHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let appearanceHeaderLabelHeight = appearanceHeaderLabel.heightAnchor.constraint(equalToConstant: 40)

        // backButton (Top-right, next to appearanceHeaderLabel)
        let backButtonTop = backButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 10)
        let backButtonLeading = backButton.leadingAnchor.constraint(equalTo: appearanceHeaderLabel.trailingAnchor, constant: 10)
        let backButtonTrailing = backButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -10)
        let backButtonWidth = backButton.widthAnchor.constraint(equalTo: backButton.heightAnchor)
        let backButtonWidthRatio = backButton.widthAnchor.constraint(equalTo: containerView.widthAnchor, multiplier: 50.0 / 414.0)
        let backButtonMinHeight = backButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 25)
        let backButtonMaxHeight = backButton.heightAnchor.constraint(lessThanOrEqualToConstant: 75)
        // Apply lower priority to width ratio, so 25-75 clamp is never broken
        backButtonWidthRatio.priority = .defaultHigh

        // themeHeaderLabel (below appearanceHeaderLabel)
        let themeHeaderLabelTop = themeHeaderLabel.topAnchor.constraint(equalTo: appearanceHeaderLabel.bottomAnchor, constant: 20)
        let themeHeaderLabelLeading = themeHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let themeHeaderLabelTrailing = themeHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // interfaceStyleSegmentedControl (below themeHeaderLabel)
        let interfaceStyleSegmentedControlTop = interfaceStyleSegmentedControl.topAnchor.constraint(equalTo: themeHeaderLabel.bottomAnchor, constant: 10)
        let interfaceStyleSegmentedControlLeading = interfaceStyleSegmentedControl.leadingAnchor.constraint(equalTo: themeHeaderLabel.leadingAnchor)
        let interfaceStyleSegmentedControlTrailing = interfaceStyleSegmentedControl.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let interfaceStyleSegmentedControlHeight = interfaceStyleSegmentedControl.heightAnchor.constraint(equalToConstant: 40)

        // measurementHeaderLabel (below interfaceStyleSegmentedControl)
        let measurementHeaderLabelTop = measurementHeaderLabel.topAnchor.constraint(equalTo: interfaceStyleSegmentedControl.bottomAnchor, constant: 45)
        let measurementHeaderLabelLeading = measurementHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let measurementHeaderLabelTrailing = measurementHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // measurementSystemSegmentedControl (below measurementHeaderLabel)
        let measurementSystemSegmentedControlTop = measurementSystemSegmentedControl.topAnchor.constraint(equalTo: measurementHeaderLabel.bottomAnchor, constant: 10)
        let measurementSystemSegmentedControlLeading = measurementSystemSegmentedControl.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let measurementSystemSegmentedControlTrailing = measurementSystemSegmentedControl.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let measurementSystemSegmentedControlHeight = measurementSystemSegmentedControl.heightAnchor.constraint(equalToConstant: 40)
        let measurementSystemSegmentedControlBottom = measurementSystemSegmentedControl.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -10)

        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor)
        let containerViewWidth = containerView.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor)
        let viewSafeAreaBottom = view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let viewSafeAreaTrailing = view.safeAreaLayoutGuide.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)

        // scrollView
        let scrollViewTop = scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
        let scrollViewBottom = scrollView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        let scrollViewLeading = scrollView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor)
        let scrollViewTrailing = scrollView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor)

        NSLayoutConstraint.activate([
            // appearanceHeaderLabel
            appearanceHeaderLabelTop, appearanceHeaderLabelLeading, appearanceHeaderLabelHeight,

            // backButton
            backButtonTop, backButtonLeading, backButtonTrailing,
            backButtonWidth, backButtonWidthRatio, backButtonMinHeight, backButtonMaxHeight,

            // themeHeaderLabel
            themeHeaderLabelTop, themeHeaderLabelLeading, themeHeaderLabelTrailing,

            // interfaceStyleSegmentedControl
            interfaceStyleSegmentedControlTop, interfaceStyleSegmentedControlLeading,
            interfaceStyleSegmentedControlTrailing, interfaceStyleSegmentedControlHeight,

            // measurementHeaderLabel
            measurementHeaderLabelTop, measurementHeaderLabelLeading, measurementHeaderLabelTrailing,

            // measurementSystemSegmentedControl
            measurementSystemSegmentedControlTop, measurementSystemSegmentedControlLeading,
            measurementSystemSegmentedControlTrailing, measurementSystemSegmentedControlHeight, measurementSystemSegmentedControlBottom,

            // containerView
            containerViewTop, containerViewLeading, containerViewWidth, viewSafeAreaBottom, viewSafeAreaTrailing,

            // scrollView
            scrollViewTop, scrollViewBottom, scrollViewLeading, scrollViewTrailing
        ])
    }

}
//
//  SettingsNotifsTableVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsTableVC: GeneralUITableViewController, SettingsNotifsUseNotificationsTVCDelegate {
    
    // MARK: - SettingsNotifsUseNotificationsTVCDelegate
    
    func didToggleIsNotificationEnabled() {
        synchronizeAllIsEnabled()
    }
    
    // MARK: - Properties
    
    private static var settingsNotifsTableVC: SettingsNotifsTableVC?
    
    private var settingsNotifsCategoriesTableVC: SettingsNotifsCategoriesTableVC?
    
    private var settingsNotifsAlarmsTableVC: SettingsNotifsAlarmsTableVC?
    
    private let settingsNotifsTVCReuseIdentifiers = [SettingsNotifsUseNotificationsTVC.reuseIdentifier,
                                                     SettingsNotifsSilentModeTVC.reuseIdentifier,
                                                     SettingsNotifsCategoriesTVC.reuseIdentifier,
                                                     SettingsNotifsAlarmsTVC.reuseIdentifier
    ]
    
    // MARK: - Main
    
    convenience init() {
        self.init(style: .plain)
    }
    
    override init(style: UITableView.Style) {
        super.init(style: style)
        modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        settingsNotifsTVCReuseIdentifiers.forEach { settingsNotifsTVCReuseIdentifier in
            switch settingsNotifsTVCReuseIdentifier {
            case SettingsNotifsUseNotificationsTVC.reuseIdentifier:
                tableView.register(SettingsNotifsUseNotificationsTVC.self, forCellReuseIdentifier: SettingsNotifsUseNotificationsTVC.reuseIdentifier)
            case SettingsNotifsSilentModeTVC.reuseIdentifier:
                tableView.register(SettingsNotifsSilentModeTVC.self, forCellReuseIdentifier: SettingsNotifsSilentModeTVC.reuseIdentifier)
            case SettingsNotifsCategoriesTVC.reuseIdentifier:
                tableView.register(SettingsNotifsCategoriesTVC.self, forCellReuseIdentifier: SettingsNotifsCategoriesTVC.reuseIdentifier)
            case SettingsNotifsAlarmsTVC.reuseIdentifier:
                tableView.register(SettingsNotifsAlarmsTVC.self, forCellReuseIdentifier: SettingsNotifsAlarmsTVC.reuseIdentifier)
            default: break
            }
        }
        
        SettingsNotifsTableVC.settingsNotifsTableVC = self
        
        let dummyTableTableHeaderViewHeight = 100.0
        // Adding a tableHeaderView prevents section headers from sticking and floating at the top of the page when we scroll up. This is because we are basically adding a large blank space to the top of the screen, allowing a space for the header to scroll into
        tableView.tableHeaderView = UIView(frame: CGRect(x: 0, y: 0, width: self.tableView.bounds.size.width, height: dummyTableTableHeaderViewHeight))
        tableView.contentInset = UIEdgeInsets(top: -dummyTableTableHeaderViewHeight, left: 0, bottom: 0, right: 0)
        tableView.separatorStyle = .none
    }
    
    // MARK: - Functions
    
    /// Goes through all notification cells to synchronize their isEnabled to represent the state of isNotificationEnabled
    func synchronizeAllIsEnabled() {
        // useNotificationsCell is always isEnabled true
        
        if let silentModeRow = settingsNotifsTVCReuseIdentifiers.firstIndex(of: SettingsNotifsSilentModeTVC.reuseIdentifier) {
            let silentModeCellIndexPath = IndexPath(row: silentModeRow, section: 0)
            if let silentModeCell = tableView(tableView, cellForRowAt: silentModeCellIndexPath) as? SettingsNotifsSilentModeTVC {
                silentModeCell.synchronizeIsEnabled()
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [silentModeCellIndexPath], with: .none)
            }
        }
        
        settingsNotifsCategoriesTableVC?.synchronizeAllIsEnabled()
        
        settingsNotifsAlarmsTableVC?.synchronizeAllIsEnabled()
    }
    
    /// Goes through all notification cells to synchronize their values to represent what is stored
    func synchronizeAllValues(animated: Bool) {
        synchronizeAllIsEnabled()
        
        if let useNotificationsRow = settingsNotifsTVCReuseIdentifiers.firstIndex(of: SettingsNotifsUseNotificationsTVC.reuseIdentifier) {
            let useNotificationsIndexPath = IndexPath(row: useNotificationsRow, section: 0)
            if let useNotificationsCell = tableView(tableView, cellForRowAt: useNotificationsIndexPath) as? SettingsNotifsUseNotificationsTVC {
                useNotificationsCell.synchronizeValues(animated: animated)
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [useNotificationsIndexPath], with: .none)
            }
        }
        
        if let silentModeRow = settingsNotifsTVCReuseIdentifiers.firstIndex(of: SettingsNotifsSilentModeTVC.reuseIdentifier) {
            let silentModeCellIndexPath = IndexPath(row: silentModeRow, section: 0)
            if let silentModeCell = tableView(tableView, cellForRowAt: silentModeCellIndexPath) as? SettingsNotifsSilentModeTVC {
                silentModeCell.synchronizeValues(animated: animated)
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [silentModeCellIndexPath], with: .none)
            }
        }
        
        settingsNotifsCategoriesTableVC?.synchronizeAllValues(animated: animated)
        
        settingsNotifsAlarmsTableVC?.synchronizeAllValues(animated: animated)
    }
    
    /// The isNotificationAuthorized, isNotificationEnabled, and isLoudNotificationEnabled have been potentially updated. Additionally, SettingsNotifsTableVC could be be the last view opened. Therefore, we need to inform SettingsNotifsTableVC of these changes so that it can update its switches.
    static func didSynchronizeNotificationAuthorization() {
        SettingsNotifsTableVC.settingsNotifsTableVC?.synchronizeAllValues(animated: true)
    }
    
    // MARK: - Table View Data Source
    
    override func numberOfSections(in tableView: UITableView) -> Int {
        1
    }
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        settingsNotifsTVCReuseIdentifiers.count
    }
    
    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = SettingsNotifsTableHeaderV()
        
        headerView.setup(forTitle: "Notifications")
        
        return headerView
    }
    
    override func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        SettingsNotifsTableHeaderV.cellHeight
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        // We will be indexing SettingsNotifsCategoriesTVCs.allCases for the cell identifier, therefore make sure the cell is within a defined range
        guard indexPath.row < settingsNotifsTVCReuseIdentifiers.count else {
            return GeneralUITableViewCell()
        }
        
        let identifier = settingsNotifsTVCReuseIdentifiers[indexPath.row]
        
        let cell = tableView.dequeueReusableCell(withIdentifier: identifier, for: indexPath)
        
        if let cell = cell as? SettingsNotifsUseNotificationsTVC {
            cell.setup(forDelegate: self)
        }
        
        return cell
    }
    
    override func tableView(_ tableView: UITableView, shouldHighlightRowAt indexPath: IndexPath) -> Bool {
        // None of the rows should highlight. Either they have specific controls in them or open an external view controller
        return false
    }
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        
        let identifier = settingsNotifsTVCReuseIdentifiers[indexPath.row]
        
        switch identifier {
        case SettingsNotifsCategoriesTVC.reuseIdentifier:
            let vc = SettingsNotifsCategoriesTableVC()
            PresentationManager.enqueueViewController(vc)
        case SettingsNotifsAlarmsTVC.reuseIdentifier:
            let vc = SettingsNotifsAlarmsTableVC()
            PresentationManager.enqueueViewController(vc)
        default:
            break
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        NSLayoutConstraint.activate([
        ])
        
    }
}
//
//  SettingsNotifsTableHeaderV.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/30/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class SettingsNotifsTableHeaderV: GeneralUIView {
    
    // MARK: - Elements
    
    private let contentView: GeneralUIView = GeneralUIView()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Notifications"
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        return label
    }()
    
    // MARK: - Additional UI Elements
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 260, compressionResistancePriority: 260)
        
        button.tintColor = .label
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        
        button.shouldRoundCorners = true
        button.shouldDismissParentViewController = true
        return button
    }()
    
    // MARK: - Properties
    
    private static let topConstraint = 0.0
    private static let heightConstraint = 40.0
    private static let bottomConstraint = 0.0
    
    static var cellHeight: Double {
        topConstraint + heightConstraint + bottomConstraint
    }
    
    // MARK: - Setup
    
    func setup(forTitle: String) {
        headerLabel.text = forTitle
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        contentView.frame = bounds
        addSubview(contentView)
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(backButton)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // headerLabel
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: SettingsNotifsTableHeaderV.topConstraint)
        let headerLabelBottom = headerLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: SettingsNotifsTableHeaderV.bottomConstraint)
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelHeight = headerLabel.heightAnchor.constraint(equalToConstant: SettingsNotifsTableHeaderV.heightConstraint)

        // backButton
        let backButtonTop = backButton.topAnchor.constraint(equalTo: contentView.topAnchor, constant: -10)
        let backButtonLeading = backButton.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 10)
        let backButtonTrailing = backButton.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -10)
        let backButtonWidth = backButton.widthAnchor.constraint(equalTo: backButton.heightAnchor)
        let backButtonWidthRatio = backButton.widthAnchor.constraint(equalTo: contentView.widthAnchor, multiplier: 50.0 / 414.0)
        let backButtonMinHeight = backButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 25)
        let backButtonMaxHeight = backButton.heightAnchor.constraint(lessThanOrEqualToConstant: 75)
        // Avoid 25–75 clamp bug by lowering the width ratio priority
        backButtonWidthRatio.priority = .defaultHigh

        NSLayoutConstraint.activate([
            // headerLabel
            headerLabelTop, headerLabelBottom, headerLabelLeading, headerLabelHeight,

            // backButton
            backButtonTop, backButtonLeading, backButtonTrailing,
            backButtonWidth, backButtonWidthRatio, backButtonMinHeight, backButtonMaxHeight
        ])
    }

}
//
//  SettingsNotifsCategoriesFamilyTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesFamilyTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 230, compressionResistancePriority: 230)
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    // MARK: - Additional UI Elements
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Family"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let alwaysOnSwitch: GeneralUISwitch = {
        let uiSwitch = GeneralUISwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isEnabled = false
        uiSwitch.isOn = true
        return uiSwitch
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesFamilyTVC"
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        setup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Setup
    
    private func setup() {
        let precalculatedDynamicTextColor = descriptionLabel.textColor
        descriptionLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            let message = NSMutableAttributedString(
                string: "Receive notifications about your Hound family. ",
                attributes: [
                    .font: VisualConstant.FontConstant.secondaryColorDescLabel,
                    .foregroundColor: precalculatedDynamicTextColor as Any
                ]
            )
            
            message.append(NSAttributedString(
                string: "This category cannot be turned off.",
                attributes: [
                    .font: VisualConstant.FontConstant.emphasizedSecondaryColorDescLabel,
                    .foregroundColor: precalculatedDynamicTextColor as Any
                ])
            )
            
            message.append(NSAttributedString(
                string: " Examples include: a user joining, leaving, or locking your family.",
                attributes: [
                    .font: VisualConstant.FontConstant.secondaryColorDescLabel,
                    .foregroundColor: precalculatedDynamicTextColor as Any
                ])
            )
            
            return message
        }
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(alwaysOnSwitch)
        contentView.addSubview(descriptionLabel)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // alwaysOnSwitch
        let alwaysOnSwitchTop = alwaysOnSwitch.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let alwaysOnSwitchLeading = alwaysOnSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 10)
        let alwaysOnSwitchTrailing = alwaysOnSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -40)
        
        // headerLabel
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelCenterY = headerLabel.centerYAnchor.constraint(equalTo: alwaysOnSwitch.centerYAnchor)
        
        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: alwaysOnSwitch.bottomAnchor, constant: 7.5)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        
        NSLayoutConstraint.activate([
            // alwaysOnSwitch
            alwaysOnSwitchTop, alwaysOnSwitchLeading, alwaysOnSwitchTrailing,
            
            // headerLabel
            headerLabelLeading, headerLabelCenterY,
            
            // descriptionLabel
            descriptionLabelTop, descriptionLabelBottom, descriptionLabelLeading, descriptionLabelTrailing
        ])
    }

}
//
//  SettingsNotifsCategoriesReminderTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesReminderTVC: GeneralUITableViewCell {

    // MARK: - Elements

    private let isReminderNotificationEnabledSwitch: GeneralUISwitch = {
        let uiSwitch = GeneralUISwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isOn = true
        
        return uiSwitch
    }()
    
    // MARK: - Additional UI Elements
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Reminder"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 230, compressionResistancePriority: 230)
        label.text = "Recieve notifications about your family's reminders. Examples include: a reminder's alarm sounding."
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()

    @objc private func didToggleIsReminderNotificationEnabled(_ sender: Any) {
        let beforeUpdatesReminderNotificationEnabled = UserConfiguration.isReminderNotificationEnabled

        UserConfiguration.isReminderNotificationEnabled = isReminderNotificationEnabledSwitch.isOn

        let body = [KeyConstant.userConfigurationIsReminderNotificationEnabled.rawValue: UserConfiguration.isReminderNotificationEnabled]

        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.isReminderNotificationEnabled = beforeUpdatesReminderNotificationEnabled
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesReminderTVC"

    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    // MARK: - Functions

    /// Updates the displayed isEnabled to reflect the state of isNotificationEnabled stored.
    func synchronizeIsEnabled() {
        isReminderNotificationEnabledSwitch.isEnabled = UserConfiguration.isNotificationEnabled
    }

    /// Updates the displayed values to reflect the values stored.
    func synchronizeValues(animated: Bool) {
        synchronizeIsEnabled()

        isReminderNotificationEnabledSwitch.setOn(UserConfiguration.isReminderNotificationEnabled, animated: animated)
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(isReminderNotificationEnabledSwitch)
        contentView.addSubview(descriptionLabel)
        
        isReminderNotificationEnabledSwitch.addTarget(self, action: #selector(didToggleIsReminderNotificationEnabled), for: .valueChanged)
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        // isReminderNotificationEnabledSwitch
        let isReminderNotificationEnabledSwitchTop = isReminderNotificationEnabledSwitch.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let isReminderNotificationEnabledSwitchLeading = isReminderNotificationEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 10)
        let isReminderNotificationEnabledSwitchTrailing = isReminderNotificationEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -40)
        
        // headerLabel
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelCenterY = headerLabel.centerYAnchor.constraint(equalTo: isReminderNotificationEnabledSwitch.centerYAnchor)
        
        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: isReminderNotificationEnabledSwitch.bottomAnchor, constant: 7.5)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        
        NSLayoutConstraint.activate([
            // Switch
            isReminderNotificationEnabledSwitchTop,
            isReminderNotificationEnabledSwitchLeading,
            isReminderNotificationEnabledSwitchTrailing,
            
            // Header label
            headerLabelLeading,
            headerLabelCenterY,
            
            // Description label
            descriptionLabelTop,
            descriptionLabelBottom,
            descriptionLabelLeading,
            descriptionLabelTrailing
        ])
    }

}
//
//  SettingsNotifsCategoriesLogTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesLogTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    private let isLogNotificationEnabledSwitch: GeneralUISwitch = {
        let uiSwitch = GeneralUISwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isOn = true
        
        return uiSwitch
    }()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Log"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 230, compressionResistancePriority: 230)
        label.text = "Receive notifications about your family's logs. Examples include: a user creating a log."
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    @objc private func didToggleIsLogNotificationEnabled(_ sender: Any) {
        let beforeUpdatesLogNotificationEnabled = UserConfiguration.isLogNotificationEnabled
        
        UserConfiguration.isLogNotificationEnabled = isLogNotificationEnabledSwitch.isOn
        
        let body = [KeyConstant.userConfigurationIsLogNotificationEnabled.rawValue: UserConfiguration.isLogNotificationEnabled]
        
        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.isLogNotificationEnabled = beforeUpdatesLogNotificationEnabled
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesLogTVC"
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    /// Updates the displayed isEnabled to reflect the state of isNotificationEnabled stored.
    func synchronizeIsEnabled() {
        isLogNotificationEnabledSwitch.isEnabled = UserConfiguration.isNotificationEnabled
    }
    
    /// Updates the displayed values to reflect the values stored.
    func synchronizeValues(animated: Bool) {
        synchronizeIsEnabled()
        
        isLogNotificationEnabledSwitch.setOn(UserConfiguration.isLogNotificationEnabled, animated: animated)
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(isLogNotificationEnabledSwitch)
        contentView.addSubview(descriptionLabel)
        
        isLogNotificationEnabledSwitch.addTarget(self, action: #selector(didToggleIsLogNotificationEnabled), for: .valueChanged)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // isLogNotificationEnabledSwitch
        let isLogNotificationEnabledSwitchTop = isLogNotificationEnabledSwitch.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let isLogNotificationEnabledSwitchLeading = isLogNotificationEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 10)
        let isLogNotificationEnabledSwitchTrailing = isLogNotificationEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -40)

        // headerLabel
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelCenterY = headerLabel.centerYAnchor.constraint(equalTo: isLogNotificationEnabledSwitch.centerYAnchor)

        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: isLogNotificationEnabledSwitch.bottomAnchor, constant: 7.5)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        NSLayoutConstraint.activate([
            // isLogNotificationEnabledSwitch
            isLogNotificationEnabledSwitchTop, isLogNotificationEnabledSwitchLeading, isLogNotificationEnabledSwitchTrailing,

            // headerLabel
            headerLabelLeading, headerLabelCenterY,

            // descriptionLabel
            descriptionLabelTop, descriptionLabelBottom, descriptionLabelLeading, descriptionLabelTrailing
        ])
    }

}
//
//  SettingsNotifsCategoriesTableVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesTableVC: GeneralUITableViewController {
    
    // MARK: - Properties
    
    private let settingsNotifsCategoriesTVCReuseIdentifiers = [SettingsNotifsCategoriesAccountTVC.reuseIdentifier,
                                                               SettingsNotifsCategoriesFamilyTVC.reuseIdentifier,
                                                               SettingsNotifsCategoriesLogTVC.reuseIdentifier,
                                                               SettingsNotifsCategoriesReminderTVC.reuseIdentifier
    ]

    // MARK: - Main

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true

        let dummyTableTableHeaderViewHeight = 100.0
        // Adding a tableHeaderView prevents section headers from sticking and floating at the top of the page when we scroll up. This is because we are basically adding a large blank space to the top of the screen, allowing a space for the header to scroll into
        tableView.tableHeaderView = UIView(frame: CGRect(x: 0, y: 0, width: self.tableView.bounds.size.width, height: dummyTableTableHeaderViewHeight))
        tableView.contentInset = UIEdgeInsets(top: -dummyTableTableHeaderViewHeight, left: 0, bottom: 0, right: 0)
        tableView.separatorStyle = .none
    }

    // MARK: - Functions

    /// Goes through all notification cells to synchronize their isEnabled to represent the state of isNotificationEnabled
    func synchronizeAllIsEnabled() {
        // NO-OP class SettingsNotifsCategoriesAccountTVC

        // NO-OP class SettingsNotifsCategoriesFamilyTVC

        if let logRow = settingsNotifsCategoriesTVCReuseIdentifiers.firstIndex(of: SettingsNotifsCategoriesLogTVC.reuseIdentifier) {
            let logIndexPath = IndexPath(row: logRow, section: 0)
            if let logCell = tableView(tableView, cellForRowAt: logIndexPath) as? SettingsNotifsCategoriesLogTVC {
                logCell.synchronizeIsEnabled()
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [logIndexPath], with: .none)
            }
        }

        if let reminderRow = settingsNotifsCategoriesTVCReuseIdentifiers.firstIndex(of: SettingsNotifsCategoriesReminderTVC.reuseIdentifier) {
            let reminderIndexPath = IndexPath(row: reminderRow, section: 0)
            if let reminderCell = tableView(tableView, cellForRowAt: reminderIndexPath) as? SettingsNotifsCategoriesReminderTVC {
                reminderCell.synchronizeIsEnabled()
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [reminderIndexPath], with: .none)
            }
        }
    }

    /// Goes through all notification cells to synchronize their values to represent what is stored
    func synchronizeAllValues(animated: Bool) {
        synchronizeAllIsEnabled()

        // NO-OP class SettingsNotifsCategoriesAccountTVC

        // NO-OP class SettingsNotifsCategoriesFamilyTVC

        if let logRow = settingsNotifsCategoriesTVCReuseIdentifiers.firstIndex(of: SettingsNotifsCategoriesLogTVC.reuseIdentifier) {
            let logIndexPath = IndexPath(row: logRow, section: 0)
            if let logCell = tableView(tableView, cellForRowAt: logIndexPath) as? SettingsNotifsCategoriesLogTVC {
                logCell.synchronizeValues(animated: animated)
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [logIndexPath], with: .none)
            }
        }

        if let reminderRow = settingsNotifsCategoriesTVCReuseIdentifiers.firstIndex(of: SettingsNotifsCategoriesReminderTVC.reuseIdentifier) {
            let reminderIndexPath = IndexPath(row: reminderRow, section: 0)
            if let reminderCell = tableView(tableView, cellForRowAt: reminderIndexPath) as? SettingsNotifsCategoriesReminderTVC {
                reminderCell.synchronizeValues(animated: animated)
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [reminderIndexPath], with: .none)
            }
        }
    }

    // MARK: - Table View Data Source

    override func numberOfSections(in tableView: UITableView) -> Int {
        1
    }

    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        settingsNotifsCategoriesTVCReuseIdentifiers.count
    }

    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = SettingsNotifsTableHeaderV()

        headerView.setup(forTitle: "Categories")

        return headerView
    }

    override func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        SettingsNotifsTableHeaderV.cellHeight
    }

    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        // We will be indexing SettingsNotifsCategoriesTVCs.allCases for the cell identifier, therefore make sure the cell is within a defined range
        guard indexPath.row < settingsNotifsCategoriesTVCReuseIdentifiers.count else {
            return GeneralUITableViewCell()
        }

        let identifier = settingsNotifsCategoriesTVCReuseIdentifiers[indexPath.row]

        let cell = tableView.dequeueReusableCell(withIdentifier: identifier, for: indexPath)

        return cell
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
    }

    override func setupConstraints() {
        super.setupConstraints()
        NSLayoutConstraint.activate([
        ])
        
    }
}
//
//  SettingsNotifsCategoriesAccountTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesAccountTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 230, compressionResistancePriority: 230)
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    // MARK: - Additional UI Elements
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Account"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let alwaysOnSwitch: GeneralUISwitch = {
        let uiSwitch = GeneralUISwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isEnabled = false
        uiSwitch.isOn = true
        return uiSwitch
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesAccountTVC"
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        setup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Setup
    
    private func setup() {
        let precalculatedDynamicTextColor = descriptionLabel.textColor
        descriptionLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            let message = NSMutableAttributedString(
                string: "Receive notifications about your account. ",
                attributes: [
                    .font: VisualConstant.FontConstant.secondaryColorDescLabel,
                    .foregroundColor: precalculatedDynamicTextColor as Any
                ]
            )
            
            message.append(NSAttributedString(
                string: "This category cannot be turned off.",
                attributes: [
                    .font: VisualConstant.FontConstant.emphasizedSecondaryColorDescLabel,
                    .foregroundColor: precalculatedDynamicTextColor as Any
                ])
            )
            
            message.append(NSAttributedString(
                string: " Examples include: getting kicked from your Hound family, accidentally terminating Hound while Loud Alarms is enabled.",
                attributes: [
                    .font: VisualConstant.FontConstant.secondaryColorDescLabel,
                    .foregroundColor: precalculatedDynamicTextColor as Any
                ])
            )
            
            return message
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(alwaysOnSwitch)
        contentView.addSubview(descriptionLabel)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // alwaysOnSwitch
        let alwaysOnSwitchTop = alwaysOnSwitch.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let alwaysOnSwitchLeading = alwaysOnSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 10)
        let alwaysOnSwitchTrailing = alwaysOnSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -40)
        
        // headerLabel
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelCenterY = headerLabel.centerYAnchor.constraint(equalTo: alwaysOnSwitch.centerYAnchor)
        
        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: alwaysOnSwitch.bottomAnchor, constant: 7.5)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        
        NSLayoutConstraint.activate([
            // alwaysOnSwitch
            alwaysOnSwitchTop, alwaysOnSwitchLeading, alwaysOnSwitchTrailing,
            
            // headerLabel
            headerLabelLeading, headerLabelCenterY,
            
            // descriptionLabel
            descriptionLabelTop, descriptionLabelBottom, descriptionLabelLeading, descriptionLabelTrailing
        ])
    }

}
//
//  SettingsNotifsAlarmsTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsTVC: GeneralUITableViewCell {
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Configure Alarms"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.text = "By default, your reminder alarms will repeatedly ring, play the 'Radar' sound effect, and snooze for five minutes"
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let chevonImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 300, compressionResistancePriority: 300)
        
        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = .systemGray4
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsAlarmsTVC"
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(descriptionLabel)
        contentView.addSubview(chevonImageView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelHeight = headerLabel.heightAnchor.constraint(equalToConstant: 25)
        let headerLabelTrailing = headerLabel.trailingAnchor.constraint(equalTo: descriptionLabel.trailingAnchor)
        
        // chevonImageView
        let chevonImageViewLeading = chevonImageView.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 5)
        let chevonImageViewTrailing = chevonImageView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let chevonImageViewCenterY = chevonImageView.centerYAnchor.constraint(equalTo: contentView.centerYAnchor)
        let chevonImageViewWidthByHeight = chevonImageView.widthAnchor.constraint(equalTo: chevonImageView.heightAnchor, multiplier: 1.0 / 1.5)
        let chevonImageViewWidthByHeader = chevonImageView.widthAnchor.constraint(equalTo: headerLabel.heightAnchor, multiplier: 20.0 / 25.0)
        chevonImageViewWidthByHeader.priority = .defaultHigh // Prevents ambiguous width when hugging
        
        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 7.5)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor)
        // trailing linked via headerLabel.trailing
        
        NSLayoutConstraint.activate([
            // headerLabel
            headerLabelTop, headerLabelLeading, headerLabelHeight, headerLabelTrailing,
            
            // chevonImageView
            chevonImageViewLeading, chevonImageViewTrailing, chevonImageViewCenterY, chevonImageViewWidthByHeight, chevonImageViewWidthByHeader,
            
            // descriptionLabel
            descriptionLabelTop, descriptionLabelBottom, descriptionLabelLeading
        ])
    }

}
//
//  SettingsNotifsAlarmsNotificationSoundTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/14/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsNotificationSoundTVC: GeneralUITableViewCell {

    // MARK: - Elements

    private let notificationSoundLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.contentMode = .left
        label.text = "Notification Sound"
        label.font = VisualConstant.FontConstant.weakSecondaryRegularLabel
        return label
    }()

    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsAlarmsNotificationSoundTVC"

    private static let topConstraint: CGFloat = 7.5
    private static let heightConstraint: CGFloat = 17.5
    private static let bottomConstraint: CGFloat = 7.5
    static let cellHeight: CGFloat = topConstraint + heightConstraint + bottomConstraint

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    private(set) var isCustomSelected: Bool = false

    // MARK: - Setup

    func setup(forNotificationSound notificationSound: String) {
        notificationSoundLabel.text = notificationSound
    }
    
    // MARK: - Functions

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    func setCustomSelectedTableViewCell(_ selected: Bool, animated: Bool) {
        // DO NOT INVOKE DEFAULT IMPLEMENTATION OF super.setSelected(selected, animated: animated)
        guard selected != isCustomSelected else {
            return
        }

        isCustomSelected = selected

        UIView.animate(withDuration: animated ? VisualConstant.AnimationConstant.toggleSelectUIElement : 0.0) {
            self.contentView.backgroundColor = selected ? .systemBlue : .systemBackground
            self.notificationSoundLabel.textColor = selected ? .systemBackground : .label
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(notificationSoundLabel)
        
    }

    override func setupConstraints() {
        super.setupConstraints()

        // notificationSoundLabel constraints
        let notificationSoundLabelTop = notificationSoundLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: SettingsNotifsAlarmsNotificationSoundTVC.topConstraint)
        let notificationSoundLabelBottom = notificationSoundLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -SettingsNotifsAlarmsNotificationSoundTVC.bottomConstraint)
        let notificationSoundLabelLeading = notificationSoundLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 15)
        let notificationSoundLabelTrailing = notificationSoundLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -15)
        let notificationSoundLabelHeight = notificationSoundLabel.heightAnchor.constraint(equalToConstant: SettingsNotifsAlarmsNotificationSoundTVC.heightConstraint)
        
        NSLayoutConstraint.activate([
            notificationSoundLabelTop,
            notificationSoundLabelBottom,
            notificationSoundLabelLeading,
            notificationSoundLabelTrailing,
            notificationSoundLabelHeight
        ])
    }

}
//
//  SettingsNotifsAlarmsNotificationSoundsTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsNotificationSoundsTVC: GeneralUITableViewCell, UITableViewDelegate, UITableViewDataSource {
    
    // MARK: - Properties
    
    private let notificationSoundsTableView: GeneralUITableView = {
        let tableView = GeneralUITableView(huggingPriority: 260, compressionResistancePriority: 260)
        tableView.alwaysBounceVertical = true
        tableView.backgroundColor = .systemBackground
        tableView.separatorColor = .systemGray2
        tableView.borderWidth = 1
        tableView.borderColor = .label
        tableView.shouldAutomaticallyAdjustHeight = true
        tableView.shouldRoundCorners = true
        return tableView
    }()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Alarm Sound"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.text = "Changes the sound your alarms play. Tap on one of them to hear what it sounds like!"
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        setup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Setup
    
    private func setup() {
        notificationSoundsTableView.register(SettingsNotifsAlarmsNotificationSoundTVC.self, forCellReuseIdentifier: SettingsNotifsAlarmsNotificationSoundTVC.reuseIdentifier)
        notificationSoundsTableView.delegate = self
        notificationSoundsTableView.dataSource = self
        
        notificationSoundsTableView.isScrollEnabled = false
        
        // notificationSoundsTableView won't automatically size itself inside a cell. If you set rowHeight to automaticDimension and estimatedRowHeight to 42.0, the cell will always resize to 42.0, not adapting at all. translatesAutoresizingMaskIntoConstraints doesn't do anything either. Hard coding the cell's size in storyboard (top, bottom, height, and row height set) doesn't resolve this either.
        notificationSoundsTableView.rowHeight = SettingsNotifsAlarmsNotificationSoundTVC.cellHeight
        
        synchronizeValues(animated: false)
    }
    
    // MARK: - Functions
    
    /// Updates the displayed isEnabled to reflect the state of isNotificationEnabled stored.
    func synchronizeIsEnabled() {
        notificationSoundsTableView.isUserInteractionEnabled = UserConfiguration.isNotificationEnabled
    }
    
    /// Updates the displayed values to reflect the values stored.
    func synchronizeValues(animated: Bool) {
        synchronizeIsEnabled()
        
        // set all cells to unselected
        for cellRow in 0..<NotificationSound.allCases.count {
            let cellIndexPath = IndexPath(row: cellRow, section: 0)
            let cell = notificationSoundsTableView.cellForRow(at: cellIndexPath) as? SettingsNotifsAlarmsNotificationSoundTVC
            cell?.setCustomSelectedTableViewCell(false, animated: true)
        }
        
        // set user configuration notification sound cell to selected
        guard let currentNotificationSoundCellRow = NotificationSound.allCases.firstIndex(of: UserConfiguration.notificationSound) else {
            return
        }
        let currentNotificationSoundCellIndexPath = IndexPath(row: currentNotificationSoundCellRow, section: 0)
        let currentNotificationSoundCell = notificationSoundsTableView.cellForRow(at: currentNotificationSoundCellIndexPath) as? SettingsNotifsAlarmsNotificationSoundTVC
        currentNotificationSoundCell?.setCustomSelectedTableViewCell(true, animated: true)
    }
    
    // MARK: - Table View Data Source
    
    func numberOfSections(in tableView: UITableView) -> Int {
        1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        NotificationSound.allCases.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        guard let cell = notificationSoundsTableView.dequeueReusableCell(withIdentifier: SettingsNotifsAlarmsNotificationSoundTVC.reuseIdentifier, for: indexPath) as? SettingsNotifsAlarmsNotificationSoundTVC else {
            return GeneralUITableViewCell()
        }
        
        let notificationSound = NotificationSound.allCases[indexPath.row]
        
        cell.setup(forNotificationSound: notificationSound == NotificationSound.radar ? "Radar (Default)" : notificationSound.rawValue)
        cell.setCustomSelectedTableViewCell(notificationSound == UserConfiguration.notificationSound, animated: false)
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        guard let selectedCell = notificationSoundsTableView.cellForRow(at: indexPath) as? SettingsNotifsAlarmsNotificationSoundTVC,
              let currentNotificationSoundIndex = NotificationSound.allCases.firstIndex(of: UserConfiguration.notificationSound) else {
            // we need the selected cell and current notification sound index before we proceed
            AudioManager.stopAudio()
            return
        }
        
        let selectedNotificationSound = NotificationSound.allCases[indexPath.row]
        
        guard selectedNotificationSound != UserConfiguration.notificationSound else {
            // cell selected is the same as the current sound saved, toggle the audio
            if AudioManager.isPlaying {
                AudioManager.stopAudio()
            }
            else {
                AudioManager.playAudio(forAudioPath: "\(UserConfiguration.notificationSound.rawValue.lowercased())")
            }
            
            return
        }
        
        // the new cell selected is different that the current sound saved
        
        // find the current notification sound cell and unselect it, as the user just selected a new one
        let currentNotificationSoundIndexPath = IndexPath(row: currentNotificationSoundIndex, section: 0)
        let currentNotificationSoundCell = notificationSoundsTableView.cellForRow(at: currentNotificationSoundIndexPath) as? SettingsNotifsAlarmsNotificationSoundTVC
        currentNotificationSoundCell?.setCustomSelectedTableViewCell(false, animated: true)
        
        // highlight the new selected cell
        selectedCell.setCustomSelectedTableViewCell(true, animated: true)
        
        // leave this code right here, don't move below or its value will be incorrect
        let beforeUpdateNotificationSound = UserConfiguration.notificationSound
        
        // assign user configuration to new value and play its audio
        UserConfiguration.notificationSound = selectedNotificationSound
        AudioManager.playAudio(forAudioPath: "\(UserConfiguration.notificationSound.rawValue.lowercased())")
        
        // contact server to attempt to persist change
        let body = [KeyConstant.userConfigurationNotificationSound.rawValue: UserConfiguration.notificationSound.rawValue]
        
        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.notificationSound = beforeUpdateNotificationSound
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(notificationSoundsTableView)
        contentView.addSubview(descriptionLabel)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel (top)
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelTrailing = headerLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        
        // notificationSoundsTableView (middle)
        let notificationSoundsTableViewTop = notificationSoundsTableView.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 5)
        let notificationSoundsTableViewLeading = notificationSoundsTableView.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor)
        let notificationSoundsTableViewTrailing = notificationSoundsTableView.trailingAnchor.constraint(equalTo: headerLabel.trailingAnchor)
        
        // descriptionLabel (bottom)
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: notificationSoundsTableView.bottomAnchor, constant: 5)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: headerLabel.trailingAnchor)
        
        NSLayoutConstraint.activate([
            // headerLabel
            headerLabelTop,
            headerLabelLeading,
            headerLabelTrailing,
            
            // notificationSoundsTableView
            notificationSoundsTableViewTop,
            notificationSoundsTableViewLeading,
            notificationSoundsTableViewTrailing,
            
            // descriptionLabel
            descriptionLabelTop,
            descriptionLabelBottom,
            descriptionLabelLeading,
            descriptionLabelTrailing
        ])
    }

}
//
//  SettingsNotifsAlarmsSnoozeLengthTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsSnoozeLengthTVC: GeneralUITableViewCell {

    // MARK: - Elements

    private let snoozeLengthDatePicker: GeneralUIDatePicker = {
        let datePicker = GeneralUIDatePicker(huggingPriority: 280, compressionResistancePriority: 280)
        datePicker.datePickerMode = .countDownTimer
        return datePicker
    }()
    
    // MARK: - Additional UI Elements
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Alarm Snooze"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.text = "If you snooze an alarm, this is the length of time until it sounds again."
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()

    @objc private func didUpdateSnoozeLength(_ sender: Any) {
        let beforeUpdateSnoozeLength = UserConfiguration.snoozeLength

        UserConfiguration.snoozeLength = snoozeLengthDatePicker.countDownDuration

        let body = [KeyConstant.userConfigurationSnoozeLength.rawValue: UserConfiguration.snoozeLength]
        
        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.snoozeLength = beforeUpdateSnoozeLength
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsAlarmsSnoozeLengthTVC"

    // MARK: - Main
        
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    // MARK: - Functions

    /// Updates the displayed isEnabled to reflect the state of isNotificationEnabled stored.
    func synchronizeIsEnabled() {
        snoozeLengthDatePicker.isEnabled = UserConfiguration.isNotificationEnabled
    }

    /// Updates the displayed values to reflect the values stored.
    func synchronizeValues(animated: Bool) {
        synchronizeIsEnabled()

        snoozeLengthDatePicker.countDownDuration = UserConfiguration.snoozeLength

        // fixes issue with first time datepicker updates not triggering function
        DispatchQueue.main.asyncAfter(deadline: .now()) {
            self.snoozeLengthDatePicker.countDownDuration = UserConfiguration.snoozeLength
        }
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(snoozeLengthDatePicker)
        contentView.addSubview(descriptionLabel)
        
        snoozeLengthDatePicker.addTarget(self, action: #selector(didUpdateSnoozeLength), for: .valueChanged)
    }

    override func setupConstraints() {
        super.setupConstraints()

        // headerLabel (top)
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelTrailing = headerLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // snoozeLengthDatePicker (middle)
        let snoozeLengthDatePickerTop = snoozeLengthDatePicker.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 5)
        let snoozeLengthDatePickerLeading = snoozeLengthDatePicker.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let snoozeLengthDatePickerTrailing = snoozeLengthDatePicker.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let snoozeLengthDatePickerHeight = snoozeLengthDatePicker.heightAnchor.constraint(equalTo: contentView.widthAnchor, multiplier: 120.0 / 414.0)

        // descriptionLabel (bottom)
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: snoozeLengthDatePicker.bottomAnchor, constant: 5)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        NSLayoutConstraint.activate([
            // headerLabel
            headerLabelTop,
            headerLabelLeading,
            headerLabelTrailing,

            // snoozeLengthDatePicker
            snoozeLengthDatePickerTop,
            snoozeLengthDatePickerLeading,
            snoozeLengthDatePickerTrailing,
            snoozeLengthDatePickerHeight,

            // descriptionLabel
            descriptionLabelTop,
            descriptionLabelBottom,
            descriptionLabelLeading,
            descriptionLabelTrailing
        ])
    }

}
//
//  SettingsNotifsAlarmsTableVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

private enum SettingsNotifsAlarmsTVCs: String, CaseIterable {
    case SettingsNotifsAlarmsLoudNotificationsTVC
    case SettingsNotifsAlarmsSnoozeLengthTVC
    case SettingsNotifsAlarmsNotificationSoundsTVC
}

final class SettingsNotifsAlarmsTableVC: GeneralUITableViewController {

    // MARK: - Main

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true

        let dummyTableTableHeaderViewHeight = 100.0
        // Adding a tableHeaderView prevents section headers from sticking and floating at the top of the page when we scroll up. This is because we are basically adding a large blank space to the top of the screen, allowing a space for the header to scroll into
        tableView.tableHeaderView = UIView(frame: CGRect(x: 0, y: 0, width: self.tableView.bounds.size.width, height: dummyTableTableHeaderViewHeight))
        tableView.contentInset = UIEdgeInsets(top: -dummyTableTableHeaderViewHeight, left: 0, bottom: 0, right: 0)
        tableView.separatorStyle = .none
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        AudioManager.stopAudio()
    }

    // MARK: - Functions

    /// Goes through all notification cells to synchronize their isEnabled to represent the state of isNotificationEnabled
    func synchronizeAllIsEnabled() {
        if let loudNotificationsRow = SettingsNotifsAlarmsTVCs.allCases.firstIndex(of: SettingsNotifsAlarmsTVCs.SettingsNotifsAlarmsLoudNotificationsTVC) {
            let loudNotificationsIndexPath = IndexPath(row: loudNotificationsRow, section: 0)
            if let loudNotificationsCell = tableView(tableView, cellForRowAt: loudNotificationsIndexPath) as? SettingsNotifsAlarmsLoudNotificationsTVC {
                loudNotificationsCell.synchronizeIsEnabled()
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [loudNotificationsIndexPath], with: .none)
            }
        }

        if let snoozeLengthRow = SettingsNotifsAlarmsTVCs.allCases.firstIndex(of: SettingsNotifsAlarmsTVCs.SettingsNotifsAlarmsSnoozeLengthTVC) {
            let snoozeLengthIndexPath = IndexPath(row: snoozeLengthRow, section: 0)
            if let snoozeLengthCell = tableView(tableView, cellForRowAt: snoozeLengthIndexPath) as? SettingsNotifsAlarmsSnoozeLengthTVC {
                snoozeLengthCell.synchronizeIsEnabled()
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [snoozeLengthIndexPath], with: .none)
            }
        }

        if let notificationSoundRow = SettingsNotifsAlarmsTVCs.allCases.firstIndex(of: SettingsNotifsAlarmsTVCs.SettingsNotifsAlarmsNotificationSoundsTVC) {
            let notificationSoundIndexPath = IndexPath(row: notificationSoundRow, section: 0)
            if let notificationSoundCell = tableView(tableView, cellForRowAt: notificationSoundIndexPath) as? SettingsNotifsAlarmsNotificationSoundsTVC {
                notificationSoundCell.synchronizeIsEnabled()
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [notificationSoundIndexPath], with: .none)
            }
        }

    }

    /// Goes through all notification cells to synchronize their values to represent what is stored
    func synchronizeAllValues(animated: Bool) {
        synchronizeAllIsEnabled()

        if let loudNotificationsRow = SettingsNotifsAlarmsTVCs.allCases.firstIndex(of: SettingsNotifsAlarmsTVCs.SettingsNotifsAlarmsLoudNotificationsTVC) {
            let loudNotificationsIndexPath = IndexPath(row: loudNotificationsRow, section: 0)
            if let loudNotificationsCell = tableView(tableView, cellForRowAt: loudNotificationsIndexPath) as? SettingsNotifsAlarmsLoudNotificationsTVC {
                loudNotificationsCell.synchronizeValues(animated: animated)
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [loudNotificationsIndexPath], with: .none)
            }
        }

        if let snoozeLengthRow = SettingsNotifsAlarmsTVCs.allCases.firstIndex(of: SettingsNotifsAlarmsTVCs.SettingsNotifsAlarmsSnoozeLengthTVC) {
            let snoozeLengthIndexPath = IndexPath(row: snoozeLengthRow, section: 0)
            if let snoozeLengthCell = tableView(tableView, cellForRowAt: snoozeLengthIndexPath) as? SettingsNotifsAlarmsSnoozeLengthTVC {
                snoozeLengthCell.synchronizeValues(animated: animated)
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [snoozeLengthIndexPath], with: .none)
            }
        }

        if let notificationSoundRow = SettingsNotifsAlarmsTVCs.allCases.firstIndex(of: SettingsNotifsAlarmsTVCs.SettingsNotifsAlarmsNotificationSoundsTVC) {
            let notificationSoundIndexPath = IndexPath(row: notificationSoundRow, section: 0)
            if let notificationSoundCell = tableView(tableView, cellForRowAt: notificationSoundIndexPath) as? SettingsNotifsAlarmsNotificationSoundsTVC {
                notificationSoundCell.synchronizeValues(animated: animated)
                // we have to reload the cell specifically to be able to see the changes
                tableView.reloadRows(at: [notificationSoundIndexPath], with: .none)
            }
        }
    }

    // MARK: - Table View Data Source

    override func numberOfSections(in tableView: UITableView) -> Int {
        1
    }

    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        SettingsNotifsAlarmsTVCs.allCases.count
    }

    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = SettingsNotifsTableHeaderV()

        headerView.setup(forTitle: "Alarms")

        return headerView
    }

    override func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        SettingsNotifsTableHeaderV.cellHeight
    }

    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        // We will be indexing SettingsNotifsCategoriesTVCs.allCases for the cell identifier, therefore make sure the cell is within a defined range
        guard indexPath.row < SettingsNotifsAlarmsTVCs.allCases.count else {
            return GeneralUITableViewCell()
        }

        let identifierCase = SettingsNotifsAlarmsTVCs.allCases[indexPath.row]
        let identifier = identifierCase.rawValue

        let cell = tableView.dequeueReusableCell(withIdentifier: identifier, for: indexPath)

        return cell
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        
    }

    override func setupConstraints() {
        super.setupConstraints()
        NSLayoutConstraint.activate([
        ])
        
    }
}
//
//  SettingsNotifsAlarmsLoudNotificationsTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsAlarmsLoudNotificationsTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    private let isLoudNotificationEnabledSwitch: GeneralUISwitch = {
        let uiSwitch = GeneralUISwitch(huggingPriority: 255, compressionResistancePriority: 255)
        uiSwitch.isOn = UserConfiguration.isNotificationEnabled
        return uiSwitch
    }()
    
    @objc private func didToggleIsLoudNotificationEnabled(_ sender: Any) {
        let beforeUpdateIsLoudNotificationEnabled = UserConfiguration.isLoudNotificationEnabled
        
        UserConfiguration.isLoudNotificationEnabled = isLoudNotificationEnabledSwitch.isOn
        
        let body = [KeyConstant.userConfigurationIsLoudNotificationEnabled.rawValue: UserConfiguration.isLoudNotificationEnabled]
        
        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.isLoudNotificationEnabled = beforeUpdateIsLoudNotificationEnabled
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    // MARK: - Additional UI Elements
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Loud Alarms"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsAlarmsLoudNotificationsTVC"
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        setup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Setup
    
    private func setup() {
        synchronizeValues(animated: false)
        
        let precalculatedDynamicTextColor = descriptionLabel.textColor
        
        descriptionLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            let message = NSMutableAttributedString(
                string: "Alarms will ring and repeatedly vibrate despite your phone being silenced, locked, or in focus mode. ",
                attributes: [
                    .font: VisualConstant.FontConstant.secondaryColorDescLabel,
                    .foregroundColor: precalculatedDynamicTextColor as Any
                ]
            )
            
            message.append(NSAttributedString(
                string: "If Hound is terminated, Loud Alarms will not work properly.",
                attributes: [
                    .font: VisualConstant.FontConstant.emphasizedSecondaryColorDescLabel,
                    .foregroundColor: precalculatedDynamicTextColor as Any
                ])
            )
            
            return message
        }
    }
    
    // MARK: - Functions
    
    /// Updates the displayed isEnabled to reflect the state of isNotificationEnabled stored.
    func synchronizeIsEnabled() {
        isLoudNotificationEnabledSwitch.isEnabled = UserConfiguration.isNotificationEnabled
    }
    
    /// Updates the displayed values to reflect the values stored.
    func synchronizeValues(animated: Bool) {
        synchronizeIsEnabled()
        
        isLoudNotificationEnabledSwitch.setOn(UserConfiguration.isLoudNotificationEnabled, animated: animated)
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(descriptionLabel)
        contentView.addSubview(isLoudNotificationEnabledSwitch)
        
        isLoudNotificationEnabledSwitch.addTarget(self, action: #selector(didToggleIsLoudNotificationEnabled), for: .valueChanged)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // isLoudNotificationEnabledSwitch
        let isLoudNotificationEnabledSwitchTop = isLoudNotificationEnabledSwitch.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let isLoudNotificationEnabledSwitchLeading = isLoudNotificationEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 10)
        let isLoudNotificationEnabledSwitchTrailing = isLoudNotificationEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -40)
        let isLoudNotificationEnabledSwitchCenterY = isLoudNotificationEnabledSwitch.centerYAnchor.constraint(equalTo: headerLabel.centerYAnchor)

        // headerLabel
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)

        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: isLoudNotificationEnabledSwitch.bottomAnchor, constant: 7.5)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        NSLayoutConstraint.activate([
            // Switch
            isLoudNotificationEnabledSwitchTop,
            isLoudNotificationEnabledSwitchLeading,
            isLoudNotificationEnabledSwitchTrailing,
            isLoudNotificationEnabledSwitchCenterY,

            // Header label
            headerLabelLeading,

            // Description label
            descriptionLabelTop,
            descriptionLabelBottom,
            descriptionLabelLeading,
            descriptionLabelTrailing
        ])
    }

}
//
//  SettingsNotifsSilentModeTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsSilentModeTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    private let isSilentModeEnabledSwitch: GeneralUISwitch = {
        let uiSwitch = GeneralUISwitch(huggingPriority: 300, compressionResistancePriority: 300)
        uiSwitch.isOn = UserConfiguration.isSilentModeEnabled
        
        return uiSwitch
    }()
    
    @objc private func didToggleIsSilentModeEnabled(_ sender: Any) {
        let beforeUpdateIsSilentModeEnabled = UserConfiguration.isSilentModeEnabled
        
        UserConfiguration.isSilentModeEnabled = isSilentModeEnabledSwitch.isOn
        
        let body = [KeyConstant.userConfigurationIsSilentModeEnabled.rawValue: UserConfiguration.isSilentModeEnabled]
        
        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.isSilentModeEnabled = beforeUpdateIsSilentModeEnabled
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    private let silentModeStartHoursDatePicker: GeneralUIDatePicker = {
        let datePicker = GeneralUIDatePicker()
        datePicker.datePickerMode = .time
        datePicker.minuteInterval = 5
        datePicker.preferredDatePickerStyle = .compact
        return datePicker
    }()
    
    @objc private func didUpdateSilentModeStartHours(_ sender: Any) {
        let beforeUpdateSilentModeStartUTCHour = UserConfiguration.silentModeStartUTCHour
        let beforeUpdateSilentModeStartUTCMinute = UserConfiguration.silentModeStartUTCMinute
        
        UserConfiguration.silentModeStartUTCHour = Calendar.UTCCalendar.component(.hour, from: silentModeStartHoursDatePicker.date)
        UserConfiguration.silentModeStartUTCMinute = Calendar.UTCCalendar.component(.minute, from: silentModeStartHoursDatePicker.date)
        
        let body = [KeyConstant.userConfigurationSilentModeStartUTCHour.rawValue: UserConfiguration.silentModeStartUTCHour,
                    KeyConstant.userConfigurationSilentModeStartUTCMinute.rawValue: UserConfiguration.silentModeStartUTCMinute]
        
        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.silentModeStartUTCHour = beforeUpdateSilentModeStartUTCHour
                UserConfiguration.silentModeStartUTCMinute = beforeUpdateSilentModeStartUTCMinute
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    private let silentModeEndHoursDatePicker: GeneralUIDatePicker = {
        let datePicker = GeneralUIDatePicker(huggingPriority: 240, compressionResistancePriority: 240)
        datePicker.datePickerMode = .time
        datePicker.minuteInterval = 5
        datePicker.preferredDatePickerStyle = .compact
        
        return datePicker
    }()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 300)
        label.text = "Silent Hours"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 230, compressionResistancePriority: 230)
        label.text = "Configure a time range where you won't recieve notifications (including alarms)."
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let timeRangeToLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 260, compressionResistancePriority: 260)
        label.text = "to"
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        return label
    }()
    
    @objc private func didUpdateSilentModeEndHours(_ sender: Any) {
        let beforeUpdateSilentModeEndUTCHour = UserConfiguration.silentModeEndUTCHour
        let beforeUpdateSilentModeEndUTCMinute = UserConfiguration.silentModeEndUTCMinute
        
        UserConfiguration.silentModeEndUTCHour = Calendar.UTCCalendar.component(.hour, from: silentModeEndHoursDatePicker.date)
        UserConfiguration.silentModeEndUTCMinute = Calendar.UTCCalendar.component(.minute, from: silentModeEndHoursDatePicker.date)
        
        let body = [KeyConstant.userConfigurationSilentModeEndUTCHour.rawValue: UserConfiguration.silentModeEndUTCHour,
                    KeyConstant.userConfigurationSilentModeEndUTCMinute.rawValue: UserConfiguration.silentModeEndUTCMinute]
        
        UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                // Revert local values to previous state due to an error
                UserConfiguration.silentModeEndUTCHour = beforeUpdateSilentModeEndUTCHour
                UserConfiguration.silentModeEndUTCMinute = beforeUpdateSilentModeEndUTCMinute
                self.synchronizeValues(animated: true)
                return
            }
        }
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsSilentModeTVC"
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    /// Updates the displayed isEnabled to reflect the state of isNotificationEnabled stored.
    func synchronizeIsEnabled() {
        isSilentModeEnabledSwitch.isEnabled = UserConfiguration.isNotificationEnabled
        
        silentModeStartHoursDatePicker.isEnabled = UserConfiguration.isNotificationEnabled
        
        silentModeEndHoursDatePicker.isEnabled = UserConfiguration.isNotificationEnabled
    }
    
    /// Updates the displayed values to reflect the values stored.
    func synchronizeValues(animated: Bool) {
        synchronizeIsEnabled()
        
        isSilentModeEnabledSwitch.setOn(UserConfiguration.isSilentModeEnabled, animated: animated)
        
        silentModeStartHoursDatePicker.setDate(
            Calendar.UTCCalendar.date(
                bySettingHour: UserConfiguration.silentModeStartUTCHour,
                minute: UserConfiguration.silentModeStartUTCMinute,
                second: 0, of: Date()) ?? Date(),
            animated: animated)
        
        silentModeEndHoursDatePicker.setDate(
            Calendar.UTCCalendar.date(
                bySettingHour: UserConfiguration.silentModeEndUTCHour,
                minute: UserConfiguration.silentModeEndUTCMinute,
                second: 0, of: Date()) ?? Date(),
            animated: animated)
        
        // fixes issue with first time datepicker updates not triggering function
        DispatchQueue.main.asyncAfter(deadline: .now()) {
            self.silentModeStartHoursDatePicker.setDate(
                Calendar.UTCCalendar.date(
                    bySettingHour: UserConfiguration.silentModeStartUTCHour,
                    minute: UserConfiguration.silentModeStartUTCMinute,
                    second: 0, of: Date()) ?? Date(),
                animated: animated)
            self.silentModeEndHoursDatePicker.setDate(
                Calendar.UTCCalendar.date(
                    bySettingHour: UserConfiguration.silentModeEndUTCHour,
                    minute: UserConfiguration.silentModeEndUTCMinute,
                    second: 0, of: Date()) ?? Date(),
                animated: animated)
        }
        
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(descriptionLabel)
        contentView.addSubview(silentModeStartHoursDatePicker)
        contentView.addSubview(timeRangeToLabel)
        contentView.addSubview(silentModeEndHoursDatePicker)
        contentView.addSubview(isSilentModeEnabledSwitch)
        
        isSilentModeEnabledSwitch.addTarget(self, action: #selector(didToggleIsSilentModeEnabled), for: .valueChanged)
        silentModeStartHoursDatePicker.addTarget(self, action: #selector(didUpdateSilentModeStartHours), for: .valueChanged)
        silentModeEndHoursDatePicker.addTarget(self, action: #selector(didUpdateSilentModeEndHours), for: .valueChanged)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelHeight = headerLabel.heightAnchor.constraint(equalToConstant: 25)
        
        // isSilentModeEnabledSwitch
        let isSilentModeEnabledSwitchLeading = isSilentModeEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 10)
        let isSilentModeEnabledSwitchTrailing = isSilentModeEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -40)
        let isSilentModeEnabledSwitchCenterY = isSilentModeEnabledSwitch.centerYAnchor.constraint(equalTo: headerLabel.centerYAnchor)
        
        // silentModeStartHoursDatePicker
        let silentModeStartHoursDatePickerTop = silentModeStartHoursDatePicker.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 20)
        let silentModeStartHoursDatePickerLeading = silentModeStartHoursDatePicker.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor)
        let silentModeStartHoursDatePickerWidth = silentModeStartHoursDatePicker.widthAnchor.constraint(equalTo: silentModeStartHoursDatePicker.heightAnchor, multiplier: 2.75)
        
        // timeRangeToLabel
        let timeRangeToLabelLeading = timeRangeToLabel.leadingAnchor.constraint(equalTo: silentModeStartHoursDatePicker.trailingAnchor, constant: 10)
        let timeRangeToLabelCenterY = timeRangeToLabel.centerYAnchor.constraint(equalTo: silentModeStartHoursDatePicker.centerYAnchor)
        let timeRangeToLabelHeight = timeRangeToLabel.heightAnchor.constraint(equalToConstant: 35)
        
        // silentModeEndHoursDatePicker
        let silentModeEndHoursDatePickerLeading = silentModeEndHoursDatePicker.leadingAnchor.constraint(equalTo: timeRangeToLabel.trailingAnchor, constant: 10)
        let silentModeEndHoursDatePickerTrailing = silentModeEndHoursDatePicker.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let silentModeEndHoursDatePickerCenterY = silentModeEndHoursDatePicker.centerYAnchor.constraint(equalTo: timeRangeToLabel.centerYAnchor)
        let silentModeEndHoursDatePickerWidth = silentModeEndHoursDatePicker.widthAnchor.constraint(equalTo: silentModeEndHoursDatePicker.heightAnchor, multiplier: 2.75)
        
        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: timeRangeToLabel.bottomAnchor, constant: 15)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor)
        let descriptionLabelTrailing = descriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        
        NSLayoutConstraint.activate([
            // headerLabel
            headerLabelTop, headerLabelLeading, headerLabelHeight,
            
            // isSilentModeEnabledSwitch
            isSilentModeEnabledSwitchLeading, isSilentModeEnabledSwitchTrailing, isSilentModeEnabledSwitchCenterY,
            
            // silentModeStartHoursDatePicker
            silentModeStartHoursDatePickerTop, silentModeStartHoursDatePickerLeading, silentModeStartHoursDatePickerWidth,
            
            // timeRangeToLabel
            timeRangeToLabelLeading, timeRangeToLabelCenterY, timeRangeToLabelHeight,
            
            // silentModeEndHoursDatePicker
            silentModeEndHoursDatePickerLeading, silentModeEndHoursDatePickerTrailing, silentModeEndHoursDatePickerCenterY, silentModeEndHoursDatePickerWidth,
            
            // descriptionLabel
            descriptionLabelTop, descriptionLabelLeading, descriptionLabelTrailing, descriptionLabelBottom
        ])
    }

}
//
//  SettingsNotifsUseNotificationsTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/24/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol SettingsNotifsUseNotificationsTVCDelegate: AnyObject {
    func didToggleIsNotificationEnabled()
}

final class SettingsNotifsUseNotificationsTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    private let isNotificationEnabledSwitch: GeneralUISwitch = {
        let uiSwitch = GeneralUISwitch(huggingPriority: 260, compressionResistancePriority: 260)
        
        uiSwitch.isOn = UserConfiguration.isNotificationEnabled
        
        return uiSwitch
    }()
    
    @objc private func didToggleIsNotificationEnabled(_ sender: Any) {
        let beforeUpdateIsNotificationEnabled = UserConfiguration.isNotificationEnabled
        
        UNUserNotificationCenter.current().getNotificationSettings { permission in
            // needed as  UNUserNotificationCenter.current().getNotificationSettings on other thread
            DispatchQueue.main.async {
                switch permission.authorizationStatus {
                case .authorized:
                    // even if we get .authorized, they doesn't mean the user wants to enabled notifications. the user could have authorized notifications months ago and now gone to this page to tap the switch, flipping it from on to off.
                    UserConfiguration.isNotificationEnabled.toggle()
                    
                    // the switch has been manually flicked by the user to invoke this, so don't call synchronizeValues as that would cause the switch to be animated for a second time
                    self.synchronizeUseNotificationsDescriptionLabel()
                    self.delegate?.didToggleIsNotificationEnabled()
                    
                    let body = [KeyConstant.userConfigurationIsNotificationEnabled.rawValue: UserConfiguration.isNotificationEnabled]
                    
                    UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
                        guard responseStatus != .failureResponse else {
                            // Revert local values to previous state due to an error
                            UserConfiguration.isNotificationEnabled = beforeUpdateIsNotificationEnabled
                            self.synchronizeValues(animated: true)
                            self.delegate?.didToggleIsNotificationEnabled()
                            return
                        }
                    }
                case .denied:
                    // nothing to update (as permissions denied) so we don't tell the server anything
                    
                    // Permission is denied, so we want to flip the switch back to its proper off position
                    let switchDisableTimer = Timer(fire: Date().addingTimeInterval(0.25), interval: -1, repeats: false) { _ in
                        self.synchronizeValues(animated: true)
                    }
                    
                    RunLoop.main.add(switchDisableTimer, forMode: .common)
                    
                    // Attempt to re-direct the user to their iPhone's settings for Hound, so they can enable notifications
                    guard let url = URL(string: UIApplication.openSettingsURLString), UIApplication.shared.canOpenURL(url) else {
                        // If we can't redirect the user, then just user a generic pop-up
                        PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.notificationsDisabledTitle, forSubtitle: VisualConstant.BannerTextConstant.notificationsDisabledSubtitle, forStyle: .danger)
                        return
                    }
                    
                    UIApplication.shared.open(url)
                case .notDetermined:
                    // don't advise the user if they want to turn on notifications. we already know that the user wants to turn on notification because they just toggle a switch to turn them on
                    NotificationPermissionsManager.requestNotificationAuthorization(shouldAdviseUserBeforeRequestingNotifications: false) {
                        // the request get notifications is complete
                        self.synchronizeValues(animated: true)
                        self.delegate?.didToggleIsNotificationEnabled()
                    }
                case .provisional:
                    AppDelegate.generalLogger.fault(".provisional")
                case .ephemeral:
                    AppDelegate.generalLogger.fault(".ephemeral")
                @unknown default:
                    AppDelegate.generalLogger.fault("@unknown notification authorization status")
                }
            }
        }
        
    }
    
    private let useNotificationsDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 240, compressionResistancePriority: 240)
        label.text = "Notifications help you stay up to date about the status of your dogs, reminders, and Hound family. "
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Use Notifications"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsUseNotificationsTVC"
    
    private weak var delegate: SettingsNotifsUseNotificationsTVCDelegate?
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        synchronizeValues(animated: false)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: SettingsNotifsUseNotificationsTVCDelegate) {
        self.delegate = forDelegate
    }
    
    // MARK: - Functions
    
    /// Updates the displayed values to reflect the values stored.
    func synchronizeValues(animated: Bool) {
        isNotificationEnabledSwitch.setOn(UserConfiguration.isNotificationEnabled, animated: animated)
        
        synchronizeUseNotificationsDescriptionLabel()
    }
    
    private func synchronizeUseNotificationsDescriptionLabel() {
        let dogCount = DogManager.globalDogManager?.dogs.count ?? 1
        
        let precalculatedDynamicNotificationsText = "Notifications help you stay up to date about both the status of your dog\(dogCount <= 1 ? "" : "s") and Hound family. "
        let precalculatedDynamicTextColor = useNotificationsDescriptionLabel.textColor
        let precaulculatedDynamicIsNotificationsEnabled = UserConfiguration.isNotificationEnabled == false
        
        useNotificationsDescriptionLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            let message = NSMutableAttributedString(
                string: precalculatedDynamicNotificationsText,
                attributes: [.font: VisualConstant.FontConstant.secondaryColorDescLabel, .foregroundColor: precalculatedDynamicTextColor as Any]
            )
            
            if precaulculatedDynamicIsNotificationsEnabled {
                message.append(NSMutableAttributedString(
                    string: "You can't modify the settings below until you enable notifications.",
                    attributes: [.font: VisualConstant.FontConstant.emphasizedSecondaryColorDescLabel, .foregroundColor: precalculatedDynamicTextColor as Any])
                )
            }
            
            return message
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(isNotificationEnabledSwitch)
        contentView.addSubview(useNotificationsDescriptionLabel)
        
        isNotificationEnabledSwitch.addTarget(self, action: #selector(didToggleIsNotificationEnabled), for: .valueChanged)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelCenterY = headerLabel.centerYAnchor.constraint(equalTo: isNotificationEnabledSwitch.centerYAnchor)
        let headerLabelHeight = headerLabel.heightAnchor.constraint(equalToConstant: 25)
        
        // isNotificationEnabledSwitch
        let isNotificationEnabledSwitchTop = isNotificationEnabledSwitch.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let isNotificationEnabledSwitchLeading = isNotificationEnabledSwitch.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 10)
        let isNotificationEnabledSwitchTrailing = isNotificationEnabledSwitch.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -40)
        
        // useNotificationsDescriptionLabel
        let useNotificationsDescriptionLabelTop = useNotificationsDescriptionLabel.topAnchor.constraint(equalTo: isNotificationEnabledSwitch.bottomAnchor, constant: 7.5)
        let useNotificationsDescriptionLabelLeading = useNotificationsDescriptionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let useNotificationsDescriptionLabelTrailing = useNotificationsDescriptionLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let useNotificationsDescriptionLabelBottom = useNotificationsDescriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        
        NSLayoutConstraint.activate([
            // headerLabel
            headerLabelLeading, headerLabelCenterY, headerLabelHeight,
            
            // isNotificationEnabledSwitch
            isNotificationEnabledSwitchTop, isNotificationEnabledSwitchLeading, isNotificationEnabledSwitchTrailing,
            
            // useNotificationsDescriptionLabel
            useNotificationsDescriptionLabelTop, useNotificationsDescriptionLabelLeading,
            useNotificationsDescriptionLabelTrailing, useNotificationsDescriptionLabelBottom
        ])
    }

}
//
//  SettingsNotifsCategoriesTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsNotifsCategoriesTVC: GeneralUITableViewCell {
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Notification Categories"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.text = "By default, Hound will send notifications about your account, family, logs, and reminders."
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let chevonImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 300, compressionResistancePriority: 300)

        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = .systemGray4
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsNotifsCategoriesTVC"
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(headerLabel)
        contentView.addSubview(descriptionLabel)
        contentView.addSubview(chevonImageView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // headerLabel
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelHeight = headerLabel.heightAnchor.constraint(equalToConstant: 25)
        let headerLabelTrailing = headerLabel.trailingAnchor.constraint(equalTo: descriptionLabel.trailingAnchor)
        
        // chevonImageView
        let chevonImageViewLeading = chevonImageView.leadingAnchor.constraint(equalTo: headerLabel.trailingAnchor, constant: 5)
        let chevonImageViewTrailing = chevonImageView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let chevonImageViewCenterY = chevonImageView.centerYAnchor.constraint(equalTo: contentView.centerYAnchor)
        let chevonImageViewWidthByHeight = chevonImageView.widthAnchor.constraint(equalTo: chevonImageView.heightAnchor, multiplier: 1.0 / 1.5)
        let chevonImageViewWidthByHeader = chevonImageView.widthAnchor.constraint(equalTo: headerLabel.heightAnchor, multiplier: 20.0 / 25.0)
        chevonImageViewWidthByHeader.priority = .defaultHigh // Prevents conflict in rare cases
        
        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 7.5)
        let descriptionLabelBottom = descriptionLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor)
        // trailing is already linked via headerLabel.trailing
        
        NSLayoutConstraint.activate([
            // headerLabel
            headerLabelTop, headerLabelLeading, headerLabelHeight, headerLabelTrailing,
            
            // chevonImageView
            chevonImageViewLeading, chevonImageViewTrailing, chevonImageViewCenterY, chevonImageViewWidthByHeight, chevonImageViewWidthByHeader,
            
            // descriptionLabel
            descriptionLabelTop, descriptionLabelBottom, descriptionLabelLeading
        ])
    }

}
//
//  SettingsFamilyViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/16/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsFamilyViewController: GeneralUIViewController, UITableViewDelegate, UITableViewDataSource {
    
    // MARK: - Elements
    
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        scrollView.bounces = false
        scrollView.bouncesZoom = false
        
        return scrollView
    }()
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        
        return view
    }()
    
    private let pageHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 380, compressionResistancePriority: 380)
        label.text = "Family"
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        return label
    }()
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 360, compressionResistancePriority: 360)
        
        button.tintColor = .label
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        button.shouldRoundCorners = true
        button.shouldDismissParentViewController = true
        
        return button
    }()
    
    private let familyCodeHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let familyCodeDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        
        let activeSubscriptionNumberOfFamilyMembers = FamilyInformation.familyActiveSubscription.numberOfFamilyMembers
        let precalculatedDynamicTextColor = label.textColor
        
        label.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            let message: NSMutableAttributedString = NSMutableAttributedString(
                string: "The family code is the key your family. Have a prospective family member input the code above to join your family (case-insensitive).",
                attributes: [.font: VisualConstant.FontConstant.secondaryColorDescLabel, .foregroundColor: precalculatedDynamicTextColor as Any])
            
            // Add a disclaimer for the user that they
            if activeSubscriptionNumberOfFamilyMembers <= 1 {
                message.append(
                    NSAttributedString(
                        string: " Currently, your Hound plan is for individual use only. To add family members, try out a free trial of Hound+!",
                        attributes: [.font: VisualConstant.FontConstant.emphasizedSecondaryColorDescLabel, .foregroundColor: precalculatedDynamicTextColor as Any]
                    )
                )
            }
            
            return message
        }
        
        return label
    }()
    
    private let shareFamilyButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 230, compressionResistancePriority: 230)
        
        button.setTitle("Invite to Family", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderColor = .label
        button.borderWidth = 2
        button.shouldRoundCorners = true
        
        return button
    }()
    
    @objc private func didTouchUpInsideShareFamily(_ sender: Any) {
        guard let familyCode = familyCode else {
            return
        }
        
        ExportActivityViewManager.shareFamilyCode(forFamilyCode: familyCode)
    }
    
    private let membersHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.text = "Members"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let familyMembersTableView: GeneralUITableView = {
        let tableView = GeneralUITableView(huggingPriority: 240, compressionResistancePriority: 240)
        tableView.bounces = false
        tableView.isScrollEnabled = false
        tableView.bouncesZoom = false
        tableView.separatorStyle = .none
        tableView.backgroundColor = .systemBackground
        tableView.shouldAutomaticallyAdjustHeight = true
        tableView.borderWidth = 1
        tableView.borderColor = .label
        tableView.shouldRoundCorners = true
        return tableView
    }()
    
    private let leaveFamilyButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 230, compressionResistancePriority: 230)
        
        button.setTitle("Leave Family", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderColor = .label
        button.borderWidth = 2
        button.shouldRoundCorners = true
        
        return button
    }()
    
    private let leaveFamilyDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 220, compressionResistancePriority: 220)
        label.text = "Family members can freely join or leave families. The head can only leave by deleting the family, which requires all other members to leave first (or be kicked)."
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    @objc private func didTouchUpInsideLeaveFamily(_ sender: Any) {
        // We don't want to check the status of a family's subscription locally.
        // In order for a user to cancel a subscription, they must use Apple's subscription interface
        // This inherently doesn't update Hound, only the server.
        // Therefore the Hound app will always be outdated on this information.
        guard let leaveFamilyAlertController = leaveFamilyAlertController else {
            return
        }
        
        PresentationManager.enqueueAlert(leaveFamilyAlertController)
    }
    
    // MARK: - Properties
    
    private var leaveFamilyAlertController: UIAlertController?
    
    private var familyCode: String? {
        var familyCode = FamilyInformation.familyCode
        if let code = familyCode {
            familyCode?.insert("-", at: code.index(code.startIndex, offsetBy: 4))
        }
        return familyCode
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        self.familyMembersTableView.register(SettingsFamilyHeadTVC.self, forCellReuseIdentifier: SettingsFamilyHeadTVC.reuseIdentifier)
        self.familyMembersTableView.register(SettingsFamilyMemberTVC.self, forCellReuseIdentifier: SettingsFamilyMemberTVC.reuseIdentifier)
        self.familyMembersTableView.delegate = self
        self.familyMembersTableView.dataSource = self
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        repeatableSetup()
    }
    
    // MARK: - Functions
    
    /// These properties can be reassigned. Does not reload anything, rather just configures.
    private func repeatableSetup() {
        
        // MARK: Family Code
        familyCodeHeaderLabel.text = "Code: \(familyCode ?? "NO CODE⚠️")"
        
        // MARK: Family Members
        
        familyMembersTableView.allowsSelection = UserInformation.isUserFamilyHead
        
        // MARK: Leave Family Button
        
        let leaveFamilyAlertController = UIAlertController(title: "placeholder", message: nil, preferredStyle: .alert)
        
        // user is not the head of the family, so the button is enabled for them
        if UserInformation.isUserFamilyHead == false {
            leaveFamilyButton.isEnabled = true
            
            leaveFamilyButton.setTitle("Leave Family", for: .normal)
            
            leaveFamilyAlertController.title = "Are you sure you want to leave your family?"
            let leaveAlertAction = UIAlertAction(title: "Leave Family", style: .destructive) { _ in
                PresentationManager.beginFetchingInformationIndicator()
                FamilyRequest.delete(forErrorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                    PresentationManager.endFetchingInformationIndicator {
                        guard responseStatus == .successResponse else {
                            return
                        }
                        
                        // family was successfully left, revert to server sync view controller
                        self.dismissToViewController(ofClass: ServerSyncViewController.self, completionHandler: nil)
                    }
                }
            }
            leaveFamilyAlertController.addAction(leaveAlertAction)
        }
        // user is the head of the family, further checks needed
        else {
            // user must kicked other members before they can destroy their family
            leaveFamilyButton.isEnabled = FamilyInformation.familyMembers.count == 1
            leaveFamilyButton.setTitle("Delete Family", for: .normal)
            
            leaveFamilyAlertController.title = "Are you sure you want to delete your family?"
            
            let deleteAlertAction = UIAlertAction(title: "Delete Family", style: .destructive) { _ in
                PresentationManager.beginFetchingInformationIndicator()
                FamilyRequest.delete(forErrorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                    PresentationManager.endFetchingInformationIndicator {
                        guard responseStatus == .successResponse else {
                            return
                        }
                        // family was successfully deleted, revert to server sync view controller
                        self.dismissToViewController(ofClass: ServerSyncViewController.self, completionHandler: nil)
                    }
                }
            }
            leaveFamilyAlertController.addAction(deleteAlertAction)
        }
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
        leaveFamilyAlertController.addAction(cancelAlertAction)
        self.leaveFamilyAlertController = leaveFamilyAlertController
    }
    
    // MARK: - Table View Data Source
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return FamilyInformation.familyMembers.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        guard let familyMember = FamilyInformation.familyMembers.safeIndex(indexPath.row) else {
            return GeneralUITableViewCell()
        }
        
        let cell = indexPath.row == 0
        ? tableView.dequeueReusableCell(withIdentifier: SettingsFamilyHeadTVC.reuseIdentifier, for: indexPath)
        : tableView.dequeueReusableCell(withIdentifier: SettingsFamilyMemberTVC.reuseIdentifier, for: indexPath)
        
        if let cell = cell as? SettingsFamilyHeadTVC {
            cell.setup(forDisplayFullName: familyMember.displayFullName ?? VisualConstant.TextConstant.unknownName)
            cell.containerView.roundCorners(setCorners: .all)
        }
        
        if let cell = cell as? SettingsFamilyMemberTVC {
            cell.setup(forDisplayFullName: familyMember.displayFullName ?? VisualConstant.TextConstant.unknownName)
            cell.containerView.roundCorners(setCorners: .none)
        }
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        self.familyMembersTableView.deselectRow(at: indexPath, animated: true)
        // the first row is the family head who should be able to be selected
        guard indexPath.row != 0 else {
            return
        }
        
        // construct the alert controller which will confirm if the user wants to kick the family member
        let familyMember = FamilyInformation.familyMembers[indexPath.row]
        let kickFamilyMemberAlertController = UIAlertController(title: "Do you want to kick \(familyMember.displayFullName ?? VisualConstant.TextConstant.unknownName) from your family?", message: nil, preferredStyle: .alert)
        
        let kickAlertAction = UIAlertAction(title: "Kick \(familyMember.displayFullName ?? VisualConstant.TextConstant.unknownName)", style: .destructive) { _ in
            // the user wants to kick the family member so query the server
            let body = [KeyConstant.familyKickUserId.rawValue: familyMember.userId]
            PresentationManager.beginFetchingInformationIndicator()
            FamilyRequest.delete(forErrorAlert: .automaticallyAlertForAll, forBody: body) { responseStatusFamilyDelete, _ in
                PresentationManager.endFetchingInformationIndicator {
                    guard responseStatusFamilyDelete == .successResponse else {
                        return
                    }
                    
                    // Refresh this page
                    FamilyRequest.get(forErrorAlert: .automaticallyAlertForAll) { responseStatusFamilyGet, _ in
                        guard responseStatusFamilyGet == .successResponse else {
                            return
                        }
                        
                        self.repeatableSetup()
                        self.familyMembersTableView.reloadData()
                        // its possible that the familymembers table changed its constraint for height, so re-layout
                        self.view.setNeedsLayout()
                        self.view.layoutIfNeeded()
                    }
                }
            }
        }
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
        
        kickFamilyMemberAlertController.addAction(kickAlertAction)
        kickFamilyMemberAlertController.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(kickFamilyMemberAlertController)
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        scrollView.addSubview(containerView)
        containerView.addSubview(familyMembersTableView)
        containerView.addSubview(familyCodeHeaderLabel)
        containerView.addSubview(familyCodeDescriptionLabel)
        containerView.addSubview(leaveFamilyButton)
        containerView.addSubview(leaveFamilyDescriptionLabel)
        containerView.addSubview(backButton)
        containerView.addSubview(pageHeaderLabel)
        containerView.addSubview(shareFamilyButton)
        containerView.addSubview(membersHeaderLabel)
        
        shareFamilyButton.addTarget(self, action: #selector(didTouchUpInsideShareFamily), for: .touchUpInside)
        leaveFamilyButton.addTarget(self, action: #selector(didTouchUpInsideLeaveFamily), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // scrollView
        NSLayoutConstraint.activate([
            scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            scrollView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            scrollView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
            scrollView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        ])
        
        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: scrollView.topAnchor),
            containerView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
            containerView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
            containerView.widthAnchor.constraint(equalTo: scrollView.widthAnchor)
        ])
        
        // pageHeaderLabel
        NSLayoutConstraint.activate([
            pageHeaderLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: ConstraintConstant.Global.contentVertInset),
            pageHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            pageHeaderLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.PageHeader.labelMaxHeight),
            pageHeaderLabel.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.PageHeader.labelHeightMultipler ).withPriority(.defaultHigh)
        ])
        
        // backButton
        NSLayoutConstraint.activate([
            backButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: ConstraintConstant.Button.miniCircleInset),
            backButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Button.miniCircleInset),
            backButton.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.Button.miniCircleHeightMultiplier).withPriority(.defaultHigh),
            backButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.miniCircleMaxHeight),
            backButton.createSquareConstraint()
        ])
        
        // familyCodeHeaderLabel
        NSLayoutConstraint.activate([
            familyCodeHeaderLabel.topAnchor.constraint(equalTo: pageHeaderLabel.bottomAnchor, constant: ConstraintConstant.PageHeader.vertSpacingToSection),
            familyCodeHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            familyCodeHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            familyCodeHeaderLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.sectionTitleMaxHeight),
            familyCodeHeaderLabel.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.Section.sectionTitleHeightMultipler ).withPriority(.defaultHigh)
        ])
        
        // familyCodeDescriptionLabel
        NSLayoutConstraint.activate([
            familyCodeDescriptionLabel.topAnchor.constraint(equalTo: familyCodeHeaderLabel.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing),
            familyCodeDescriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            familyCodeDescriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])
        
        // shareFamilyButton
        NSLayoutConstraint.activate([
            shareFamilyButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            shareFamilyButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            shareFamilyButton.heightAnchor.constraint(equalTo: shareFamilyButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            shareFamilyButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight),
            shareFamilyButton.topAnchor.constraint(equalTo: familyCodeDescriptionLabel.bottomAnchor, constant: 25.0)
        ])
        
        // membersHeaderLabel
        NSLayoutConstraint.activate([
            membersHeaderLabel.topAnchor.constraint(equalTo: shareFamilyButton.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing),
            membersHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            membersHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            membersHeaderLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.sectionTitleMaxHeight),
            membersHeaderLabel.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.Section.sectionTitleHeightMultipler).withPriority(.defaultHigh)
        ])
        
        // familyMembersTableView
        NSLayoutConstraint.activate([
            familyMembersTableView.topAnchor.constraint(equalTo: membersHeaderLabel.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing),
            familyMembersTableView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            familyMembersTableView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])
        
        // leaveFamilyButton
        NSLayoutConstraint.activate([
            leaveFamilyButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            leaveFamilyButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            leaveFamilyButton.heightAnchor.constraint(equalTo: shareFamilyButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            leaveFamilyButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight),
            leaveFamilyButton.topAnchor.constraint(equalTo: familyMembersTableView.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing)
        ])
        
        NSLayoutConstraint.activate([
            leaveFamilyDescriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            leaveFamilyDescriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            leaveFamilyDescriptionLabel.topAnchor.constraint(equalTo: leaveFamilyButton.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing),
            leaveFamilyDescriptionLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -ConstraintConstant.Global.contentVertInset)
        ])
    }
    
}
//
//  SettingsFamilyHeadTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/5/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsFamilyHeadTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    // public so corners can be rounded
    let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBlue
        return view
    }()
    
    private let iconView: GeneralUIImageView = {
        let iconView = GeneralUIImageView()
        
        iconView.image = UIImage(systemName: "crown")
        iconView.tintColor = .systemBackground
        
        return iconView
    }()
    
    private let displayFullNameLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        label.textColor = .systemBackground
        return label
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsFamilyHeadTVC"
    
    // MARK: - Setup
    
    func setup(forDisplayFullName displayFullName: String) {
        displayFullNameLabel.text = displayFullName
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(iconView)
        containerView.addSubview(displayFullNameLabel)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        let inset: CGFloat = 5
        let iconSize: CGFloat = 50
        
        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor)
        ])
        
        // iconView
        NSLayoutConstraint.activate([
            iconView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: inset),
            iconView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -inset),
            iconView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: inset),
            iconView.createSquareConstraint(),
            iconView.heightAnchor.constraint(equalToConstant: iconSize)
        ])
        
        // displayFullNameLabel
        NSLayoutConstraint.activate([
            displayFullNameLabel.centerYAnchor.constraint(equalTo: iconView.centerYAnchor),
            displayFullNameLabel.heightAnchor.constraint(equalTo: iconView.heightAnchor),
            displayFullNameLabel.leadingAnchor.constraint(equalTo: iconView.trailingAnchor, constant: inset),
            displayFullNameLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -inset)
        ])
    }

}
//
//  SettingsFamilyMemberTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/5/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SettingsFamilyMemberTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        return view
    }()
    
    private let displayFullNameLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.font = VisualConstant.FontConstant.emphasizedSecondaryHeaderLabel
        return label
    }()
    
    private var chevronLeadingConstraint: GeneralLayoutConstraint!
    private var chevronTrailingConstraint: GeneralLayoutConstraint!
    private let chevonImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 285, compressionResistancePriority: 285)
        
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = .systemGray4
        
        return imageView
    }()
    
    private let iconView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 290, compressionResistancePriority: 290)

        imageView.image = UIImage(systemName: "person.fill")
        imageView.tintColor = .label
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "SettingsFamilyMemberTVC"
    
    // MARK: - Setup
    
    func setup(forDisplayFullName displayFullName: String) {
        displayFullNameLabel.text = displayFullName
        
        // if the user is not the family head, that means the cell should not be selectable nor should we show the chevron that indicates selectability
        isUserInteractionEnabled = UserInformation.isUserFamilyHead
        
        if UserInformation.isUserFamilyHead {
            chevonImageView.isHidden = false
            chevronLeadingConstraint.restore()
            chevronTrailingConstraint.restore()
        }
        else {
            chevonImageView.isHidden = true
            chevronLeadingConstraint.constant = 0.0
            chevronTrailingConstraint.constant = 0.0
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        contentView.backgroundColor = .secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(iconView)
        containerView.addSubview(chevonImageView)
        containerView.addSubview(displayFullNameLabel)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        let chevronInset: CGFloat = 7.5
        let iconSize: CGFloat = 30
        
        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor)
        ])
        
        // iconView
        NSLayoutConstraint.activate([
            iconView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: ConstraintConstant.Global.contentVertInset),
            iconView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -ConstraintConstant.Global.contentVertInset),
            iconView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            iconView.widthAnchor.constraint(equalTo: iconView.heightAnchor),
            iconView.heightAnchor.constraint(equalToConstant: iconSize)
        ])
        
        // displayFullNameLabel
        NSLayoutConstraint.activate([
            displayFullNameLabel.centerYAnchor.constraint(equalTo: iconView.centerYAnchor),
            displayFullNameLabel.heightAnchor.constraint(equalTo: iconView.heightAnchor),
            displayFullNameLabel.leadingAnchor.constraint(equalTo: iconView.trailingAnchor, constant: ConstraintConstant.Global.intraContentHoriInset)
        ])
        
        // chevonImageView
        chevronLeadingConstraint = GeneralLayoutConstraint(wrapping: chevonImageView.leadingAnchor.constraint(equalTo: displayFullNameLabel.trailingAnchor, constant: ConstraintConstant.Global.intraContentHoriInset))
        chevronTrailingConstraint = GeneralLayoutConstraint(wrapping: containerView.trailingAnchor.constraint(equalTo: chevonImageView.trailingAnchor, constant: chevronInset))
        NSLayoutConstraint.activate([
            chevronLeadingConstraint.constraint,
            chevronTrailingConstraint.constraint,
            chevonImageView.centerYAnchor.constraint(equalTo: containerView.centerYAnchor),
            chevonImageView.widthAnchor.constraint(equalTo: chevonImageView.heightAnchor, multiplier: ConstraintConstant.Button.chevronWidthToHeighRatio),
            chevonImageView.widthAnchor.constraint(equalTo: iconView.heightAnchor, multiplier: 20 / 35)
        ])
    }

}
//
//  SettingsAccountViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/16/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol SettingsAccountViewControllerDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager)
}

final class SettingsAccountViewController: GeneralUIViewController {
    
    // MARK: - Elements
    
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        scrollView.bounces = false
        scrollView.bouncesZoom = false
        
        return scrollView
    }()
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        return view
    }()
    
    private let pageHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 355, compressionResistancePriority: 355)
        label.text = "Account"
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        return label
    }()
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 360, compressionResistancePriority: 360)
        
        button.tintColor = .label
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        
        button.shouldRoundCorners = true
        button.shouldDismissParentViewController = true
        return button
    }()
    
    private let userNameHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 350, compressionResistancePriority: 350)
        label.text = "Name"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let userNameLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 340, compressionResistancePriority: 340)
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let userEmailHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 320, compressionResistancePriority: 320)
        label.text = "Email"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let userEmailLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 310, compressionResistancePriority: 310)
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let copyUserEmailButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 330, compressionResistancePriority: 330)
        
        button.setImage(UIImage(systemName: "doc.on.clipboard"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        
        return button
    }()
    
    @objc private func didTapCopyUserEmail(_ sender: Any) {
        guard let userEmail = UserInformation.userEmail else {
            return
        }
        
        UIPasteboard.general.setPasteboard(forString: userEmail)
    }
    
    private let userIdHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Support ID"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let userIdLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let copyUserIdButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 300, compressionResistancePriority: 300)
        
        button.setImage(UIImage(systemName: "doc.on.clipboard"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        
        return button
    }()
    
    private let redownloadDataButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 270, compressionResistancePriority: 270)
       
        button.setTitle("Redownload Data", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderColor = .label
        button.borderWidth = 2
        button.shouldRoundCorners = true
        
        return button
    }()
    
    private let redownloadDataDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 260, compressionResistancePriority: 260)
        label.text = "Deletes local storage of all dogs, reminders, logs, and triggers to fully redownload them from the Hound server, ensuring that the data displayed locally reflects the data stored server-side."
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryColorDescLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let deleteAccountButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 270, compressionResistancePriority: 270)
        
        button.setTitle("Delete Account", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemRed
        
        button.shouldRoundCorners = true
        
        return button
    }()
    
    @objc private func didTapCopyUserId(_ sender: Any) {
        guard let userId = UserInformation.userId else {
            return
        }
        
        UIPasteboard.general.setPasteboard(forString: userId)
    }
    
    @objc private func didTapRedownloadData(_ sender: Any) {
        PresentationManager.beginFetchingInformationIndicator()
        
        // store the date of our old sync if the request fails (as we will be overriding the typical way of doing it)
        let currentUserConfigurationPreviousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization
        // manually set previousDogManagerSynchronization to default value so we will retrieve everything from the server
        LocalConfiguration.previousDogManagerSynchronization = nil
        
        DogsRequest.get(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogManager: DogManager()) { dogManager, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                guard responseStatus != .failureResponse, let dogManager = dogManager else {
                    // Revert previousDogManagerSynchronization previous value. This is necessary as we circumvented the DogsRequest automatic handling of it to allow us to retrieve all entries.
                    LocalConfiguration.previousDogManagerSynchronization = currentUserConfigurationPreviousDogManagerSynchronization
                    return
                }
                
                if responseStatus == .successResponse {
                    PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.successRedownloadDataTitle, forSubtitle: VisualConstant.BannerTextConstant.successRedownloadDataSubtitle, forStyle: .success)
                }
                else {
                    if OfflineModeManager.shared.hasDisplayedOfflineModeBanner == true {
                        // If OfflineModeManager has displayed its banner that indicates its turning on, then we are safe to display this banner. Otherwise, we would run the risk of both of these banners displaying if its the first time enterin offline mode.
                        PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.infoRedownloadOnHoldTitle, forSubtitle: VisualConstant.BannerTextConstant.infoRedownloadOnHoldSubtitle, forStyle: .info)
                    }
                }
                
                // successful query to fully redownload the dogManager, no need to mess with previousDogManagerSynchronization as that is automatically handled
                self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: dogManager)
            }
        }
    }
    
    @objc private func didTapDeleteAccount(_ sender: Any) {
        
        let deleteAccountAlertController = UIAlertController(title: "Are you sure you want to delete your account?", message: nil, preferredStyle: .alert)
        
        let deleteAlertAction = UIAlertAction(title: "Delete Account", style: .destructive) { _ in
            PresentationManager.beginFetchingInformationIndicator()
            
            UserRequest.delete(forErrorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                PresentationManager.endFetchingInformationIndicator {
                    guard responseStatus == .successResponse else {
                        return
                    }
                    
                    // family was successfully deleted, revert to server sync view controller
                    self.dismissToViewController(ofClass: ServerSyncViewController.self, completionHandler: nil)
                }
            }
        }
        deleteAccountAlertController.addAction(deleteAlertAction)
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
        deleteAccountAlertController.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(deleteAccountAlertController)
    }
    
    // MARK: - Properties
    
    private weak var delegate: SettingsAccountViewControllerDelegate?
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .pageSheet
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
       
        userNameLabel.text = UserInformation.displayFullName
        
        userEmailLabel.text = UserInformation.userEmail ?? VisualConstant.TextConstant.unknownEmail
        copyUserEmailButton.isEnabled = UserInformation.userEmail != nil
        
        userIdLabel.text = UserInformation.userId ?? VisualConstant.TextConstant.unknownUserId
        copyUserIdButton.isEnabled = UserInformation.userId != nil
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: SettingsAccountViewControllerDelegate) {
        self.delegate = forDelegate
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        scrollView.addSubview(containerView)
        containerView.addSubview(userNameHeaderLabel)
        containerView.addSubview(userNameLabel)
        containerView.addSubview(userEmailHeaderLabel)
        containerView.addSubview(redownloadDataButton)
        containerView.addSubview(redownloadDataDescriptionLabel)
        containerView.addSubview(userEmailLabel)
        containerView.addSubview(userIdHeaderLabel)
        containerView.addSubview(userIdLabel)
        containerView.addSubview(copyUserIdButton)
        containerView.addSubview(copyUserEmailButton)
        containerView.addSubview(deleteAccountButton)
        containerView.addSubview(backButton)
        containerView.addSubview(pageHeaderLabel)
        
        redownloadDataButton.addTarget(self, action: #selector(didTapRedownloadData), for: .touchUpInside)
        copyUserIdButton.addTarget(self, action: #selector(didTapCopyUserId), for: .touchUpInside)
        copyUserEmailButton.addTarget(self, action: #selector(didTapCopyUserEmail), for: .touchUpInside)
        deleteAccountButton.addTarget(self, action: #selector(didTapDeleteAccount), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // scrollView
        NSLayoutConstraint.activate([
            scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            scrollView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            scrollView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
            scrollView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        ])

        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: scrollView.topAnchor),
            containerView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
            containerView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
            containerView.widthAnchor.constraint(equalTo: scrollView.widthAnchor)
        ])
        
        // pageHeaderLabel
        NSLayoutConstraint.activate([
            pageHeaderLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: ConstraintConstant.Global.contentVertInset),
            pageHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            pageHeaderLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.PageHeader.labelMaxHeight),
            pageHeaderLabel.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.PageHeader.labelHeightMultipler ).withPriority(.defaultHigh)
        ])
        
        // backButton
        NSLayoutConstraint.activate([
            backButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: ConstraintConstant.Button.miniCircleInset),
            backButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Button.miniCircleInset),
            backButton.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.Button.miniCircleHeightMultiplier).withPriority(.defaultHigh),
            backButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.miniCircleMaxHeight),
            backButton.createSquareConstraint()
        ])
        
        // userNameHeaderLabel constraints
        NSLayoutConstraint.activate([
            userNameHeaderLabel.topAnchor.constraint(equalTo: pageHeaderLabel.bottomAnchor, constant: ConstraintConstant.PageHeader.vertSpacingToSection),
            userNameHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            userNameHeaderLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            userNameHeaderLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.sectionTitleMaxHeight),
            userNameHeaderLabel.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.Section.sectionTitleHeightMultipler ).withPriority(.defaultHigh)
        ])
        
        // userNameLabel constraints
        NSLayoutConstraint.activate([
            userNameLabel.topAnchor.constraint(equalTo: userNameHeaderLabel.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing),
            userNameLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            userNameLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])
        
        // userEmailHeaderLabel constraints
        NSLayoutConstraint.activate([
            userEmailHeaderLabel.topAnchor.constraint(equalTo: userNameLabel.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing),
            userEmailHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            userEmailHeaderLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.sectionTitleMaxHeight),
            userEmailHeaderLabel.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.Section.sectionTitleHeightMultipler ).withPriority(.defaultHigh)
        ])
        
        // copyUserEmailButton
        NSLayoutConstraint.activate([
            copyUserEmailButton.centerYAnchor.constraint(equalTo: userEmailHeaderLabel.centerYAnchor),
            copyUserEmailButton.leadingAnchor.constraint(equalTo: userEmailHeaderLabel.trailingAnchor, constant: ConstraintConstant.Global.intraContentHoriInset),
            copyUserEmailButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -2.0 * ConstraintConstant.Global.contentHoriInset),
            copyUserEmailButton.heightAnchor.constraint(equalTo: userEmailHeaderLabel.heightAnchor, multiplier: 1.5),
            copyUserEmailButton.createSquareConstraint()
        ])
        
        // userEmailLabel constraints
        NSLayoutConstraint.activate([
            userEmailLabel.topAnchor.constraint(equalTo: userEmailHeaderLabel.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing),
            userEmailLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            userEmailLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])
        
        // userIdHeaderLabel constraints
        NSLayoutConstraint.activate([
            userIdHeaderLabel.topAnchor.constraint(equalTo: userEmailLabel.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing),
            userIdHeaderLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            userIdHeaderLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.sectionTitleMaxHeight),
            userIdHeaderLabel.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.Section.sectionTitleHeightMultipler ).withPriority(.defaultHigh)
        ])
        
        // copyUserIdButton constraints
        NSLayoutConstraint.activate([
            copyUserIdButton.centerYAnchor.constraint(equalTo: userIdHeaderLabel.centerYAnchor),
            copyUserIdButton.leadingAnchor.constraint(equalTo: userIdHeaderLabel.trailingAnchor, constant: ConstraintConstant.Global.intraContentHoriInset),
            copyUserIdButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -2.0 * ConstraintConstant.Global.contentHoriInset),
            copyUserIdButton.heightAnchor.constraint(equalTo: userIdHeaderLabel.heightAnchor, multiplier: 1.5),
            copyUserIdButton.createSquareConstraint()
        ])
        
        // userIdLabel constraints
        NSLayoutConstraint.activate([
            userIdLabel.topAnchor.constraint(equalTo: userIdHeaderLabel.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing),
            userIdLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            userIdLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])
        
        // redownloadDataButton constraints
        NSLayoutConstraint.activate([
            redownloadDataButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            redownloadDataButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            redownloadDataButton.heightAnchor.constraint(equalTo: redownloadDataButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            redownloadDataButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight),
            redownloadDataButton.topAnchor.constraint(equalTo: userIdLabel.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing)
        ])
        
        // redownloadDataDescriptionLabel constraints
        NSLayoutConstraint.activate([
            redownloadDataDescriptionLabel.topAnchor.constraint(equalTo: redownloadDataButton.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing),
            redownloadDataDescriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            redownloadDataDescriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])
        
        // deleteAccountButton constraints
        NSLayoutConstraint.activate([
            deleteAccountButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            deleteAccountButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            deleteAccountButton.heightAnchor.constraint(equalTo: deleteAccountButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            deleteAccountButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight),
            deleteAccountButton.topAnchor.constraint(equalTo: redownloadDataDescriptionLabel.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing),
            deleteAccountButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -ConstraintConstant.Global.contentVertInset)
        ])
        
    }

}
//
//  SettingsViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/5/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import StoreKit
import UIKit

protocol SettingsPagesTableViewControllerDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager)
}

final class SettingsPagesTableViewController: GeneralUITableViewController, SettingsAccountViewControllerDelegate, FamilyUpgradeIntroductionViewControllerDelegate {
    
    // MARK: - SettingsAccountViewControllerDelegate
    
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager) {
        delegate?.didUpdateDogManager(sender: Sender(origin: sender, localized: self), forDogManager: forDogManager)
    }
    
    // MARK: - FamilyUpgradeIntroductionViewControllerDelegate
    
    func didTouchUpInsideUpgrade() {
        SettingsSubscriptionViewController.fetchProductsThenGetViewController { vc in
            guard let vc = vc else {
                // Error message automatically handled
                return
            }
            
            PresentationManager.enqueueViewController(vc)
        }
    }
    
    // MARK: - Properties
    
    private weak var delegate: SettingsPagesTableViewControllerDelegate?
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        self.tableView.register(SettingsPagesTVC.self, forCellReuseIdentifier: SettingsPagesTVC.reuseIdentifier)
        tableView.separatorStyle = .none
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        // MARK: Introduction Page
        
        if LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController == false && FamilyInformation.familyActiveSubscription.productId == ClassConstant.SubscriptionConstant.defaultSubscription.productId {
            let vc = FamilyUpgradeIntroductionViewController()
            vc.setup(forDelegate: self)
            PresentationManager.enqueueViewController(vc)
        }
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: SettingsPagesTableViewControllerDelegate) {
        self.delegate = forDelegate
    }
    
    // MARK: - Table View Data Source
    
    override func numberOfSections(in tableView: UITableView) -> Int {
        2
    }
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        var numberOfRows = 0
        
        // We have two sections of settings pages, splitting them based upon whether they are a setting inside hound or a webpage we redirect the user two
        SettingsPages.allCases.forEach { settingsPage in
            switch settingsPage {
            case .account, .family, .subscription, .appearance, .notifications:
                numberOfRows += (section == 0 ? 1 : 0)
            case .website, .feedback, .support, .eula, .privacyPolicy, .termsAndConditions:
                numberOfRows += (section == 1 ? 1 : 0)
            }
        }
        
        return numberOfRows
    }
    
    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = GeneralHeaderView()
        
        headerView.setTitle(section == 0 ? "Preferences" : "Links")
        
        return headerView
    }
    
    override func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return GeneralHeaderView.cellHeight
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let settingsPage = SettingsPages.allCases.safeIndex((indexPath.section * 5) + indexPath.row)
        guard let settingsPage = settingsPage else {
            return GeneralUITableViewCell()
        }
        
        let settingsPagesTableViewCell = tableView.dequeueReusableCell(withIdentifier: SettingsPagesTVC.reuseIdentifier, for: indexPath) as? SettingsPagesTVC
        
        guard let settingsPagesTableViewCell = settingsPagesTableViewCell else {
            return GeneralUITableViewCell()
        }
        
        settingsPagesTableViewCell.setup(forPage: settingsPage)
        
        switch settingsPage {
        case .account:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .top)
        case .notifications:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .bottom)
        case .website:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .top)
        case .termsAndConditions:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .bottom)
        default:
            settingsPagesTableViewCell.containerView.roundCorners(setCorners: .none)
        }
        
        return settingsPagesTableViewCell
    }
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let settingsPagesTableViewCell = tableView.cellForRow(at: indexPath) as? SettingsPagesTVC
        
        guard let settingsPagesTableViewCell = settingsPagesTableViewCell, let page = settingsPagesTableViewCell.page else {
            return
        }
        
        switch page {
        case .account:
            let vc = SettingsAccountViewController()
            vc.setup(forDelegate: self)
            PresentationManager.enqueueViewController(vc)
        case .family:
            let vc = SettingsFamilyViewController()
            PresentationManager.enqueueViewController(vc)
        case .subscription:
            SettingsSubscriptionViewController.fetchProductsThenGetViewController { vc in
                guard let vc = vc else {
                    // Error message automatically handled
                    return
                }
                
                PresentationManager.enqueueViewController(vc)
            }
        case .appearance:
            let vc = SettingsAppearanceViewController()
            PresentationManager.enqueueViewController(vc)
        case .notifications:
            let vc = SettingsNotifsTableVC()
            PresentationManager.enqueueViewController(vc)
        case .website, .support, .eula, .privacyPolicy, .termsAndConditions:
            if let url = page.url {
                UIApplication.shared.open(url)
            }
        case .feedback:
            let vc = SurveyAppExperienceViewController()
            PresentationManager.enqueueViewController(vc)
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        tableView.backgroundColor = .secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
    }
    
    override func setupConstraints() {
        super.setupConstraints()
    }
}
//
//  HoundIntroductionDogNameView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/3/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol HoundIntroductionDogNameViewDelegate: AnyObject {
    func willContinue(forDogName: String?)
}

// UI VERIFIED
final class HoundIntroductionDogNameView: GeneralUIView, UITextFieldDelegate, UIGestureRecognizerDelegate {

    // MARK: - UITextFieldDelegate

    func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
        dogManager?.dogs.first == nil
    }

    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        self.dismissKeyboard()
        dogNameTextField.isEnabled = false
        continueButton.isEnabled = false
        delegate?.willContinue(forDogName: inputDogName)
        return false
    }

    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        guard let currentText = textField.text, let stringRange = Range(range, in: currentText) else {
            return true
        }
        let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
        return updatedText.count <= ClassConstant.DogConstant.dogNameCharacterLimit
    }

    // MARK: - UIGestureRecognizerDelegate

    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }

    // MARK: - Elements

    private let introductionView = IntroductionView()

    private let dogNameTextField: GeneralUITextField = {
        let textField = GeneralUITextField(huggingPriority: 350, compressionResistencePriority: 350)
        textField.placeholder = "Bella"
        textField.textAlignment = .center
        textField.backgroundColor = .systemBackground
        textField.borderWidth = 0.5
        textField.borderColor = .systemGray2
        textField.shouldRoundCorners = true
        return textField
    }()

    private let continueButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 290, compressionResistancePriority: 290)
        button.isEnabled = false
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        button.setTitle("Continue", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.backgroundColor = .systemBackground
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        return button
    }()

    private var mainStack: UIStackView!

    // MARK: - Properties

    private weak var delegate: HoundIntroductionDogNameViewDelegate?

    private var inputDogName: String? {
        guard dogManager?.dogs.first == nil else {
            return nil
        }
        let trimmedText = dogNameTextField.text?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        return trimmedText.isEmpty ? ClassConstant.DogConstant.defaultDogName : trimmedText
    }

    private var dogManager: DogManager?

    // MARK: - Setup

    func setup(forDelegate: HoundIntroductionDogNameViewDelegate, forDogManager: DogManager) {
        delegate = forDelegate
        dogManager = forDogManager

        dogNameTextField.delegate = self
        dogNameTextField.isEnabled = forDogManager.dogs.isEmpty
        continueButton.isEnabled = true

        introductionView.backgroundImageView.image = UIImage(named: "autumnParkFamilyWithDog")

        if let dog = forDogManager.dogs.first {
            introductionView.pageHeaderLabel.text = "We see you have a pack!"
            introductionView.pageDescriptionLabel.text = "You can manage \(dog.dogName)\(forDogManager.dogs.count > 1 ? " (and other dogs)" : "") on the next page"
            dogNameTextField.placeholder = dog.dogName
        }
        else {
            introductionView.pageHeaderLabel.text = "What is your dog's name?"
            introductionView.pageDescriptionLabel.text = "We will generate a basic dog for you"
            dogNameTextField.placeholder = ClassConstant.DogConstant.defaultDogName
            dismissKeyboardOnTap(delegate: self)
        }
    }

    // MARK: - Functions

    @objc private func didTouchUpInsideContinue(_ sender: Any) {
        self.dismissKeyboard()
        dogNameTextField.isEnabled = false
        continueButton.isEnabled = false
        delegate?.willContinue(forDogName: inputDogName)
    }

    // MARK: - Setup Elements

    override func setupGeneratedViews() {
        self.backgroundColor = .systemBackground
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        addSubview(introductionView)

        mainStack = UIStackView(arrangedSubviews: [dogNameTextField, continueButton])
        mainStack.axis = .vertical
        mainStack.spacing = ConstraintConstant.Section.interSectionVertSpacing
        mainStack.translatesAutoresizingMaskIntoConstraints = false

        introductionView.contentView.addSubview(mainStack)

        continueButton.addTarget(self, action: #selector(didTouchUpInsideContinue), for: .touchUpInside)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: bottomAnchor),

            mainStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            mainStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            mainStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            mainStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor),
            
            dogNameTextField.heightAnchor.constraint(equalTo: continueButton.heightAnchor),

            continueButton.heightAnchor.constraint(equalTo: continueButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            continueButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight)
        ])
    }
}
//
//  HoundIntroductionDogIconView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol HoundIntroductionDogIconViewDelegate: AnyObject {
    func willFinish(forDogIcon: UIImage?)
}

// UI VERIFIED
final class HoundIntroductionDogIconView: GeneralUIView, UIImagePickerControllerDelegate, UINavigationControllerDelegate {

    // MARK: - UIImagePickerControllerDelegate

    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
        if let dogIcon = DogIconManager.processDogIcon(forInfo: info) {
            dogIconButton.setTitle(nil, for: .normal)
            dogIconButton.setImage(dogIcon, for: .normal)
        }
        picker.dismiss(animated: true)
    }

    // MARK: - Elements

    private let introductionView = IntroductionView()

    private let dogIconButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 230, compressionResistancePriority: 230)
        button.setTitle("Choose", for: .normal)
        button.setTitleColor(.placeholderText, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.circleButton
        button.backgroundColor = .systemBackground
        button.borderWidth = 0.5
        button.borderColor = .systemGray2
        button.shouldRoundCorners = true
        return button
    }()

    private let finishButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 290, compressionResistancePriority: 290)
        button.setTitle("Finish", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        button.backgroundColor = .systemBackground
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        return button
    }()

    private var mainStack: UIStackView!

    // MARK: - Properties

    private weak var delegate: HoundIntroductionDogIconViewDelegate?

    private var dogIcon: UIImage? {
        dogIconButton.imageView?.image
    }

    // MARK: - Setup

    func setup(forDelegate: HoundIntroductionDogIconViewDelegate, forDogName dogName: String) {
        delegate = forDelegate

        introductionView.backgroundImageView.image = UIImage(named: "blueShorelineManThrowingStickForDog")
        introductionView.pageHeaderLabel.text = "Select an icon for \(dogName)"
        introductionView.pageDescriptionLabel.text = "It's optional, but adding a cute picture for them is a wonderful choice"

        dogIconButton.isEnabled = true
        finishButton.isEnabled = true

        DogIconManager.didSelectDogIconController.delegate = self
    }

    // MARK: - Functions

    @objc private func didTouchUpInsideDogIcon(_ sender: Any) {
        PresentationManager.enqueueActionSheet(DogIconManager.openCameraOrGalleryForDogIconActionSheet, sourceView: dogIconButton)
    }

    @objc private func didTouchUpInsideFinish(_ sender: Any) {
        dogIconButton.isEnabled = false
        finishButton.isEnabled = false
        delegate?.willFinish(forDogIcon: dogIcon)
    }

    // MARK: - Setup Elements

    override func setupGeneratedViews() {
        backgroundColor = .systemBackground
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        addSubview(introductionView)

        mainStack = UIStackView(arrangedSubviews: [dogIconButton, finishButton])
        mainStack.axis = .vertical
        mainStack.spacing = ConstraintConstant.Section.interSectionVertSpacing
        mainStack.alignment = .center
        mainStack.translatesAutoresizingMaskIntoConstraints = false

        introductionView.contentView.addSubview(mainStack)

        dogIconButton.addTarget(self, action: #selector(didTouchUpInsideDogIcon), for: .touchUpInside)
        finishButton.addTarget(self, action: #selector(didTouchUpInsideFinish), for: .touchUpInside)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: bottomAnchor),

            mainStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            mainStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            mainStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            mainStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor),

            dogIconButton.createSquareConstraint(),
            dogIconButton.heightAnchor.constraint(equalTo: self.widthAnchor, multiplier: ConstraintConstant.Button.circleHeightMultiplier * 1.25).withPriority(.defaultHigh),
            dogIconButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.circleMaxHeight * 1.25),

            finishButton.leadingAnchor.constraint(equalTo: mainStack.leadingAnchor),
            finishButton.trailingAnchor.constraint(equalTo: mainStack.trailingAnchor),
            finishButton.heightAnchor.constraint(equalTo: self.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            finishButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight)
        ])
    }
}
//
//  HoundIntroductionViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/26/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED
final class HoundIntroductionViewController: GeneralUIViewController,
                                             UIScrollViewDelegate,
                                             HoundIntroductionDogNameViewDelegate,
                                             HoundIntroductionDogIconViewDelegate {
    
    // MARK: - Elements
    
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        scrollView.isPagingEnabled = true
        scrollView.isScrollEnabled = false
        return scrollView
    }()
    
    private let dogNamePage: HoundIntroductionDogNameView = {
        let page = HoundIntroductionDogNameView(frame: .zero)
        return page
    }()
    
    private let dogIconPage: HoundIntroductionDogIconView = {
        let page = HoundIntroductionDogIconView(frame: .zero)
        return page
    }()
    
    // MARK: - Properties
    
    private var didSetupCustomSubviews: Bool = false
    private var pages: [UIView] { [dogNamePage, dogIconPage] }
    private var currentPageIndex: Int = 0
    
    private enum PageDirection {
        case next
        case previous
    }
    
    /// The dogName that was entered by the user on dogNamePage. nil if the family already had a dog and the user wasn't allowed to input a dogName
    private var dogNameInput: String?
    /// The dogIcon that was entered by the user on dogIconPage. nil if user didn't input a dogIcon
    private var dogIconInput: UIImage?
    
    // MARK: Dog Manager
    
    private var dogManager: DogManager = DogManager.globalDogManager ?? DogManager()
    
    func setDogManager(sender: Sender, forDogManager: DogManager) {
        dogManager = forDogManager
    }
    
    // MARK: - HoundIntroductionDogNameViewDelegate
    
    func willContinue(forDogName dogName: String?) {
        // Store the entered dog name
        self.dogNameInput = dogName
        
        // Configure the dogIconPage for the next step
        let defaultName = dogManager.dogs.first?.dogName ?? ClassConstant.DogConstant.defaultDogName
        let nameToUse = dogName ?? defaultName
        dogIconPage.setup(forDelegate: self, forDogName: nameToUse)
        
        // Advance the scroll view to the next page
        goToPage(forPageDirection: .next, forAnimated: true)
    }
    
    // MARK: - HoundIntroductionDogIconViewDelegate
    
    func willFinish(forDogIcon dogIcon: UIImage?) {
        self.dogIconInput = dogIcon
        
        // If the family already has at least one dog, simply update its icon
        if let existingDog = dogManager.dogs.first {
            existingDog.dogIcon = self.dogIconInput
            
            // Persist the new dog icon locally
            if let icon = existingDog.dogIcon {
                DogIconManager.addIcon(forDogUUID: existingDog.dogUUID, forDogIcon: icon)
            }
            
            // Manually present MainTabBarController
            let mainTabBarController = MainTabBarController()
            mainTabBarController.setDogManager(sender: Sender(origin: self, localized: self),
                                               forDogManager: dogManager)
            PresentationManager.enqueueViewController(mainTabBarController)
            
        }
        else {
            // No dogs exist yet: create a new Dog object and send request
            let newDog = (try? Dog(forDogName: dogNameInput ?? ClassConstant.DogConstant.defaultDogName))
            ?? Dog()
            newDog.dogIcon = dogIconInput
            
            PresentationManager.beginFetchingInformationIndicator()
            DogsRequest.create(forErrorAlert: .automaticallyAlertOnlyForFailure, forDog: newDog) { responseStatus, _ in
                PresentationManager.endFetchingInformationIndicator {
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    
                    // Add the newly created dog to our local manager
                    self.dogManager.addDog(forDog: newDog)
                    
                    // Manually present MainTabBarController
                    let mainTabBarController = MainTabBarController()
                    mainTabBarController.setDogManager(sender: Sender(origin: self, localized: self),
                                                       forDogManager: self.dogManager)
                    PresentationManager.enqueueViewController(mainTabBarController)
                }
            }
        }
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        scrollView.delegate = self
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard didSetupCustomSubviews == false else {
            return
        }
        
        didSetupCustomSubviews = true
        
        dogNamePage.setup(forDelegate: self, forDogManager: dogManager)
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        // Mark the introduction as completed locally
        LocalConfiguration.localHasCompletedHoundIntroductionViewController = true
    }
    
    // MARK: - Functions
    
    private func goToPage(forPageDirection pageDirection: PageDirection, forAnimated animated: Bool) {
        let delta = (pageDirection == .next ? 1 : -1)
        let targetIndex = min(max(currentPageIndex + delta, 0), pages.count - 1)
        currentPageIndex = targetIndex
        
        let offset = CGPoint(
            x: scrollView.frame.width * CGFloat(targetIndex),
            y: 0
        )
        scrollView.isScrollEnabled = true
        scrollView.setContentOffset(offset, animated: animated)
        scrollView.isScrollEnabled = false
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        pages.forEach { scrollView.addSubview($0) }
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // scrollView
        let scrollViewTop = scrollView.topAnchor.constraint(equalTo: view.topAnchor)
        let scrollViewBottom = scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        let scrollViewLeading = scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor)
        let scrollViewTrailing = scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        
        // dogNamePage
        let dogNamePageTop = dogNamePage.topAnchor.constraint(equalTo: scrollView.contentLayoutGuide.topAnchor)
        let dogNamePageBottom = dogNamePage.bottomAnchor.constraint(equalTo: scrollView.contentLayoutGuide.bottomAnchor)
        let dogNamePageLeading = dogNamePage.leadingAnchor.constraint(equalTo: scrollView.contentLayoutGuide.leadingAnchor)
        let dogNamePageWidth = dogNamePage.widthAnchor.constraint(equalTo: scrollView.frameLayoutGuide.widthAnchor)
        let dogNamePageHeight = dogNamePage.heightAnchor.constraint(equalTo: scrollView.frameLayoutGuide.heightAnchor)

        // dogIconPage
        let dogIconPageTop = dogIconPage.topAnchor.constraint(equalTo: scrollView.contentLayoutGuide.topAnchor)
        let dogIconPageBottom = dogIconPage.bottomAnchor.constraint(equalTo: scrollView.contentLayoutGuide.bottomAnchor)
        let dogIconPageLeading = dogIconPage.leadingAnchor.constraint(equalTo: dogNamePage.trailingAnchor)
        let dogIconPageWidth = dogIconPage.widthAnchor.constraint(equalTo: scrollView.frameLayoutGuide.widthAnchor)
        let dogIconPageHeight = dogIconPage.heightAnchor.constraint(equalTo: scrollView.frameLayoutGuide.heightAnchor)
        let dogIconPageTrailing = dogIconPage.trailingAnchor.constraint(equalTo: scrollView.contentLayoutGuide.trailingAnchor)

        NSLayoutConstraint.activate([
            // scrollView
            scrollViewTop,
            scrollViewBottom,
            scrollViewLeading,
            scrollViewTrailing,

            // dogNamePage
            dogNamePageTop,
            dogNamePageBottom,
            dogNamePageLeading,
            dogNamePageWidth,
            dogNamePageHeight,

            // dogIconPage
            dogIconPageTop,
            dogIconPageBottom,
            dogIconPageLeading,
            dogIconPageWidth,
            dogIconPageHeight,
            dogIconPageTrailing
        ])
    }

}
//
//  ServerFamilyIntroductionViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/3/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol ServerFamilyIntroductionViewControllerDelegate: AnyObject {
    /// Invoked by FamilyRequest completionHandler either when successfully created or joined a family. If this function is invoked, this view has completed
    func didCreateOrJoinFamily()
}

// UI VERIFIED
final class ServerFamilyIntroductionViewController: GeneralUIViewController, UITextFieldDelegate {
    
    // MARK: - UITextFieldDelegate
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn newRange: NSRange, replacementString newString: String) -> Bool {
        // attempt to read the range they are trying to change
        guard let previousText = textField.text, let newStringRange = Range(newRange, in: previousText) else {
            return true
        }
        
        // add their newString in the newRange to the previousText and uppercase it all
        var uppercasedUpdatedText = previousText
            .replacingCharacters(in: newStringRange, with: newString)
            .uppercased()
        
        // The user can delete whatever they want. We only want to check when they add a character
        guard uppercasedUpdatedText.count > previousText.count else {
            // The user deleted a character. Therefore, the join button should always be disabled as code can't exceed length of 8
            familyCodeJoinAction?.isEnabled = uppercasedUpdatedText.replacingOccurrences(of: "-", with: "").count == familyCodeWithoutDashLength
            return true
        }
        
        // MARK: Verify new character is a valid character
        // A family code input can only contain the alphabet, numbers, and a dash (exclude 0, O, I, L). We automatically convert lowercase to uppercase.
        let acceptableCharacters = "ABCDEFGHJKMNPQRSTUVWXYZ123456789-"
        var containsInvalidCharacter = false
        uppercasedUpdatedText.forEach { character in
            if acceptableCharacters.firstIndex(of: character) == nil {
                containsInvalidCharacter = true
            }
        }
        guard !containsInvalidCharacter else {
            return false
        }
        
        // MARK: Verify dash (-) placement and count
        // If uppercasedUpdatedText has a dash and previousText doesn't have a dash, the user added a dash.
        if let dashIndexInNew = uppercasedUpdatedText.firstIndex(of: "-"),
           previousText.firstIndex(of: "-") == nil {
            let indexOfAddedDash = uppercasedUpdatedText.distance(from: uppercasedUpdatedText.startIndex, to: dashIndexInNew)
            // If the dash isn't exactly in index 4, reject the change
            if indexOfAddedDash != 4 {
                return false
            }
        }
        // If the previousText's first dash and uppercasedUpdatedText's last dash are in different indices, then the user is trying to add another dash
        else if previousText.firstIndex(of: "-") != uppercasedUpdatedText.lastIndex(of: "-") {
            return false
        }
        // If uppercasedUpdatedText doesn't have a dash and its length is ≥ 4, insert a dash at position 4
        else if uppercasedUpdatedText.firstIndex(of: "-") == nil && uppercasedUpdatedText.count >= 4 {
            let dashIndexPosition = uppercasedUpdatedText.index(uppercasedUpdatedText.startIndex, offsetBy: 4)
            uppercasedUpdatedText.insert("-", at: dashIndexPosition)
        }
        
        // MARK: Verify length
        if uppercasedUpdatedText.replacingOccurrences(of: "-", with: "").count > familyCodeWithoutDashLength {
            return false
        }
        
        // MARK: Check family code completion
        // To reach this point, the updated text only contains valid characters at valid positions
        familyCodeJoinAction?.isEnabled = uppercasedUpdatedText.replacingOccurrences(of: "-", with: "").count == familyCodeWithoutDashLength
        
        // Update the text field's text
        textField.text = uppercasedUpdatedText
        
        // Return false because we manually set the text field's text
        return false
    }
    
    // MARK: - Elements
    
    private let introductionView = IntroductionView()
    
    private lazy var createFamilyButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.setTitle("Create", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        
        button.addTarget(self, action: #selector(willCreateFamily), for: .touchUpInside)
        
        return button
    }()
    
    private let subDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "As the head of your own Hound family, you'll manage its members and any in-app purchases."
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.tertiaryColorDescLabel
        label.textColor = .tertiaryLabel
        return label
    }()
    
    private lazy var joinFamilyButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.setTitle("Join", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        
        button.addTarget(self, action: #selector(willJoinFamily), for: .touchUpInside)
        
        return button
    }()
    
    /// Stack view containing createFamilyButton and subDescriptionLabel
    private var createStack: UIStackView!
    
    /// Stack view containing both the createStack and joinFamilyButton
    private var mainStack: UIStackView!
    
    // MARK: - Properties
    
    private weak var delegate: ServerFamilyIntroductionViewControllerDelegate?
    
    /// Keep track of this alert action so we can later reference it to enable and disable it
    private var familyCodeJoinAction: UIAlertAction?
    
    /// A family's join code is eight characters long
    private let familyCodeWithoutDashLength = 8
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        introductionView.backgroundImageView.image = UIImage(named: "lightBeachFamilyPicnicWithDog")
        
        introductionView.pageHeaderLabel.text = "Family"
        
        introductionView.pageDescriptionLabel.text = "To use Hound, you must create or join a family. Families allow multiple users to collaborate on their dogs' care."
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: ServerFamilyIntroductionViewControllerDelegate) {
        self.delegate = forDelegate
    }
    
    // MARK: - Functions
    
    @objc private func willCreateFamily(_ sender: Any) {
        PresentationManager.beginFetchingInformationIndicator()
        FamilyRequest.create(forErrorAlert: .automaticallyAlertForNone) { responseStatus, houndError in
            PresentationManager.endFetchingInformationIndicator {
                // The user is already in a family so can't create a new one
                if houndError?.name == ErrorConstant.FamilyResponseError.joinInFamilyAlready(forRequestId: -1, forResponseId: -1).name {
                    self.dismiss(animated: true, completion: nil)
                    return
                }
                
                guard responseStatus == .successResponse else {
                    // Manually alert because we want to intercept the possible joinInFamilyAlready error
                    houndError?.alert()
                    return
                }
                
                self.delegate?.didCreateOrJoinFamily()
                self.dismiss(animated: true, completion: nil)
            }
        }
    }
    
    @objc private func willJoinFamily(_ sender: Any) {
        let familyCodeAlertController = UIAlertController(
            title: "Join a Family",
            message: "The code is case-insensitive",
            preferredStyle: .alert
        )
        familyCodeAlertController.addTextField { textField in
            textField.placeholder = "Enter a family code..."
            textField.autocapitalizationType = .allCharacters
            textField.delegate = self
            textField.returnKeyType = .done
            textField.enablesReturnKeyAutomatically = true
        }
        let joinAction = UIAlertAction(title: "Join", style: .default) { [weak familyCodeAlertController] _ in
            guard let textField = familyCodeAlertController?.textFields?.first else { return }
            
            // Uppercase everything then strip dashes, whitespace, newlines
            let familyCode = (textField.text ?? "")
                .uppercased()
                .replacingOccurrences(of: "-", with: "")
                .trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Code is empty
            if familyCode.isEmpty {
                ErrorConstant.FamilyRequestError.familyCodeBlank().alert()
            }
            // Code isn't long enough
            else if familyCode.count != self.familyCodeWithoutDashLength {
                ErrorConstant.FamilyRequestError.familyCodeInvalid().alert()
            }
            // Client-side code is OK
            else {
                PresentationManager.beginFetchingInformationIndicator()
                FamilyRequest.update(
                    forErrorAlert: .automaticallyAlertForNone,
                    forBody: [KeyConstant.familyCode.rawValue: familyCode]
                ) { responseStatus, houndError in
                    PresentationManager.endFetchingInformationIndicator {
                        // Already in a family
                        if houndError?.name == ErrorConstant.FamilyResponseError.joinInFamilyAlready(forRequestId: -1, forResponseId: -1).name {
                            self.dismiss(animated: true, completion: nil)
                            return
                        }
                        // Family limit too low
                        if houndError?.name == ErrorConstant.FamilyResponseError.limitFamilyMemberTooLow(forRequestId: -1, forResponseId: -1).name {
                            let vc = LimitTooLowViewController()
                            PresentationManager.enqueueViewController(vc)
                            return
                        }
                        guard responseStatus == .successResponse else {
                            // Manually alert for all other errors
                            houndError?.alert()
                            return
                        }
                        self.delegate?.didCreateOrJoinFamily()
                        self.dismiss(animated: true, completion: nil)
                    }
                }
            }
        }
        joinAction.isEnabled = false
        familyCodeJoinAction = joinAction
        
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        familyCodeAlertController.addAction(joinAction)
        familyCodeAlertController.addAction(cancelAction)
        
        PresentationManager.enqueueAlert(familyCodeAlertController)
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        
        view.addSubview(introductionView)
        
        createStack = UIStackView(arrangedSubviews: [createFamilyButton, subDescriptionLabel])
        createStack.axis = .vertical
        createStack.alignment = .center
        createStack.distribution = .fill
        createStack.spacing = ConstraintConstant.Section.intraSectionVertSpacing
        createStack.translatesAutoresizingMaskIntoConstraints = false
        
        mainStack = UIStackView(arrangedSubviews: [createStack, joinFamilyButton])
        mainStack.axis = .vertical
        mainStack.alignment = .center
        mainStack.distribution = .fill
        mainStack.spacing = 30
        mainStack.translatesAutoresizingMaskIntoConstraints = false
        
        introductionView.contentView.addSubview(mainStack)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // introductionView
        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        ])
        
        // mainStack
        NSLayoutConstraint.activate([
            mainStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            mainStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            mainStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            mainStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor)
        ])
        
        // createFamilyButton
        NSLayoutConstraint.activate([
            createFamilyButton.widthAnchor.constraint(equalTo: mainStack.widthAnchor),
            createFamilyButton.heightAnchor.constraint(equalTo: createFamilyButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            createFamilyButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight)
        ])
        
        // subDescriptionLabel
        NSLayoutConstraint.activate([
            subDescriptionLabel.widthAnchor.constraint(equalTo: mainStack.widthAnchor)
        ])
        
        // joinFamilyButton
        NSLayoutConstraint.activate([
            joinFamilyButton.widthAnchor.constraint(equalTo: mainStack.widthAnchor),
            joinFamilyButton.heightAnchor.constraint(equalTo: createFamilyButton.heightAnchor)
        ])
    }
}
//
//  RemindersIntroductionViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/6/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol RemindersIntroductionViewControllerDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, forDogManager dogManager: DogManager)
}

// UI VERIFIED
final class RemindersIntroductionViewController: GeneralUIViewController {
    
    // MARK: - Elements

    private let introductionView = IntroductionView()

    private lazy var setUpRemindersButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 270, compressionResistancePriority: 270)

        button.setTitle("Set Up Reminders", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        button.backgroundColor = .systemBlue
        button.shouldRoundCorners = true
        button.addTarget(self, action: #selector(didTouchUpInsideSetUpReminders), for: .touchUpInside)

        return button
    }()

    private lazy var maybeLaterButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 260, compressionResistancePriority: 260)

        button.setTitle("Maybe Later", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        button.backgroundColor = .systemBackground
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        button.addTarget(self, action: #selector(didTouchUpInsideMaybeLater), for: .touchUpInside)

        return button
    }()

    /// Stack view containing the two buttons
    private var buttonStack: UIStackView!

    // MARK: - Properties

    private weak var delegate: RemindersIntroductionViewControllerDelegate?
    private var dogManager = DogManager()

    // MARK: - Main

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true

        introductionView.backgroundImageView.image = UIImage(named: "creamBackyardCoupleTeachingDogTrick")
        introductionView.pageHeaderLabel.text = "Reminders"
        introductionView.pageDescriptionLabel.text = "We'll create reminders that are useful for most dogs. Do you want to use them?"
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        LocalConfiguration.localHasCompletedRemindersIntroductionViewController = true
    }

    // MARK: - Setup

    func setup(forDelegate: RemindersIntroductionViewControllerDelegate, forDogManager: DogManager) {
        self.delegate = forDelegate
        self.dogManager = forDogManager
    }

    // MARK: - Functions

    @objc private func didTouchUpInsideSetUpReminders(_ sender: Any) {
        setUpRemindersButton.isEnabled = false
        maybeLaterButton.isEnabled = false

        NotificationPermissionsManager.requestNotificationAuthorization(shouldAdviseUserBeforeRequestingNotifications: true) {
            guard self.dogManager.hasCreatedReminder == false, let dog = self.dogManager.dogs.first else {
                self.dismiss(animated: true, completion: nil)
                return
            }

            let reminders = ClassConstant.ReminderConstant.defaultReminders
            PresentationManager.beginFetchingInformationIndicator()
            RemindersRequest.create(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: dog.dogUUID, forReminders: reminders) { responseStatus, _ in
                PresentationManager.endFetchingInformationIndicator {
                    guard responseStatus != .failureResponse else {
                        self.setUpRemindersButton.isEnabled = true
                        self.maybeLaterButton.isEnabled = true
                        return
                    }

                    dog.dogReminders.addReminders(forReminders: reminders)
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                    self.dismiss(animated: true, completion: nil)
                }
            }
        }
    }

    @objc private func didTouchUpInsideMaybeLater(_ sender: Any) {
        setUpRemindersButton.isEnabled = false
        maybeLaterButton.isEnabled = false

        NotificationPermissionsManager.requestNotificationAuthorization(shouldAdviseUserBeforeRequestingNotifications: true) {
            self.dismiss(animated: true, completion: nil)
        }
    }

    // MARK: - Setup Elements

    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(introductionView)

        buttonStack = UIStackView(arrangedSubviews: [setUpRemindersButton, maybeLaterButton])
        buttonStack.axis = .vertical
        buttonStack.spacing = ConstraintConstant.Section.interSectionVertSpacing
        buttonStack.translatesAutoresizingMaskIntoConstraints = false

        introductionView.contentView.addSubview(buttonStack)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: view.topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: view.bottomAnchor),

            buttonStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            buttonStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            buttonStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            buttonStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor),

            setUpRemindersButton.heightAnchor.constraint(equalTo: setUpRemindersButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            setUpRemindersButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight),

            maybeLaterButton.heightAnchor.constraint(equalTo: setUpRemindersButton.heightAnchor)
        ])
    }
}
//
//  FamilyUpgradeIntroductionViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/15/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import KeychainSwift
import UIKit

protocol FamilyUpgradeIntroductionViewControllerDelegate: AnyObject {
    func didTouchUpInsideUpgrade()
}

// UI VERIFIED
final class FamilyUpgradeIntroductionViewController: GeneralUIViewController {

    // MARK: - Elements

    private let introductionView = IntroductionView()

    private lazy var upgradeButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 270, compressionResistancePriority: 270)
        button.setTitle(self.userPurchasedProductFromSubscriptionGroup20965379 ? "Upgrade" : "Start Free Trial", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        button.backgroundColor = .systemBlue
        button.shouldRoundCorners = true
        button.addTarget(self, action: #selector(didTouchUpInsideUpgrade), for: .touchUpInside)
        return button
    }()

    private lazy var maybeLaterButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 260, compressionResistancePriority: 260)
        button.setTitle("Maybe Later", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        button.backgroundColor = .systemBackground
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        button.shouldDismissParentViewController = true
        return button
    }()

    /// Stack view containing both buttons
    private var buttonStack: UIStackView!

    // MARK: - Properties

    private weak var delegate: FamilyUpgradeIntroductionViewControllerDelegate?

    private var userPurchasedProductFromSubscriptionGroup20965379: Bool {
        KeychainSwift().getBool(KeyConstant.userPurchasedProductFromSubscriptionGroup20965379.rawValue) ?? false
    }

    // MARK: - Main

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true

        introductionView.backgroundImageView.image = UIImage(named: "darkGreenForestWithMountainsFamilyWalkingDog")
        introductionView.pageHeaderLabel.text = "Family"

        introductionView.pageDescriptionLabel.attributedTextClosure = {
            let message: NSMutableAttributedString = NSMutableAttributedString(
                string: "No need to go it alone! Grow your Hound family to ",
                attributes: [
                    .font: VisualConstant.FontConstant.primaryRegularLabel,
                    .foregroundColor: UIColor.secondaryLabel
                ])

            message.append(NSAttributedString(
                string: "six members",
                attributes: [
                    .font: VisualConstant.FontConstant.emphasizedPrimaryRegularLabel,
                    .foregroundColor: UIColor.secondaryLabel
                ]))

            message.append(NSAttributedString(
                string: " with Hound+. ",
                attributes: [
                    .font: VisualConstant.FontConstant.primaryRegularLabel,
                    .foregroundColor: UIColor.secondaryLabel
                ]))

            if self.userPurchasedProductFromSubscriptionGroup20965379 == false {
                message.append(NSAttributedString(
                    string: "Try it out today with a one week free trial.",
                    attributes: [
                        .font: VisualConstant.FontConstant.primaryRegularLabel,
                        .foregroundColor: UIColor.secondaryLabel
                    ]))
            }

            return message
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController = true
    }

    // MARK: - Setup

    func setup(forDelegate: FamilyUpgradeIntroductionViewControllerDelegate) {
        self.delegate = forDelegate
    }

    // MARK: - Functions

    @objc private func didTouchUpInsideUpgrade(_ sender: Any) {
        self.dismiss(animated: true) {
            self.delegate?.didTouchUpInsideUpgrade()
        }
    }

    // MARK: - Setup Elements

    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(introductionView)

        buttonStack = UIStackView(arrangedSubviews: [upgradeButton, maybeLaterButton])
        buttonStack.axis = .vertical
        buttonStack.spacing = ConstraintConstant.Section.interSectionVertSpacing
        buttonStack.translatesAutoresizingMaskIntoConstraints = false

        introductionView.contentView.addSubview(buttonStack)
    }

    override func setupConstraints() {
        super.setupConstraints()

        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: view.topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: view.bottomAnchor),

            buttonStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            buttonStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            buttonStack.leadingAnchor.constraint(equalTo: introductionView.contentView.leadingAnchor),
            buttonStack.trailingAnchor.constraint(equalTo: introductionView.contentView.trailingAnchor),

            upgradeButton.heightAnchor.constraint(equalTo: upgradeButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            upgradeButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight),

            maybeLaterButton.heightAnchor.constraint(equalTo: upgradeButton.heightAnchor)
        ])
    }
}
//
//  ServerLoginIntroductionViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/3/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import AuthenticationServices
import UIKit

// UI VERIFIED
final class ServerLoginIntroductionViewController: GeneralUIViewController,
                                       ASAuthorizationControllerDelegate,
                                       ASAuthorizationControllerPresentationContextProviding,
                                       UITextFieldDelegate {
    
    // MARK: - ASAuthorizationControllerPresentationContextProviding
    
    func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
        // Return the window into which the authorization controller should present
        return self.view.window ?? ASPresentationAnchor()
    }
    
    // MARK: - ASAuthorizationControllerDelegate
    
    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
        guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential else {
            ErrorConstant.SignInWithAppleError.other().alert()
            return
        }
        
        // Persist Apple ID info (only available on first sign–in) into UserInformation & UserDefaults
        UserInformation.userIdentifier = appleIDCredential.user
        UserInformation.userEmail = appleIDCredential.email ?? UserInformation.userEmail
        UserInformation.userFirstName = appleIDCredential.fullName?.givenName ?? UserInformation.userFirstName
        UserInformation.userLastName = appleIDCredential.fullName?.familyName ?? UserInformation.userLastName
        UserInformation.persist(toUserDefaults: UserDefaults.standard)
        
        signInUser()
    }
    
    func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
        // Handle errors from Sign In with Apple
        guard let authError = error as? ASAuthorizationError else { return }
        switch authError.code {
        case .canceled:
            // The user cancelled Apple sign–in; no alert needed
            break
        case .unknown:
            ErrorConstant.SignInWithAppleError.notSignedIn().alert()
        default:
            ErrorConstant.SignInWithAppleError.other().alert()
        }
    }
    
    // MARK: - Elements
    
    private let introductionView = IntroductionView()
    
    /// "Sign In/Up with Apple" button; its type depends on whether userIdentifier exists
    private lazy var signInWithAppleButton: ASAuthorizationAppleIDButton = {
        let buttonType: ASAuthorizationAppleIDButton.ButtonType = (UserInformation.userIdentifier != nil) ? .signIn : .signUp
        let btn = ASAuthorizationAppleIDButton(type: buttonType, style: .whiteOutline)
        btn.translatesAutoresizingMaskIntoConstraints = false
        btn.cornerRadius = CGFloat.greatestFiniteMagnitude
        btn.addTarget(self, action: #selector(didTouchUpInsideSignInWithApple), for: .touchUpInside)
        btn.layer.borderWidth = 2.0
        btn.layer.borderColor = UIColor.label.cgColor
        return btn
    }()
    
    /// Description below the Apple button
    private let signInWithAppleDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.tertiaryColorDescLabel
        label.textColor = .tertiaryLabel
        label.textAlignment = .center
        let mode = (UserInformation.userIdentifier == nil) ? "Up" : "In"
        label.text = """
            Currently, Hound only offers accounts through the "Sign \(mode) With Apple" feature. \
            As per Apple, this requires you have an Apple ID with two‐factor authentication enabled.
            """
        return label
    }()
    
    /// Stack view containing sign-in button and description
    private var signInStack: UIStackView!
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        introductionView.backgroundImageView.image = UIImage(named: "darkTealMeadowsMenWalkingDogs")
        
        introductionView.pageHeaderLabel.text = "Welcome to Hound"
        
        if UserInformation.userIdentifier != nil {
            introductionView.pageDescriptionLabel.text = """
                Sign in to your existing Hound account below. If you don't have one, \
                creating or joining a family will come soon...
                """
        }
        else {
            introductionView.pageDescriptionLabel.text = """
                Create your Hound account below. Creating or joining a family will come soon...
                """
        }
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        // Adjust corner radius & border of the Apple button once sizes are known
        signInWithAppleButton.layer.cornerRadius = signInWithAppleButton.frame.height / 2
    }
    
    // MARK: - Functions
    
    @objc private func didTouchUpInsideSignInWithApple() {
        let appleIDProvider = ASAuthorizationAppleIDProvider()
        let request = appleIDProvider.createRequest()
        request.requestedScopes = [.fullName, .email]
        
        let authorizationController = ASAuthorizationController(authorizationRequests: [request])
        authorizationController.delegate = self
        authorizationController.presentationContextProvider = self
        authorizationController.performRequests()
    }
    
    /// Kick off the user sign‐in / sign‐up flow, showing activity indicator and dismissing on success.
    private func signInUser() {
        PresentationManager.beginFetchingInformationIndicator()
        
        UserRequest.create(forErrorAlert: .automaticallyAlertForNone) { responseStatus, houndErrorCreate in
            guard responseStatus != .failureResponse else {
                // If creation failed, try “get” in case the account already exists:
                UserRequest.get(forErrorAlert: .automaticallyAlertOnlyForFailure) { responseStatus, houndErrorGet in
                    PresentationManager.endFetchingInformationIndicator {
                        guard responseStatus != .failureResponse else {
                            // Show error from GET if it failed:
                            (houndErrorGet ?? ErrorConstant.GeneralResponseError.getFailureResponse(forRequestId: -1, forResponseId: -1)).alert()
                            return
                        }
                        // If GET succeeded, but userId is still missing, that’s unexpected:
                        guard UserInformation.userId != nil else {
                            (houndErrorGet ?? ErrorConstant.GeneralResponseError.getNoResponse()).alert()
                            return
                        }
                        self.dismiss(animated: true, completion: nil)
                    }
                }
                return
            }
            
            // On successful create (or no‐response but userId set):
            guard UserInformation.userId != nil else {
                (houndErrorCreate ?? ErrorConstant.GeneralResponseError.getNoResponse()).alert()
                return
            }
            
            // All good; dismiss:
            PresentationManager.endFetchingInformationIndicator {
                self.dismiss(animated: true, completion: nil)
            }
        }
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        
        view.addSubview(introductionView)
        
        signInStack = UIStackView(arrangedSubviews: [signInWithAppleButton, signInWithAppleDescriptionLabel])
        signInStack.axis = .vertical
        signInStack.alignment = .center
        signInStack.distribution = .fill
        signInStack.spacing = 12.5
        signInStack.translatesAutoresizingMaskIntoConstraints = false
        introductionView.contentView.addSubview(signInStack)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // introductionView
        NSLayoutConstraint.activate([
            introductionView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            introductionView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
            introductionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            introductionView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        ])
        
        // signInStack
        NSLayoutConstraint.activate([
            signInStack.centerXAnchor.constraint(equalTo: introductionView.contentView.centerXAnchor),
            signInStack.centerYAnchor.constraint(equalTo: introductionView.contentView.centerYAnchor),
            signInStack.widthAnchor.constraint(equalTo: introductionView.contentView.widthAnchor)
        ])
        
        // signInWithAppleButton
        NSLayoutConstraint.activate([
            signInWithAppleButton.widthAnchor.constraint(equalTo: introductionView.contentView.widthAnchor),
            signInWithAppleButton.heightAnchor.constraint(equalTo: signInWithAppleButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            signInWithAppleButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight)
        ])
        
        // signInWithAppleDescriptionLabel
        NSLayoutConstraint.activate([
            signInWithAppleDescriptionLabel.widthAnchor.constraint(equalTo: signInWithAppleDescriptionLabel.widthAnchor)
        ])
    }

}
//
//  ServerSyncViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/3/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED
final class ServerSyncViewController: GeneralUIViewController, ServerFamilyIntroductionViewControllerDelegate {
    
    // MARK: - ServerFamilyIntroductionViewControllerDelegate
    
    func didCreateOrJoinFamily() {
        DogManager.globalDogManager = nil
    }
    
    // MARK: - Elements
    
    private let pawWithHands: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 300, compressionResistancePriority: 300)

        return imageView
    }()
    
    private let getRequestsProgressView: GeneralUIProgressView = {
        let progressView = GeneralUIProgressView()
        progressView.progressTintColor = .systemBackground
        progressView.trackTintColor = .systemGray2
        return progressView
    }()
    
    private let troubleshootLoginButton: GeneralUIButton = {
        let button = GeneralUIButton()
        button.isHidden = true
        
        button.setTitle("Go to Login Page", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        
        return button
    }()
    
    @objc private func didTapTroubleshootLogin(_ sender: Any) {
        if troubleshootLoginButton.tag == VisualConstant.ViewTagConstant.serverSyncViewControllerRetryLogin {
            self.repeatableSetup()
        }
        else if troubleshootLoginButton.tag == VisualConstant.ViewTagConstant.serverSyncViewControllerGoToLoginPage {
            let vc = ServerLoginIntroductionViewController()
            PresentationManager.enqueueViewController(vc)
        }
    }
    
    // MARK: - Properties
    
    /// What fraction of the loading/progress bar the types request is worth when completed
    private var getGlobalTypesProgressFractionOfWhole = (0.5 / 3.0)
    @objc private dynamic var getGlobalTypesProgress: Progress?
    private var getGlobalTypesProgressObserver: NSKeyValueObservation?
    
    /// What fraction of the loading/progress bar the user request is worth when completed
    private var getUserProgressFractionOfWhole = (0.5 / 3.0)
    @objc private dynamic var getUserProgress: Progress?
    private var getUserProgressObserver: NSKeyValueObservation?
    
    /// What fraction of the loading/progress bar the family request is worth when completed
    private var getFamilyProgressFractionOfWhole = (0.5 / 3.0)
    @objc private dynamic var getFamilyProgress: Progress?
    private var getFamilyProgressObserver: NSKeyValueObservation?
    
    /// What fraction of the loading/progress bar the dogs request is worth when completed
    private var getDogsProgressFractionOfWhole = 0.5
    @objc private dynamic var getDogsProgress: Progress?
    private var getDogsProgressObserver: NSKeyValueObservation?
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        self.pawWithHands.image = UITraitCollection.current.userInterfaceStyle == .dark
        ? ClassConstant.DogConstant.blackPawWithHands
        : ClassConstant.DogConstant.whitePawWithHands
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        repeatableSetup()
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        
        // As soon as this view disappears, we want to halt the observers to clean up / deallocate resources.
        getGlobalTypesProgressObserver?.invalidate()
        getGlobalTypesProgressObserver = nil
        getUserProgressObserver?.invalidate()
        getUserProgressObserver = nil
        getFamilyProgressObserver?.invalidate()
        getFamilyProgressObserver = nil
        getDogsProgressObserver?.invalidate()
        getDogsProgressObserver = nil
    }
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        
        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            self.pawWithHands.image = UITraitCollection.current.userInterfaceStyle == .dark
            ? ClassConstant.DogConstant.blackPawWithHands
            : ClassConstant.DogConstant.whitePawWithHands
        }
    }
    
    // MARK: - Functions
    
    private func repeatableSetup() {
        // reset troubleshootLoginButton incase it is needed again for another issue
        troubleshootLoginButton.tag = 0
        troubleshootLoginButton.isHidden = true
        
        getGlobalTypesProgress = nil
        getGlobalTypesProgressObserver = nil
        getUserProgress = nil
        getUserProgressObserver = nil
        getFamilyProgress = nil
        getFamilyProgressObserver = nil
        getDogsProgress = nil
        getDogsProgressObserver = nil
        
        // Before fetching user or any other information, we need types from the server
        self.getGlobalTypes()
    }
    
    /// If we recieved a failure response from a request, redirect the user to the login page in an attempt to recover
    private func failureResponseForRequest() {
        troubleshootLoginButton.tag = VisualConstant.ViewTagConstant.serverSyncViewControllerGoToLoginPage
        troubleshootLoginButton.setTitle("Go to Login Page", for: .normal)
        troubleshootLoginButton.isHidden = false
    }
    
    private func noResponseForRequest() {
        troubleshootLoginButton.tag = VisualConstant.ViewTagConstant.serverSyncViewControllerRetryLogin
        troubleshootLoginButton.setTitle("Retry Login", for: .normal)
        troubleshootLoginButton.isHidden = false
    }
    
    // MARK: Get Functions
    
    private func getGlobalTypes() {
        getGlobalTypesProgress = GlobalTypesRequest.get(forErrorAlert: .automaticallyAlertOnlyForFailure) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                self.failureResponseForRequest()
                return
            }
            
            guard GlobalTypes.shared != nil else {
                // If the user just has no internet, then show a button that lets them try again
                if responseStatus == .noResponse {
                    self.noResponseForRequest()
                }
                else {
                    self.failureResponseForRequest()
                }
                return
            }
            
            if UserInformation.userIdentifier != nil {
                self.getUser()
            }
            // placeholder userId, therefore we need to have them login to even know who they are
            else {
                
                // we have the user sign into their apple id, then attempt to first create an account then get an account (if the creates fails) then throw an error message (if the get fails too).
                // if all succeeds, then the user information and user configuration is loaded
                let vc = ServerLoginIntroductionViewController()
                PresentationManager.enqueueViewController(vc)
            }
        }
        
        if getGlobalTypesProgress != nil {
            // We can't use if let getGlobalTypesProgress = getGlobalTypesProgress here. We need to observe the actual getUserProgress (not an if let "copy" of it) variable that is defined in this class for the KeyValueObservation to work.
            getGlobalTypesProgressObserver = observe(\.getGlobalTypesProgress?.fractionCompleted, options: [.new]) { _, change in
                self.didObserveProgressChange()
                
                // If the get request progress is complete (indicated by the fractionCompleted being 1.0), then we can invalidate the observer as it is no longer needed
                if let optionalNewValue = change.newValue, let newValue = optionalNewValue, newValue == 1.0 {
                    self.getGlobalTypesProgressObserver?.invalidate()
                }
            }
        }
        
    }
    
    private func getUser() {
        getUserProgress = UserRequest.get(forErrorAlert: .automaticallyAlertOnlyForFailure) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                self.failureResponseForRequest()
                return
            }
            
            // This is a special case. If previousDogManagerSynchronization is nil, the user's local data was cleared. This, in conjunction with no response, would mean we would open the app up to a blank screen. This would terrify the user that their data is lost. Therefore, force them to wait for a connection
            guard responseStatus != .noResponse || LocalConfiguration.previousDogManagerSynchronization == nil else {
                self.noResponseForRequest()
                return
            }
            
            guard UserInformation.userIdentifier != nil && UserInformation.userId != nil else {
                // If the user just has no internet, then show a button that lets them try again
                if responseStatus == .noResponse {
                    self.noResponseForRequest()
                }
                // If the suer has internet and still no userId, they need to login
                else {
                    self.failureResponseForRequest()
                }
                return
            }
            
            if UserInformation.familyId != nil {
                // Continue fetching the users family information
                self.getFamilyInformation()
            }
            else {
                // User needs to join a family because they have no familyId
                let vc = ServerFamilyIntroductionViewController()
                vc.setup(forDelegate: self)
                PresentationManager.enqueueViewController(vc)
            }
        }
        
        if getUserProgress != nil {
            // We can't use if let getUserProgress = getUserProgress here. We need to observe the actual getUserProgress (not an if let "copy" of it) variable that is defined in this class for the KeyValueObservation to work.
            getUserProgressObserver = observe(\.getUserProgress?.fractionCompleted, options: [.new]) { _, change in
                self.didObserveProgressChange()
                
                // If the get request progress is complete (indicated by the fractionCompleted being 1.0), then we can invalidate the observer as it is no longer needed
                if let optionalNewValue = change.newValue, let newValue = optionalNewValue, newValue == 1.0 {
                    self.getUserProgressObserver?.invalidate()
                }
            }
        }
        
    }
    
    private func getFamilyInformation() {
        getFamilyProgress = FamilyRequest.get(forErrorAlert: .automaticallyAlertOnlyForFailure) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                self.failureResponseForRequest()
                return
            }
            
            self.getDogs()
        }
        
        if getFamilyProgress != nil {
            // We can't use if let getFamilyProgress = getFamilyProgress here. We need to observe the actual getFamilyProgress (not an if let "copy" of it) variable that is defined in this class for the KeyValueObservation to work.
            getFamilyProgressObserver = observe(\.getFamilyProgress?.fractionCompleted, options: [.new]) { _, change in
                self.didObserveProgressChange()
                
                // If the get request progress is complete (indicated by the fractionCompleted being 1.0), then we can invalidate the observer as it is no longer needed
                if let optionalNewValue = change.newValue, let newValue = optionalNewValue, newValue == 1.0 {
                    self.getFamilyProgressObserver?.invalidate()
                }
            }
        }
    }
    
    private func getDogs() {
        let dogManager = DogManager.globalDogManager ?? DogManager()
        // we want to use our own custom error message
        getDogsProgress = DogsRequest.get(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogManager: dogManager) { newDogManager, responseStatus, _ in
            guard responseStatus != .failureResponse else {
                self.failureResponseForRequest()
                return
            }
            
            DogManager.globalDogManager = newDogManager
            
            // hasn't shown configuration to create/update dog
            if LocalConfiguration.localHasCompletedHoundIntroductionViewController == false {
                // Created family, no dogs present
                // OR joined family, no dogs present
                // OR joined family, dogs already present
                let vc = HoundIntroductionViewController()
                PresentationManager.enqueueViewController(vc)
                
            }
            // has shown configuration before
            else {
                let vc = MainTabBarController()
                PresentationManager.enqueueViewController(vc)
            }
        }
        
        if getDogsProgress != nil {
            // We can't use if let getDogsProgress = getDogsProgress here. We need to observe the actual getDogsProgress (not an if let "copy" of it) variable that is defined in this class for the KeyValueObservation to work.
            getDogsProgressObserver = observe(\.getDogsProgress?.fractionCompleted, options: [.new]) { _, change in
                self.didObserveProgressChange()
                
                // If the get request progress is complete (indicated by the fractionCompleted being 1.0), then we can invalidate the observer as it is no longer needed
                if let optionalNewValue = change.newValue, let newValue = optionalNewValue, newValue == 1.0 {
                    self.getDogsProgressObserver?.invalidate()
                }
            }
        }
        
    }
    
    // The .fractionCompleted variable on one of the progress objects was updated. Therefore, we must update our loading bar
    private func didObserveProgressChange() {
        DispatchQueue.main.async {
            let globalTypesProgress = (self.getGlobalTypesProgress?.fractionCompleted ?? 0.0) * self.getGlobalTypesProgressFractionOfWhole
            
            let userProgress = (self.getUserProgress?.fractionCompleted ?? 0.0) * self.getUserProgressFractionOfWhole
            
            let familyProgress =
            (self.getFamilyProgress?.fractionCompleted ?? 0.0) * self.getFamilyProgressFractionOfWhole
            
            let dogsProgress =
            (self.getDogsProgress?.fractionCompleted ?? 0.0) * self.getDogsProgressFractionOfWhole
            
            self.getRequestsProgressView.setProgress(Float(globalTypesProgress + userProgress + familyProgress + dogsProgress), animated: true)
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(pawWithHands)
        view.addSubview(getRequestsProgressView)
        view.addSubview(troubleshootLoginButton)
        troubleshootLoginButton.addTarget(self, action: #selector(didTapTroubleshootLogin), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pawWithHands
        // pawWithHands
        NSLayoutConstraint.activate([
            pawWithHands.centerXAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerXAnchor),
            pawWithHands.centerYAnchor.constraint(equalTo: view.centerYAnchor),
            pawWithHands.createSquareConstraint(),
            pawWithHands.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 0.4).withPriority(.defaultHigh),
            pawWithHands.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight * 3.0)
        ])
        
        // getRequestsProgressView
        NSLayoutConstraint.activate([
            getRequestsProgressView.topAnchor.constraint(equalTo: pawWithHands.bottomAnchor, constant: 35),
            getRequestsProgressView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            getRequestsProgressView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            getRequestsProgressView.heightAnchor.constraint(equalTo: troubleshootLoginButton.heightAnchor, multiplier: 0.1)
        ])
        
        // troubleshootLoginButton
        NSLayoutConstraint.activate([
            troubleshootLoginButton.topAnchor.constraint(equalTo: getRequestsProgressView.bottomAnchor, constant: 35),
            troubleshootLoginButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            troubleshootLoginButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            troubleshootLoginButton.createScreenWideHeightMultiplier(),
            troubleshootLoginButton.createScrenWideMaxHeight()
        ])
    }

}
//
//  AppVersionOutdatedViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/31/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED
class AppVersionOutdatedViewController: GeneralUIViewController {
    
    // MARK: - Elements
    
    private let pawWithHands: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 290, compressionResistancePriority: 290)

        imageView.image = UIImage(named: "whitePawWithHands")
        
        return imageView
    }()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.text = "New Hound Update Available"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "It looks like you're using an outdated version of Hound. Update now for the latest features and improvements!"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.textColor = .secondarySystemBackground
        return label
    }()
    
    private let openAppStoreButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.setTitle("Open App Store", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        
        return button
    }()
    
    @objc private func didTapOpenAppStore(_ sender: Any) {
        // Open the page for hound on the user's device, don't include a localized url (e.g. with the /us/) so it localizes to a users zone
        guard let url = URL(string: "https://apps.apple.com/app/hound-family-dog-organizer/id1564604025") else {
            return
        }
        UIApplication.shared.open(url)
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        self.pawWithHands.image = UITraitCollection.current.userInterfaceStyle == .dark
        ? ClassConstant.DogConstant.blackPawWithHands
        : ClassConstant.DogConstant.whitePawWithHands
    }
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        
        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            self.pawWithHands.image = UITraitCollection.current.userInterfaceStyle == .dark
            ? ClassConstant.DogConstant.blackPawWithHands
            : ClassConstant.DogConstant.whitePawWithHands
        }
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBlue
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(pawWithHands)
        view.addSubview(headerLabel)
        view.addSubview(descriptionLabel)
        view.addSubview(openAppStoreButton)
        
        openAppStoreButton.addTarget(self, action: #selector(didTapOpenAppStore), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pawWithHands
        let pawWithHandsCenterX = pawWithHands.centerXAnchor.constraint(equalTo: view.centerXAnchor)
        let pawWithHandsWidth = pawWithHands.widthAnchor.constraint(equalTo: pawWithHands.heightAnchor)
        let pawWithHandsWidthRelative = pawWithHands.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 4.0 / 10.0)
        
        // headerLabel
        let headerLabelTop = headerLabel.topAnchor.constraint(equalTo: pawWithHands.bottomAnchor, constant: 20)
        let headerLabelLeading = headerLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let headerLabelTrailing = headerLabel.trailingAnchor.constraint(equalTo: openAppStoreButton.trailingAnchor)
        let headerLabelTrailingSafe = headerLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let headerLabelTrailingDesc = headerLabel.trailingAnchor.constraint(equalTo: descriptionLabel.trailingAnchor)
        let headerLabelCenterY = headerLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor)
        
        // descriptionLabel
        let descriptionLabelTop = descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 12.5)
        let descriptionLabelLeading = descriptionLabel.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor)
        
        // openAppStoreButton
        let openAppStoreButtonTop = openAppStoreButton.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor, constant: 35)
        let openAppStoreButtonLeading = openAppStoreButton.leadingAnchor.constraint(equalTo: headerLabel.leadingAnchor)
        let openAppStoreButtonWidth = openAppStoreButton.createScreenWideHeightMultiplier()
        
        NSLayoutConstraint.activate([
            // pawWithHands
            pawWithHandsCenterX,
            pawWithHandsWidth,
            pawWithHandsWidthRelative,
            
            // headerLabel
            headerLabelTop,
            headerLabelLeading,
            headerLabelTrailing,
            headerLabelTrailingSafe,
            headerLabelTrailingDesc,
            headerLabelCenterY,
            
            // descriptionLabel
            descriptionLabelTop,
            descriptionLabelLeading,
            
            // openAppStoreButton
            openAppStoreButtonTop,
            openAppStoreButtonLeading,
            openAppStoreButtonWidth
        ])
    }

}
//
//  BluePawViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/24/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED
class BluePawViewController: GeneralUIViewController {

    // MARK: - Elements
    
    private let pawWithHands: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 340, compressionResistancePriority: 340)

        imageView.image = UIImage(named: "whitePawWithHands")
        
        return imageView
    }()
    
    let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 330, compressionResistancePriority: 330)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBackground
        return label
    }()
    
    let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 320, compressionResistancePriority: 320)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.textColor = .secondarySystemBackground
        return label
    }()
    
    let backButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 350, compressionResistancePriority: 350)
        
        button.tintColor = .systemBackground
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBlue
        
        button.shouldDismissParentViewController = true
        return button
    }()

    let contentView: GeneralUIView = {
        let view = GeneralUIView(huggingPriority: 310, compressionResistancePriority: 310)
        
        return view
    }()
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        self.pawWithHands.image = UITraitCollection.current.userInterfaceStyle == .dark
        ? ClassConstant.DogConstant.blackPawWithHands
        : ClassConstant.DogConstant.whitePawWithHands
    }
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)

        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            self.pawWithHands.image = UITraitCollection.current.userInterfaceStyle == .dark
            ? ClassConstant.DogConstant.blackPawWithHands
            : ClassConstant.DogConstant.whitePawWithHands
        }
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBlue
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(pawWithHands)
        view.addSubview(headerLabel)
        view.addSubview(descriptionLabel)
        view.addSubview(backButton)
        view.addSubview(contentView)
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        // backButton
        NSLayoutConstraint.activate([
            backButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: ConstraintConstant.Button.miniCircleInset),
            backButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Button.miniCircleInset),
            backButton.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.Button.miniCircleHeightMultiplier).withPriority(.defaultHigh),
            backButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.miniCircleMaxHeight),
            backButton.createSquareConstraint()
        ])

        // pawWithHands
        NSLayoutConstraint.activate([
            pawWithHands.centerXAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerXAnchor),
            pawWithHands.createSquareConstraint(),
            pawWithHands.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 0.4).withPriority(.defaultHigh),
            pawWithHands.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight * 3.0)
        ])

        // headerLabel
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: pawWithHands.bottomAnchor, constant: 20),
            headerLabel.centerYAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerYAnchor),
            headerLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            headerLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])

        // descriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 12.5),
            descriptionLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])

        // contentView
        NSLayoutConstraint.activate([
            contentView.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor),
            contentView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            contentView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            contentView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -ConstraintConstant.Global.contentVertInset)
        ])
    }

}
//
//  SurveyAppExperienceViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/4/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED
class SurveyAppExperienceViewController: GeneralUIViewController, UITextViewDelegate {
    
    // MARK: - UITextViewDelegate
    
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        // Don't allow the user to add a new line. If they do, we interpret that as the user hitting the done button.
        guard text != "\n" else {
            self.dismissKeyboard()
            return false
        }
        
        // get the current text, or use an empty string if that failed
        let currentText = textView.text ?? ""
        
        // attempt to read the range they are trying to change, or exit if we can't
        guard let stringRange = Range(range, in: currentText) else { return false }
        
        // add their new text to the existing text
        let updatedText = currentText.replacingCharacters(in: stringRange, with: text)
        
        // make sure the result is under logNoteCharacterLimit
        return updatedText.count <= ClassConstant.FeedbackConstant.appExperienceSuggestionCharacterLimit
    }
    
    // MARK: - Elements
    
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        scrollView.bounces = false
        scrollView.bouncesZoom = false
        
        return scrollView
    }()
    
    private let containerView: GeneralUIView = GeneralUIView()
    
    private let pageHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.text = "How are you enjoying Hound?"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 290, compressionResistancePriority: 290)
        
        button.tintColor = .systemBackground
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBlue
        
        button.shouldDismissParentViewController = true
        return button
    }()
    
    private let oneStarButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = .systemBackground
        return button
    }()
    
    private let twoStarButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = .systemBackground
        return button
    }()

    private let threeStarButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = .systemBackground
        return button
    }()
    
    private let fourStarButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = .systemBackground
        return button
    }()
    
    private let fiveStarButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 280, compressionResistancePriority: 280)
        button.setImage(UIImage(systemName: "star"), for: .normal)
        button.tintColor = .systemBackground
        return button
    }()
    
    /// Stack view containing all star rating buttons
    private let starsStackView: UIStackView = {
        let stackView = UIStackView()
        stackView.axis = .horizontal
        stackView.alignment = .center
        stackView.distribution = .equalSpacing
        stackView.translatesAutoresizingMaskIntoConstraints = false
        return stackView
    }()
    
    @objc private func didTapStar(_ sender: Any) {
        guard let tappedStar = sender as? GeneralUIButton else {
            return
        }
        
        indexOfUserStarRating = orderedStarButtons.firstIndex(of: tappedStar)
    }
    
    private let descriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.text = "What could we do to improve?"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        label.textColor = .systemBackground
        return label
    }()
    
    private let suggestionTextView: GeneralUITextView = {
        let textView = GeneralUITextView(huggingPriority: 260, compressionResistancePriority: 260)
        
        textView.backgroundColor = .systemBackground
        textView.textColor = .label
        textView.font = VisualConstant.FontConstant.primaryRegularLabel
        textView.placeholder = "Share any thoughts, suggestions, or issues..."
        
        textView.borderWidth = 2
        textView.borderColor = .label
        textView.shouldRoundCorners = true
        return textView
    }()
    
    private let submitButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.setTitle("Submit", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        
        // Continue button is disabled until the user selects a rating
        button.isEnabled = false
        
        return button
    }()
    
    @objc private func didTapSubmit(_ sender: Any) {
        guard let indexOfUserStarRating = indexOfUserStarRating else {
            return
        }
        
        // for numberOfStars, adjust the index 0-4 of the star rating to its actual 1-5 value.
        SurveyFeedbackRequest.create(forErrorAlert: .automaticallyAlertForNone, numberOfStars: (indexOfUserStarRating + 1), appExperienceFeedback: suggestionTextView.text ?? "") { _, _ in
            return
        }
        
        self.dismiss(animated: true) {
            // After we successfully submit this survey and dismiss the view, thank the user
            PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.surveyFeedbackAppExperienceTitle, forSubtitle: VisualConstant.BannerTextConstant.surveyFeedbackAppExperienceSubtitle, forStyle: .success)
        }
    }
    
    // MARK: - Properties
    
    /// An ordered array of the star buttons, where index 0 is 1 star and index 4 is 5 stars
    private var orderedStarButtons: [GeneralUIButton] {
        return [oneStarButton, twoStarButton, threeStarButton, fourStarButton, fiveStarButton]
    }
    
    private var storedIndexOfUserStarRating: Int?
    /// The index of what star the user rated Hound (1 star = 0 & 5 stars = 4)
    private var indexOfUserStarRating: Int? {
        get {
            return storedIndexOfUserStarRating
        }
        set {
            let oldValue = storedIndexOfUserStarRating
            storedIndexOfUserStarRating = newValue
            
            guard let indexOfUserStarRating = indexOfUserStarRating, oldValue != indexOfUserStarRating else {
                // The rating is being set to nil or the new rating is the same as the old rating, so clear all of the stars and the rating
                storedIndexOfUserStarRating = nil
               
                UIView.animate(withDuration: VisualConstant.AnimationConstant.toggleSelectUIElement) {
                    // A star isn't selected so the user can't submit
                    self.submitButton.isEnabled = false
                    self.orderedStarButtons.forEach { starButton in
                        starButton.isUserInteractionEnabled = false
                        starButton.setImage(UIImage(systemName: "star"), for: .normal)
                    }
                } completion: { _ in
                    self.orderedStarButtons.forEach { starButton in
                        starButton.isUserInteractionEnabled = true
                    }
                }
                return
            }
            
            // Find the number of stars the user rated
            // If the user rated 3 stars, then we want to change stars 1, 2, and 3 to being the selected filled star image, and change stars 4 and 5 to the unfilled star iamge
            let selectedStarButtons = indexOfUserStarRating >= orderedStarButtons.count ? orderedStarButtons : Array(orderedStarButtons.prefix(through: indexOfUserStarRating))
            let unselectedStarButtons = orderedStarButtons.filter { starButton in
                return selectedStarButtons.contains(starButton) == false
            }
            
            UIView.animate(withDuration: VisualConstant.AnimationConstant.toggleSelectUIElement) {
                // A star is selected so the user can now submit
                self.submitButton.isEnabled = true
                selectedStarButtons.forEach { selectedStarButton in
                    selectedStarButton.isUserInteractionEnabled = false
                    selectedStarButton.setImage(UIImage(systemName: "star.fill"), for: .normal)
                }
                unselectedStarButtons.forEach { unselectedStarButton in
                    unselectedStarButton.isUserInteractionEnabled = false
                    unselectedStarButton.setImage(UIImage(systemName: "star"), for: .normal)
                }
            } completion: { _ in
                selectedStarButtons.forEach { selectedStarButton in
                    selectedStarButton.isUserInteractionEnabled = true
                }
                unselectedStarButtons.forEach { unselectedStarButton in
                    unselectedStarButton.isUserInteractionEnabled = true
                }
            }
        }
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        // When this view controller is constructed, check that we requested survey feedback for app exp
        LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.append(Date())
        
        self.suggestionTextView.delegate = self
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBlue
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        scrollView.addSubview(containerView)
        
        // Setup stars stack
        orderedStarButtons.forEach { starButton in
            starsStackView.addArrangedSubview(starButton)
            starButton.addTarget(self, action: #selector(didTapStar), for: .touchUpInside)
        }
        
        // Add views to container
        containerView.addSubview(pageHeaderLabel)
        containerView.addSubview(backButton)
        containerView.addSubview(starsStackView)
        containerView.addSubview(descriptionLabel)
        containerView.addSubview(suggestionTextView)
        containerView.addSubview(submitButton)
        
        submitButton.addTarget(self, action: #selector(didTapSubmit), for: .touchUpInside)
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        // ScrollView
        NSLayoutConstraint.activate([
            scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            scrollView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor),
            scrollView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            scrollView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor)
        ])
        
        // ContainerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: scrollView.topAnchor),
            containerView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
            containerView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
            containerView.widthAnchor.constraint(equalTo: scrollView.widthAnchor)
        ])
        
        // HeaderLabel
        NSLayoutConstraint.activate([
            pageHeaderLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 15),
            pageHeaderLabel.centerXAnchor.constraint(equalTo: containerView.centerXAnchor),
            pageHeaderLabel.trailingAnchor.constraint(lessThanOrEqualTo: backButton.leadingAnchor, constant: -ConstraintConstant.Global.intraContentHoriInset)
        ])
        
        // backButton
        NSLayoutConstraint.activate([
            backButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: ConstraintConstant.Button.miniCircleInset),
            backButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Button.miniCircleInset),
            backButton.heightAnchor.constraint(equalTo: containerView.widthAnchor, multiplier: ConstraintConstant.Button.miniCircleHeightMultiplier).withPriority(.defaultHigh),
            backButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.miniCircleMaxHeight),
            backButton.createSquareConstraint()
        ])
        
        // StarsStackView
        NSLayoutConstraint.activate([
            starsStackView.topAnchor.constraint(equalTo: pageHeaderLabel.bottomAnchor, constant: 35),
            starsStackView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset * 2.0),
            starsStackView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset * 2.0),
        ])
        
        // Make all stars equal size and square
        for starButton in orderedStarButtons {
            NSLayoutConstraint.activate([
                starButton.heightAnchor.constraint(equalTo: containerView.widthAnchor, multiplier: ConstraintConstant.Button.miniCircleHeightMultiplier * 1.5).withPriority(.defaultHigh),
                starButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.miniCircleMaxHeight * 1.5),
                starButton.createSquareConstraint()
            ])
        }
        
        // DescriptionLabel
        NSLayoutConstraint.activate([
            descriptionLabel.topAnchor.constraint(equalTo: starsStackView.bottomAnchor, constant: 45),
            descriptionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            descriptionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])
        
        // SuggestionTextView
        NSLayoutConstraint.activate([
            suggestionTextView.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor, constant: 20),
            suggestionTextView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            suggestionTextView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            suggestionTextView.heightAnchor.constraint(equalTo: containerView.widthAnchor, multiplier: ConstraintConstant.Section.inputHeightMultiplier * 3.0).withPriority(.defaultHigh),
            suggestionTextView.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight * 3.0)
        ])
        
        // SubmitButton
        NSLayoutConstraint.activate([
            submitButton.topAnchor.constraint(equalTo: suggestionTextView.bottomAnchor, constant: 35),
            submitButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            submitButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            submitButton.heightAnchor.constraint(equalTo: submitButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            submitButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight),
            submitButton.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -15)
        ])
    }
}
//
//  LimitExceededViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/6/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED
class LimitExceededViewController: BluePawViewController {

    // MARK: - Elements
    
    private let upgradeSubscriptionOrBackButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 310, compressionResistancePriority: 310)
        
        button.setTitle("Upgrade Subscription", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
       
        return button
    }()
    
    @objc private func didTapPurchaseSubscriptionOrBack(_ sender: Any) {
        // Functionality of this button varies depending on if you are a family member or not
        if UserInformation.isUserFamilyHead {
            SettingsSubscriptionViewController.fetchProductsThenGetViewController { vc in
                guard let vc = vc else {
                    // Error message automatically handled
                    return
                }
                
                PresentationManager.enqueueViewController(vc)
            }
        }
        else {
            self.dismiss(animated: true)
        }
    }
    
    // MARK: - Properties
    
    /// By how many family members the family is exceeding its family member limit
    private var numberOfExceededFamilyMembers: Int {
        return FamilyInformation.familyMembers.count - FamilyInformation.familyActiveSubscription.numberOfFamilyMembers
    }
    
    /// Inside viewIsAppearing, if the family isn't exceeding its family member limit, then we will automatically dismiss the view. This helps track an edge case where the view may be dismissed on its first appearance when the user's local active family subscription is outdated
    private var isFirstTimeAppearing: Bool = true
    
    // MARK: - Main

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        headerLabel.text = "Family Member Limit Exceeded"
        
        if UserInformation.isUserFamilyHead {
            // We make the primary button allow the family head to purchase a subscription and enable a secondary button to allow them to dismiss
            upgradeSubscriptionOrBackButton.setTitle("Upgrade Subscription", for: .normal)
            backButton.isHidden = false
        }
        else {
            // We make the primary button the dismiss button for non family members
            upgradeSubscriptionOrBackButton.setTitle("Back", for: .normal)
            backButton.isHidden = true
        }
        
        descriptionLabel.text = {
            return ErrorConstant.FamilyResponseError.limitFamilyMemberExceeded(forRequestId: -1, forResponseId: -1).description
        }()
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard isFirstTimeAppearing == false else {
            isFirstTimeAppearing = false
            return
        }
        
        // If this isn't the views first time appearing, that means this view was presented, then likely another view appeared on top (e.g. the screen to buy a new subscription). Therefore, its possible the user bought a new subscription which would solve the issue of why this view controller was presented
        
        // Check if the user's family is in compliance now
        if numberOfExceededFamilyMembers <= 0 {
            self.dismiss(animated: true)
        }
    }

    // MARK: - Setup Elements

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(upgradeSubscriptionOrBackButton)
        
        upgradeSubscriptionOrBackButton.addTarget(self, action: #selector(didTapPurchaseSubscriptionOrBack), for: .touchUpInside)
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        // upgradeSubscriptionOrBackButton
        NSLayoutConstraint.activate([
            upgradeSubscriptionOrBackButton.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 35),
            upgradeSubscriptionOrBackButton.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            upgradeSubscriptionOrBackButton.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
            upgradeSubscriptionOrBackButton.createScreenWideHeightMultiplier(),
            upgradeSubscriptionOrBackButton.createScrenWideMaxHeight()
        ])
    }
}
//
//  LimitTooLowViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/6/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED
class LimitTooLowViewController: BluePawViewController {
    
    // MARK: - Elements
    
    private let bigBackButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.setTitle("Back", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 2
        button.borderColor = .label
        button.shouldRoundCorners = true
        
        button.shouldDismissParentViewController = true
        
        return button
    }()
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        backButton.isHidden = true
        headerLabel.text = "Hound+ Subscription Needed"
        descriptionLabel.text = "You're trying to join a Hound family with a limited number of family members! Please have the family head upgrade to a Hound+ subscription before attempting to join."
    }
    
    // MARK: - Setup Elements
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(bigBackButton)
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // backButton
        NSLayoutConstraint.activate([
            bigBackButton.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 35),
            bigBackButton.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            bigBackButton.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
            bigBackButton.createScreenWideHeightMultiplier(),
            bigBackButton.createScrenWideMaxHeight()
        ])
    }
}
//
//  LogsViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/17/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol LogsViewControllerDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager)
}

final class LogsViewController: GeneralUIViewController,
                                UIGestureRecognizerDelegate,
                                LogsTableViewControllerDelegate,
                                LogsAddLogDelegate,
                                LogsFilterDelegate {
    
    // MARK: - UIGestureRecognizerDelegate
    
    /// Allow multiple gesture recognizers to be recognized at once
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer,
                           shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
    // MARK: - LogsAddLogDelegate & LogsTableViewControllerDelegate
    
    /// Called when the dogManager is updated from add-log or table view
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager) {
        setDogManager(sender: sender, forDogManager: forDogManager)
    }
    
    // MARK: - LogsTableViewControllerDelegate
    
    /// Called when a log is selected in the table view
    func didSelectLog(forDogUUID: UUID, forLog: Log) {
        let vc = LogsAddLogViewController()
        logsAddLogViewController = vc
        vc.setup(
            forDelegate: self,
            forDogManager: self.dogManager,
            forDogUUIDToUpdate: forDogUUID,
            forLogToUpdate: forLog
        )
        PresentationManager.enqueueViewController(vc)
    }
    
    /// Show or hide the “No logs recorded” label, and update its text based on dog count
    func shouldUpdateNoLogsRecorded(forIsHidden: Bool) {
        noLogsRecordedLabel.isHidden = forIsHidden
        if dogManager.dogs.isEmpty {
            noLogsRecordedLabel.text = "No logs recorded! Try creating a dog and adding some logs to it..."
        }
        else if dogManager.dogs.count == 1, let dog = dogManager.dogs.first {
            noLogsRecordedLabel.text = "No logs recorded! Try adding some to \(dog.dogName)..."
        }
        else {
            noLogsRecordedLabel.text = "No logs recorded! Try adding some to one of your dogs..."
        }
    }
    
    /// Adjust button alphas and hide/show based on scroll offset and log availability
    func shouldUpdateAlphaForButtons(forAlpha: Double) {
        addLogButton.alpha = forAlpha
        exportLogsButton.alpha = forAlpha
        filterLogsButton.alpha = forAlpha
        
        addLogButton.isHidden = (addLogButton.alpha == 0.0) || dogManager.dogs.isEmpty
        exportLogsButton.isHidden = (exportLogsButton.alpha == 0.0) || !familyHasAtLeastOneLog
        shouldUpdateFilterLogsButton()
    }
    
    /// Update filter button’s hidden state after filter values change
    func shouldUpdateFilterLogsButton() {
        // In addition to other logic, hide filterLogsButton if there is ≤1 available in all filter categories
        filterLogsButton.isHidden = (filterLogsButton.alpha == 0.0)
        || !familyHasAtLeastOneLog
        || ((logsTableViewController.logsFilter.availableDogs.count) <= 1
            && (logsTableViewController.logsFilter.availableLogActions.count) <= 1
            && (logsTableViewController.logsFilter.availableFamilyMembers.count) <= 1)
    }
    
    // MARK: - LogsFilterDelegate
    
    /// Pass updated filter to the logs table view controller
    func didUpdateLogsFilter(forLogsFilter: LogsFilter) {
        logsTableViewController.logsFilter = forLogsFilter
    }
    
    // MARK: - Elements
    
    /// Container view to hold background or other layering (was UIContainerView in storyboard)
    private let logsTableViewController: LogsTableViewController = LogsTableViewController()
    
    /// Label displayed when no logs exist; hidden by default
    private let noLogsRecordedLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.isHidden = true
        label.text = "No logs recorded! Try creating some..."
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBlue
        return label
    }()
    
    private let addLogButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 260, compressionResistancePriority: 260)
        
        button.setImage(UIImage(systemName: "plus.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.tintColor = .systemBlue
        button.backgroundCircleTintColor = .secondarySystemBackground
        return button
    }()
    
    /// Button to present filter UI; tint color and background set
    private let filterLogsButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 240, compressionResistancePriority: 240)
        
        button.tintColor = .systemBlue
        button.setImage(
            UIImage(systemName: "line.3.horizontal.decrease.circle.fill"),
            for: .normal
        )
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .secondarySystemBackground
        return button
    }()
    
    /// Button to export logs; tint color and background set
    private let exportLogsButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBlue
        button.setImage(
            UIImage(systemName: "square.and.arrow.up.circle.fill"),
            for: .normal
        )
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .secondarySystemBackground
        return button
    }()
    
    /// Action for the export logs button; collects all logs and invokes export manager
    @objc private func didTouchUpInsideExportLogs(_ sender: Any) {
        var dogUUIDLogTuples: [(UUID, Log)] = []
        
        // Flatten the 2D array into a single array
        logsTableViewController.logsForDogUUIDsGroupedByDate.forEach {
            dogUUIDLogTuples += $0
        }
        
        ExportActivityViewManager.exportLogs(forDogUUIDLogTuples: dogUUIDLogTuples)
    }
    
    // MARK: - Properties
    
    /// Returns true if at least one dog has at least one log
    private var familyHasAtLeastOneLog: Bool {
        var containsAtLeastOneLog = false
        dogManager.dogs.forEach { dog in
            if dog.dogLogs.dogLogs.isEmpty == false {
                containsAtLeastOneLog = true
            }
        }
        return containsAtLeastOneLog
    }
    
    private var logsAddLogViewController: LogsAddLogViewController?
    
    private var logsFilterViewController: LogsFilterViewController?
    
    private weak var delegate: LogsViewControllerDelegate?
    
    // MARK: - Dog Manager
    
    private(set) var dogManager: DogManager = DogManager()
    
    /// Set the dogManager and update UI elements and child controllers
    func setDogManager(sender: Sender, forDogManager: DogManager) {
        dogManager = forDogManager
        
        addLogButton.isHidden = dogManager.dogs.isEmpty
        exportLogsButton.isHidden = !familyHasAtLeastOneLog
        filterLogsButton.isHidden = !familyHasAtLeastOneLog
        
        if (sender.localized is LogsTableViewController) == false {
            logsTableViewController.setDogManager(
                sender: Sender(origin: sender, localized: self),
                forDogManager: dogManager
            )
        }
        if (sender.localized is MainTabBarController) == true {
            if logsAddLogViewController?.viewIfLoaded?.window == nil {
                // If add‐log VC isn’t currently visible, dismiss it when dog data changes
                logsAddLogViewController?.dismiss(animated: true)
            }
            // Dismiss filter VC if data changes, so filters remain valid
            logsFilterViewController?.dismiss(animated: true)
        }
        if (sender.localized is MainTabBarController) == false {
            delegate?.didUpdateDogManager(
                sender: Sender(origin: sender, localized: self),
                forDogManager: dogManager
            )
        }
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        logsTableViewController.setup(forDelegate: self)
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: LogsViewControllerDelegate) {
        self.delegate = forDelegate
    }
    
    // MARK: - Functions
    
    func scrollLogsTableViewControllerToTop() {
        guard let y = logsTableViewController.referenceContentOffsetY else {
            return
        }
        logsTableViewController.tableView?.setContentOffset(CGPoint(x: 0, y: y), animated: true)
    }
    
    // MARK: - Setup Elements
    
    /// Add all subviews and set up targets
    override func setupGeneratedViews() {
        view.backgroundColor = .secondarySystemBackground
        super.setupGeneratedViews()
    }
    
    /// Add subviews and attach button targets immediately after each view is added
    override func addSubViews() {
        super.addSubViews()
        embedChild(logsTableViewController)
        
        view.addSubview(noLogsRecordedLabel)
        view.addSubview(addLogButton)
        view.addSubview(filterLogsButton)
        view.addSubview(exportLogsButton)
        
        let addLogAction = UIAction { [weak self] _ in
            guard let self = self else { return }
            
            let vc = LogsAddLogViewController()
            vc.setup(forDelegate: self, forDogManager: dogManager, forDogUUIDToUpdate: nil, forLogToUpdate: nil)
            PresentationManager.enqueueViewController(vc)
        }
        addLogButton.addAction(addLogAction, for: .touchUpInside)
        
        let filterLogsAction = UIAction { [weak self] _ in
            guard let self = self else { return }
            
            let vc = LogsFilterViewController()
            vc.setup(forDelegate: self, forFilter: logsTableViewController.logsFilter)
            PresentationManager.enqueueViewController(vc)
        }
        filterLogsButton.addAction(filterLogsAction, for: .touchUpInside)
        
        exportLogsButton.addTarget(
            self,
            action: #selector(didTouchUpInsideExportLogs),
            for: .touchUpInside
        )
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // logsTableViewController.view
        let logsTableViewTop = logsTableViewController.view.topAnchor.constraint(equalTo: view.topAnchor)
        let logsTableViewBottom = logsTableViewController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        let logsTableViewLeading = logsTableViewController.view.leadingAnchor.constraint(equalTo: view.leadingAnchor)
        let logsTableViewTrailing = logsTableViewController.view.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        
        // addLogButton
        let addLogButtonBottom = addLogButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -ConstraintConstant.Button.circleInset)
        let addLogButtonTrailing = addLogButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Button.circleInset)
        let addLogButtonWidthMultiplier = addLogButton.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Button.circleHeightMultiplier)
        addLogButtonWidthMultiplier.priority = .defaultHigh
        let addLogButtonMaxWidth = addLogButton.widthAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.circleMaxHeight)
        let addLogButtonSquare = addLogButton.createSquareConstraint()
        
        // exportLogsButton
        let exportLogsButtonTop = exportLogsButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: ConstraintConstant.Button.miniCircleInset)
        let exportLogsButtonTrailing = exportLogsButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Button.miniCircleInset)
        let exportLogsButtonWidth = exportLogsButton.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Button.miniCircleHeightMultiplier)
        let exportLogsButtonMaxWidth = exportLogsButton.widthAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.miniCircleMaxHeight)
        let exportLogsButtonSquare = exportLogsButton.createSquareConstraint()
        
        // filterLogsButton
        let filterLogsButtonTop = filterLogsButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: ConstraintConstant.Button.miniCircleInset)
        let filterLogsButtonTrailing = filterLogsButton.trailingAnchor.constraint(equalTo: exportLogsButton.leadingAnchor, constant: -ConstraintConstant.Button.miniCircleInset)
        let filterLogsButtonWidth = filterLogsButton.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Button.miniCircleHeightMultiplier)
        let filterLogsButtonMaxWidth = filterLogsButton.widthAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.miniCircleMaxHeight)
        let filterLogsButtonSquare = filterLogsButton.createSquareConstraint()
        
        // noLogsRecordedLabel
        let noLogsRecordedLabelLeading = noLogsRecordedLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let noLogsRecordedLabelTrailing = noLogsRecordedLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let noLogsRecordedLabelCenterY = noLogsRecordedLabel.centerYAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerYAnchor)
        
        NSLayoutConstraint.activate([
            // logsTableViewController.view
            logsTableViewTop, logsTableViewBottom, logsTableViewLeading, logsTableViewTrailing,
            
            // addLogButton
            addLogButtonBottom, addLogButtonTrailing, addLogButtonSquare, addLogButtonWidthMultiplier, addLogButtonMaxWidth,
            
            // exportLogsButton
            exportLogsButtonTop, exportLogsButtonTrailing, exportLogsButtonWidth, exportLogsButtonMaxWidth, exportLogsButtonSquare,
            
            // filterLogsButton
            filterLogsButtonTop, filterLogsButtonTrailing, filterLogsButtonWidth, filterLogsButtonMaxWidth, filterLogsButtonSquare,
            
            // noLogsRecordedLabel
            noLogsRecordedLabelLeading, noLogsRecordedLabelTrailing, noLogsRecordedLabelCenterY
        ])
    }
}
//
//  LogsFilterViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/20/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol LogsFilterDelegate: AnyObject {
    func didUpdateLogsFilter(forLogsFilter: LogsFilter)
}

class LogsFilterViewController: GeneralUIViewController, DropDownUIViewDataSource {
    
    // MARK: - Elements
    
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        scrollView.bounces = false
        scrollView.bouncesZoom = false
        
        return scrollView
    }()
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        return view
    }()
    
    /// We use this padding so that the content inside the scroll view is ≥ the size of the safe area.
    /// If it is not, then the drop down menus will clip outside the content area, displaying on the lower half
    /// of the region but being un-interactable because they are outside the containerView.
    private weak var containerViewExtraPaddingHeight: NSLayoutConstraint!
    private let containerViewExtraPadding: GeneralUIView = {
        let view = GeneralUIView()
        view.isHidden = true
        return view
    }()
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.text = "Filter"
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        return label
    }()
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 310, compressionResistancePriority: 310)
        button.tintColor = .label
        button.setImage(UIImage(systemName: "xmark.circle"), for: .normal)
        button.shouldRoundCorners = true
        button.backgroundCircleTintColor = .systemBackground
        
        button.shouldDismissParentViewController = true
        return button
    }()
    
    
    /// We use this padding so that the content inside the scroll view is >= the size of the safe area. If it is not, then the drop down menus will clip outside the content area, displaying on the lower half of the region but being un-interactable because they are outside the containerView
    private let dogsLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.text = "Dogs"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let filterDogsLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        label.shouldRoundCorners = true
        return label
    }()
    
    private let logActionsLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.text = "Actions"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let filterLogActionsLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 260, compressionResistancePriority: 260)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        label.shouldRoundCorners = true
        return label
    }()
    
    private let familyMembersLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "Family Members"
        label.font = VisualConstant.FontConstant.secondaryHeaderLabel
        return label
    }()
    
    private let filterFamilyMembersLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 240, compressionResistancePriority: 240)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        label.shouldRoundCorners = true
        return label
    }()
    
    private let alignmentViewForClearButton: GeneralUIView = {
        let view = GeneralUIView(huggingPriority: 220, compressionResistancePriority: 220)
        view.isHidden = true
        return view
    }()
    
    private let clearButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 220, compressionResistancePriority: 220)
        
        button.setTitle("Clear", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderColor = .label
        button.borderWidth = 2
        button.shouldRoundCorners = true
        
        button.shouldDismissParentViewController = true
        
        return button
    }()
    
    private let applyButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 230, compressionResistancePriority: 230)
        
        button.setTitle("Apply", for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBlue
        
        button.shouldRoundCorners = true
        
        button.shouldDismissParentViewController = true
        return button
    }()
    
    // appleFilterButton and clearFilterButton both are set to dismiss the view when tapped. Additionally, when the view will disappear, the filter's current state is sent through the delegate. Therefore, we don't need to do any additional logic (other than clearing the filter for the clear button).
    
    @objc private func didTapClearFilter(_ sender: Any) {
        filter?.clearAll()
    }
    
    // MARK: - Properties
    
    private weak var delegate: LogsFilterDelegate?
    private lazy var uiDelegate = LogsFilterUIInteractionDelegate()
    
    private var dropDownFilterDogs: DropDownUIView?
    private var dropDownFilterLogActions: DropDownUIView?
    private var dropDownFilterFamilyMembers: DropDownUIView?
    private var filter: LogsFilter?
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        filterDogsLabel.placeholder = "Select a dog (or dogs)..."
        filterLogActionsLabel.placeholder = "Select an action (or actions)..."
        filterFamilyMembersLabel.placeholder = "Select a family member (or members)..."
        
        updateDynamicUIElements()
    }
    
    private var didSetupCustomSubviews: Bool = false
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard didSetupCustomSubviews == false else {
            return
        }
        
        didSetupCustomSubviews = true
        
        updateDynamicUIElements()
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        guard let filter = filter else {
            return
        }
        
        delegate?.didUpdateLogsFilter(forLogsFilter: filter)
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: LogsFilterDelegate, forFilter: LogsFilter) {
        delegate = forDelegate
        filter = forFilter
    }
    
    // MARK: - Functions
    
    private func updateDynamicUIElements() {
        if let filter = filter, filter.filterDogs.count >= 1 {
            filterDogsLabel.text = {
                if filter.filterDogs.count == 1, let lastRemainingDog = filter.filterDogs.first {
                    // The user only has one dog selected to filter by
                    return lastRemainingDog.dogName
                }
                else if filter.filterDogs.count > 1 && filter.filterDogs.count < filter.availableDogs.count {
                    // The user has multiple, but not all, dogs selected to filter by
                    return "Multiple"
                }
                
                // The user has all dogs selected to filter by
                return "All"
            }()
        }
        else {
            // The user has no dogs selected to filter by, so we interpret this as including all dogs in the filter
            filterDogsLabel.text = nil
        }
        if let filter = filter, filter.filterLogActions.count >= 1 {
            filterLogActionsLabel.text = {
                if filter.filterLogActions.count == 1, let lastRemainingLogAction = filter.filterLogActions.first {
                    // The user only has one log action selected to filter by
                    return lastRemainingLogAction.convertToReadableName(customActionName: nil, includeMatchingEmoji: true)
                }
                else if filter.filterLogActions.count > 1 && filter.filterLogActions.count < filter.availableLogActions.count {
                    // The user has multiple, but not all, log actions selected to filter by
                    return "Multiple"
                }
                
                // The user has all log actions selected to filter by
                return "All"
            }()
        }
        else {
            // The user has no log actions selected to filter by, so we interpret this as including all log actions in the filter
            filterLogActionsLabel.text = nil
        }
        if let filter = filter, filter.filterFamilyMembers.count >= 1 {
            filterFamilyMembersLabel.text = {
                if filter.filterFamilyMembers.count == 1, let lastRemainingFamilyMember = filter.filterFamilyMembers.first {
                    // The user only has one family member selected to filter by
                    return lastRemainingFamilyMember.displayFullName ?? VisualConstant.TextConstant.unknownName
                }
                else if filter.filterFamilyMembers.count > 1 && filter.filterFamilyMembers.count < filter.availableFamilyMembers.count {
                    // The user has multiple, but not all, family members selected to filter by
                    return "Multiple"
                }
                
                // The user has all family members selected to filter by
                return "All"
            }()
        }
        else {
            // The user has no family member selected to filter by, so we interpret this as including all family members in the filter
            filterFamilyMembersLabel.text = nil
        }
        
        self.view.setNeedsLayout()
        self.view.layoutIfNeeded()
        
        // Adjust containerView padding so content fills safe area
        let containerHeightWithoutPadding = self.containerView.frame.height - self.containerViewExtraPaddingHeight.constant
        let shortfall = self.view.safeAreaLayoutGuide.layoutFrame.height - containerHeightWithoutPadding
        self.containerViewExtraPaddingHeight.constant = max(shortfall, 0.0)
    }
    
    // MARK: Drop Down
    
    @objc private func didTapScreen(sender: UITapGestureRecognizer) {
        guard let senderView = sender.view else {
            return
        }
        
        let originalTouchPoint = sender.location(in: senderView)
        
        guard let deepestTouchedView = senderView.hitTest(originalTouchPoint, with: nil) else {
            return
        }
        
        // If the dropDown exist, then we might have to possibly hide it. The only case where we wouldn't want to collapse the drop down is if we click the dropdown itself or its corresponding label
        if let dropDownFilterDogs = dropDownFilterDogs, deepestTouchedView.isDescendant(of: filterDogsLabel) == false && deepestTouchedView.isDescendant(of: dropDownFilterDogs) == false {
            dropDownFilterDogs.hideDropDown(animated: true)
        }
        if let dropDownFilterLogActions = dropDownFilterLogActions, deepestTouchedView.isDescendant(of: filterLogActionsLabel) == false && deepestTouchedView.isDescendant(of: dropDownFilterLogActions) == false {
            dropDownFilterLogActions.hideDropDown(animated: true)
        }
        if let dropDownFilterFamilyMembers = dropDownFilterFamilyMembers, deepestTouchedView.isDescendant(of: filterFamilyMembersLabel) == false && deepestTouchedView.isDescendant(of: dropDownFilterFamilyMembers) == false {
            dropDownFilterFamilyMembers.hideDropDown(animated: true)
        }
    }
    
    @objc private func didTapLabelForDropDown(sender: UITapGestureRecognizer) {
        guard let name = sender.name, let targetDropDownType = LogsFilterDropDownTypes(rawValue: name) else {
            return
        }
        
        let targetDropDown = dropDown(forDropDownType: targetDropDownType)
        
        if (targetDropDown?.isDown ?? false) == false {
            showDropDown(targetDropDownType, animated: true)
        }
        else {
            targetDropDown?.hideDropDown(animated: true)
        }
    }
    
    /// For a given LogsFilterDropDownTypes, return the corresponding dropDown object
    private func dropDown(forDropDownType: LogsFilterDropDownTypes) -> DropDownUIView? {
        switch forDropDownType {
        case .filterDogs:
            return dropDownFilterDogs
        case .filterLogActions:
            return dropDownFilterLogActions
        case .filterFamilyMembers:
            return dropDownFilterFamilyMembers
        }
    }
    
    /// For a given LogsFilterDropDownTypes, return the corresponding label that shows the dropdown
    private func labelForDropDown(forDropDownType: LogsFilterDropDownTypes) -> GeneralUILabel {
        switch forDropDownType {
        case .filterDogs:
            return filterDogsLabel
        case .filterLogActions:
            return filterLogActionsLabel
        case .filterFamilyMembers:
            return filterFamilyMembersLabel
        }
    }
    
    /// Dismisses the keyboard and other dropdowns to show filterDogsLabel
    private func showDropDown(_ dropDownType: LogsFilterDropDownTypes, animated: Bool) {
        var targetDropDown = dropDown(forDropDownType: dropDownType)
        let labelForTargetDropDown = labelForDropDown(forDropDownType: dropDownType)
        
        if targetDropDown == nil {
            targetDropDown = DropDownUIView()
            if let targetDropDown = targetDropDown {
                targetDropDown.setupDropDown(
                    forDropDownUIViewIdentifier: dropDownType.rawValue,
                    forDataSource: self,
                    forViewPositionReference: labelForTargetDropDown.frame,
                    forOffset: 2.5,
                    forRowHeight: DropDownUIView.rowHeightForGeneralUILabel
                )
                
                // Assign our actual drop down variable to the local variable drop down we just created
                switch dropDownType {
                case .filterDogs:
                    dropDownFilterDogs = targetDropDown
                case .filterLogActions:
                    dropDownFilterLogActions = targetDropDown
                case .filterFamilyMembers:
                    dropDownFilterFamilyMembers = targetDropDown
                }
                
                // All of our dropDowns ordered by priority, where the lower the index views should be displayed over the higher index views
                let dropDownsOrderedByPriority: [DropDownUIView?] = {
                    return [dropDownFilterDogs, dropDownFilterLogActions, dropDownFilterFamilyMembers]
                }()
                let indexOfTargetDropDown = dropDownsOrderedByPriority.firstIndex(of: targetDropDown)
                
                if let superview = labelForTargetDropDown.superview, let indexOfTargetDropDown = indexOfTargetDropDown {
                    var didInsertSubview = false
                    // Iterate through dropDownsOrderedByPriority backwards, starting at our drop down. If the next nearest dropdown exists, then insert our dropdown below it
                    // E.g. targetDropDown = dropDownLogStartDate -> dropDownLogUnit doesn't exist yet -> dropDownFilterLogActions exists so insert subview directly below it
                    // Insert the target drop down view above all lower indexed (and thus lower priority) drop downs.
                    
                    for i in (0..<indexOfTargetDropDown).reversed() {
                        if let nearestHigherPriorityDropDown = dropDownsOrderedByPriority[i] {
                            superview.insertSubview(targetDropDown, belowSubview: nearestHigherPriorityDropDown)
                            didInsertSubview = true
                            break
                        }
                    }
                    
                    if didInsertSubview == false {
                        // If no lower priority drop downs are visible, add it normally
                        superview.addSubview(targetDropDown)
                    }
                }
            }
        }
        
        // Dynamically show the target dropDown
        targetDropDown?.showDropDown(
            // Either show a maximum of 6.5 rows or the number of rows specified below
            numberOfRowsToShow: min(6.5, {
                switch dropDownType {
                case .filterDogs:
                    return CGFloat(filter?.availableDogs.count ?? 0)
                case .filterLogActions:
                    return CGFloat(filter?.availableLogActions.count ?? 0)
                case .filterFamilyMembers:
                    return CGFloat(filter?.availableFamilyMembers.count ?? 0)
                }
            }()),
            animated: animated
        )
    }
    
    // MARK: - Drop Down Data Source
    
    func setupCellForDropDown(cell: UITableViewCell, indexPath: IndexPath, dropDownUIViewIdentifier: String) {
        guard let filter = filter, let customCell = cell as? DropDownTVC else {
            return
        }
        
        customCell.adjustLeadingTrailing(newConstant: DropDownUIView.insetForGeneralUILabel)
        
        if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterDogs.rawValue {
            let dog = filter.availableDogs[indexPath.row]
            
            customCell.setCustomSelectedTableViewCell(forSelected: filter.filterDogs.contains(where: {$0.dogUUID == dog.dogUUID}))
            customCell.label.text = dog.dogName
        }
        else if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterLogActions.rawValue {
            let logActionType = filter.availableLogActions[indexPath.row]
            
            customCell.setCustomSelectedTableViewCell(forSelected: filter.filterLogActions.contains(where: {$0 == logActionType}))
            customCell.label.text = logActionType.convertToReadableName(customActionName: nil, includeMatchingEmoji: true)
        }
        else if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterFamilyMembers.rawValue {
            let familyMember = filter.availableFamilyMembers[indexPath.row]
            
            customCell.setCustomSelectedTableViewCell(forSelected: filter.filterFamilyMembers.contains(where: {$0.userId == familyMember.userId}))
            customCell.label.text = familyMember.displayFullName ?? VisualConstant.TextConstant.unknownName
        }
    }
    
    func numberOfRows(forSection: Int, dropDownUIViewIdentifier: String) -> Int {
        guard let filter = filter else {
            return 0
        }
        
        if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterDogs.rawValue {
            return filter.availableDogs.count
        }
        else if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterLogActions.rawValue {
            return filter.availableLogActions.count
        }
        else if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterFamilyMembers.rawValue {
            return filter.availableFamilyMembers.count
        }
        
        return 0
    }
    
    func numberOfSections(dropDownUIViewIdentifier: String) -> Int {
        if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterDogs.rawValue {
            return 1
        }
        else if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterLogActions.rawValue {
            return 1
        }
        else if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterFamilyMembers.rawValue {
            return 1
        }
        
        return 0
    }
    
    func selectItemInDropDown(indexPath: IndexPath, dropDownUIViewIdentifier: String) {
        guard let filter = filter else {
            return
        }
        
        if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterDogs.rawValue, let selectedCell = dropDownFilterDogs?.dropDownTableView?.cellForRow(at: indexPath) as? DropDownTVC {
            let dogSelected = filter.availableDogs[indexPath.row]
            let beforeSelectNumberOfDogsSelected = filter.availableDogs.count
            
            if selectedCell.isCustomSelected == true {
                // The user has unselected a dog, remove it from our array
                filter.apply(forFilterDogs: filter.filterDogs.filter { filterDog in
                    return filterDog.dogUUID != dogSelected.dogUUID
                })
            }
            else {
                // The user has selected a parent dog, add it to our array
                filter.apply(forFilterDogs: filter.filterDogs + [dogSelected])
            }
            
            selectedCell.setCustomSelectedTableViewCell(forSelected: !selectedCell.isCustomSelected)
            
            if beforeSelectNumberOfDogsSelected == 0 {
                // If initially, there were no dogs selected, then the user selected their first dog, we immediately hide this drop down. We assume they only want to filter by one dog, though they could do more
                dropDownFilterDogs?.hideDropDown(animated: true)
            }
            else if filter.filterDogs.count == filter.availableDogs.count {
                // selected every dog in the drop down, close the drop down
                dropDownFilterDogs?.hideDropDown(animated: true)
            }
        }
        else if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterLogActions.rawValue, let selectedCell = dropDownFilterLogActions?.dropDownTableView?.cellForRow(at: indexPath) as? DropDownTVC {
            let logActionSelected = filter.availableLogActions[indexPath.row]
            let beforeSelectNumberOfLogActionsSelected = filter.availableLogActions.count
            
            if selectedCell.isCustomSelected == true {
                // The user has unselected a log action, remove it from our array
                filter.apply(forFilterLogActions: filter.filterLogActions.filter { filterLogAction in
                    return filterLogAction != logActionSelected
                })
            }
            else {
                // The user has selected a log action, add it to our array
                filter.apply(forFilterLogActions: filter.filterLogActions + [logActionSelected])
            }
            
            selectedCell.setCustomSelectedTableViewCell(forSelected: !selectedCell.isCustomSelected)
            
            if beforeSelectNumberOfLogActionsSelected == 0 {
                // If initially, there were no log actions selected, then the user selected their first log action, we immediately hide this drop down. We assume they only want to filter by one log action, though they could do more
                dropDownFilterLogActions?.hideDropDown(animated: true)
            }
            else if filter.filterLogActions.count == filter.availableLogActions.count {
                // selected every log action in the drop down, close the drop down
                dropDownFilterLogActions?.hideDropDown(animated: true)
            }
        }
        else if dropDownUIViewIdentifier == LogsFilterDropDownTypes.filterFamilyMembers.rawValue, let selectedCell = dropDownFilterFamilyMembers?.dropDownTableView?.cellForRow(at: indexPath) as? DropDownTVC {
            let familyMemberSelected = filter.availableFamilyMembers[indexPath.row]
            let beforeSelectNumberOfFamilyMembersSelected = filter.availableFamilyMembers.count
            
            if selectedCell.isCustomSelected == true {
                // The user has unselected a family member, remove it from our array
                filter.apply(forFilterFamilyMembers: filter.filterFamilyMembers.filter { filterFamilyMember in
                    return filterFamilyMember.userId != familyMemberSelected.userId
                })
            }
            else {
                // The user has selected a family member, add it to our array
                filter.apply(forFilterFamilyMembers: filter.filterFamilyMembers + [familyMemberSelected])
            }
            
            selectedCell.setCustomSelectedTableViewCell(forSelected: !selectedCell.isCustomSelected)
            
            if beforeSelectNumberOfFamilyMembersSelected == 0 {
                // If initially, there were no family members selected, then the user selected their first family member, we immediately hide this drop down. We assume they only want to filter by one family member, though they could do more
                dropDownFilterFamilyMembers?.hideDropDown(animated: true)
            }
            else if filter.filterFamilyMembers.count == filter.availableFamilyMembers.count {
                // selected every family member in the drop down, close the drop down
                dropDownFilterFamilyMembers?.hideDropDown(animated: true)
            }
        }
        
        // Once the selection update is done, then update the UI
        updateDynamicUIElements()
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        scrollView.addSubview(containerView)
        
        containerView.addSubview(headerLabel)
        containerView.addSubview(backButton)
        containerView.addSubview(filterDogsLabel)
        containerView.addSubview(dogsLabel)
        containerView.addSubview(filterLogActionsLabel)
        containerView.addSubview(logActionsLabel)
        containerView.addSubview(filterFamilyMembersLabel)
        containerView.addSubview(familyMembersLabel)
        containerView.addSubview(alignmentViewForClearButton)
        containerView.addSubview(clearButton)
        containerView.addSubview(applyButton)
        containerView.addSubview(containerViewExtraPadding)
        
        let didTapScreenGesture = UITapGestureRecognizer(target: self, action: #selector(didTapScreen(sender:)))
        didTapScreenGesture.delegate = uiDelegate
        didTapScreenGesture.cancelsTouchesInView = false
        view.addGestureRecognizer(didTapScreenGesture)
        
        let filterDogsLabelGesture = UITapGestureRecognizer(target: self, action: #selector(didTapLabelForDropDown(sender:)))
        filterDogsLabelGesture.name = LogsFilterDropDownTypes.filterDogs.rawValue
        filterDogsLabelGesture.delegate = uiDelegate
        filterDogsLabelGesture.cancelsTouchesInView = false
        filterDogsLabel.isUserInteractionEnabled = true
        filterDogsLabel.addGestureRecognizer(filterDogsLabelGesture)
        
        let filterLogActionsLabelGesture = UITapGestureRecognizer(target: self, action: #selector(didTapLabelForDropDown(sender:)))
        filterLogActionsLabelGesture.name = LogsFilterDropDownTypes.filterLogActions.rawValue
        filterLogActionsLabelGesture.delegate = uiDelegate
        filterLogActionsLabelGesture.cancelsTouchesInView = false
        filterLogActionsLabel.isUserInteractionEnabled = true
        filterLogActionsLabel.addGestureRecognizer(filterLogActionsLabelGesture)
        
        let filterFamilyMembersLabelGesture = UITapGestureRecognizer(target: self, action: #selector(didTapLabelForDropDown(sender:)))
        filterFamilyMembersLabelGesture.name = LogsFilterDropDownTypes.filterFamilyMembers.rawValue
        filterFamilyMembersLabelGesture.delegate = uiDelegate
        filterFamilyMembersLabelGesture.cancelsTouchesInView = false
        filterFamilyMembersLabel.isUserInteractionEnabled = true
        filterFamilyMembersLabel.addGestureRecognizer(filterFamilyMembersLabelGesture)
        
        clearButton.addTarget(self, action: #selector(didTapClearFilter), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // scrollView
        NSLayoutConstraint.activate([
            scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            scrollView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            scrollView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
            scrollView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        ])

        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: scrollView.topAnchor),
            containerView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
            containerView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
            containerView.widthAnchor.constraint(equalTo: scrollView.widthAnchor)
        ])

        // headerLabel
        let headerLabelHeightMultiplier = headerLabel.heightAnchor.constraint(
            equalTo: view.widthAnchor,
            multiplier: ConstraintConstant.PageHeader.labelHeightMultipler
        ).withPriority(.defaultHigh)
        NSLayoutConstraint.activate([
            headerLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: ConstraintConstant.Global.contentVertInset),
            headerLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            headerLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.PageHeader.labelMaxHeight),
            headerLabelHeightMultiplier
        ])

        // backButton
        NSLayoutConstraint.activate([
            backButton.topAnchor.constraint(equalTo: containerView.topAnchor, constant: ConstraintConstant.Button.miniCircleInset),
            backButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Button.miniCircleInset),
            backButton.heightAnchor.constraint(equalTo: view.widthAnchor, multiplier: ConstraintConstant.Button.miniCircleHeightMultiplier).withPriority(.defaultHigh),
            backButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.miniCircleMaxHeight),
            backButton.createSquareConstraint()
        ])

        // dogsLabel
        let dogsLabelHeightMultiplier = dogsLabel.heightAnchor.constraint(
            equalTo: view.widthAnchor,
            multiplier: ConstraintConstant.Section.sectionTitleHeightMultipler
        ).withPriority(.defaultHigh)
        let dogsLabelBottomConstraint = filterDogsLabel.topAnchor.constraint(equalTo: dogsLabel.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing)
        NSLayoutConstraint.activate([
            dogsLabel.topAnchor.constraint(equalTo: headerLabel.bottomAnchor, constant: 20),
            dogsLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            dogsLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            dogsLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.sectionTitleMaxHeight),
            dogsLabelHeightMultiplier,
            dogsLabelBottomConstraint
        ])

        // Dogs Input Label
        let filterDogsHeightMultiplier = filterDogsLabel.heightAnchor.constraint(
            equalTo: view.widthAnchor,
            multiplier: ConstraintConstant.Section.inputHeightMultiplier
        ).withPriority(.defaultHigh)
        NSLayoutConstraint.activate([
            filterDogsLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            filterDogsLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            filterDogsLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight),
            filterDogsHeightMultiplier
        ])
        let filterDogsBottomConstraint = logActionsLabel.topAnchor.constraint(equalTo: filterDogsLabel.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing)
        filterDogsBottomConstraint.isActive = true

        // logActionsLabel
        let logActionsLabelHeightMultiplier = logActionsLabel.heightAnchor.constraint(
            equalTo: view.widthAnchor,
            multiplier: ConstraintConstant.Section.sectionTitleHeightMultipler
        ).withPriority(.defaultHigh)
        NSLayoutConstraint.activate([
            logActionsLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            logActionsLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            logActionsLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.sectionTitleMaxHeight),
            logActionsLabelHeightMultiplier
        ])
        let logActionsLabelBottomConstraint = filterLogActionsLabel.topAnchor.constraint(equalTo: logActionsLabel.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing)
        logActionsLabelBottomConstraint.isActive = true

        // filterLogActionsLabel
        let filterLogActionsHeightMultiplier = filterLogActionsLabel.heightAnchor.constraint(
            equalTo: view.widthAnchor,
            multiplier: ConstraintConstant.Section.inputHeightMultiplier
        ).withPriority(.defaultHigh)
        NSLayoutConstraint.activate([
            filterLogActionsLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            filterLogActionsLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            filterLogActionsLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight),
            filterLogActionsHeightMultiplier
        ])
        let filterLogActionsBottomConstraint = familyMembersLabel.topAnchor.constraint(equalTo: filterLogActionsLabel.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing)
        filterLogActionsBottomConstraint.isActive = true

        // familyMembersLabel
        let familyMembersLabelHeightMultiplier = familyMembersLabel.heightAnchor.constraint(
            equalTo: view.widthAnchor,
            multiplier: ConstraintConstant.Section.sectionTitleHeightMultipler
        ).withPriority(.defaultHigh)
        NSLayoutConstraint.activate([
            familyMembersLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            familyMembersLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            familyMembersLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.sectionTitleMaxHeight),
            familyMembersLabelHeightMultiplier
        ])
        let familyMembersLabelBottomConstraint = filterFamilyMembersLabel.topAnchor.constraint(equalTo: familyMembersLabel.bottomAnchor, constant: ConstraintConstant.Section.intraSectionVertSpacing)
         familyMembersLabelBottomConstraint.isActive = true

        // filterFamilyMembersLabel
        let filterFamilyMembersHeightMultiplier = filterFamilyMembersLabel.heightAnchor.constraint(
            equalTo: view.widthAnchor,
            multiplier: ConstraintConstant.Section.inputHeightMultiplier
        ).withPriority(.defaultHigh)
        NSLayoutConstraint.activate([
            filterFamilyMembersLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            filterFamilyMembersLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            filterFamilyMembersLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight),
            filterFamilyMembersHeightMultiplier
        ])
        let filterFamilyMembersBottomConstraint = applyButton.topAnchor.constraint(equalTo: filterFamilyMembersLabel.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing)
        filterFamilyMembersBottomConstraint.isActive = true

        // applyButton
        NSLayoutConstraint.activate([
            applyButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            applyButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            applyButton.heightAnchor.constraint(equalTo: applyButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            applyButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight),
            applyButton.topAnchor.constraint(equalTo: filterFamilyMembersLabel.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing)
        ])

        // clearButton
        NSLayoutConstraint.activate([
            clearButton.topAnchor.constraint(equalTo: applyButton.bottomAnchor, constant: ConstraintConstant.Section.interSectionVertSpacing),
            clearButton.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            clearButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            clearButton.heightAnchor.constraint(equalTo: applyButton.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh),
            clearButton.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight)
        ])

        // containerViewExtraPadding
        containerViewExtraPaddingHeight = containerViewExtraPadding.heightAnchor.constraint(equalToConstant: 0)
        NSLayoutConstraint.activate([
            containerViewExtraPadding.topAnchor.constraint(equalTo: clearButton.bottomAnchor),
            containerViewExtraPadding.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            containerViewExtraPadding.trailingAnchor.constraint(equalTo: containerView.trailingAnchor),
            containerViewExtraPadding.bottomAnchor.constraint(equalTo: containerView.bottomAnchor),
            containerViewExtraPaddingHeight
        ])
    }

}
//
//  LogsFilterUIInteractionDelegate.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class LogsFilterUIInteractionDelegate: NSObject, UIGestureRecognizerDelegate {

    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
}
//
//  LogsFilterTypes.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum LogsFilterDropDownTypes: String {
    case filterDogs = "DropDownFilterDogs"
    case filterLogActions = "DropDownFilterLogActions"
    case filterFamilyMembers = "DropDownFilterFamilyMembers"
}
//
//  LogsTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/18/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class LogsTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    /// Container view for all subviews
    let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        return view
    }()
    
    /// Emoji icon indicating the log action
    private let logActionIconLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 450, compressionResistancePriority: 450)
        label.textAlignment = .center
        label.font = .systemFont(ofSize: 42.5, weight: .medium)
        label.isRoundingToCircle = true
        label.shouldRoundCorners = true
        return label
    }()
    
    /// Label for the dog’s name
    private let dogNameLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 440, compressionResistancePriority: 440)
        label.font = VisualConstant.FontConstant.emphasizedPrimaryRegularLabel
        return label
    }()
    
    /// Label describing the log action (without emoji)
    private lazy var logActionTextLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 430, compressionResistancePriority: 430)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        return label
    }()
    
    private var logDateAndDurationStack: UIStackView!
    /// Label showing the start (and optional end) time of the log
    private let logStartToEndDateLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 420, compressionResistancePriority: 420)
        label.textAlignment = .right
        label.font = VisualConstant.FontConstant.secondaryRegularLabel
        return label
    }()
    
    /// Label showing the duration of the log (e.g., “1 hr”)
    private let logDurationLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 410, compressionResistancePriority: 410)
        label.textAlignment = .right
        label.font = VisualConstant.FontConstant.secondaryRegularLabel
        return label
    }()
    
    private var dogNameToUnitNoteStackConstraint: GeneralLayoutConstraint!
    private var logUnitAndNoteStackFullTrailingConstraint: NSLayoutConstraint!
    private var logUnitAndNoteStackMaxTrailingConstraint: NSLayoutConstraint!
    private var dogNameToContainerBottomConstraint: NSLayoutConstraint!
    private var logUnitAndNoteStackHeightConstraint: NSLayoutConstraint!
    private var logUnitAndNoteStackBottomConstraint: NSLayoutConstraint!
    private var logUnitAndNoteStack: UIStackView!
    /// Label showing any units for the log (e.g., miles, kCal)
    private let logUnitLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 400, compressionResistancePriority: 400)
        label.backgroundColor = .secondarySystemBackground
        label.font = VisualConstant.FontConstant.tertiaryRegularLabel
        label.shouldRoundCorners = true
        return label
    }()
    
    /// Label for any optional note on the log
    private let logNoteLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 390, compressionResistancePriority: 390)
        label.backgroundColor = .secondarySystemBackground
        label.font = VisualConstant.FontConstant.tertiaryRegularLabel
        label.shouldRoundCorners = true
        return label
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "LogsTVC"
    
    // MARK: - Setup
    
    /// Configure the cell’s labels and adjust dynamic constraints based on the provided Log
    func setup(forParentDogName dogName: String, forLog log: Log) {
        logActionIconLabel.text = log.logActionType.emoji
        
        // Pad label so it lines up with other labels
        dogNameLabel.text = " \(dogName)"
        
        logActionTextLabel.text = log.logActionType.convertToReadableName(customActionName: log.logCustomActionName, includeMatchingEmoji: false)
        
        let logStartDateFormatter = DateFormatter()
        logStartDateFormatter.setLocalizedDateFormatFromTemplate("hma") // e.g., “7:53 AM”
        logStartToEndDateLabel.text = logStartDateFormatter.string(from: log.logStartDate)
        
        if let logEndDate = log.logEndDate {
            let logEndDateFormatter = DateFormatter()
            if log.logStartDate.distance(to: logEndDate) < 60 * 60 * 24 {
                // Same day: no need for date information
                logEndDateFormatter.setLocalizedDateFormatFromTemplate("hma")
            }
            else {
                // Different day: show month + day (and year if not current)
                let logEndYear = Calendar.current.component(.year, from: logEndDate)
                let currentYear = Calendar.current.component(.year, from: Date())
                logEndDateFormatter.setLocalizedDateFormatFromTemplate(logEndYear == currentYear ? "MMMd" : "MMMdyy")
            }
            logStartToEndDateLabel.text = logStartToEndDateLabel.text?.appending(" - \(logEndDateFormatter.string(from: logEndDate))")
        }
        
        logDurationLabel.text = {
            guard let logEndDate = log.logEndDate else {
                return nil
            }
            return log.logStartDate.distance(to: logEndDate).readable(capitalizeWords: false, abreviateWords: true)
        }()
        let logDurationIsHidden = logDurationLabel.text == nil
        
        let logUnitString: String? = {
            guard let unitType = log.logUnitType, let numUnits = log.logNumberOfLogUnits else {
                return nil
            }
            return unitType.convertedMeasurementString(forLogNumberOfLogUnits: numUnits, toTargetSystem: UserConfiguration.measurementSystem)
        }()
        logUnitLabel.text = logUnitString.map { "  \($0)  " }
        let logUnitIsHidden = logUnitString == nil
        logUnitLabel.isHidden = logUnitIsHidden
        
        logNoteLabel.text = {
            let trimmedNote = log.logNote.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !trimmedNote.isEmpty else { return nil }
            return "  \(trimmedNote)  "
        }()
        let logNoteIsHidden = logNoteLabel.text == nil
        logNoteLabel.isHidden = logNoteIsHidden
    
        let shouldShowUnitNoteStack = !(logUnitIsHidden && logNoteIsHidden)
        logUnitAndNoteStack.isHidden = !shouldShowUnitNoteStack
        
        if logDurationIsHidden {
            dogNameToUnitNoteStackConstraint.constant = 0
        }
        else {
            dogNameToUnitNoteStackConstraint.restore()
        }
        dogNameToUnitNoteStackConstraint.isActive = shouldShowUnitNoteStack
        
        logUnitAndNoteStackHeightConstraint.isActive = shouldShowUnitNoteStack
        logUnitAndNoteStackBottomConstraint.isActive = shouldShowUnitNoteStack
        
        dogNameToContainerBottomConstraint.isActive = !shouldShowUnitNoteStack
        
        logUnitAndNoteStackFullTrailingConstraint.isActive = !logNoteIsHidden
        logUnitAndNoteStackMaxTrailingConstraint.isActive = logNoteIsHidden
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        selectionStyle = .none
        backgroundColor = .clear
        contentView.backgroundColor = .clear
        selectedBackgroundView?.backgroundColor = .clear
        
        super.setupGeneratedViews()
    }
    
    private let interContentSpacing: CGFloat = 5.0
    private let verticalInsetFromContainer: CGFloat = 7.5
    private let horizontalInsetFromContainer: CGFloat = 10.0
    private let logActionIconInset: CGFloat = 2.5
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(logActionIconLabel)
        containerView.addSubview(dogNameLabel)
        containerView.addSubview(logActionTextLabel)

        logDateAndDurationStack = UIStackView(arrangedSubviews: [logStartToEndDateLabel, logDurationLabel])
        logDateAndDurationStack.axis = .vertical
        logDateAndDurationStack.alignment = .fill
        logDateAndDurationStack.distribution = .fillEqually
        logDateAndDurationStack.spacing = interContentSpacing
        logDateAndDurationStack.translatesAutoresizingMaskIntoConstraints = false
        containerView.addSubview(logDateAndDurationStack)

        logUnitAndNoteStack = UIStackView(arrangedSubviews: [logUnitLabel, logNoteLabel])
        logUnitAndNoteStack.axis = .horizontal
        logUnitAndNoteStack.alignment = .fill
        logUnitAndNoteStack.distribution = .fill // stack height is driven by contents
        logUnitAndNoteStack.spacing = interContentSpacing
        logUnitAndNoteStack.translatesAutoresizingMaskIntoConstraints = false
        containerView.addSubview(logUnitAndNoteStack)
    }

    override func setupConstraints() {
        super.setupConstraints()
        // containerView
        NSLayoutConstraint.activate([
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])
        // logActionIconLabel
        NSLayoutConstraint.activate([
            logActionIconLabel.topAnchor.constraint(equalTo: dogNameLabel.topAnchor, constant: -(verticalInsetFromContainer - logActionIconInset)),
            logActionIconLabel.bottomAnchor.constraint(equalTo: dogNameLabel.bottomAnchor, constant: verticalInsetFromContainer - logActionIconInset),
            logActionIconLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: horizontalInsetFromContainer - logActionIconInset),
            logActionIconLabel.createSquareConstraint()
        ])
        // dogNameLabel
        NSLayoutConstraint.activate([
            dogNameLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: verticalInsetFromContainer),
            dogNameLabel.leadingAnchor.constraint(equalTo: logActionIconLabel.trailingAnchor, constant: interContentSpacing - logActionIconInset)
        ])
        // logActionTextLabel
        NSLayoutConstraint.activate([
            logActionTextLabel.leadingAnchor.constraint(equalTo: dogNameLabel.trailingAnchor, constant: interContentSpacing),
            logActionTextLabel.topAnchor.constraint(equalTo: dogNameLabel.topAnchor),
            logActionTextLabel.heightAnchor.constraint(equalTo: dogNameLabel.heightAnchor)
        ])
        // logDateAndDurationStack
        NSLayoutConstraint.activate([
            logDateAndDurationStack.leadingAnchor.constraint(equalTo: logActionTextLabel.trailingAnchor, constant: interContentSpacing),
            logDateAndDurationStack.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -horizontalInsetFromContainer),
            logDateAndDurationStack.topAnchor.constraint(equalTo: dogNameLabel.topAnchor),
            logDateAndDurationStack.bottomAnchor.constraint(equalTo: dogNameLabel.bottomAnchor)
        ])
        // logUnitAndNoteStack
        dogNameToUnitNoteStackConstraint = GeneralLayoutConstraint(wrapping: dogNameLabel.bottomAnchor.constraint(equalTo: logUnitAndNoteStack.topAnchor, constant: -interContentSpacing))
        dogNameToContainerBottomConstraint = dogNameLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -verticalInsetFromContainer)
        dogNameToContainerBottomConstraint.isActive = false

        logUnitAndNoteStackFullTrailingConstraint = logUnitAndNoteStack.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -horizontalInsetFromContainer)
        logUnitAndNoteStackMaxTrailingConstraint = logUnitAndNoteStack.trailingAnchor.constraint(lessThanOrEqualTo: containerView.trailingAnchor, constant: -horizontalInsetFromContainer)
        logUnitAndNoteStackMaxTrailingConstraint.isActive = false
        // can't constraint stack directly without an error, so make its element inside constraint logUnitLabel
        logUnitAndNoteStackHeightConstraint = logUnitLabel.heightAnchor.constraint(equalTo: logStartToEndDateLabel.heightAnchor)
        logUnitAndNoteStackBottomConstraint = logUnitAndNoteStack.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -verticalInsetFromContainer)
        NSLayoutConstraint.activate([
            dogNameToUnitNoteStackConstraint.constraint,
            // dont activate dogNameToContainerBottomConstraint
            logUnitAndNoteStackHeightConstraint,
            logUnitAndNoteStackFullTrailingConstraint,
            // dont activate logUnitAndNoteStackMaxTrailingConstraint
            logUnitAndNoteStackBottomConstraint,
            logUnitAndNoteStack.leadingAnchor.constraint(equalTo: dogNameLabel.leadingAnchor)
        ])
    }

}
//
//  LogsAddLogUIInteractionDelegate.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/15/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol LogsAddLogUIInteractionActionsDelegate: AnyObject {
    func dismissKeyboard()
    func logCustomActionNameTextFieldDidReturn()
    func didUpdateLogNumberOfLogUnits()
}

final class LogsAddLogUIInteractionDelegate: NSObject, UITextFieldDelegate, UITextViewDelegate, UIGestureRecognizerDelegate {
    
    weak var actionsDelegate: LogsAddLogUIInteractionActionsDelegate?
    var logCustomActionNameTextField: GeneralUITextField?
    var logNumberOfLogUnitsTextField: GeneralUITextField?

    // MARK: - UITextFieldDelegate
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        if textField.isEqual(logCustomActionNameTextField) {
            actionsDelegate?.logCustomActionNameTextFieldDidReturn()
        }
        actionsDelegate?.dismissKeyboard()
        return false
    }
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        if textField.isEqual(logCustomActionNameTextField) {
            return processLogCustomActionNameTextField(shouldChangeCharactersIn: range, replacementString: string)
        }
        else if textField.isEqual(logNumberOfLogUnitsTextField) {
            DispatchQueue.main.asyncAfter(deadline: .now()) {
                // Delay the call to delegate ever so slightly. This is because we want to return the value from processLogNumberOfLogUnitsTextField before the delegate is called, so that the value of logNumberOfLogUnitsTextField is updated before updateDynamicUIElements() is called. This delay allows enough time for this to happen
                self.actionsDelegate?.didUpdateLogNumberOfLogUnits()
            }
            return processLogNumberOfLogUnitsTextField(shouldChangeCharactersIn: range, replacementString: string)
        }
        
        return false
    }
    
    private func processLogCustomActionNameTextField(shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        // attempt to read the range they are trying to change
        guard let currentText = logCustomActionNameTextField?.text, let stringRange = Range(range, in: currentText) else {
            return true
        }
        
        // add their new text to the existing text
        let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
        
        // make sure the result is logCustomActionNameCharacterLimit
        return updatedText.count <= ClassConstant.LogConstant.logCustomActionNameCharacterLimit
    }
    
    private func processLogNumberOfLogUnitsTextField(shouldChangeCharactersIn newRange: NSRange, replacementString newString: String) -> Bool {
        // attempt to read the range they are trying to change
        guard let previousText = logNumberOfLogUnitsTextField?.text, let newStringRange = Range(newRange, in: previousText) else {
            return true
        }

        // add their newString in the newRange to the previousText and uppercase it all, giving us our uppercasedUpdatedText
        var updatedText = previousText.replacingCharacters(in: newStringRange, with: newString)

        // The user can delete whatever they want. We only want to check when they add a character
        guard updatedText.count > previousText.count else {
            return true
        }
        
        // MARK: Remove invalid grouping separator
        // when a user inputs number of logs, it should not have a grouping separator, e.g. 12,345.67 should just be 12345.67
        updatedText = updatedText.replacingOccurrences(of: Locale.current.groupingSeparator ?? ",", with: "")

        // MARK: Verify new character is a valid character
        // number of logs units is a decimal so it can only contain 0-9 and a period (also technically a , for countries that use that instead of a .)
        let decimalSeparator: Character = Locale.current.decimalSeparator?.first ?? "."
        
        var acceptableCharacters = "0123456789"
        acceptableCharacters.append(decimalSeparator)
        
        var containsInvalidCharacter = false
        updatedText.forEach { character in
            if acceptableCharacters.firstIndex(of: character) == nil {
                containsInvalidCharacter = true
            }
        }
        guard containsInvalidCharacter == false else {
            return false
        }

        // MARK: Verify period/command count
        let occurancesOfDecimalSeparator = {
            var count = 0
            updatedText.forEach { char in
                if char == decimalSeparator {
                    count += 1
                }
            }
            return count
        }()
        
        if occurancesOfDecimalSeparator > 1 {
            // If updated text has more than one period/comma, it will be an invalid decimal number
            return false
        }
        
        // MARK: Verify number of digits after period or comma
        // "123.456"
        if let componentBeforeDecimalSeparator = updatedText.split(separator: decimalSeparator).safeIndex(0) {
            // "123"
            // We only want to allow five numbers before the decimal place
            if componentBeforeDecimalSeparator.count > 5 {
                return false
            }
        }
        if let componentAfterDecimalSeparator = updatedText.split(separator: decimalSeparator).safeIndex(1) {
            // "456"
            // We only want to allow two decimals after the decimal place
            if componentAfterDecimalSeparator.count > 2 {
                return false
            }
        }
        
        // At the end of the function, update the text field's text to the updated text
        logNumberOfLogUnitsTextField?.text = updatedText
        // Return false because we manually set the text field's text
        return false
    }
    
    // MARK: - UITextViewDelegate
    
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        // Don't allow the user to add a new line. If they do, we interpret that as the user hitting the done button.
        guard text != "\n" else {
            actionsDelegate?.dismissKeyboard()
            return false
        }
        
        // get the current text, or use an empty string if that failed
        let currentText = textView.text ?? ""
        
        // attempt to read the range they are trying to change, or exit if we can't
        guard let stringRange = Range(range, in: currentText) else { return false }
        
        // add their new text to the existing text
        let updatedText = currentText.replacingCharacters(in: stringRange, with: text)
        
        // make sure the result is under logNoteCharacterLimit
        return updatedText.count <= ClassConstant.LogConstant.logNoteCharacterLimit
    }
    
    // if extra space is added, removes it and ends editing, makes done button function like done instead of adding new line
    func textViewDidChange(_ textView: UITextView) {
        if textView.text.contains("\n") {
            textView.text = textView.text.trimmingCharacters(in: .newlines)
            actionsDelegate?.dismissKeyboard()
        }
    }
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
}
//
//  LogsAddLogTypes.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/17/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum LogsAddLogDropDownTypes: String {
    case parentDog = "DropDownParentDog"
    case logActionType = "DropDownLogAction"
    case logUnit = "DropDownLogUnit"
    case logStartDate = "DropDownLogStartDate"
    case logEndDate = "DropDownLogEndDate"
}
//
//  LogsAddLogViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/30/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol LogsAddLogDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager)
}

final class LogsAddLogViewController: GeneralUIViewController,
                                      LogsAddLogUIInteractionActionsDelegate,
                                      DropDownUIViewDataSource {
    
    // MARK: - LogsAddLogUIInteractionActionsDelegate
    
    func logCustomActionNameTextFieldDidReturn() {
        if logStartDateSelected == nil {
            // If a user input a logCustomActionName in that dynamically-appearing field and logStartDateSelected is nil,
            // that means the normal flow of selecting log action -> selecting log start date was interrupted. Resume this
            // by opening logStartDate dropdown.
            showDropDown(.logStartDate, animated: true)
        }
    }
    
    @objc func didUpdateLogNumberOfLogUnits() {
        // When the user enters a number into log units, it could update the plurality of the logUnitLabel
        // (e.g. no number but "pills" then the user enters 1 so "pills" should become "pill").
        // So by setting logUnitTypeSelected it updates logUnitLabel.
        updateDynamicUIElements()
    }
    
    // MARK: - Elements
    
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        return scrollView
    }()
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        return view
    }()
    
    /// We use this padding so that the content inside the scroll view is ≥ the size of the safe area.
    /// If it is not, then the drop down menus will clip outside the content area, displaying on the lower half
    /// of the region but being un-interactable because they are outside the containerView.
    private weak var containerViewExtraPaddingHeight: NSLayoutConstraint!
    private let containerViewExtraPadding: GeneralUIView = {
        let view = GeneralUIView()
        view.isHidden = true
        return view
    }()
    
    private let pageTitleLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.textAlignment = .center
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBlue
        return label
    }()
    
    private var parentDogHeightMultiplier: GeneralLayoutConstraint!
    private var parentDogHeightMax: GeneralLayoutConstraint!
    private var parentDogBottom: GeneralLayoutConstraint!
    private let parentDogLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 290, compressionResistancePriority: 290)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        label.shouldRoundCorners = true
        return label
    }()
    
    private var familyMemberNameHeightMultiplier: GeneralLayoutConstraint!
    private var familyMemberNameHeightMax: GeneralLayoutConstraint!
    private var familyMemberNameBottom: GeneralLayoutConstraint!
    private let familyMemberNameLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 285, compressionResistancePriority: 285)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.shouldRoundCorners = true
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        return label
    }()
    
    private let logActionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        
        label.shouldRoundCorners = true
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        return label
    }()
    
    private var logCustomActionNameHeightMultiplier: GeneralLayoutConstraint!
    private var logCustomActionNameHeightMax: GeneralLayoutConstraint!
    private var logCustomActionNameBottom: GeneralLayoutConstraint!
    /// Text input for logCustomActionNameName
    private let logCustomActionNameTextField: GeneralUITextField = {
        let textField = GeneralUITextField(huggingPriority: 275, compressionResistencePriority: 775)
        
        textField.borderColor = .systemGray2
        textField.borderWidth = 0.5
        textField.shouldRoundCorners = true
        
        return textField
    }()
    
    private let logNumberOfLogUnitsTextField: GeneralUITextField = {
        let textField = GeneralUITextField()
        
        textField.textAlignment = .center
        textField.keyboardType = .decimalPad
        
        textField.borderColor = .systemGray2
        textField.borderWidth = 0.5
        textField.shouldRoundCorners = true
        
        return textField
    }()
    
    private var logUnitHeightMultiplier: GeneralLayoutConstraint!
    private var logUnitHeightMax: GeneralLayoutConstraint!
    private var logUnitBottom: GeneralLayoutConstraint!
    private let logUnitLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 245, compressionResistancePriority: 245)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.shouldRoundCorners = true
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        return label
    }()
    
    private let logNoteTextView: GeneralUITextView = {
        let textView = GeneralUITextView(huggingPriority: 240, compressionResistancePriority: 240)
        textView.textColor = .label
        textView.font = VisualConstant.FontConstant.primaryRegularLabel
        textView.shouldRoundCorners = true
        textView.borderColor = .systemGray2
        textView.borderWidth = 0.5
        return textView
    }()
    
    private let logStartDateLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.shouldRoundCorners = true
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        return label
    }()
    
    private var logStartDateHeightMultiplier: GeneralLayoutConstraint!
    private var logStartDateHeightMax: GeneralLayoutConstraint!
    private let logStartDatePicker: GeneralUIDatePicker = {
        let datePicker = GeneralUIDatePicker(huggingPriority: 265, compressionResistancePriority: 265)
        datePicker.isHidden = true
        datePicker.datePickerMode = .dateAndTime
        datePicker.minuteInterval = 5
        datePicker.preferredDatePickerStyle = .wheels
        return datePicker
    }()
    
    @objc private func didUpdateLogStartDate(_ sender: Any) {
        // By updating logStartDateSelected, it can invalidate the quick time select options in the open drop down.
        // If a user then selects an invalid option, it will lead to incorrect data or crashing.
        self.dropDownLogEndDate?.hideDropDown(animated: true)
        self.logStartDateSelected = logStartDatePicker.date
        self.dismissKeyboard()
    }
    
    private let logEndDateLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 260, compressionResistancePriority: 260)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.shouldRoundCorners = true
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        return label
    }()
    
    private var logEndDateHeightMultiplier: GeneralLayoutConstraint!
    private var logEndDateHeightMax: GeneralLayoutConstraint!
    private let logEndDatePicker: GeneralUIDatePicker = {
        let datePicker = GeneralUIDatePicker(huggingPriority: 255, compressionResistancePriority: 255)
        datePicker.isHidden = true
        datePicker.datePickerMode = .dateAndTime
        datePicker.minuteInterval = 5
        datePicker.preferredDatePickerStyle = .wheels
        return datePicker
    }()
    
    @objc private func didUpdateLogEndDate(_ sender: Any) {
        // By updating logEndDateSelected, it can invalidate the quick time select options in the open drop down.
        // If a user then selects an invalid option, it will lead to incorrect data or crashing.
        self.dropDownLogStartDate?.hideDropDown(animated: true)
        self.logEndDateSelected = logEndDatePicker.date
        self.dismissKeyboard()
    }
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 310, compressionResistancePriority: 310)
        
        button.tintColor = .systemGray2
        button.setImage(UIImage(systemName: "arrow.backward.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        return button
    }()
    
    @objc private func didTouchUpInsideBack(_ sender: Any) {
        if didUpdateInitialValues == true {
            let unsavedInformationConfirmation = UIAlertController(
                title: "Are you sure you want to exit?",
                message: nil,
                preferredStyle: .alert
            )
            
            let exitAlertAction = UIAlertAction(
                title: "Yes, I don't want to save changes",
                style: .default
            ) { _ in
                self.dismiss(animated: true) {
                    // Wait for the view to be dismissed, then see if we should request any sort of review from the user
                    // (if we don't wait, then the view presented by ShowBonusInformationManager will be dismissed when this view dismisses)
                    ShowBonusInformationManager.requestAppStoreReviewIfNeeded()
                    ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
                }
            }
            
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            
            unsavedInformationConfirmation.addAction(exitAlertAction)
            unsavedInformationConfirmation.addAction(cancelAlertAction)
            
            PresentationManager.enqueueAlert(unsavedInformationConfirmation)
        }
        else {
            self.dismiss(animated: true) {
                // Wait for the view to be dismissed, then see if we should request any sort of review from the user
                ShowBonusInformationManager.requestAppStoreReviewIfNeeded()
                ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
            }
        }
    }
    
    private let saveLogButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 310, compressionResistancePriority: 310)
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "checkmark.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        return button
    }()
    
    @objc private func didTouchUpInsideSaveLog(_ sender: Any) {
        guard forDogUUIDsSelected.count >= 1 else {
            ErrorConstant.LogError.parentDogMissing().alert()
            return
        }
        guard let logActionSelected = logActionSelected else {
            ErrorConstant.LogError.logActionMissing().alert()
            return
        }
        guard let logStartDateSelected = logStartDateSelected else {
            ErrorConstant.LogError.logStartDateMissing().alert()
            return
        }
        
        // Check to see if we are updating or adding a log
        guard let dogUUIDToUpdate = dogUUIDToUpdate, let logToUpdate = logToUpdate else {
            willAddLog(logActionSelected: logActionSelected, logStartDateSelected: logStartDateSelected)
            return
        }
        
        willUpdateLog(dogUUIDToUpdate: dogUUIDToUpdate,
                      logToUpdate: logToUpdate,
                      logActionSelected: logActionSelected,
                      logStartDateSelected: logStartDateSelected)
    }
    
    private let removeLogButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 310, compressionResistancePriority: 310)
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "trash"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        return button
    }()
    
    @objc private func didTouchUpInsideRemoveLog(_ sender: Any) {
        guard let dogUUIDToUpdate = dogUUIDToUpdate else {
            return
        }
        guard let logToUpdate = logToUpdate else {
            return
        }
        
        let removeLogConfirmation = UIAlertController(
            title: "Are you sure you want to delete this log?",
            message: nil,
            preferredStyle: .alert
        )
        
        let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
            
            // The user decided to delete so we must query server
            LogsRequest.delete(
                forErrorAlert: .automaticallyAlertOnlyForFailure,
                forDogUUID: dogUUIDToUpdate,
                forLogUUID: logToUpdate.logUUID
            ) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }
                
                self.dogManager?.findDog(forDogUUID: dogUUIDToUpdate)?
                    .dogLogs.removeLog(forLogUUID: logToUpdate.logUUID)
                
                if let dogManager = self.dogManager {
                    self.delegate?.didUpdateDogManager(
                        sender: Sender(origin: self, localized: self),
                        forDogManager: dogManager
                    )
                }
                
                self.dismiss(animated: true) {
                    // Wait for the view to be dismissed, then see if we should request any sort of review from the user
                    ShowBonusInformationManager.requestAppStoreReviewIfNeeded()
                    ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
                }
            }
        }
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        removeLogConfirmation.addAction(removeAlertAction)
        removeLogConfirmation.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(removeLogConfirmation)
    }
    
    // MARK: - Properties
    
    private weak var delegate: LogsAddLogDelegate?
    
    private lazy var uiDelegate: LogsAddLogUIInteractionDelegate = {
        let delegate = LogsAddLogUIInteractionDelegate()
        delegate.actionsDelegate = self
        delegate.logCustomActionNameTextField = self.logCustomActionNameTextField
        delegate.logNumberOfLogUnitsTextField = self.logNumberOfLogUnitsTextField
        return delegate
    }()
    
    private var dogManager: DogManager?
    private var dogUUIDToUpdate: UUID?
    private var logToUpdate: Log?
    
    // MARK: Initial Value Tracking
    
    private var initialForDogUUIDsSelected: [UUID] = []
    private var initialLogActionType: LogActionType?
    private var initialLogCustomActionName: String?
    private var initialLogUnitType: LogUnitType?
    private var initialLogNumberOfLogUnits: String?
    private var initialLogNote: String?
    private var initialLogStartDate: Date?
    private var initialLogEndDate: Date?
    
    private var didUpdateInitialValues: Bool {
        if initialLogActionType != logActionSelected { return true }
        if logActionSelected?.allowsCustom == true && initialLogCustomActionName != logCustomActionNameTextField.text {
            return true
        }
        if initialLogUnitType != logUnitTypeSelected { return true }
        if initialLogNumberOfLogUnits != logNumberOfLogUnitsTextField.text { return true }
        if initialLogNote != logNoteTextView.text { return true }
        if initialLogStartDate != logStartDateSelected { return true }
        if initialLogEndDate != logEndDateSelected { return true }
        if initialForDogUUIDsSelected != forDogUUIDsSelected { return true }
        return false
    }
    
    // MARK: Parent Dog Drop Down
    
    private var dropDownParentDog: DropDownUIView?
    private var forDogUUIDsSelected: [UUID] = [] {
        didSet {
            parentDogLabel.text = {
                guard let dogManager = dogManager, !forDogUUIDsSelected.isEmpty else {
                    // If no parent dog selected, leave text blank so placeholder displays
                    return nil
                }
                
                // If only one dog selected, show that dog's name
                if forDogUUIDsSelected.count == 1,
                   let lastRemainingDogUUID = self.forDogUUIDsSelected.first,
                   let lastRemainingDog = dogManager.dogs.first(where: { $0.dogUUID == lastRemainingDogUUID }) {
                    return lastRemainingDog.dogName
                }
                // If multiple but not all dogs selected, show "Multiple"
                else if forDogUUIDsSelected.count > 1 && forDogUUIDsSelected.count < dogManager.dogs.count {
                    return "Multiple"
                }
                // If all dogs selected, show "All"
                else if forDogUUIDsSelected.count == dogManager.dogs.count {
                    return "All"
                }
                
                return nil
            }()
        }
    }
    
    // MARK: Log Action Drop Down
    
    private var dropDownLogAction: DropDownUIView?
    /// The selected log action type
    private var logActionSelected: LogActionType? {
        didSet {
            updateDynamicUIElements()
            
            // READ ME BEFORE CHANGING CODE BELOW: this is for the label for the logActionType dropdown,
            // so we only want the names to be the defaults. I.e. if our log is "Custom" with "someCustomActionName",
            // the logActionLabel should only show "Custom" and then the logCustomActionNameTextField should be "someCustomActionName".
            logActionLabel.text = logActionSelected?.convertToReadableName(customActionName: nil, includeMatchingEmoji: true)
            
            // If log action changed to something where the current logUnit is no longer valid, clear logUnitTypeSelected
            if let selected = logActionSelected {
                let validUnits = selected.associatedLogUnitTypes
                if let currentUnit = logUnitTypeSelected, !validUnits.contains(currentUnit) {
                    logUnitTypeSelected = nil
                }
            }
            else {
                logUnitTypeSelected = nil
            }
        }
    }
    
    // MARK: Log Unit Drop Down
    
    private var dropDownLogUnit: DropDownUIView?
    /// The selected log unit type
    private var logUnitTypeSelected: LogUnitType? {
        didSet {
            updateDynamicUIElements()
        }
    }
    
    // MARK: Log Start Date
    
    private var dropDownLogStartDate: DropDownUIView?
    private var dropDownLogStartDateOptions: [TimeQuickSelectOptions] {
        // If logEndDateSelected is nil, all options are valid
        guard let endDate = logEndDateSelected else {
            return TimeQuickSelectOptions.allCases
        }
        return TimeQuickSelectOptions.optionsOccurringBeforeDate(
            startingPoint: Date(),
            occurringOnOrBefore: endDate
        )
    }
    private var logStartDateSelected: Date? {
        didSet {
            if let start = logStartDateSelected {
                let dateFormatter = DateFormatter()
                if Calendar.current.isDateInToday(start) {
                    // If the start date is today, show only time
                    dateFormatter.setLocalizedDateFormatFromTemplate("hma") // 7:53 AM
                }
                else {
                    // If start date is not today, show month/day and possibly year
                    let yearOfStart = Calendar.current.component(.year, from: start)
                    let currentYear = Calendar.current.component(.year, from: Date())
                    let format = (yearOfStart == currentYear) ? "MMMMdhma" : "MMMMdyyyyhma"
                    dateFormatter.setLocalizedDateFormatFromTemplate(format)
                }
                logStartDateLabel.text = dateFormatter.string(from: start)
            }
            else {
                logStartDateLabel.text = nil
            }
        }
    }
    private var isShowingLogStartDatePicker = false {
        didSet {
            if isShowingLogStartDatePicker {
                isShowingLogEndDatePicker = false
                // If showing the logStartDatePicker, dropDownLogEndDate might be out of place; remove and rebuild
                dropDownLogEndDate?.removeFromSuperview()
                dropDownLogEndDate = nil
                
                // Ensure start date ≤ end date if end date already set
                if let endDate = logEndDateSelected {
                    logStartDatePicker.maximumDate = endDate
                }
                
                // Sync date picker’s date
                logStartDatePicker.date = logStartDateSelected
                ?? Date.roundDate(
                    targetDate: Date(),
                    roundingInterval: Double(60 * logStartDatePicker.minuteInterval),
                    roundingMethod: .toNearestOrAwayFromZero
                )
                // Save this value so that if user doesn’t manually change it, we preserve it
                logStartDateSelected = logStartDatePicker.date
            }
            
            updateDynamicUIElements()
        }
    }
    
    // MARK: Log End Date Drop Down
    
    private var dropDownLogEndDate: DropDownUIView?
    private var dropDownLogEndDateOptions: [TimeQuickSelectOptions] {
        // If logStartDateSelected is nil, all options are valid
        guard let start = logStartDateSelected else {
            return TimeQuickSelectOptions.allCases
        }
        return TimeQuickSelectOptions.optionsOccurringAfterDate(
            startingPoint: Date(),
            occurringOnOrAfter: start
        )
    }
    private var logEndDateSelected: Date? {
        didSet {
            if let end = logEndDateSelected {
                let dateFormatter = DateFormatter()
                if Calendar.current.isDateInToday(end) {
                    // If end date is today, show only time
                    dateFormatter.setLocalizedDateFormatFromTemplate("hma")
                }
                else {
                    // If end date is not today, show month/day and possibly year
                    let yearOfEnd = Calendar.current.component(.year, from: end)
                    let currentYear = Calendar.current.component(.year, from: Date())
                    let format = (yearOfEnd == currentYear) ? "MMMMdhma" : "MMMMdyyyyhma"
                    dateFormatter.setLocalizedDateFormatFromTemplate(format)
                }
                logEndDateLabel.text = dateFormatter.string(from: end)
            }
            else {
                logEndDateLabel.text = nil
            }
        }
    }
    private var isShowingLogEndDatePicker = false {
        didSet {
            if isShowingLogEndDatePicker {
                isShowingLogStartDatePicker = false
                // If showing the logEndDatePicker, dropDownLogStartDate might be out of place; remove and rebuild
                dropDownLogStartDate?.removeFromSuperview()
                dropDownLogStartDate = nil
                
                // Ensure end date ≥ start date if start date already set
                if let start = logStartDateSelected {
                    logEndDatePicker.minimumDate = start
                }
                
                // Sync date picker’s date
                logEndDatePicker.date = logEndDateSelected
                ?? Date.roundDate(
                    targetDate: Date(),
                    roundingInterval: Double(60 * logEndDatePicker.minuteInterval),
                    roundingMethod: .toNearestOrAwayFromZero
                )
                // Save this value so that if user doesn’t manually change it, we preserve it
                logEndDateSelected = logEndDatePicker.date
            }
            
            updateDynamicUIElements()
        }
    }
    
    // MARK: - Main
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        // Set forDogUUIDsSelected = [] to invoke didSet and initialize label text appropriately
        forDogUUIDsSelected = []
        initialForDogUUIDsSelected = forDogUUIDsSelected
        
        guard let dogManager = dogManager else {
            return
        }
        
        if let dogUUIDToUpdate = dogUUIDToUpdate, logToUpdate != nil {
            pageTitleLabel.text = "Edit Log"
            if let dog = dogManager.findDog(forDogUUID: dogUUIDToUpdate) {
                forDogUUIDsSelected = [dog.dogUUID]
                initialForDogUUIDsSelected = forDogUUIDsSelected
            }
            
            parentDogLabel.isEnabled = false
        }
        else {
            pageTitleLabel.text = "Create Log"
            removeLogButton.removeFromSuperview()
            
            // If the family only has one dog, then force the parent dog selected to be that single dog.
            // Otherwise, leave list empty so user must select.
            if dogManager.dogs.count == 1 {
                if let uuid = dogManager.dogs.first?.dogUUID {
                    forDogUUIDsSelected = [uuid]
                    initialForDogUUIDsSelected = forDogUUIDsSelected
                }
            }
            
            // Disable parentDogLabel if only one dog in family
            parentDogLabel.isEnabled = dogManager.dogs.count != 1
            familyMemberNameLabel.isEnabled = true
        }
        
        // Parent Dog Label placeholder logic
        parentDogLabel.placeholder = dogManager.dogs.count <= 1
        ? "What dog did you take care of?"
        : "What dog(s) did you take care of?"
        
        // Family Member Name
        familyMemberNameLabel.isEnabled = false
        familyMemberNameLabel.text = FamilyInformation.findFamilyMember(forUserId: logToUpdate?.userId)?.displayFullName
        // This placeholder is dynamic; show family member name or keep blank for indentation
        familyMemberNameLabel.placeholder = familyMemberNameLabel.text
        
        // Log Action
        logActionSelected = logToUpdate?.logActionType
        initialLogActionType = logActionSelected
        logActionLabel.placeholder = "What action did you do?"
        
        // Log Custom Action Name
        logCustomActionNameTextField.text = logToUpdate?.logCustomActionName
        initialLogCustomActionName = logCustomActionNameTextField.text
        logCustomActionNameTextField.placeholder = "Add a custom action..."
        logCustomActionNameTextField.delegate = uiDelegate
        
        // Log Unit
        let convertedLogUnits: (LogUnitType, Double)? = {
            guard let unitType = logToUpdate?.logUnitType,
                  let numberOfUnits = logToUpdate?.logNumberOfLogUnits else {
                return nil
            }
            return LogUnitTypeConverter.convert(
                forLogUnitType: unitType,
                forNumberOfLogUnits: numberOfUnits,
                toTargetSystem: UserConfiguration.measurementSystem
            )
        }()
        
        logUnitTypeSelected = convertedLogUnits?.0
        initialLogUnitType = logUnitTypeSelected
        logUnitLabel.placeholder = "Add a unit..."
        
        // Log Number of Log Units
        logNumberOfLogUnitsTextField.text = LogUnitType.convertDoubleToRoundedString(
            forLogNumberOfLogUnits: convertedLogUnits?.1
        )
        initialLogNumberOfLogUnits = logNumberOfLogUnitsTextField.text
        logNumberOfLogUnitsTextField.placeholder = " 0" + (Locale.current.decimalSeparator ?? ".") + "0"
        logNumberOfLogUnitsTextField.delegate = uiDelegate
        
        // Log Start Date
        logStartDateSelected = logToUpdate?.logStartDate
        initialLogStartDate = logStartDateSelected
        logStartDateLabel.placeholder = "When did this happen?"
        
        // Log End Date
        logEndDateSelected = logToUpdate?.logEndDate
        initialLogEndDate = logEndDateSelected
        logEndDateLabel.placeholder = "Add an end date..."
        
        // Log Note
        logNoteTextView.text = logToUpdate?.logNote
        initialLogNote = logNoteTextView.text
        // Spaces to align with general label
        logNoteTextView.placeholder = "Add some notes..."
        logNoteTextView.delegate = uiDelegate
        
        // MARK: Gestures
        
        parentDogLabel.isUserInteractionEnabled = dogManager.dogs.count != 1
    }
    
    private var didSetupCustomSubviews: Bool = false
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard didSetupCustomSubviews == false else {
            return
        }
        
        didSetupCustomSubviews = true
        
        updateDynamicUIElements()
        
        // If the user hasn't selected a parent dog (first time the VC appears), show parent dog dropdown
        if forDogUUIDsSelected.isEmpty {
            showDropDown(.parentDog, animated: false)
        }
        // Else if user has a parent dog selected (only one dog in family), show log action dropdown
        else if logActionSelected == nil {
            showDropDown(.logActionType, animated: false)
        }
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: LogsAddLogDelegate,
               forDogManager: DogManager,
               forDogUUIDToUpdate: UUID?,
               forLogToUpdate: Log?) {
        delegate = forDelegate
        dogManager = forDogManager
        dogUUIDToUpdate = forDogUUIDToUpdate
        logToUpdate = forLogToUpdate
    }
    
    // MARK: - Functions
    
    private func updateDynamicUIElements() {
        // We don't want this page to get too cluttered. Therefore, if editing a log (so family member name will be shown),
        // hide parent dog. Parent dog is uneditable as well, so no functionality is lost.
        let parentDogIsHidden = dogUUIDToUpdate != nil && logToUpdate != nil
        parentDogLabel.isHidden = parentDogIsHidden
        if parentDogIsHidden {
            parentDogHeightMultiplier.setMultiplier(0.0)
            parentDogHeightMax.constant = 0.0
            parentDogBottom.constant = 0.0
        }
        else {
            parentDogHeightMultiplier.restore()
            parentDogHeightMax.restore()
            parentDogBottom.restore()
        }
        
        // The family member to a log is not editable by a user. Its set internally by the server.
        // Therefore, if creating a log, don't show it as it will automatically be the user. If editing a log, show it
        // so a user can know who created this log.
        let familyMemberNameIsHidden = dogUUIDToUpdate == nil || logToUpdate == nil
        familyMemberNameLabel.isHidden = familyMemberNameIsHidden
        if familyMemberNameIsHidden {
            familyMemberNameHeightMultiplier.setMultiplier(0.0)
            familyMemberNameHeightMax.constant = 0.0
            familyMemberNameBottom.constant = 0.0
        }
        else {
            familyMemberNameHeightMultiplier.restore()
            familyMemberNameHeightMax.restore()
            familyMemberNameBottom.restore()
        }
        
        let logCustomActionNameIsHidden = logActionSelected?.allowsCustom != true
        logCustomActionNameTextField.isHidden = logCustomActionNameIsHidden
        if logCustomActionNameIsHidden {
            logCustomActionNameHeightMultiplier.setMultiplier(0.0)
            logCustomActionNameHeightMax.constant = 0.0
            logCustomActionNameBottom.constant = 0.0
        }
        else {
            logCustomActionNameHeightMultiplier.restore()
            logCustomActionNameHeightMax.restore()
            logCustomActionNameBottom.restore()
        }
        
        let logStartDatePickerIsHidden = !isShowingLogStartDatePicker
        logStartDateLabel.isHidden = !logStartDatePickerIsHidden
        logStartDatePicker.isHidden = logStartDatePickerIsHidden
        if logStartDatePickerIsHidden {
            logStartDateHeightMultiplier.restore()
            logStartDateHeightMax.restore()
        }
        else {
            if let origMulti = logStartDateHeightMultiplier.originalMultiplier {
                logStartDateHeightMultiplier.setMultiplier(origMulti * 4.0)
            }
            logStartDateHeightMax.constant = logStartDateHeightMax.originalConstant * 4.0
        }
        
        let logEndDatePickerIsHidden = !isShowingLogEndDatePicker
        logEndDateLabel.isHidden = !logEndDatePickerIsHidden
        logEndDatePicker.isHidden = logEndDatePickerIsHidden
        
        if logEndDatePickerIsHidden {
            logEndDateHeightMultiplier.restore()
            logEndDateHeightMax.restore()
        }
        else {
            if let origMulti = logEndDateHeightMultiplier.originalMultiplier {
                logEndDateHeightMultiplier.setMultiplier(origMulti * 4.0)
            }
            logEndDateHeightMax.constant = logEndDateHeightMax.originalConstant * 4.0
        }
        
        let logUnitIsHidden: Bool = {
            guard let selected = logActionSelected else {
                return true
            }
            // If logAction has associated unit types, show logUnit
            return selected.associatedLogUnitTypes.isEmpty
        }()
        
        logUnitLabel.text = logUnitTypeSelected?.convertDoubleToPluralityString(
            forLogNumberOfLogUnits: LogUnitType.convertStringToDouble(
                forLogNumberOfLogUnits: logNumberOfLogUnitsTextField.text
            )
        )
        logUnitLabel.isHidden = logUnitIsHidden
        logNumberOfLogUnitsTextField.isHidden = logUnitIsHidden
        logNumberOfLogUnitsTextField.isEnabled = logUnitTypeSelected != nil
        if logCustomActionNameIsHidden {
            logUnitHeightMultiplier.setMultiplier(0.0)
            logUnitHeightMax.constant = 0.0
            logUnitBottom.constant = 0.0
        }
        else {
            logUnitHeightMultiplier.restore()
            logUnitHeightMax.restore()
            logUnitBottom.restore()
        }
        
        UIView.animate(withDuration: VisualConstant.AnimationConstant.showOrHideUIElement) {
            self.view.setNeedsLayout()
            self.view.layoutIfNeeded()
            
            // Adjust containerView padding so content fills safe area
            let containerHeightWithoutPadding = self.containerView.frame.height - self.containerViewExtraPaddingHeight.constant
            let shortfall = self.view.safeAreaLayoutGuide.layoutFrame.height - containerHeightWithoutPadding
            self.containerViewExtraPaddingHeight.constant = max(shortfall, 0.0)
        }
    }
    
    // MARK: - Drop Down Handling
    
    @objc private func didTapScreen(sender: UITapGestureRecognizer) {
        guard let senderView = sender.view else { return }
        let point = sender.location(in: senderView)
        guard let touched = senderView.hitTest(point, with: nil) else { return }
        
        // If a dropDown exists, hide it unless tap is on its label or itself
        if let dd = dropDownParentDog, !touched.isDescendant(of: parentDogLabel) && !touched.isDescendant(of: dd) {
            dd.hideDropDown(animated: true)
        }
        if let dd = dropDownLogAction, !touched.isDescendant(of: logActionLabel) && !touched.isDescendant(of: dd) {
            dd.hideDropDown(animated: true)
        }
        if let dd = dropDownLogUnit, !touched.isDescendant(of: logUnitLabel) && !touched.isDescendant(of: dd) {
            dd.hideDropDown(animated: true)
        }
        if let dd = dropDownLogStartDate, !touched.isDescendant(of: logStartDateLabel) && !touched.isDescendant(of: dd) {
            dd.hideDropDown(animated: true)
        }
        if let dd = dropDownLogEndDate, !touched.isDescendant(of: logEndDateLabel) && !touched.isDescendant(of: dd) {
            dd.hideDropDown(animated: true)
        }
        
        // Dismiss keyboard if tap was outside text inputs
        dismissKeyboard()
    }
    
    @objc private func didTapLabelForDropDown(sender: UITapGestureRecognizer) {
        guard let name = sender.name,
              let targetType = LogsAddLogDropDownTypes(rawValue: name) else { return }
        
        let targetDropDown = dropDown(forDropDownType: targetType)
        
        if (targetDropDown?.isDown ?? false) == false {
            showDropDown(targetType, animated: true)
        }
        else {
            targetDropDown?.hideDropDown(animated: true)
        }
    }
    
    /// For a given dropDownType, return the corresponding dropDown UIView
    private func dropDown(forDropDownType type: LogsAddLogDropDownTypes) -> DropDownUIView? {
        switch type {
        case .parentDog: return dropDownParentDog
        case .logActionType: return dropDownLogAction
        case .logUnit: return dropDownLogUnit
        case .logStartDate: return dropDownLogStartDate
        case .logEndDate: return dropDownLogEndDate
        }
    }
    
    /// For a given dropDownType, return the label that triggers it
    private func labelForDropDown(forDropDownType type: LogsAddLogDropDownTypes) -> GeneralUILabel {
        switch type {
        case .parentDog: return parentDogLabel
        case .logActionType: return logActionLabel
        case .logUnit: return logUnitLabel
        case .logStartDate: return logStartDateLabel
        case .logEndDate: return logEndDateLabel
        }
    }
    
    /// Show or hide the dropdown for the given type
    private func showDropDown(_ type: LogsAddLogDropDownTypes, animated: Bool) {
        // If showing start date and only "custom" and "now" are valid, show picker
        if type == .logStartDate && dropDownLogStartDateOptions.count <= 1 {
            isShowingLogStartDatePicker = true
            return
        }
        // If showing end date and only "custom" is valid, show picker
        if type == .logEndDate && dropDownLogEndDateOptions.count <= 1 {
            isShowingLogEndDatePicker = true
            return
        }
        
        var targetDropDown = dropDown(forDropDownType: type)
        let label = labelForDropDown(forDropDownType: type)
        
        if targetDropDown == nil {
            targetDropDown = DropDownUIView()
            if let targetDropDown = targetDropDown {
                targetDropDown.setupDropDown(
                    forDropDownUIViewIdentifier: type.rawValue,
                    forDataSource: self,
                    forViewPositionReference: label.frame,
                    forOffset: 2.5,
                    forRowHeight: DropDownUIView.rowHeightForGeneralUILabel
                )
                
                switch type {
                case .parentDog: dropDownParentDog = targetDropDown
                case .logActionType: dropDownLogAction = targetDropDown
                case .logUnit: dropDownLogUnit = targetDropDown
                case .logStartDate: dropDownLogStartDate = targetDropDown
                case .logEndDate: dropDownLogEndDate = targetDropDown
                }
                
                // Insert dropdown in correct z-order
                let ordered: [DropDownUIView?] = [
                    dropDownParentDog,
                    dropDownLogAction,
                    dropDownLogStartDate,
                    dropDownLogEndDate,
                    dropDownLogUnit
                ]
                if let superview = label.superview,
                   let index = ordered.firstIndex(of: targetDropDown) {
                    var inserted = false
                    for i in (0..<index).reversed() {
                        if let higher = ordered[i] {
                            superview.insertSubview(targetDropDown, belowSubview: higher)
                            inserted = true
                            break
                        }
                    }
                    if !inserted {
                        superview.addSubview(targetDropDown)
                    }
                }
            }
        }
        
        // Dynamically show the dropdown
        targetDropDown?.showDropDown(
            numberOfRowsToShow: min(6.5, {
                switch type {
                case .parentDog:
                    return CGFloat(dogManager?.dogs.count ?? 0)
                case .logActionType:
                    return CGFloat(GlobalTypes.shared.logActionTypes.count)
                    + CGFloat(LocalConfiguration.localPreviousLogCustomActionNames.count)
                case .logUnit:
                    guard let selected = logActionSelected else { return 0.0 }
                    return CGFloat(selected.associatedLogUnitTypes.count)
                case .logStartDate:
                    return CGFloat(dropDownLogStartDateOptions.count)
                case .logEndDate:
                    return CGFloat(dropDownLogEndDateOptions.count)
                }
            }()),
            animated: animated
        )
    }
    
    // MARK: - Drop Down Data Source
    
    func setupCellForDropDown(cell: UITableViewCell, indexPath: IndexPath, dropDownUIViewIdentifier: String) {
        guard let customCell = cell as? DropDownTVC else { return }
        customCell.adjustLeadingTrailing(newConstant: DropDownUIView.insetForGeneralUILabel)
        
        if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.parentDog.rawValue {
            guard let dm = dogManager else { return }
            let dog = dm.dogs[indexPath.row]
            customCell.setCustomSelectedTableViewCell(
                forSelected: forDogUUIDsSelected.contains(dog.dogUUID)
            )
            customCell.label.text = dog.dogName
        }
        else if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.logActionType.rawValue {
            // Predefined LogActionTypes
            if indexPath.row < GlobalTypes.shared.logActionTypes.count {
                customCell.label.text = GlobalTypes.shared.logActionTypes[indexPath.row]
                    .convertToReadableName(customActionName: nil, includeMatchingEmoji: true)
                if let selected = logActionSelected,
                   GlobalTypes.shared.logActionTypes.firstIndex(of: selected) == indexPath.row {
                    customCell.setCustomSelectedTableViewCell(forSelected: true)
                }
                else {
                    customCell.setCustomSelectedTableViewCell(forSelected: false)
                }
            }
            // User-generated custom names
            else {
                let prev = LocalConfiguration.localPreviousLogCustomActionNames[
                    indexPath.row - GlobalTypes.shared.logActionTypes.count
                ]
                customCell.label.text = LogActionType.find(
                    forLogActionTypeId: prev.logActionTypeId
                ).convertToReadableName(customActionName: prev.logCustomActionName)
                customCell.setCustomSelectedTableViewCell(forSelected: false)
            }
        }
        else if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.logUnit.rawValue {
            guard let selectedAction = logActionSelected else { return }
            customCell.setCustomSelectedTableViewCell(forSelected: false)
            let unitTypes = selectedAction.associatedLogUnitTypes
            if indexPath.row < unitTypes.count {
                let unit = unitTypes[indexPath.row]
                customCell.label.text = unit.convertDoubleToPluralityString(
                    forLogNumberOfLogUnits: LogUnitType.convertStringToDouble(
                        forLogNumberOfLogUnits: logNumberOfLogUnitsTextField.text
                    ) ?? 0.0
                )
                if let selectedUnit = logUnitTypeSelected, selectedUnit == unit {
                    customCell.setCustomSelectedTableViewCell(forSelected: true)
                }
            }
        }
        else if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.logStartDate.rawValue {
            customCell.setCustomSelectedTableViewCell(forSelected: false)
            if let option = dropDownLogStartDateOptions.safeIndex(indexPath.row) {
                customCell.label.text = option.rawValue
                // Do not set “selected” visually, as quick select depends on current time
            }
        }
        else if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.logEndDate.rawValue {
            customCell.setCustomSelectedTableViewCell(forSelected: false)
            if let option = dropDownLogEndDateOptions.safeIndex(indexPath.row) {
                customCell.label.text = option.rawValue
                // Do not set “selected” visually, as quick select depends on current time
            }
        }
    }
    
    func numberOfRows(forSection: Int, dropDownUIViewIdentifier: String) -> Int {
        switch dropDownUIViewIdentifier {
        case LogsAddLogDropDownTypes.parentDog.rawValue:
            return dogManager?.dogs.count ?? 0
        case LogsAddLogDropDownTypes.logActionType.rawValue:
            return GlobalTypes.shared.logActionTypes.count + LocalConfiguration.localPreviousLogCustomActionNames.count
        case LogsAddLogDropDownTypes.logUnit.rawValue:
            guard let selected = logActionSelected else { return 0 }
            return selected.associatedLogUnitTypes.count
        case LogsAddLogDropDownTypes.logStartDate.rawValue:
            return dropDownLogStartDateOptions.count
        case LogsAddLogDropDownTypes.logEndDate.rawValue:
            return dropDownLogEndDateOptions.count
        default:
            return 0
        }
    }
    
    func numberOfSections(dropDownUIViewIdentifier: String) -> Int {
        // Each dropdown has a single section
        return 1
    }
    
    func selectItemInDropDown(indexPath: IndexPath, dropDownUIViewIdentifier: String) {
        if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.parentDog.rawValue,
           let cell = dropDownParentDog?.dropDownTableView?.cellForRow(at: indexPath) as? DropDownTVC,
           let dm = dogManager {
            
            let dog = dm.dogs[indexPath.row]
            let beforeCount = forDogUUIDsSelected.count
            
            if cell.isCustomSelected {
                // Unselect parent dog
                forDogUUIDsSelected.removeAll { $0 == dog.dogUUID }
            }
            else {
                // Select parent dog
                forDogUUIDsSelected.append(dog.dogUUID)
            }
            cell.setCustomSelectedTableViewCell(forSelected: !cell.isCustomSelected)
            
            if beforeCount == 0 {
                // After first selection, hide parent dropdown and open log action dropdown
                dropDownParentDog?.hideDropDown(animated: true)
                showDropDown(.logActionType, animated: true)
            }
            else if forDogUUIDsSelected.count == dm.dogs.count {
                // If all dogs selected, close dropdown
                dropDownParentDog?.hideDropDown(animated: true)
            }
        }
        else if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.logActionType.rawValue,
                let cell = dropDownLogAction?.dropDownTableView?.cellForRow(at: indexPath) as? DropDownTVC {
            
            let beforeSelection = logActionSelected
            
            if cell.isCustomSelected {
                // Unselect current log action
                cell.setCustomSelectedTableViewCell(forSelected: false)
                logActionSelected = nil
                // Do not hide dropdown, need selection for valid log
                return
            }
            
            cell.setCustomSelectedTableViewCell(forSelected: true)
            
            if indexPath.row < GlobalTypes.shared.logActionTypes.count {
                logActionSelected = GlobalTypes.shared.logActionTypes[indexPath.row]
                if logActionSelected?.allowsCustom == true {
                    // If custom log action is allowed, begin editing textField
                    logCustomActionNameTextField.becomeFirstResponder()
                }
            }
            else {
                let prev = LocalConfiguration.localPreviousLogCustomActionNames[
                    indexPath.row - GlobalTypes.shared.logActionTypes.count
                ]
                logActionSelected = LogActionType.find(forLogActionTypeId: prev.logActionTypeId)
                logCustomActionNameTextField.text = prev.logCustomActionName
            }
            
            dropDownLogAction?.hideDropDown(animated: true)
            
            if beforeSelection == nil && !logCustomActionNameTextField.isFirstResponder {
                // First-time selection of log action, so open next dropdown
                if !isShowingLogStartDatePicker {
                    showDropDown(.logStartDate, animated: true)
                }
                else {
                    showDropDown(.logEndDate, animated: true)
                }
            }
        }
        else if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.logUnit.rawValue,
                let cell = dropDownLogUnit?.dropDownTableView?.cellForRow(at: indexPath) as? DropDownTVC,
                let selectedAction = logActionSelected {
            
            if cell.isCustomSelected {
                cell.setCustomSelectedTableViewCell(forSelected: false)
                logUnitTypeSelected = nil
            }
            else {
                let unitTypes = selectedAction.associatedLogUnitTypes
                cell.setCustomSelectedTableViewCell(forSelected: true)
                logUnitTypeSelected = unitTypes[indexPath.row]
            }
            
            dropDownLogUnit?.hideDropDown(animated: true)
        }
        else if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.logStartDate.rawValue,
                let cell = dropDownLogStartDate?.dropDownTableView?.cellForRow(at: indexPath) as? DropDownTVC {
            
            // Time quick select cells should never stay visually selected.
            cell.setCustomSelectedTableViewCell(forSelected: true)
            
            let timeIntervalSelected = dropDownLogStartDateOptions[indexPath.row].valueInSeconds()
            if let interval = timeIntervalSelected {
                // Apply the quick select option
                logStartDateSelected = Date().addingTimeInterval(interval)
            }
            else {
                isShowingLogStartDatePicker = true
            }
            
            dropDownLogStartDate?.hideDropDown(animated: true)
        }
        else if dropDownUIViewIdentifier == LogsAddLogDropDownTypes.logEndDate.rawValue,
                let cell = dropDownLogEndDate?.dropDownTableView?.cellForRow(at: indexPath) as? DropDownTVC {
            
            cell.setCustomSelectedTableViewCell(forSelected: true)
            
            let timeIntervalSelected = dropDownLogEndDateOptions[indexPath.row].valueInSeconds()
            if let interval = timeIntervalSelected {
                logEndDateSelected = Date().addingTimeInterval(interval)
            }
            else {
                isShowingLogEndDatePicker = true
            }
            
            dropDownLogEndDate?.hideDropDown(animated: true)
        }
    }
    
    // MARK: - Add / Update Log Tasks
    
    private func willAddLog(logActionSelected: LogActionType, logStartDateSelected: Date) {
        saveLogButton.beginSpinning()
        
        // Only retrieve matchingReminders if switch is on.
        let matchingReminders: [(UUID, Reminder)] = {
            return dogManager?.matchingReminders(
                forDogUUIDs: forDogUUIDsSelected,
                forLogActionType: logActionSelected,
                forLogCustomActionName: logCustomActionNameTextField.text
            ) ?? []
        }()
        
        let completionTracker = CompletionTracker(
            numberOfTasks: forDogUUIDsSelected.count + matchingReminders.count
        ) {
            // Each time a task completes, update the dog manager so everything else updates
            if let dm = self.dogManager {
                self.delegate?.didUpdateDogManager(
                    sender: Sender(origin: self, localized: self),
                    forDogManager: dm
                )
            }
        } completedAllTasksCompletionHandler: {
            // When everything completes, close the page
            self.saveLogButton.endSpinning()
            self.dismiss(animated: true) {
                // Request reviews or surveys after dismissal
                ShowBonusInformationManager.requestAppStoreReviewIfNeeded()
                ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
            }
        } failedTaskCompletionHandler: {
            // If a problem is encountered, stop the indicator
            self.saveLogButton.endSpinning()
        }
        
        matchingReminders.forEach { dogUUID, matchingReminder in
            matchingReminder.enableIsSkipping(forSkippedDate: logStartDateSelected)
            
            RemindersRequest.update(
                forErrorAlert: .automaticallyAlertOnlyForFailure,
                forDogUUID: dogUUID,
                forReminders: [matchingReminder]
            ) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    completionTracker.failedTask()
                    return
                }
                completionTracker.completedTask()
            }
        }
        
        for dogUUIDSelected in forDogUUIDsSelected {
            // Each dog needs its own newLog object with its own unique UUID
            let logToAdd = Log(
                forLogActionTypeId: logActionSelected.logActionTypeId,
                forLogCustomActionName: logCustomActionNameTextField.text,
                forLogStartDate: logStartDateSelected,
                forLogEndDate: logEndDateSelected,
                forLogNote: logNoteTextView.text,
                forLogUnitTypeId: logUnitTypeSelected?.logUnitTypeId,
                forLogNumberOfUnits: LogUnitType.convertStringToDouble(
                    forLogNumberOfLogUnits: logNumberOfLogUnitsTextField.text
                )
            )
            
            LogsRequest.create(
                forErrorAlert: .automaticallyAlertOnlyForFailure,
                forDogUUID: dogUUIDSelected,
                forLog: logToAdd
            ) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    completionTracker.failedTask()
                    return
                }
                
                // Request was successful, so add the new custom action name locally
                LocalConfiguration.addLogCustomAction(
                    forLogActionType: logToAdd.logActionType,
                    forLogCustomActionName: logToAdd.logCustomActionName
                )
                
                self.dogManager?.findDog(forDogUUID: dogUUIDSelected)?
                    .dogLogs.addLog(forLog: logToAdd)
                
                completionTracker.completedTask()
            }
        }
    }
    
    private func willUpdateLog(
        dogUUIDToUpdate: UUID,
        logToUpdate: Log,
        logActionSelected: LogActionType,
        logStartDateSelected: Date
    ) {
        logToUpdate.changeLogDate(
            forLogStartDate: logStartDateSelected,
            forLogEndDate: logEndDateSelected
        )
        logToUpdate.logActionTypeId = logActionSelected.logActionTypeId
        logToUpdate.logCustomActionName = logActionSelected.allowsCustom
        ? (logCustomActionNameTextField.text ?? "")
        : ""
        logToUpdate.changeLogUnit(
            forLogUnitTypeId: logUnitTypeSelected?.logUnitTypeId,
            forLogNumberOfLogUnits: LogUnitType.convertStringToDouble(
                forLogNumberOfLogUnits: logNumberOfLogUnitsTextField.text
            )
        )
        logToUpdate.logNote = logNoteTextView.text ?? ""
        
        saveLogButton.beginSpinning()
        
        LogsRequest.update(
            forErrorAlert: .automaticallyAlertOnlyForFailure,
            forDogUUID: dogUUIDToUpdate,
            forLog: logToUpdate
        ) { responseStatus, _ in
            self.saveLogButton.endSpinning()
            guard responseStatus != .failureResponse else {
                return
            }
            
            // Request was successful, so store the custom action name locally
            LocalConfiguration.addLogCustomAction(
                forLogActionType: logToUpdate.logActionType,
                forLogCustomActionName: logToUpdate.logCustomActionName
            )
            
            self.dogManager?.findDog(forDogUUID: dogUUIDToUpdate)?
                .dogLogs.addLog(forLog: logToUpdate)
            
            if let dm = self.dogManager {
                self.delegate?.didUpdateDogManager(
                    sender: Sender(origin: self, localized: self),
                    forDogManager: dm
                )
            }
            
            self.dismiss(animated: true) {
                // Request reviews or surveys after dismissal
                ShowBonusInformationManager.requestAppStoreReviewIfNeeded()
                ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
            }
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        view.addSubview(saveLogButton)
        view.addSubview(backButton)
        
        scrollView.addSubview(containerView)
        containerView.addSubview(pageTitleLabel)
        containerView.addSubview(parentDogLabel)
        containerView.addSubview(familyMemberNameLabel)
        containerView.addSubview(logActionLabel)
        containerView.addSubview(logCustomActionNameTextField)
        containerView.addSubview(logStartDateLabel)
        containerView.addSubview(logStartDatePicker)
        containerView.addSubview(removeLogButton)
        containerView.addSubview(logEndDateLabel)
        containerView.addSubview(logEndDatePicker)
        containerView.addSubview(logUnitLabel)
        containerView.addSubview(logNoteTextView)
        containerView.addSubview(logNumberOfLogUnitsTextField)
        containerView.addSubview(containerViewExtraPadding)
        
        let didTapScreenGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapScreen(sender:))
        )
        didTapScreenGesture.delegate = uiDelegate
        didTapScreenGesture.cancelsTouchesInView = false
        view.addGestureRecognizer(didTapScreenGesture)
        
        let parentDogLabelGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapLabelForDropDown(sender:))
        )
        parentDogLabelGesture.name = LogsAddLogDropDownTypes.parentDog.rawValue
        parentDogLabelGesture.delegate = uiDelegate
        parentDogLabelGesture.cancelsTouchesInView = false
        parentDogLabel.isUserInteractionEnabled = true
        parentDogLabel.addGestureRecognizer(parentDogLabelGesture)
        
        let logActionLabelGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapLabelForDropDown(sender:))
        )
        logActionLabelGesture.name = LogsAddLogDropDownTypes.logActionType.rawValue
        logActionLabelGesture.delegate = uiDelegate
        logActionLabelGesture.cancelsTouchesInView = false
        logActionLabel.isUserInteractionEnabled = true
        logActionLabel.addGestureRecognizer(logActionLabelGesture)
        
        let logUnitLabelGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapLabelForDropDown(sender:))
        )
        logUnitLabelGesture.name = LogsAddLogDropDownTypes.logUnit.rawValue
        logUnitLabelGesture.delegate = uiDelegate
        logUnitLabelGesture.cancelsTouchesInView = false
        logUnitLabel.isUserInteractionEnabled = true
        logUnitLabel.addGestureRecognizer(logUnitLabelGesture)
        
        let logStartDateLabelGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapLabelForDropDown(sender:))
        )
        logStartDateLabelGesture.name = LogsAddLogDropDownTypes.logStartDate.rawValue
        logStartDateLabelGesture.delegate = uiDelegate
        logStartDateLabelGesture.cancelsTouchesInView = false
        logStartDateLabel.isUserInteractionEnabled = true
        logStartDateLabel.addGestureRecognizer(logStartDateLabelGesture)
        
        let logEndDateLabelGesture = UITapGestureRecognizer(
            target: self,
            action: #selector(didTapLabelForDropDown(sender:))
        )
        logEndDateLabelGesture.name = LogsAddLogDropDownTypes.logEndDate.rawValue
        logEndDateLabelGesture.delegate = uiDelegate
        logEndDateLabelGesture.cancelsTouchesInView = false
        logEndDateLabel.isUserInteractionEnabled = true
        logEndDateLabel.addGestureRecognizer(logEndDateLabelGesture)
        
        backButton.addTarget(self, action: #selector(didTouchUpInsideBack), for: .touchUpInside)
        saveLogButton.addTarget(self, action: #selector(didTouchUpInsideSaveLog), for: .touchUpInside)
        
        removeLogButton.addTarget(self, action: #selector(didTouchUpInsideRemoveLog), for: .touchUpInside)
        logStartDatePicker.addTarget(self, action: #selector(didUpdateLogStartDate), for: .valueChanged)
        logEndDatePicker.addTarget(self, action: #selector(didUpdateLogEndDate), for: .valueChanged)
        logNumberOfLogUnitsTextField.addTarget(self, action: #selector(didUpdateLogNumberOfLogUnits), for: .editingChanged)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pageTitleLabel
        let titleTop = pageTitleLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 10)
        let titleCenterX = pageTitleLabel.centerXAnchor.constraint(equalTo: containerView.centerXAnchor)
        let titleHeight = pageTitleLabel.heightAnchor.constraint(equalToConstant: 40)
        
        // removeLogButton
        let removeTop = removeLogButton.topAnchor.constraint(equalTo: pageTitleLabel.topAnchor)
        let removeBottom = removeLogButton.bottomAnchor.constraint(equalTo: pageTitleLabel.bottomAnchor)
        let removeLeading = removeLogButton.leadingAnchor.constraint(equalTo: pageTitleLabel.trailingAnchor, constant: 10)
        let removeTrailing = removeLogButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let removeSquare = removeLogButton.createSquareConstraint()
        
        // parentDogLabel
        let parentDogTop = parentDogLabel.topAnchor.constraint(equalTo: pageTitleLabel.bottomAnchor, constant: 15)
        parentDogBottom = GeneralLayoutConstraint(wrapping: familyMemberNameLabel.topAnchor.constraint(equalTo: parentDogLabel.bottomAnchor, constant: 10))
        let parentDogLeading = parentDogLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let parentDogTrailing = parentDogLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        parentDogHeightMultiplier = GeneralLayoutConstraint(wrapping: parentDogLabel.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Section.inputHeightMultiplier))
        parentDogHeightMultiplier.constraint.priority = .defaultHigh
        parentDogHeightMax = GeneralLayoutConstraint(wrapping: parentDogLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight))
        
        // familyMemberNameLabel
        familyMemberNameBottom = GeneralLayoutConstraint(wrapping: logActionLabel.topAnchor.constraint(equalTo: familyMemberNameLabel.bottomAnchor, constant: 10))
        let familyMemberLeading = familyMemberNameLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let familyMemberTrailing = familyMemberNameLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        familyMemberNameHeightMultiplier = GeneralLayoutConstraint(wrapping: familyMemberNameLabel.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Section.inputHeightMultiplier))
        familyMemberNameHeightMultiplier.constraint.priority = .defaultHigh
        familyMemberNameHeightMax = GeneralLayoutConstraint(wrapping: familyMemberNameLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight))
        
        // logActionLabel
        let logActionLeading = logActionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let logActionTrailing = logActionLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let logActionBottom = logActionLabel.bottomAnchor.constraint(equalTo: logCustomActionNameTextField.topAnchor, constant: -10)
        let logActionHeightMultiplier = logActionLabel.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Section.inputHeightMultiplier)
        logActionHeightMultiplier.priority = .defaultHigh
        let logActionHeightMaxConstraint = logActionLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight)
        
        // logCustomActionNameTextField
        logCustomActionNameBottom = GeneralLayoutConstraint(wrapping: logStartDateLabel.topAnchor.constraint(equalTo: logCustomActionNameTextField.bottomAnchor, constant: 10))
        let logCustomLeading = logCustomActionNameTextField.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let logCustomTrailing = logCustomActionNameTextField.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        logCustomActionNameHeightMultiplier = GeneralLayoutConstraint(wrapping: logCustomActionNameTextField.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Section.inputHeightMultiplier))
        logCustomActionNameHeightMultiplier.constraint.priority = .defaultHigh
        logCustomActionNameHeightMax = GeneralLayoutConstraint(wrapping: logCustomActionNameTextField.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight))
        
        // logStartDateLabel & logStartDatePicker
        let logStartBottom = logStartDateLabel.bottomAnchor.constraint(equalTo: logEndDateLabel.topAnchor, constant: -10)
        let logStartLeading = logStartDateLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let logStartTrailing = logStartDateLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        logStartDateHeightMultiplier = GeneralLayoutConstraint(wrapping: logStartDateLabel.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Section.inputHeightMultiplier))
        logStartDateHeightMultiplier.constraint.priority = .defaultHigh
        logStartDateHeightMax = GeneralLayoutConstraint(wrapping: logStartDateLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight))
        
        let logStartPickerTop = logStartDatePicker.topAnchor.constraint(equalTo: logStartDateLabel.topAnchor)
        let logStartPickerLeading = logStartDatePicker.leadingAnchor.constraint(equalTo: logStartDateLabel.leadingAnchor)
        let logStartPickerTrailing = logStartDatePicker.trailingAnchor.constraint(equalTo: logStartDateLabel.trailingAnchor)
        let logStartPickerBottom = logStartDatePicker.bottomAnchor.constraint(equalTo: logStartDateLabel.bottomAnchor)
        
        // logEndDateLabel & logEndDatePicker
        let logEndBottom = logEndDateLabel.bottomAnchor.constraint(equalTo: logUnitLabel.topAnchor, constant: -10)
        let logEndLeading = logEndDateLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let logEndTrailing = logEndDateLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        logEndDateHeightMultiplier = GeneralLayoutConstraint(wrapping: logEndDateLabel.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Section.inputHeightMultiplier))
        logEndDateHeightMultiplier.constraint.priority = .defaultHigh
        logEndDateHeightMax = GeneralLayoutConstraint(wrapping: logEndDateLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight))
        
        let logEndPickerTop = logEndDatePicker.topAnchor.constraint(equalTo: logEndDateLabel.topAnchor)
        let logEndPickerLeading = logEndDatePicker.leadingAnchor.constraint(equalTo: logEndDateLabel.leadingAnchor)
        let logEndPickerTrailing = logEndDatePicker.trailingAnchor.constraint(equalTo: logEndDateLabel.trailingAnchor)
        let logEndPickerBottom = logEndDatePicker.bottomAnchor.constraint(equalTo: logEndDateLabel.bottomAnchor)
        
        // logUnitLabel
        logUnitBottom = GeneralLayoutConstraint(wrapping: logUnitLabel.bottomAnchor.constraint(equalTo: logNoteTextView.topAnchor, constant: -10))
        let logUnitTrailing = logUnitLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        logUnitHeightMultiplier = GeneralLayoutConstraint(wrapping: logUnitLabel.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Section.inputHeightMultiplier))
        logUnitHeightMultiplier.constraint.priority = .defaultHigh
        logUnitHeightMax = GeneralLayoutConstraint(wrapping: logUnitLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight))
        
        // logNumberOfLogUnitsTextField
        let numberFieldCenterY = logNumberOfLogUnitsTextField.centerYAnchor.constraint(equalTo: logUnitLabel.centerYAnchor)
        let numberFieldLeading = logNumberOfLogUnitsTextField.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let numberFieldTrailing = logNumberOfLogUnitsTextField.trailingAnchor.constraint(equalTo: logUnitLabel.leadingAnchor, constant: -10)
        let numberFieldWidth = logNumberOfLogUnitsTextField.widthAnchor.constraint(equalTo: logUnitLabel.widthAnchor, multiplier: 1.0 / 3.0)
        let numberFieldHeight = logNumberOfLogUnitsTextField.heightAnchor.constraint(equalTo: logUnitLabel.heightAnchor)
        
        // logNoteTextView
        let noteBottom = logNoteTextView.bottomAnchor.constraint(equalTo: containerViewExtraPadding.topAnchor)
        let noteLeading = logNoteTextView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let noteTrailing = logNoteTextView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let noteHeightMultiplier = logNoteTextView.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Section.inputHeightMultiplier * 3.0)
        noteHeightMultiplier.priority = .defaultHigh
        let noteHeightMax = logNoteTextView.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Section.inputMaxHeight * 3.0)
        
        // containerViewExtraPadding
        containerViewExtraPaddingHeight = containerViewExtraPadding.heightAnchor.constraint(equalToConstant: 50)
        let containerViewExtraPaddingBottom = containerViewExtraPadding.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let containerViewExtraPaddingLeading = containerViewExtraPadding.leadingAnchor.constraint(equalTo: containerView.leadingAnchor)
        let containerViewExtraPaddingTrailing = containerViewExtraPadding.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        
        // saveLogButton
        let saveBottom = saveLogButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -10)
        let saveWidthRatio = saveLogButton.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Button.circleHeightMultiplier)
        let saveMaxWidth = saveLogButton.widthAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.circleMaxHeight)
        let saveSquare = saveLogButton.createSquareConstraint()
        let saveTrailing = saveLogButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)
        
        // backButton
        let backBottom = backButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -10)
        let backWidthRatio = backButton.heightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Button.circleHeightMultiplier)
        let backMaxWidth = backButton.widthAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.circleMaxHeight)
        let backSquare = backButton.createSquareConstraint()
        let backLeading = backButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        
        // scrollView
        let scrollTop = scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
        let scrollLeading = scrollView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor)
        let scrollTrailing = scrollView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor)
        let scrollBottom = scrollView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        
        // containerView
        let containerTop = containerView.topAnchor.constraint(equalTo: scrollView.topAnchor)
        let containerLeading = containerView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor)
        let containerTrailing = containerView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor)
        let containerWidth = containerView.widthAnchor.constraint(equalTo: scrollView.widthAnchor)
        let containerBottom = containerView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor)
        
        NSLayoutConstraint.activate([
            // pageTitleLabel
            titleTop,
            titleCenterX,
            titleHeight,
            
            // removeLogButton
            removeTop,
            removeBottom,
            removeLeading,
            removeTrailing,
            removeSquare,
            
            // parentDogLabel
            parentDogTop,
            parentDogBottom.constraint,
            parentDogLeading,
            parentDogTrailing,
            parentDogHeightMultiplier.constraint,
            parentDogHeightMax.constraint,
            
            // familyMemberNameLabel
            familyMemberNameBottom.constraint,
            familyMemberLeading,
            familyMemberTrailing,
            familyMemberNameHeightMultiplier.constraint,
            familyMemberNameHeightMax.constraint,
            
            // logActionLabel
            logActionLeading,
            logActionTrailing,
            logActionHeightMultiplier,
            logActionHeightMaxConstraint,
            logActionBottom,
            
            // logCustomActionNameTextField
            logCustomActionNameBottom.constraint,
            logCustomLeading,
            logCustomTrailing,
            logCustomActionNameHeightMultiplier.constraint,
            logCustomActionNameHeightMax.constraint,
            
            // logStartDateLabel & logStartDatePicker
            logStartBottom,
            logStartLeading,
            logStartTrailing,
            logStartDateHeightMultiplier.constraint,
            logStartDateHeightMax.constraint,
            
            logStartPickerTop,
            logStartPickerLeading,
            logStartPickerTrailing,
            logStartPickerBottom,
            
            // logEndDateLabel & logEndDatePicker
            logEndBottom,
            logEndLeading,
            logEndTrailing,
            logEndDateHeightMultiplier.constraint,
            logEndDateHeightMax.constraint,
            
            logEndPickerTop,
            logEndPickerLeading,
            logEndPickerTrailing,
            logEndPickerBottom,
            
            // logUnitLabel
            logUnitBottom.constraint,
            logUnitTrailing,
            logUnitHeightMultiplier.constraint,
            logUnitHeightMax.constraint,
            
            // logNumberOfLogUnitsTextField
            numberFieldCenterY,
            numberFieldLeading,
            numberFieldTrailing,
            numberFieldWidth,
            numberFieldHeight,
            
            // logNoteTextView
            noteBottom,
            noteLeading,
            noteTrailing,
            noteHeightMultiplier,
            noteHeightMax,
            
            // containerViewExtraPadding
            containerViewExtraPaddingHeight,
            containerViewExtraPaddingBottom,
            containerViewExtraPaddingLeading,
            containerViewExtraPaddingTrailing,
            
            // saveLogButton
            saveBottom,
            saveWidthRatio,
            saveMaxWidth,
            saveSquare,
            saveTrailing,
            
            // backButton
            backBottom,
            backWidthRatio,
            backMaxWidth,
            backSquare,
            backLeading,
            
            // scrollView
            scrollTop,
            scrollLeading,
            scrollTrailing,
            scrollBottom,
            
            // containerView
            containerTop,
            containerLeading,
            containerTrailing,
            containerWidth,
            containerBottom,
        ])
        
        
    }
    
    
}
//
//  LogsTableViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/17/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol LogsTableViewControllerDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager)
    func didSelectLog(forDogUUID: UUID, forLog: Log)
    func shouldUpdateNoLogsRecorded(forIsHidden: Bool)
    func shouldUpdateAlphaForButtons(forAlpha: Double)
    func shouldUpdateFilterLogsButton()
}

final class LogsTableViewController: GeneralUITableViewController {
    
    // MARK: - UIScrollViewDelegate
    
    override func scrollViewDidScroll(_ scrollView: UIScrollView) {
        guard let referenceContentOffsetY = referenceContentOffsetY else {
            return
        }
        
        // Sometimes the default contentOffset.y isn't 0.0; adjust it to 0.0
        let adjustedContentOffsetY = scrollView.contentOffset.y - referenceContentOffsetY
        // When contentOffset.y reaches alphaConstant, UI element's alpha becomes 0
        let alphaConstant: Double = 100.0
        let alpha: Double = max(1.0 - (adjustedContentOffsetY / alphaConstant), 0.0)
        delegate?.shouldUpdateAlphaForButtons(forAlpha: alpha)
    }
    
    // MARK: - Properties
    
    /// Array of tuples [[(forDogUUID, log)]].
    /// Logs are grouped by date; first element is future, last is oldest.
    private(set) var logsForDogUUIDsGroupedByDate: [[(UUID, Log)]] = []
    
    private var storedLogsFilter: LogsFilter = LogsFilter(forDogManager: DogManager())
    var logsFilter: LogsFilter {
        get {
            storedLogsFilter
        }
        set {
            self.storedLogsFilter = newValue
            
            // Only reload data if view is visible; otherwise mark for later update
            guard self.viewIfLoaded?.window != nil else {
                tableViewDataSourceHasBeenUpdated = true
                return
            }
            
            reloadTable()
        }
    }
    
    /// Track if we need to refresh data when view appears
    private var tableViewDataSourceHasBeenUpdated: Bool = false
    
    private weak var delegate: LogsTableViewControllerDelegate?
    
    /// Tracks default contentOffset.y (usually ~–47.0) to compute alpha changes
    private(set) var referenceContentOffsetY: Double?
    
    // MARK: Page Loader
    
    /// How many logs to load each time user scrolls to bottom
    private static var logsDisplayedLimitIncrementation = 100
    /// Number of logs currently displayed; initial value is twice the incrementation
    static var logsDisplayedLimit: Int = logsDisplayedLimitIncrementation * 2
    
    // MARK: - Dog Manager
    
    private(set) var dogManager: DogManager = DogManager()
    
    /// Update dogManager and refresh UI accordingly
    func setDogManager(sender: Sender, forDogManager: DogManager) {
        dogManager = forDogManager
        logsFilter.apply(forDogManager: forDogManager)
        
        if (sender.localized is LogsTableViewController) == true {
            delegate?.didUpdateDogManager(sender: Sender(origin: sender, localized: self), forDogManager: dogManager)
        }
        
        reloadTable()
        
        delegate?.shouldUpdateFilterLogsButton()
        delegate?.shouldUpdateNoLogsRecorded(forIsHidden: !logsForDogUUIDsGroupedByDate.isEmpty)
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.tableView.register(LogsTVC.self, forCellReuseIdentifier: LogsTVC.reuseIdentifier)
        self.tableView.allowsSelection = true
        self.tableView.refreshControl = UIRefreshControl()
        self.tableView.refreshControl?.addTarget(self, action: #selector(refreshTableData), for: .valueChanged)
        self.tableView.separatorStyle = .none
        self.tableView.rowHeight = UITableView.automaticDimension
        self.tableView.estimatedRowHeight = 123
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        // If data was updated offscreen, reload table now
        if tableViewDataSourceHasBeenUpdated {
            reloadTable()
            tableViewDataSourceHasBeenUpdated = false
        }
        else {
            reloadTable()
        }
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        let dummyTableTableHeaderViewHeight = 100.0
        // Prevent section headers from floating by adding blank space at top
        tableView.tableHeaderView = UIView(
            frame: CGRect(
                x: 0,
                y: 0,
                width: self.tableView.bounds.size.width,
                height: dummyTableTableHeaderViewHeight
            )
        )
        tableView.contentInset = UIEdgeInsets(
            top: -dummyTableTableHeaderViewHeight,
            left: 0,
            bottom: 0,
            right: 0
        )
        
        if referenceContentOffsetY == nil {
            referenceContentOffsetY = tableView.contentOffset.y
        }
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: LogsTableViewControllerDelegate) {
        self.delegate = forDelegate
    }
    
    // MARK: - Functions
    
    /// Fetch new logs from server, then reload table
    @objc private func refreshTableData() {
        PresentationManager.beginFetchingInformationIndicator()
        DogsRequest.get(
            forErrorAlert: .automaticallyAlertOnlyForFailure,
            forDogManager: dogManager
        ) { newDogManager, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                // End refresh animation first to avoid visual glitch
                self.tableView.refreshControl?.endRefreshing()
                
                guard responseStatus != .failureResponse, let newDogManager = newDogManager else {
                    return
                }
                
                if responseStatus == .successResponse {
                    PresentationManager.enqueueBanner(
                        forTitle: VisualConstant.BannerTextConstant.successRefreshLogsTitle,
                        forSubtitle: VisualConstant.BannerTextConstant.successRefreshLogsSubtitle,
                        forStyle: .success
                    )
                }
                else {
                    if OfflineModeManager.shared.hasDisplayedOfflineModeBanner == true {
                        // Only show if offline banner already shown
                        PresentationManager.enqueueBanner(
                            forTitle: VisualConstant.BannerTextConstant.infoRefreshOnHoldTitle,
                            forSubtitle: VisualConstant.BannerTextConstant.infoRefreshOnHoldSubtitle,
                            forStyle: .info
                        )
                    }
                }
                
                self.setDogManager(
                    sender: Sender(origin: self, localized: self),
                    forDogManager: newDogManager
                )
            }
        }
    }
    
    /// Compute logsForDogUUIDsGroupedByDate and reload table view
    private func reloadTable() {
        // Avoid recomputation if no logs
        logsForDogUUIDsGroupedByDate = dogManager.logsForDogUUIDsGroupedByDate(forFilter: logsFilter)
        tableView.isUserInteractionEnabled = !logsForDogUUIDsGroupedByDate.isEmpty
        tableView.reloadData()
    }
    
    // MARK: - Table View Data Source
    
    override func numberOfSections(in tableView: UITableView) -> Int {
        return logsForDogUUIDsGroupedByDate.count
    }
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        // No logs => no rows
        guard !logsForDogUUIDsGroupedByDate.isEmpty else {
            return 0
        }
        
        return logsForDogUUIDsGroupedByDate[section].count
    }
    
    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerView = GeneralHeaderView()
        
        let date = logsForDogUUIDsGroupedByDate[section].first?.1.logStartDate ?? Date()
        let currentYear = Calendar.current.component(.year, from: Date())
        let dateYear = Calendar.current.component(.year, from: date)
        
        // today
        if Calendar.current.isDateInToday(date) {
            headerView.setTitle("Today")
        }
        // yesterday
        else if Calendar.current.isDateInYesterday(date) {
            headerView.setTitle("Yesterday")
        }
        else if Calendar.current.isDateInTomorrow(date) {
            headerView.setTitle("Tomorrow")
        }
        else {
            let dateFormatter = DateFormatter()
            // Wednesday, January 25 or Wednesday, January 25 2023
            dateFormatter.setLocalizedDateFormatFromTemplate( dateYear == currentYear ? "EEEEMMMMd" : "EEEEMMMMdyyyy")
            
            headerView.setTitle(dateFormatter.string(from: date))
        }
        
        return headerView
    }
    
    override func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return GeneralHeaderView.cellHeight
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard !logsForDogUUIDsGroupedByDate.isEmpty else {
            return GeneralUITableViewCell()
        }
        
        let (dogUUID, log) = logsForDogUUIDsGroupedByDate[indexPath.section][indexPath.row]
        
        guard let dog = dogManager.findDog(forDogUUID: dogUUID) else {
            return GeneralUITableViewCell()
        }
        
        guard let cell = tableView.dequeueReusableCell(
            withIdentifier: LogsTVC.reuseIdentifier,
            for: indexPath
        ) as? LogsTVC else {
            return GeneralUITableViewCell()
        }
        
        cell.setup(forParentDogName: dog.dogName, forLog: log)
        
        // Reset rounding before applying new corners
        cell.containerView.roundCorners(setCorners: .none)
        
        // Top cell: round top corners
        if indexPath.row == 0 {
            cell.containerView.roundCorners(addCorners: .top)
        }
        // Bottom cell: round bottom corners
        if indexPath.row == logsForDogUUIDsGroupedByDate[indexPath.section].count - 1 {
            cell.containerView.roundCorners(addCorners: .bottom)
        }
        
        return cell
    }
    
    // Allow swipe-to-delete
    override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        return true
    }
    
    // Handle deletion of a log
    override func tableView(
        _ tableView: UITableView,
        commit editingStyle: UITableViewCell.EditingStyle,
        forRowAt indexPath: IndexPath
    ) {
        guard editingStyle == .delete else {
            return
        }
        
        let (forDogUUID, forLog) = logsForDogUUIDsGroupedByDate[indexPath.section][indexPath.row]
        
        LogsRequest.delete(
            forErrorAlert: .automaticallyAlertOnlyForFailure,
            forDogUUID: forDogUUID,
            forLogUUID: forLog.logUUID
        ) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                return
            }
            
            self.dogManager.findDog(forDogUUID: forDogUUID)?
                .dogLogs.removeLog(forLogUUID: forLog.logUUID)
            self.setDogManager(
                sender: Sender(origin: self, localized: self),
                forDogManager: self.dogManager
            )
        }
    }
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let (forDogUUID, forLog) = logsForDogUUIDsGroupedByDate[indexPath.section][indexPath.row]
        
        PresentationManager.beginFetchingInformationIndicator()
        LogsRequest.get(
            forErrorAlert: .automaticallyAlertOnlyForFailure,
            forDogUUID: forDogUUID,
            forLog: forLog
        ) { log, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                self.tableView.deselectRow(at: indexPath, animated: true)
                
                guard responseStatus != .failureResponse else {
                    return
                }
                
                guard let log = log else {
                    // Log was deleted on server; update local manager
                    self.dogManager.findDog(forDogUUID: forDogUUID)?
                        .dogLogs.removeLog(forLogUUID: forLog.logUUID)
                    self.setDogManager(
                        sender: Sender(origin: self, localized: self),
                        forDogManager: self.dogManager
                    )
                    return
                }
                
                self.delegate?.didSelectLog(forDogUUID: forDogUUID, forLog: log)
            }
        }
    }
    
    override func tableView(
        _ tableView: UITableView,
        willDisplay cell: UITableViewCell,
        forRowAt indexPath: IndexPath
    ) {
        // Check if user has scrolled near bottom to load more logs
        var possibleLogsDisplayed = 0
        var currentLogsDisplayed = 0
        
        for (index, array) in logsForDogUUIDsGroupedByDate.enumerated() {
            possibleLogsDisplayed += array.count
            if index <= indexPath.section {
                currentLogsDisplayed += array.count
            }
        }
        
        // If at limit and near bottom, increase limit and reload
        guard (possibleLogsDisplayed == LogsTableViewController.logsDisplayedLimit),
              currentLogsDisplayed >= (possibleLogsDisplayed - LogsTableViewController.logsDisplayedLimitIncrementation)
        else {
            return
        }
        
        LogsTableViewController.logsDisplayedLimit += LogsTableViewController.logsDisplayedLimitIncrementation
        reloadTable()
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        tableView.backgroundColor = .secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
    }
    
    override func setupConstraints() {
        super.setupConstraints()
    }
}
//
//  AppDelegate.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import os.log
import UIKit
import UserNotifications

@UIApplicationMain

final class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate {

    static var generalLogger = Logger(subsystem: "com.example.Pupotty", category: "General")
    static var lifeCycleLogger = Logger(subsystem: "com.example.Pupotty", category: "Life Cycle")
    static var APIRequestLogger = Logger(subsystem: "com.example.Pupotty", category: "API Request")
    static var APIResponseLogger = Logger(subsystem: "com.example.Pupotty", category: "API Response")

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        AppDelegate.lifeCycleLogger.notice("Application Did Finish Launching with Options")
        
        // Trigger the initialization of NetworkManager and start monitoring
        _ = NetworkManager.shared

        PersistenceManager.applicationDidFinishLaunching()

        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this function to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }
    
    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        AppDelegate.lifeCycleLogger.notice("Application Did Discard Scene Sessions")
        // DO NOT CALL IMPORTANT LIFECYCLE OPERATIONS FROM HERE, IF ASSOCIATED SCENE OPERATION EXISTS (e.g. sceneDidEnterBackground), USE THAT INSTEAD. These function are inconsistent as should be only used as backups, as scene drive lifecycle takes precedence
        PersistenceManager.didEnterBackground(isTerminating: true)
    }

    func applicationWillEnterForeground(_ application: UIApplication) {
        AppDelegate.lifeCycleLogger.notice("Application Will Enter Foreground")
        // DO NOT CALL IMPORTANT LIFECYCLE OPERATIONS FROM HERE, IF ASSOCIATED SCENE OPERATION EXISTS (e.g. sceneDidEnterBackground), USE THAT INSTEAD. These function are inconsistent as should be only used as backups, as scene drive lifecycle takes precedence
    }

    func applicationDidEnterBackground(_ application: UIApplication) {
        AppDelegate.lifeCycleLogger.notice("Application Did Enter Background")
        // DO NOT CALL IMPORTANT LIFECYCLE OPERATIONS FROM HERE, IF ASSOCIATED SCENE OPERATION EXISTS (e.g. sceneDidEnterBackground), USE THAT INSTEAD. These function are inconsistent as should be only used as backups, as scene drive lifecycle takes precedence
    }

    func applicationWillTerminate(_ application: UIApplication) {
        AppDelegate.lifeCycleLogger.notice("Application Will Terminate")
        // DO NOT CALL IMPORTANT LIFECYCLE OPERATIONS FROM HERE, IF ASSOCIATED SCENE OPERATION EXISTS (e.g. sceneDidEnterBackground), USE THAT INSTEAD. These function are inconsistent as should be only used as backups, as scene drive lifecycle takes precedence
        PersistenceManager.didEnterBackground(isTerminating: true)
    }

    /// If the application performs didRegisterForRemoteNotificationsWithDeviceToken while a userId and/or userIdentifier are not established or loaded into memory, then the request will fail. Therefore, we check that these variables are valid. If this check fails, we set a timer to recheck every minute. We must keep track of this timer incase we need to invalidate it..
    private var userNotificationTokenTimer: Timer?
    /// The interval at which the userNotificationTokenTimer will invoke updateUserNotificationToken to attempt to update the API with the new deviceToken
    private let userNotificationTokenTimerRetryInterval: Double = 5.0
    private var userNotificationTokenTimerNumberOfRetrys: Double = 1.0

    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        let tokenParts = deviceToken.map { data in String(format: "%02.2hhx", data) }
        let token = tokenParts.joined()
        AppDelegate.generalLogger.notice("Successfully registered for remote notifications for token: \(token)")

        // If the new deviceToken is different from the saved deviceToken (i.e. there is a new token or there was no token saved), then we should attempt to update the server
        guard token != UserInformation.userNotificationToken else {
            return
        }

        updateUserNotificationToken()

        func updateUserNotificationToken() {
            // clear any existing timer for this new invocation
            userNotificationTokenTimer?.invalidate()
            userNotificationTokenTimer = nil

            // Check to make sure userId and userIdentifier are established. If they are not, then keep waiting userNotificationTokenTimerRetryInterval to check again. Once they are established, we send the request.
            guard UserInformation.userId != nil && UserInformation.userIdentifier != nil else {
                userNotificationTokenTimer = Timer(fire: Date().addingTimeInterval(userNotificationTokenTimerRetryInterval * userNotificationTokenTimerNumberOfRetrys), interval: -1, repeats: false) { _ in
                    updateUserNotificationToken()
                }
                if let userNotificationTokenTimer = userNotificationTokenTimer {
                    RunLoop.main.add(userNotificationTokenTimer, forMode: .common)
                }

                userNotificationTokenTimerNumberOfRetrys += 1.0
                return
            }

            let body: [String: CompatibleDataTypeForJSON?] = [KeyConstant.userNotificationToken.rawValue: token]
            UserRequest.update(
                forErrorAlert: .automaticallyAlertForNone,
                forBody: body
            ) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }
                
                UserInformation.userNotificationToken = token
            }
        }
    }

    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        AppDelegate.generalLogger.error("Failed to register for remote notifications with error: \(error.localizedDescription)")
    }

    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable: Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
        // look for the aps body
        guard let aps = userInfo["aps"] as? [String: Any] else {
            completionHandler(.noData)
            return
        }
        
        guard let category = aps["category"] as? String else {
            completionHandler(.noData)
            return
        }
        
        if category.contains("NOTIFICATION_CATEGORY_USER_KICKED") {
            // user was kicked from their family so we should back them into the server sync meny
            PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncViewController.self, completionHandler: nil)
            completionHandler(.newData)
            return
        }
        else if category.contains("NOTIFICATION_CATEGORY_FAMILY") {
            // family was updated so we should refresh the family
            MainTabBarController.shouldRefreshFamily = true
            completionHandler(.newData)
            return
        }
        // Always refresh the dog manager when we recieve a log notification, as that means another user logged something.
        // If we invoke on 'NOTIFICATION_CATEGORY_REMINDER' as well, then everytime a reminder triggers its alarm and a notification comes thru, it will cause a refresh. This will cause a weird interaction as we will be simultaneously showing an alert in app
        else if category.contains("NOTIFICATION_CATEGORY_LOG") {
            MainTabBarController.shouldRefreshDogManager = true
            completionHandler(.newData)
            return
        }
        // if the notification is a reminder, then check to see if loud notification can be played
        else if category.contains("NOTIFICATION_CATEGORY_REMINDER") {
            // check to see if we have a reminderLastModified available to us
            if let reminderLastModifiedString = userInfo["reminderLastModified"] as? String, let reminderLastModified = reminderLastModifiedString.formatISO8601IntoDate() {
                
                if let previousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization, previousDogManagerSynchronization.distance(to: reminderLastModified) > 0 {
                    // If the reminder was modified after the last time we synced our whole dogManager, then that means our local reminder is out of date.
                    // This makes our local reminder untrustworthy. The server reminder could have been deleted (and we don't know), the server reminder could have been created (and we don't have it locally), or the server reminder could have had its timing changes (and our locally timing will be inaccurate).
                    // Therefore, we should refresh the dogManager to make sure we are up to date on important features of the reminder's state: create, delete, timing.
                    // Once everything is synced again, the alarm will be shown as expected.

                    // Note: we also individually refresh a reminder before immediately constructing its alertController for its alarm. This ensure, even if the user has notifications turned off (meaning this piece of code right here won't be executed), that the reminder they are being show is up to date.
                    MainTabBarController.shouldRefreshDogManager = true
                }
                else if LocalConfiguration.previousDogManagerSynchronization == nil {
                    MainTabBarController.shouldRefreshDogManager = true
                }
            }

            AudioManager.playLoudNotification()

            completionHandler(.newData)
            return
        }

        completionHandler(.noData)
        return
    }
    
    func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask {
        return [.portrait]
    }

}
//
//  SceneDelegate.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        AppDelegate.lifeCycleLogger.notice("Scene Will Connect To Session")
        // Use this function to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).

        // If UserConfiguration.interfaceStyle is updated, it will send a didUpdateUserInterfaceStyle notification, which we then recieve to overrideUserInterfaceStyle every view in our window with the new value
        NotificationCenter.default.addObserver(self, selector: #selector(didUpdateUserInterfaceStyle), name: .didUpdateUserInterfaceStyle, object: nil)

        // set initial interface style
        window?.overrideUserInterfaceStyle = UserConfiguration.interfaceStyle

        guard let windowScene = scene as? UIWindowScene else { return }
        
        let window = UIWindow(windowScene: windowScene)
        let vc = ServerSyncViewController()
        window.rootViewController = vc
        window.makeKeyAndVisible()
        self.window = window
    }

    @objc private func didUpdateUserInterfaceStyle() {
        window?.overrideUserInterfaceStyle = UserConfiguration.interfaceStyle
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        AppDelegate.lifeCycleLogger.notice("Scene Did Disconnect")
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not neccessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        AppDelegate.lifeCycleLogger.notice("Scene Did Become Active")

        // Scene must be active for synchronizeReminderAlarmQueueIfNeeded to work
        ReminderAlarmManager.synchronizeReminderAlarmQueueIfNeeded()
        // Called when the scene has moved from an inactive state to an active state.
        // Use this function to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        AppDelegate.lifeCycleLogger.notice("Scene Will Resign Active")
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this function to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.
        AppDelegate.lifeCycleLogger.notice("Scene Did Enter Background")
        PersistenceManager.didEnterBackground(isTerminating: false)
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        AppDelegate.lifeCycleLogger.notice("Scene Will Enter Foreground")
        PersistenceManager.willEnterForeground()
    }
}
//
//  MainTabBar.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED
final class MainTabBar: UITabBar {

    // MARK: - Properties

    private var shapeLayer: CALayer?
    private let radii: Double = VisualConstant.LayerConstant.imageCoveringViewCornerRadius

    // MARK: - Main

    override func draw(_ rect: CGRect) {
        addShape()
    }

    override func layoutSubviews() {
        super.layoutSubviews()
        self.isTranslucent = true
        self.layer.cornerRadius = VisualConstant.LayerConstant.imageCoveringViewCornerRadius
        self.layer.cornerCurve = .continuous
    }

    // MARK: - Functions

    private func addShape() {
        let shapeLayer = CAShapeLayer()

        shapeLayer.path = {
            UIBezierPath(
                roundedRect: bounds,
                byRoundingCorners: [.topLeft, .topRight],
                cornerRadii: CGSize(width: radii, height: 0.0)
            ).cgPath
        }()
        shapeLayer.strokeColor = UIColor.systemGray4.cgColor
        shapeLayer.fillColor = UIColor.systemBackground.cgColor
        shapeLayer.lineWidth = 1
        shapeLayer.shadowColor = UIColor.systemGray4.cgColor
        shapeLayer.shadowOffset = CGSize(width: 0, height: -2)
        shapeLayer.shadowOpacity = 0.1
        shapeLayer.shadowRadius = 8
        shapeLayer.shadowPath = UIBezierPath(roundedRect: bounds, cornerRadius: radii).cgPath

        if let oldShapeLayer = self.shapeLayer {
            layer.replaceSublayer(oldShapeLayer, with: shapeLayer)
        }
        else {
            layer.insertSublayer(shapeLayer, at: 0)
        }

        self.shapeLayer = shapeLayer
    }

}
//
//  MainTabBarController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/1/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

// UI VERIFIED
final class MainTabBarController: GeneralUITabBarController,
                                  ReminderTimingManagerDelegate,
                                  RemindersIntroductionViewControllerDelegate,
                                  ReminderAlarmManagerDelegate,
                                  LogsViewControllerDelegate,
                                  DogsViewControllerDelegate,
                                  SettingsPagesTableViewControllerDelegate,
                                  OfflineModeManagerDelegate,
                                  UITabBarControllerDelegate {
    
    // MARK: LogsViewControllerDelegate && DogsViewControllerDelegate
    
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager) {
        setDogManager(sender: sender, forDogManager: forDogManager)
    }
    
    // MARK: - ReminderAlarmManagerDelegate
    
    func didAddLog(sender: Sender, forDogUUID: UUID, forLog log: Log) {
        dogManager.findDog(forDogUUID: forDogUUID)?.dogLogs.addLog(forLog: log)
        setDogManager(sender: sender, forDogManager: dogManager)
    }
    
    func didRemoveReminder(sender: Sender, forDogUUID: UUID, forReminderUUID: UUID) {
        let dogReminders = dogManager.findDog(forDogUUID: forDogUUID)?.dogReminders
        dogReminders?.removeReminder(forReminderUUID: forReminderUUID)
        setDogManager(sender: sender, forDogManager: dogManager)
    }
    
    // MARK: - ReminderAlarmManagerDelegate && ReminderTimingManagerDelegate
    
    func didAddReminder(sender: Sender, forDogUUID: UUID, forReminder reminder: Reminder) {
        dogManager.findDog(forDogUUID: forDogUUID)?.dogReminders.addReminder(forReminder: reminder)
        setDogManager(sender: sender, forDogManager: dogManager)
    }
    
    // MARK: - Dog Manager
    
    private var dogManager: DogManager = DogManager.globalDogManager ?? DogManager()
    
    /// Sets dog manager; when the value changes, propagate timers and child VCs
    func setDogManager(sender: Sender, forDogManager: DogManager) {
        dogManager = forDogManager
        DogManager.globalDogManager = dogManager
        
        // If not coming from ServerSyncViewController, initialize timers
        if (sender.localized is ServerSyncViewController) == false {
            ReminderTimingManager.initializeReminderTimers(forDogManager: dogManager)
        }
        // Propagate to DogsViewController if sender isn't DogsViewController
        if (sender.localized is DogsViewController) == false {
            dogsViewController.setDogManager(
                sender: Sender(origin: sender, localized: self),
                forDogManager: dogManager
            )
        }
        // Propagate to LogsViewController if sender isn't LogsViewController
        if (sender.localized is LogsViewController) == false {
            logsViewController.setDogManager(
                sender: Sender(origin: sender, localized: self),
                forDogManager: dogManager
            )
        }
    }
    
    // MARK: - UITabBarControllerDelegate
    
    func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -> Bool {
        if let index = tabBarController.viewControllers?.firstIndex(of: viewController),
           index != tabBarController.selectedIndex {
            // Manually set selectedIndex, disables built-in animation
            tabBarController.selectedIndex = index
            return false
        }
        return true
    }
    
    // MARK: - Properties
    
    enum MainTabBarControllerIndexes: Int {
        case logs = 0
        case reminders = 1
        case settings = 2
    }
    
    private static var mainTabBarController: MainTabBarController?
    
    private let logsViewController = LogsViewController()
    private let dogsViewController = DogsViewController()
    private let settingsPagesTableViewController = SettingsPagesTableViewController()
    
    var tabBarUpperLineView: UIView?
    
    /// Returns true if this controller is currently in the view hierarchy
    static var isInViewHierarchy: Bool {
        return MainTabBarController.mainTabBarController?.viewIfLoaded?.window != nil
    }
    
    /// Toggled when a 'reminder' or 'log' notification arrives, indicating a refresh is needed
    static var shouldRefreshDogManager: Bool = false {
        didSet {
            guard shouldRefreshDogManager == true else { return }
            guard let mainTBC = MainTabBarController.mainTabBarController,
                  mainTBC.viewIfLoaded?.window != nil else {
                // Not visible; refresh when it appears
                return
            }
            DogsRequest.get(
                forErrorAlert: .automaticallyAlertForNone,
                forDogManager: mainTBC.dogManager
            ) { newDM, _, _ in
                MainTabBarController.shouldRefreshDogManager = false
                guard let newDM = newDM else { return }
                mainTBC.setDogManager(
                    sender: Sender(origin: self, localized: self),
                    forDogManager: newDM
                )
            }
        }
    }
    
    /// Toggled when a 'family' notification arrives, indicating a family‐level refresh
    static var shouldRefreshFamily: Bool = false {
        didSet {
            guard shouldRefreshFamily == true else { return }
            guard MainTabBarController.mainTabBarController?.viewIfLoaded?.window != nil else {
                // Not visible; refresh when it appears
                return
            }
            FamilyRequest.get(forErrorAlert: .automaticallyAlertForNone) { _, _ in
                MainTabBarController.shouldRefreshFamily = false
            }
        }
    }
    
    // MARK: - Main
    
    convenience init() {
        self.init(nibName: nil, bundle: nil)
    }
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        self.modalPresentationStyle = .fullScreen
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        delegate = self
        tabBar.isTranslucent = true
        navigationController?.navigationBar.isTranslucent = true
        
        AppDelegate.generalLogger.notice("Version: \(UIApplication.appVersion)")
        
        logsViewController.setup(forDelegate: self)
        logsViewController.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: dogManager)
        
        dogsViewController.setup(forDelegate: self)
        dogsViewController.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: dogManager)
        
        settingsPagesTableViewController.setup(forDelegate: self)
        
        MainTabBarController.mainTabBarController = self
        ReminderTimingManager.delegate = self
        ReminderAlarmManager.delegate = self
        OfflineModeManager.shared.delegate = self
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        if MainTabBarController.shouldRefreshDogManager {
            DogsRequest.get(
                forErrorAlert: .automaticallyAlertForNone,
                forDogManager: self.dogManager
            ) { newDM, _, _ in
                MainTabBarController.shouldRefreshDogManager = false
                guard let newDM = newDM else { return }
                self.setDogManager(
                    sender: Sender(origin: self, localized: self),
                    forDogManager: newDM
                )
            }
        }
        
        if MainTabBarController.shouldRefreshFamily {
            FamilyRequest.get(forErrorAlert: .automaticallyAlertForNone) { _, _ in
                MainTabBarController.shouldRefreshFamily = false
            }
        }
    }
    
    private var didSetupCustomSubviews: Bool = false
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        if UserInformation.isUserFamilyHead {
            InAppPurchaseManager.initializeInAppPurchaseManager()
            InAppPurchaseManager.showPriceConsentIfNeeded()
        }
        
        ShowBonusInformationManager.showReleaseNotesBannerIfNeeded()
        
        // Synchronize notifications and timers on each appearance
        NotificationPermissionsManager.synchronizeNotificationAuthorization()
        ReminderTimingManager.initializeReminderTimers(forDogManager: dogManager)
        
        guard didSetupCustomSubviews == false else { return }
        didSetupCustomSubviews = true
        
        // Slight delay so tab item frames are valid before drawing underline
        DispatchQueue.main.asyncAfter(deadline: .now()) {
            self.addTabBarUpperLine(forIndex: self.selectedIndex)
        }
    }
    
    // MARK: - Functions
    
    override func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
        // selectedIndex is still the “old” index at this moment; compute new index manually
        guard let newIndex = tabBar.items?.firstIndex(of: item) else { return }
        addTabBarUpperLine(forIndex: newIndex)
        
        switch newIndex {
        case MainTabBarControllerIndexes.logs.rawValue:
            logsViewController.scrollLogsTableViewControllerToTop()
        case MainTabBarControllerIndexes.reminders.rawValue:
            dogsViewController.scrollDogsTableViewControllerToTop()
            
            if LocalConfiguration.localHasCompletedRemindersIntroductionViewController == false {
                if dogManager.hasCreatedReminder == false {
                    let introVC = RemindersIntroductionViewController()
                    introVC.setup(forDelegate: self, forDogManager: dogManager)
                    PresentationManager.enqueueViewController(introVC)
                }
                else {
                    // Not eligible; request notifications directly
                    NotificationPermissionsManager.requestNotificationAuthorization(
                        shouldAdviseUserBeforeRequestingNotifications: true,
                        completionHandler: nil
                    )
                    LocalConfiguration.localHasCompletedRemindersIntroductionViewController = true
                }
            }
        default:
            break
        }
    }
    
    private func addTabBarUpperLine(forIndex index: Int) {
        // Underline the selected tab item by accessing its underlying view
        guard let tabView = tabBar.items?[index].value(forKey: "view") as? UIView else {
            return
        }
        tabBarUpperLineView?.removeFromSuperview()
        
        let inset = tabView.frame.width * 0.15
        let lineFrame = CGRect(
            x: tabView.frame.minX + inset,
            y: tabView.frame.minY + 0.1,
            width: tabView.frame.width - (inset * 2),
            height: 2.0
        )
        let line = UIView(frame: lineFrame)
        line.backgroundColor = .systemBlue
        tabBar.addSubview(line)
        tabBarUpperLineView = line
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        if let mainTabBar = self.value(forKey: "tabBar") as? UITabBar,
           !(mainTabBar is MainTabBar) {
            let customTabBar = MainTabBar()
            self.setValue(customTabBar, forKey: "tabBar")
        }
        
        view.backgroundColor = .secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        let logsNavController = {
            let navController = UINavigationController(rootViewController: logsViewController)
            navController.navigationBar.barTintColor = .systemBackground
            navController.navigationBar.titleTextAttributes = [
                NSAttributedString.Key.font: UIFont.boldSystemFont(ofSize: 20),
                NSAttributedString.Key.foregroundColor: UIColor.systemBlue
            ]
            navController.navigationBar.isHidden = true
            navController.tabBarItem = UITabBarItem(
                title: "Logs",
                image: UIImage(systemName: "list.bullet.rectangle"),
                tag: MainTabBarControllerIndexes.logs.rawValue
            )
            
            return navController
        }()
        
        let dogsNavController = {
            let navController = UINavigationController(rootViewController: dogsViewController)
            navController.navigationBar.barTintColor = .systemBackground
            navController.navigationBar.titleTextAttributes = [
                NSAttributedString.Key.font: UIFont.boldSystemFont(ofSize: 20),
                NSAttributedString.Key.foregroundColor: UIColor.systemBlue
            ]
            navController.navigationBar.isHidden = true
            navController.tabBarItem = UITabBarItem(
                title: "Reminders",
                image: UIImage(named: "blackPaw"),
                tag: MainTabBarControllerIndexes.reminders.rawValue
            )
            
            return navController
        }()
        
        let settingsNavController = {
            let navController = UINavigationController(rootViewController: settingsPagesTableViewController)
            navController.navigationBar.barTintColor = .systemBackground
            navController.navigationBar.titleTextAttributes = [
                NSAttributedString.Key.font: UIFont.boldSystemFont(ofSize: 20),
                NSAttributedString.Key.foregroundColor: UIColor.systemBlue
            ]
            navController.navigationBar.isHidden = true
            navController.tabBarItem = UITabBarItem(
                title: "Settings",
                image: UIImage(systemName: "gearshape"),
                tag: MainTabBarControllerIndexes.settings.rawValue
            )
            
            return navController
        }()
        
        self.viewControllers = [logsNavController, dogsNavController, settingsNavController]
    }
    
    override func setupConstraints() {
        super.setupConstraints()
    }
}
//
//  DogsAddDogDisplayReminderTVC.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/20/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddDogDisplayReminderTVCDelegate: AnyObject {
    /// The reminder switch to toggle the enable status was flipped. The reminder was updated and the server was NOT queried.
    func didUpdateReminderIsEnabled(sender: Sender, forReminderUUID: UUID, forReminderIsEnabled: Bool)
}

final class DogsAddDogDisplayReminderTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        view.borderColor = .systemGray
        view.borderWidth = 0.5
        view.shouldRoundCorners = true
        return view
    }()
    
    private let reminderActionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.font = .systemFont(ofSize: 30, weight: .semibold)
        return label
    }()
    
    private let reminderDisplayableIntervalLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        return label
    }()
    
    private let reminderIsEnabledSwitch: GeneralUISwitch = {
        let uiSwitch = GeneralUISwitch(huggingPriority: 290, compressionResistancePriority: 290)
        uiSwitch.isOn = true
        return uiSwitch
    }()
    
    private let chevonImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 300, compressionResistancePriority: 300)

        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = .systemGray4
        
        return imageView
    }()
    
    @objc private func didToggleReminderIsEnabled(_ sender: Any) {
        guard let reminderUUID = reminderUUID else {
            return
        }
        
        delegate?.didUpdateReminderIsEnabled(sender: Sender(origin: self, localized: self), forReminderUUID: reminderUUID, forReminderIsEnabled: reminderIsEnabledSwitch.isOn)
    }
    
    // MARK: - Properties
    
    static let reuseIdentifier = "DogsDogTVC"
    
    private var reminderUUID: UUID?
    
    private weak var delegate: DogsAddDogDisplayReminderTVCDelegate?
    
    // MARK: - Setup
    
    func setup(forDelegate: DogsAddDogDisplayReminderTVCDelegate, forReminder: Reminder) {
        delegate = forDelegate
        reminderIsEnabledSwitch.isOn = forReminder.reminderIsEnabled
        
        reminderUUID = forReminder.reminderUUID
        
        let precalculatedReminderActionName = forReminder.reminderActionType.convertToReadableName(customActionName: forReminder.reminderCustomActionName)
        let precalculatedReminderActionFont = self.reminderActionLabel.font ?? UIFont()
        
        let precalculatedReminderDisplayInterval = {
            switch forReminder.reminderType {
            case .countdown:
                return forReminder.countdownComponents.readableInterval
            case .weekly:
                return forReminder.weeklyComponents.readableInterval
            case .monthly:
                return forReminder.monthlyComponents.readableInterval
            case .oneTime:
                return forReminder.oneTimeComponents.readableInterval
            }
        }()
        let precalculatedReminderDisplayIntervalFont = self.reminderDisplayableIntervalLabel.font ?? UIFont()
        
        reminderActionLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            
            return NSMutableAttributedString(
                string: precalculatedReminderActionName,
                attributes: [.font: precalculatedReminderActionFont]
            )
        }
        
        reminderDisplayableIntervalLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            
            return NSAttributedString(
                string: precalculatedReminderDisplayInterval,
                attributes: [.font: precalculatedReminderDisplayIntervalFont])
        }
        
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(reminderActionLabel)
        containerView.addSubview(reminderIsEnabledSwitch)
        reminderIsEnabledSwitch.addTarget(self, action: #selector(didToggleReminderIsEnabled), for: .valueChanged)
        containerView.addSubview(chevonImageView)
        containerView.addSubview(reminderDisplayableIntervalLabel)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: contentView.topAnchor)
        let containerViewBottom = containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let containerViewTrailing = containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        
        // reminderActionLabel
        let reminderActionLabelTop = reminderActionLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 10)
        let reminderActionLabelLeading = reminderActionLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 10)
        let reminderActionLabelTrailing = reminderActionLabel.trailingAnchor.constraint(equalTo: reminderDisplayableIntervalLabel.trailingAnchor)
        let reminderActionLabelHeight = reminderActionLabel.heightAnchor.constraint(equalToConstant: 35)
        
        // reminderIsEnabledSwitch
        let reminderIsEnabledSwitchLeading = reminderIsEnabledSwitch.leadingAnchor.constraint(equalTo: reminderActionLabel.trailingAnchor, constant: 15)
        let reminderIsEnabledSwitchCenterY = reminderIsEnabledSwitch.centerYAnchor.constraint(equalTo: containerView.centerYAnchor)
        
        // chevonImageView
        let chevonImageViewLeading = chevonImageView.leadingAnchor.constraint(equalTo: reminderIsEnabledSwitch.trailingAnchor, constant: 25)
        let chevonImageViewTrailing = chevonImageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -15)
        let chevonImageViewCenterY = chevonImageView.centerYAnchor.constraint(equalTo: containerView.centerYAnchor)
        let chevonImageViewWidth = chevonImageView.widthAnchor.constraint(equalToConstant: 20)
        let chevonImageViewWidthToHeight = chevonImageView.widthAnchor.constraint(equalTo: chevonImageView.heightAnchor, multiplier: 1 / 1.5)
        
        // reminderDisplayableIntervalLabel
        let reminderDisplayableIntervalLabelTop = reminderDisplayableIntervalLabel.topAnchor.constraint(equalTo: reminderActionLabel.bottomAnchor, constant: 2.5)
        let reminderDisplayableIntervalLabelBottom = reminderDisplayableIntervalLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -10)
        let reminderDisplayableIntervalLabelLeading = reminderDisplayableIntervalLabel.leadingAnchor.constraint(equalTo: reminderActionLabel.leadingAnchor)
        let reminderDisplayableIntervalLabelHeight = reminderDisplayableIntervalLabel.heightAnchor.constraint(equalToConstant: 20)
        
        NSLayoutConstraint.activate([
            // containerView
            containerViewTop,
            containerViewBottom,
            containerViewLeading,
            containerViewTrailing,
            
            // reminderActionLabel
            reminderActionLabelTop,
            reminderActionLabelLeading,
            reminderActionLabelTrailing,
            reminderActionLabelHeight,
            
            // reminderIsEnabledSwitch
            reminderIsEnabledSwitchLeading,
            reminderIsEnabledSwitchCenterY,
            
            // chevonImageView
            chevonImageViewLeading,
            chevonImageViewTrailing,
            chevonImageViewCenterY,
            chevonImageViewWidth,
            chevonImageViewWidthToHeight,
            
            // reminderDisplayableIntervalLabel
            reminderDisplayableIntervalLabelTop,
            reminderDisplayableIntervalLabelBottom,
            reminderDisplayableIntervalLabelLeading,
            reminderDisplayableIntervalLabelHeight
        ])
    }

}
//
//  DogsAddDogAddReminderFooterV.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/4/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddDogAddReminderFooterVDelegate: AnyObject {
    func didTouchUpInsideAddReminder()
}

class DogsAddDogAddReminderFooterV: GeneralUIView {
    
    // MARK: - Elements
    
    private let contentView: GeneralUIView = GeneralUIView()
    
    private let addReminderButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.isEnabled = false
        
        button.setTitle("Add Reminder", for: .normal)
        button.setTitleColor(.label, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.screenWideButton
        
        button.backgroundColor = .systemBackground
        
        button.borderColor = .label
        button.borderWidth = 2
        button.shouldRoundCorners = true
        
        return button
    }()
    
    @objc private func didTouchUpInsideReminder(_ sender: Any) {
        delegate?.didTouchUpInsideAddReminder()
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddDogAddReminderFooterVDelegate?
    
    private static let topConstraintConstant: CGFloat = 20.0
    private static let bottomConstraintConstant: CGFloat = 20.0
    private static let leadingConstraintConstant: CGFloat = 20.0
    private static let trailingConstraintConstant: CGFloat = 20.0
    
    // MARK: - Setup
    
    func setup(forDelegate: DogsAddDogAddReminderFooterVDelegate) {
        delegate = forDelegate
        addReminderButton.isEnabled = true
    }
    
    // MARK: - Functions
    
    static func cellHeight(forTableViewWidth: CGFloat) -> CGFloat {
        return topConstraintConstant + ((forTableViewWidth - leadingConstraintConstant - trailingConstraintConstant) * ConstraintConstant.Button.screenWideHeightMultiplier) + bottomConstraintConstant
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        contentView.frame = bounds
        addSubview(contentView)
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(addReminderButton)
        addReminderButton.addTarget(self, action: #selector(didTouchUpInsideReminder), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // addReminderButton
        let addReminderButtonTop = addReminderButton.topAnchor.constraint(equalTo: contentView.topAnchor, constant: DogsAddDogAddReminderFooterV.topConstraintConstant)
        let addReminderButtonBottom = addReminderButton.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -DogsAddDogAddReminderFooterV.bottomConstraintConstant)
        let addReminderButtonLeading = addReminderButton.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: DogsAddDogAddReminderFooterV.leadingConstraintConstant)
        let addReminderButtonTrailing = addReminderButton.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -DogsAddDogAddReminderFooterV.trailingConstraintConstant)
        let addReminderButtonCenterX = addReminderButton.centerXAnchor.constraint(equalTo: contentView.centerXAnchor)
        let addReminderButtonWidthToHeight = addReminderButton.createScreenWideHeightMultiplier()
        
        NSLayoutConstraint.activate([
            addReminderButtonTop,
            addReminderButtonBottom,
            addReminderButtonLeading,
            addReminderButtonTrailing,
            addReminderButtonCenterX,
            addReminderButtonWidthToHeight
        ])
    }

}
//
//  DogsAddDogViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/19/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddDogViewControllerDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager)
}

final class DogsAddDogViewController: GeneralUIViewController, UITextFieldDelegate, UIImagePickerControllerDelegate, UINavigationControllerDelegate, UITableViewDelegate, UITableViewDataSource, UIGestureRecognizerDelegate, DogsAddReminderViewControllerDelegate, DogsAddDogDisplayReminderTVCDelegate, DogsAddDogAddReminderFooterVDelegate {
    
    // MARK: - UIImagePickerControllerDelegate
    
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
        
        if let dogIcon = DogIconManager.processDogIcon(forInfo: info) {
            self.dogIconButton.setTitle(nil, for: .normal)
            self.dogIconButton.setImage(dogIcon, for: .normal)
        }
        
        picker.dismiss(animated: true)
    }
    
    // MARK: - UITextFieldDelegate
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        self.dismissKeyboard()
        return false
    }
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        
        // attempt to read the range they are trying to change
        guard let currentText = textField.text, let stringRange = Range(range, in: currentText) else {
            return true
        }
        
        // add their new text to the existing text
        let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
        
        // make sure the result is under dogNameCharacterLimit
        return updatedText.count <= ClassConstant.DogConstant.dogNameCharacterLimit
    }
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
    
    // MARK: - DogsAddReminderViewControllerDelegate
    
    func didAddReminder(sender: Sender, forDogUUID: UUID?, forReminder: Reminder) {
        dogReminders?.addReminder(forReminder: forReminder)
        reloadTable()
    }
    
    func didUpdateReminder(sender: Sender, forDogUUID: UUID?, forReminder: Reminder) {
        dogReminders?.addReminder(forReminder: forReminder)
        reloadTable()
    }
    
    func didRemoveReminder(sender: Sender, forDogUUID: UUID?, forReminderUUID: UUID) {
        dogReminders?.removeReminder(forReminderUUID: forReminderUUID)
        reloadTable()
    }
    
    // MARK: - DogsAddDogDisplayReminderTVCDelegate
    
    func didUpdateReminderIsEnabled(sender: Sender, forReminderUUID: UUID, forReminderIsEnabled: Bool) {
        dogReminders?.findReminder(forReminderUUID: forReminderUUID)?.reminderIsEnabled = forReminderIsEnabled
    }
    
    // MARK: - DogsAddDogAddReminderFooterVDelegate
    
    func didTouchUpInsideAddReminder() {
        let vc = DogsAddReminderViewController()
        /// DogsAddDogViewController takes care of all server communication when, and if, the user decides to save their changes to the dog. Therefore, we don't provide a reminderToUpdateDogUUID to dogsAddReminderViewController, as otherwise it would contact and update the server.
        vc.setup(forDelegate: self, forReminderToUpdateDogUUID: nil, forReminderToUpdate: nil)
        PresentationManager.enqueueViewController(vc)
    }
    
    // MARK: - Elements
    
    private let pageTitleLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 320, compressionResistancePriority: 320)
        label.textAlignment = .center
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBlue
        return label
    }()
    
    private let dogNameTextField: GeneralUITextField = {
        let textField = GeneralUITextField(huggingPriority: 290, compressionResistencePriority: 790)
        
        textField.placeholder = "Enter your dog's name..."
        textField.backgroundColor = .systemBackground
       
        textField.borderWidth = 0.5
        textField.borderColor = .systemGray
        textField.shouldRoundCorners = true
        
        return textField
    }()
    
    private let dogIconButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 290, compressionResistancePriority: 290)
        
        button.setTitle("Choose", for: .normal)
        button.setTitleColor(.placeholderText, for: .normal)
        button.titleLabel?.font = VisualConstant.FontConstant.secondaryHeaderLabel
        
        button.backgroundColor = .systemBackground
        
        button.borderWidth = 0.5
        button.borderColor = .systemGray
        button.shouldRoundCorners = true
        
        return button
    }()
    
    @objc private func didTouchUpInsideDogIcon(_ sender: Any) {
        PresentationManager.enqueueActionSheet(DogIconManager.openCameraOrGalleryForDogIconActionSheet, sourceView: dogIconButton)
    }
    
    private let remindersTableView: GeneralUITableView = {
        let tableView = GeneralUITableView()
        tableView.clipsToBounds = true
        tableView.contentMode = .scaleToFill
        tableView.bounces = false
        tableView.isScrollEnabled = false
        tableView.showsHorizontalScrollIndicator = false
        tableView.showsVerticalScrollIndicator = false
        tableView.bouncesZoom = false
        tableView.separatorStyle = .none
        tableView.rowHeight = -1
        tableView.estimatedRowHeight = -1
        tableView.sectionHeaderHeight = -1
        tableView.estimatedSectionHeaderHeight = -1
        tableView.sectionFooterHeight = -1
        tableView.estimatedSectionFooterHeight = -1
        tableView.translatesAutoresizingMaskIntoConstraints = false
        tableView.shouldAutomaticallyAdjustHeight = true
        return tableView
    }()
    
    private let addDogButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 280, compressionResistancePriority: 280)
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "checkmark.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        return button
    }()
    
    // When the add button is tapped, runs a series of checks. Makes sure the name and description of the dog is valid, and if so then passes information up chain of view controllers to DogsViewController.
    @objc private func didTouchUpInsideAddDog(_ sender: Any) {
        // could be new dog or updated one
        var dog: Dog!
        do {
            // try to initialize from a passed dog, if non exists, then we make a new one
            dog = try dogToUpdate ?? Dog(forDogName: dogNameTextField.text)
            try dog.changeDogName(forDogName: dogNameTextField.text)
            // DogsRequest handles .addIcon and .removeIcon.
            dog.dogIcon = dogIconButton.imageView?.image
        }
        catch {
            (error as? HoundError)?.alert() ?? ErrorConstant.UnknownError.unknown().alert()
            return
        }
        
        addDogButton.beginSpinning()
        
        let initialReminders = initialReminders?.dogReminders ?? []
        let currentReminders = dogReminders?.dogReminders ?? []
        let createdReminders = currentReminders.filter({ currentReminder in
            // Reminders that were just created have no reminderId
            // If a reminder was created in offline mode already, it would have no reminderId. Therefore, being classified as a created reminder. This is inaccurate, but doesn't matter, as the same flag for offline mode will be set to true again.
            return currentReminder.reminderId == nil
        })
        
        createdReminders.forEach { reminder in
            reminder.resetForNextAlarm()
        }
        
        let updatedReminders = currentReminders.filter { currentReminder in
            // The reminder needs to have already been created on the Hound server
            guard currentReminder.reminderId != nil else {
                return false
            }
            
            // Reminders that were updated were in the initialReminders array (maybe or maybe not have reminderId, depends if were in offline mode)
            guard let initialReminder = initialReminders.first(where: { initialReminder in
                initialReminder.reminderUUID == currentReminder.reminderUUID
            }) else {
                return false
            }
            
            // If current reminder is different that its corresponding initial reminder, then its been updated
            return currentReminder.isSame(asReminder: initialReminder) == false
        }
        
        updatedReminders.forEach { updatedReminder in
            // updated reminder could have had its timing updating, so resetForNextAlarm to clear skippedDate, snoozing, etc.
            updatedReminder.resetForNextAlarm()
        }
        
        // looks for reminders that were present in initialReminders but not in currentReminders
        let deletedReminders = initialReminders.filter({ initialReminder in
            // The reminder needs to have already been created on the Hound server
            guard initialReminder.reminderId != nil else {
                return false
            }
            
            // Only include reminders that no longer exist in currentReminders
            return currentReminders.contains(where: { currentReminder in
                return initialReminder.reminderUUID == currentReminder.reminderUUID
            }) == false
        })
        
        if dogToUpdate != nil {
            // dog + created reminders + updated reminders + deleted reminders
            let numberOfTasks = {
                // first task is dog update
                var numberOfTasks = 1
                if createdReminders.count >= 1 {
                    numberOfTasks += 1
                }
                if updatedReminders.count >= 1 {
                    numberOfTasks += 1
                }
                if deletedReminders.count >= 1 {
                    numberOfTasks += 1
                }
                return numberOfTasks
            }()
            
            let completionTracker = CompletionTracker(numberOfTasks: numberOfTasks) {
                // everytime a task completes, update the dog manager so everything else updates
                if let dogManager = self.dogManager {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: dogManager)
                }
            } completedAllTasksCompletionHandler: {
                // when everything completes, close the page
                self.addDogButton.endSpinning()
                self.dismiss(animated: true)
            } failedTaskCompletionHandler: {
                // if a problem is encountered, then just stop the indicator
                self.addDogButton.endSpinning()
            }
            
            // first query to update the dog itself (independent of any reminders)
            DogsRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forDog: dog) { responseStatusDogUpdate, _ in
                guard responseStatusDogUpdate != .failureResponse else {
                    completionTracker.failedTask()
                    return
                }
                
                // Updated dog
                self.dogManager?.addDog(forDog: dog)
                completionTracker.completedTask()
                
                if createdReminders.count >= 1 {
                    RemindersRequest.create(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: dog.dogUUID, forReminders: createdReminders) { responseStatusReminderCreate, _ in
                        guard responseStatusReminderCreate != .failureResponse else {
                            completionTracker.failedTask()
                            return
                        }
                        
                        dog.dogReminders.addReminders(forReminders: createdReminders)
                        completionTracker.completedTask()
                    }
                }
                
                if updatedReminders.count >= 1 {
                    RemindersRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: dog.dogUUID, forReminders: updatedReminders) { responseStatusReminderUpdate, _ in
                        guard responseStatusReminderUpdate != .failureResponse else {
                            completionTracker.failedTask()
                            return
                        }
                        
                        // add updated reminders as they already have their reminderUUID
                        dog.dogReminders.addReminders(forReminders: updatedReminders)
                        completionTracker.completedTask()
                    }
                }
                
                if deletedReminders.count >= 1 {
                    RemindersRequest.delete(
                        forErrorAlert: .automaticallyAlertOnlyForFailure,
                        forDogUUID: dog.dogUUID,
                        forReminderUUIDs: deletedReminders.map({ reminder in
                            return reminder.reminderUUID
                        })
                    ) { responseStatusReminderDelete, _ in
                        guard responseStatusReminderDelete != .failureResponse else {
                            completionTracker.failedTask()
                            return
                        }
                        
                        for deletedReminder in deletedReminders {
                            dog.dogReminders.removeReminder(forReminderUUID: deletedReminder.reminderUUID)
                        }
                        
                        completionTracker.completedTask()
                    }
                }
                
            }
        }
        else {
            // not updating, therefore the dog is being created new and the reminders are too
            DogsRequest.create(forErrorAlert: .automaticallyAlertOnlyForFailure, forDog: dog) { responseStatusDogCreate, _ in
                guard responseStatusDogCreate != .failureResponse else {
                    self.addDogButton.endSpinning()
                    return
                }
                
                RemindersRequest.create(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: dog.dogUUID, forReminders: createdReminders) { responseStatusReminderCreate, _ in
                    self.addDogButton.endSpinning()
                    
                    guard responseStatusReminderCreate != .failureResponse else {
                        // reminders were unable to be created so we delete the dog to remove everything.
                        DogsRequest.delete(forErrorAlert: .automaticallyAlertForNone, forDogUUID: dog.dogUUID) { _, _ in
                            // do nothing, we can't do more even if it fails.
                        }
                        return
                    }
                    
                    self.dogManager?.addDog(forDog: dog)
                    
                    // dog and reminders successfully created, so we can proceed
                    dog.dogReminders.addReminders(forReminders: createdReminders)
                    
                    if let dogManager = self.dogManager {
                        self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: dogManager)
                    }
                    
                    self.dismiss(animated: true)
                }
            }
        }
    }
    
    private let removeDogButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 310, compressionResistancePriority: 310)
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "trash"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        
        return button
    }()
    
    @objc private func didTouchUpInsideRemoveDog(_ sender: Any) {
        guard let dogToUpdate = dogToUpdate else {
            return
        }
        
        let removeDogConfirmation = UIAlertController(title: "Are you sure you want to delete \(dogNameTextField.text ?? dogToUpdate.dogName)?", message: nil, preferredStyle: .alert)
        
        let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
            DogsRequest.delete(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: dogToUpdate.dogUUID) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }
                
                self.dogManager?.removeDog(forDogUUID: dogToUpdate.dogUUID)
                
                if let dogManager = self.dogManager {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: dogManager)
                }
                
                self.dismiss(animated: true)
            }
            
        }
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        removeDogConfirmation.addAction(removeAlertAction)
        removeDogConfirmation.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(removeDogConfirmation)
    }
    
    private let dismissPageButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 260, compressionResistancePriority: 260)
        
        button.tintColor = .systemGray2
        button.setImage(UIImage(systemName: "arrow.backward.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        
        return button
    }()
    
    // MARK: - Additional UI Elements
    
    private let scrollView: GeneralUIScrollView = {
        let scrollView = GeneralUIScrollView()
        
        scrollView.alwaysBounceVertical = true
        
        return scrollView
    }()
    
    private let containerInsideScrollView: GeneralUIView = GeneralUIView()
    
    @objc private func didTouchUpInsideDismissPage(_ sender: Any) {
        // If the user changed any values on the page, then ask them to confirm to discarding those changes
        guard didUpdateInitialValues == true else {
            self.dismiss(animated: true)
            return
        }
        
        let unsavedInformationConfirmation = UIAlertController(title: "Are you sure you want to exit?", message: nil, preferredStyle: .alert)
        
        let exitAlertAction = UIAlertAction(title: "Yes, I don't want to save changes", style: .default) { _ in
            self.dismiss(animated: true)
        }
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        unsavedInformationConfirmation.addAction(exitAlertAction)
        unsavedInformationConfirmation.addAction(cancelAlertAction)
        
        PresentationManager.enqueueAlert(unsavedInformationConfirmation)
    }
    
    // MARK: - Properties
    
    private var didSetupCustomSubviews: Bool = false
    
    private weak var delegate: DogsAddDogViewControllerDelegate?
    
    private var dogManager: DogManager?
    private var dogToUpdate: Dog?
    /// dogReminders is either a copy of dogToUpdate's reminders or a DogReminderManager initialized to a default array of reminders. This is purposeful so that either, if you dont have a dogToUpdate, you can still create reminders, and if you do have a dogToUpdate, you don't directly update the dogToUpdate until save is pressed
    private var dogReminders: DogReminderManager?
    private var initialDogName: String?
    private var initialDogIcon: UIImage?
    private var initialReminders: DogReminderManager?
    var didUpdateInitialValues: Bool {
        if dogNameTextField.text != initialDogName {
            return true
        }
        if let image = dogIconButton.imageView?.image, image != initialDogIcon {
            return true
        }
        // need to check count, make sure the arrays are 1:1. if current reminders has more reminders than initial reminders, the loop below won't catch it, as the loop below just looks to see if each initial reminder is still present in current reminders.
        if initialReminders?.dogReminders.count != dogReminders?.dogReminders.count {
            return true
        }
        if let initialReminders = initialReminders?.dogReminders {
            let currentReminders = dogReminders?.dogReminders
            // make sure each initial reminder has a corresponding current reminder, otherwise current reminders have been updated
            for initialReminder in initialReminders {
                let currentReminder = currentReminders?.first(where: { $0.reminderUUID == initialReminder.reminderUUID })
                
                guard let currentReminder = currentReminder else {
                    // no corresponding reminder
                    return true
                }
                
                // if any of the corresponding reminders are different, then return true to indicate that a reminder has been updated
                if initialReminder.isSame(asReminder: currentReminder) == false {
                    return true
                }
            }
        }
        
        return false
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        remindersTableView.register(DogsAddDogDisplayReminderTVC.self, forCellReuseIdentifier: DogsAddDogDisplayReminderTVC.reuseIdentifier)
        
        // gestures
        self.view.dismissKeyboardOnTap(delegate: self)
        
        if dogToUpdate == nil {
            pageTitleLabel.text = "Create Dog"
            removeDogButton.removeFromSuperview()
        }
        else {
            pageTitleLabel.text = "Edit Dog"
        }
        
        dogNameTextField.text = dogToUpdate?.dogName ?? ""
        dogNameTextField.delegate = self
        
        if let dogIcon = dogToUpdate?.dogIcon {
            dogIconButton.setTitle(nil, for: .normal)
            dogIconButton.setImage(dogIcon, for: .normal)
        }
        
        initialDogName = dogNameTextField.text
        initialDogIcon = dogIconButton.imageView?.image
        
        initialReminders = (dogReminders?.copy() as? DogReminderManager)
        
        DogIconManager.didSelectDogIconController.delegate = self
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard didSetupCustomSubviews == false else {
            return
        }
        
        didSetupCustomSubviews = true
        
        let tableFooterView = DogsAddDogAddReminderFooterV(frame:
                                                                CGRect(
                                                                    x: 0,
                                                                    y: 0,
                                                                    width: remindersTableView.frame.width,
                                                                    height: DogsAddDogAddReminderFooterV.cellHeight(forTableViewWidth: remindersTableView.frame.width)
                                                                )
        )
        tableFooterView.setup(forDelegate: self)
        remindersTableView.tableFooterView = tableFooterView
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: DogsAddDogViewControllerDelegate, forDogManager: DogManager?, forDogToUpdate: Dog?) {
        delegate = forDelegate
        dogManager = forDogManager
        dogToUpdate = forDogToUpdate
        dogReminders = (dogToUpdate?.dogReminders.copy() as? DogReminderManager) ?? DogReminderManager(forReminders: ClassConstant.ReminderConstant.defaultReminders)
    }
    
    // MARK: - Functions
    
    private func reloadTable() {
        if let dogReminders = dogReminders {
            remindersTableView.allowsSelection = !dogReminders.dogReminders.isEmpty
        }
        
        remindersTableView.reloadData()
    }
    
    // MARK: - Table View Data Source
    
    func numberOfSections(in tableView: UITableView) -> Int {
        guard let dogReminders = dogReminders else {
            return 0
        }
        
        return dogReminders.dogReminders.count
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        guard dogReminders != nil else {
            return 0
        }
        
        return 1
    }
    
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        // Set the spacing between sections
        // I don't fully understand how this spacing works. Setting the value to 0.0 makes it behave as expected. As soon as its >0.0, then its size is increased by some mysterious constant + whatever value I specified here.
        return 0.1
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        return GeneralUIView()
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let dogReminders = dogReminders else {
            return GeneralUITableViewCell()
        }
        
        let cell = tableView.dequeueReusableCell(withIdentifier: DogsAddDogDisplayReminderTVC.reuseIdentifier, for: indexPath)
        
                if let castedCell = cell as? DogsAddDogDisplayReminderTVC {
                    castedCell.setup(forDelegate: self, forReminder: dogReminders.dogReminders[indexPath.section])
                    castedCell.containerView.roundCorners(setCorners: .all)
                }
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        guard let dogReminders = dogReminders else {
            return
        }
        
        let vc = DogsAddReminderViewController()
        /// DogsAddDogViewController takes care of all server communication when, and if, the user decides to save their changes to the dog. Therefore, we don't provide a reminderToUpdateDogUUID to dogsAddReminderViewController, as otherwise it would contact and update the server.
        vc.setup(forDelegate: self, forReminderToUpdateDogUUID: nil, forReminderToUpdate: dogReminders.dogReminders[indexPath.section])
        PresentationManager.enqueueViewController(vc)
    }
    
    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
        guard let dogReminders = dogReminders else {
            return
        }
        
        if editingStyle == .delete && dogReminders.dogReminders.isEmpty == false {
            let reminder = dogReminders.dogReminders[indexPath.section]
            
            let removeReminderConfirmation = UIAlertController(title: "Are you sure you want to delete \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))?", message: nil, preferredStyle: .alert)
            
            let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
                dogReminders.removeReminder(forReminderUUID: reminder.reminderUUID)
                self.remindersTableView.deleteSections([indexPath.section], with: .automatic)
            }
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            removeReminderConfirmation.addAction(removeAlertAction)
            removeReminderConfirmation.addAction(cancelAlertAction)
            PresentationManager.enqueueAlert(removeReminderConfirmation)
        }
    }
    
    func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        guard let dogReminders = dogReminders else {
            return false
        }
        
        return dogReminders.dogReminders.isEmpty == false
    }
    
    // MARK: - Navigation
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let dogsAddReminderViewController = segue.destination as? DogsAddReminderViewController {
            
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(scrollView)
        view.addSubview(addDogButton)
        view.addSubview(dismissPageButton)
        
        scrollView.addSubview(containerInsideScrollView)
        
        containerInsideScrollView.addSubview(dogIconButton)
        containerInsideScrollView.addSubview(remindersTableView)
        containerInsideScrollView.addSubview(pageTitleLabel)
        containerInsideScrollView.addSubview(removeDogButton)
        containerInsideScrollView.addSubview(dogNameTextField)
        
        addDogButton.addTarget(self, action: #selector(didTouchUpInsideAddDog), for: .touchUpInside)
        dismissPageButton.addTarget(self, action: #selector(didTouchUpInsideDismissPage), for: .touchUpInside)
        dogIconButton.addTarget(self, action: #selector(didTouchUpInsideDogIcon), for: .touchUpInside)
        removeDogButton.addTarget(self, action: #selector(didTouchUpInsideRemoveDog), for: .touchUpInside)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // pageTitleLabel
        let pageTitleLabelTop = pageTitleLabel.topAnchor.constraint(equalTo: containerInsideScrollView.topAnchor, constant: 10)
        let pageTitleLabelLeading = pageTitleLabel.leadingAnchor.constraint(equalTo: containerInsideScrollView.leadingAnchor, constant: 10)
        let pageTitleLabelCenterX = pageTitleLabel.centerXAnchor.constraint(equalTo: containerInsideScrollView.centerXAnchor)
        let pageTitleLabelHeight = pageTitleLabel.heightAnchor.constraint(equalToConstant: 40)
        
        // removeDogButton
        let removeDogButtonTop = removeDogButton.topAnchor.constraint(equalTo: containerInsideScrollView.topAnchor, constant: 5)
        let removeDogButtonLeading = removeDogButton.leadingAnchor.constraint(equalTo: pageTitleLabel.trailingAnchor, constant: 10)
        let removeDogButtonCenterY = removeDogButton.centerYAnchor.constraint(equalTo: pageTitleLabel.centerYAnchor)
        let removeDogButtonWidthToHeight = removeDogButton.widthAnchor.constraint(equalTo: removeDogButton.heightAnchor)
        
        // dogIconButton
        let dogIconButtonTop = dogIconButton.topAnchor.constraint(equalTo: pageTitleLabel.bottomAnchor, constant: 15)
        let dogIconButtonLeading = dogIconButton.leadingAnchor.constraint(equalTo: containerInsideScrollView.leadingAnchor, constant: 10)
        let dogIconButtonWidthToHeight = dogIconButton.widthAnchor.constraint(equalTo: dogIconButton.heightAnchor)
        let dogIconButtonWidthToContainer = dogIconButton.widthAnchor.constraint(equalTo: containerInsideScrollView.widthAnchor, multiplier: 100 / 414)
        let dogIconButtonHeightMin = dogIconButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 50)
        let dogIconButtonHeightMax = dogIconButton.heightAnchor.constraint(lessThanOrEqualToConstant: 150)
        dogIconButtonWidthToContainer.priority = .defaultHigh
        
        // dogNameTextField
        let dogNameTextFieldLeading = dogNameTextField.leadingAnchor.constraint(equalTo: dogIconButton.trailingAnchor, constant: 10)
        let dogNameTextFieldTrailing = dogNameTextField.trailingAnchor.constraint(equalTo: containerInsideScrollView.trailingAnchor, constant: -10)
        let dogNameTextFieldTrailingRemoveDog = dogNameTextField.trailingAnchor.constraint(equalTo: removeDogButton.trailingAnchor)
        let dogNameTextFieldCenterY = dogNameTextField.centerYAnchor.constraint(equalTo: dogIconButton.centerYAnchor)
        let dogNameTextFieldHeight = dogNameTextField.heightAnchor.constraint(equalToConstant: 45)
        
        // remindersTableView
        let remindersTableViewTop = remindersTableView.topAnchor.constraint(equalTo: dogIconButton.bottomAnchor, constant: 15)
        let remindersTableViewBottom = remindersTableView.bottomAnchor.constraint(equalTo: containerInsideScrollView.bottomAnchor)
        let remindersTableViewLeading = remindersTableView.leadingAnchor.constraint(equalTo: containerInsideScrollView.leadingAnchor)
        let remindersTableViewTrailing = remindersTableView.trailingAnchor.constraint(equalTo: containerInsideScrollView.trailingAnchor)
        
        // containerInsideScrollView
        let containerInsideScrollViewTop = containerInsideScrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
        let containerInsideScrollViewLeading = containerInsideScrollView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor)
        let containerInsideScrollViewWidth = containerInsideScrollView.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor)
        let viewSafeAreaBottomToContainer = view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: containerInsideScrollView.bottomAnchor)
        let viewSafeAreaTrailingToContainer = view.safeAreaLayoutGuide.trailingAnchor.constraint(equalTo: containerInsideScrollView.trailingAnchor)
        
        // addDogButton
        let addDogButtonBottom = addDogButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -10)
        let addDogButtonTrailing = addDogButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)
        let addDogButtonWidthToHeight = addDogButton.widthAnchor.constraint(equalTo: addDogButton.heightAnchor)
        let addDogButtonWidthToSafeArea = addDogButton.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 100 / 414)
        let addDogButtonHeightMax = addDogButton.heightAnchor.constraint(lessThanOrEqualToConstant: 150)
        let addDogButtonHeightMin = addDogButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 50)
        addDogButtonWidthToSafeArea.priority = .defaultHigh
        
        // dismissPageButton
        let dismissPageButtonBottom = dismissPageButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -10)
        let dismissPageButtonLeading = dismissPageButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let dismissPageButtonWidthToHeight = dismissPageButton.widthAnchor.constraint(equalTo: dismissPageButton.heightAnchor)
        let dismissPageButtonWidthToSafeArea = dismissPageButton.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 100 / 414)
        let dismissPageButtonHeightMin = dismissPageButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 50)
        let dismissPageButtonHeightMax = dismissPageButton.heightAnchor.constraint(lessThanOrEqualToConstant: 150)
        dismissPageButtonWidthToSafeArea.priority = .defaultHigh
        
        // scrollView
        let scrollViewTop = scrollView.topAnchor.constraint(equalTo: view.topAnchor)
        let scrollViewBottom = scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        let scrollViewLeading = scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor)
        let scrollViewTrailing = scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor)

        NSLayoutConstraint.activate([
            // pageTitleLabel
            pageTitleLabelTop,
            pageTitleLabelLeading,
            pageTitleLabelCenterX,
            pageTitleLabelHeight,
            
            // removeDogButton
            removeDogButtonTop,
            removeDogButtonLeading,
            removeDogButtonCenterY,
            removeDogButtonWidthToHeight,
            
            // dogIconButton
            dogIconButtonTop,
            dogIconButtonLeading,
            dogIconButtonWidthToHeight,
            dogIconButtonWidthToContainer,
            dogIconButtonHeightMin,
            dogIconButtonHeightMax,
            
            // dogNameTextField
            dogNameTextFieldLeading,
            dogNameTextFieldTrailing,
            dogNameTextFieldTrailingRemoveDog,
            dogNameTextFieldCenterY,
            dogNameTextFieldHeight,
            
            // remindersTableView
            remindersTableViewTop,
            remindersTableViewBottom,
            remindersTableViewLeading,
            remindersTableViewTrailing,
            
            // containerInsideScrollView
            containerInsideScrollViewTop,
            containerInsideScrollViewLeading,
            containerInsideScrollViewWidth,
            viewSafeAreaBottomToContainer,
            viewSafeAreaTrailingToContainer,
            
            // addDogButton
            addDogButtonBottom,
            addDogButtonTrailing,
            addDogButtonWidthToHeight,
            addDogButtonWidthToSafeArea,
            addDogButtonHeightMax,
            addDogButtonHeightMin,
            
            // dismissPageButton
            dismissPageButtonBottom,
            dismissPageButtonLeading,
            dismissPageButtonWidthToHeight,
            dismissPageButtonWidthToSafeArea,
            dismissPageButtonHeightMin,
            dismissPageButtonHeightMax,
            
            // scrollView
            scrollViewTop,
            scrollViewBottom,
            scrollViewLeading,
            scrollViewTrailing
        ])
    }

}
//
//  SecondViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsViewControllerDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager)
}

final class DogsViewController: GeneralUIViewController, DogsAddDogViewControllerDelegate, DogsTableViewControllerDelegate, DogsAddReminderViewControllerDelegate, UIGestureRecognizerDelegate {
    
    // MARK: - UIGestureRecognizerDelegate

    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        true
    }
    
    // MARK: - Dual Delegate Implementation

    func didUpdateDogManager(sender: Sender, forDogManager: DogManager) {
        setDogManager(sender: sender, forDogManager: forDogManager)
    }

    // MARK: - DogsAddReminderViewControllerDelegate

    func didAddReminder(sender: Sender, forDogUUID: UUID?, forReminder reminder: Reminder) {
        // forDogUUID must be defined, as we are either adding a reminder to some existing dog or creating a reminder for an existing dog. Only DogsAddDogVC can use dogsAddReminderViewController without a forDogUUID
        guard let forDogUUID = forDogUUID else {
            return
        }

        // Since our reminder was already created by the server, we don't need to worry about placeholderIds. Simply add the reminder and DogReminderManager handles it
        dogManager.findDog(forDogUUID: forDogUUID)?.dogReminders.addReminder(forReminder: reminder)

        setDogManager(sender: sender, forDogManager: dogManager)
    }

    func didUpdateReminder(sender: Sender, forDogUUID: UUID?, forReminder: Reminder) {
        // forDogUUID must be defined, as we are either adding a reminder to some existing dog or creating a reminder for an existing dog. Only DogsAddDogVC can use dogsAddReminderViewController without a forDogUUID
        guard let forDogUUID = forDogUUID else {
            return
        }

        // Since our reminder was already created by the server, we don't need to worry about placeholderIds. Simply add the reminder and DogReminderManager handles it
        dogManager.findDog(forDogUUID: forDogUUID)?.dogReminders.addReminder(forReminder: forReminder)

        setDogManager(sender: sender, forDogManager: dogManager)
    }

    func didRemoveReminder(sender: Sender, forDogUUID: UUID?, forReminderUUID: UUID) {
        // forDogUUID must be defined, as we are either adding a reminder to some existing dog or creating a reminder for an existing dog. Only DogsAddDogVC can use dogsAddReminderViewController without a forDogUUID
        guard let forDogUUID = forDogUUID else {
            return
        }

        let dogReminders = dogManager.findDog(forDogUUID: forDogUUID)?.dogReminders

        dogReminders?.removeReminder(forReminderUUID: forReminderUUID)

        setDogManager(sender: sender, forDogManager: dogManager)
    }

    // MARK: - DogsTableViewControllerDelegate

    /// If a dog in DogsTableViewController or Add Dog were tapped, invokes this function. Opens up the same page but changes between creating new and editing existing mode.
    func shouldOpenDogMenu(forDogUUID: UUID?) {
        guard let forDogUUID = forDogUUID, let forDog = dogManager.findDog(forDogUUID: forDogUUID) else {
            let vc = DogsAddDogViewController()
            vc.setup(forDelegate: self, forDogManager: dogManager, forDogToUpdate: nil)
            dogsAddDogViewController = vc
            PresentationManager.enqueueViewController(vc)
            return
        }

        PresentationManager.beginFetchingInformationIndicator()

        DogsRequest.get(forErrorAlert: .automaticallyAlertOnlyForFailure, forDog: forDog) { newDog, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                guard responseStatus != .failureResponse else {
                    return
                }
                
                guard let newDog = newDog else {
                    // If the response was successful but no dog was returned, that means the dog was deleted. Therefore, update the dogManager to indicate as such.
                    self.dogManager.removeDog(forDogUUID: forDogUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                    return
                }

                let vc = DogsAddDogViewController()
                vc.setup(forDelegate: self, forDogManager: self.dogManager, forDogToUpdate: newDog)
                self.dogsAddDogViewController = vc
                PresentationManager.enqueueViewController(vc)
            }
        }
    }

    /// If a reminder in DogsTableViewController or Add Reminder were tapped, invokes this function. Opens up the same page but changes between creating new and editing existing mode.
    func shouldOpenReminderMenu(forDogUUID: UUID, forReminder: Reminder?) {
        guard let forReminder = forReminder else {
            // creating new
            // no need to query as nothing in server since creating
            let vc = DogsAddReminderViewController()
            vc.setup(forDelegate: self, forReminderToUpdateDogUUID: forDogUUID, forReminderToUpdate: forReminder)
            self.dogsAddReminderViewController = vc
            PresentationManager.enqueueViewController(vc)
            return
        }

        // updating
        PresentationManager.beginFetchingInformationIndicator()
        // query for existing
        RemindersRequest.get(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forReminder: forReminder) { reminder, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                guard responseStatus != .failureResponse else {
                    return
                }
                guard let reminder = reminder else {
                    // If the response was successful but no reminder was returned, that means the reminder was deleted. Therefore, update the dogManager to indicate as such.
                    let dogReminders = self.dogManager.findDog(forDogUUID: forDogUUID)?.dogReminders
                    dogReminders?.removeReminder(forReminderUUID: forReminder.reminderUUID)

                    self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                    return
                }

                let vc = DogsAddReminderViewController()
                vc.setup(forDelegate: self, forReminderToUpdateDogUUID: forDogUUID, forReminderToUpdate: reminder)
                self.dogsAddReminderViewController = vc
                PresentationManager.enqueueViewController(vc)
            }
        }
    }

    func shouldUpdateAlphaForButtons(forAlpha: Double) {
        createNewDogOrReminderButton.alpha = forAlpha
        createNewDogOrReminderButton.isHidden = forAlpha == 0
    }

    // MARK: - Elements
    
    private let dogsTableViewController: DogsTableViewController = DogsTableViewController()

    private let noDogsRecordedLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.isHidden = true
        label.text = "No dogs recorded! Try creating one..."
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBlue
        return label
    }()

    private let createNewDogOrReminderButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 260, compressionResistancePriority: 260)
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "plus.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .secondarySystemBackground
        
        return button
    }()

    // MARK: - Properties

    private weak var delegate: DogsViewControllerDelegate?

    private(set) var dogsAddDogViewController: DogsAddDogViewController?

    private(set) var dogsAddReminderViewController: DogsAddReminderViewController?

    private let createNewButtonPadding: CGFloat = 10.0

    private var createNewMenuIsOpen: Bool = false
    private var createNewMenuScreenDimmer: UIView!
    private var createNewButtons: [GeneralUIButton] = []
    private var createNewLabels: [GeneralUILabel] = []
    private var createNewBackgroundLabels: [GeneralUILabel] = []

    // MARK: - Dog Manager

    private(set) var dogManager = DogManager()

    func setDogManager(sender: Sender, forDogManager: DogManager) {
        dogManager = forDogManager

        // possible senders
        // DogsTableViewController
        // DogsAddDogViewController
        // MainTabBarController

        if !(sender.localized is DogsTableViewController) {
            dogsTableViewController.setDogManager(sender: Sender(origin: sender, localized: self), forDogManager: dogManager)
        }

        if (sender.localized is MainTabBarController) == true {
            // main tab bar view controller could have performed a dog manager refresh, meaning the open modification page is invalid
            dogsAddDogViewController?.dismiss(animated: false)
            dogsAddReminderViewController?.dismiss(animated: false)
        }
        if !(sender.localized is MainTabBarController) {
            delegate?.didUpdateDogManager(sender: Sender(origin: sender, localized: self), forDogManager: dogManager)
        }

        noDogsRecordedLabel.isHidden = !dogManager.dogs.isEmpty
    }

    // MARK: - Main

    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        dogsTableViewController.setup(forDelegate: self)

        // TODO UIKIT mvoe this logic to the proper place
        let createNewMenuScreenDimmer = UIView(frame: view.frame)
        createNewMenuScreenDimmer.backgroundColor = UIColor.black
        createNewMenuScreenDimmer.isUserInteractionEnabled = false
        createNewMenuScreenDimmer.alpha = 0
        self.createNewMenuScreenDimmer = createNewMenuScreenDimmer

        let closeCreateNewDogOrReminderTap = UITapGestureRecognizer(target: self, action: #selector(closeCreateNewDogOrReminder))
        closeCreateNewDogOrReminderTap.delegate = self
        createNewMenuScreenDimmer.addGestureRecognizer(closeCreateNewDogOrReminderTap)

        self.view.addSubview(createNewMenuScreenDimmer)
        self.view.bringSubviewToFront(createNewDogOrReminderButton)
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        closeCreateNewDogOrReminder()
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: DogsViewControllerDelegate) {
        self.delegate = forDelegate
    }

    // MARK: - Functions
    
    func scrollDogsTableViewControllerToTop() {
        guard let y = dogsTableViewController.referenceContentOffsetY else {
            return
        }
        dogsTableViewController.tableView?.setContentOffset(CGPoint(x: 0, y: y), animated: true)
    }
    
    @objc private func didTouchUpInsideCreateNewDogOrReminder(_ sender: Any) {
        if createNewMenuIsOpen {
            closeCreateNewDogOrReminder()
        }
        else {
            openCreateNewDogOrReminder()
        }
    }

    @objc private func willOpenMenu(sender: Any) {
        // The sender could be a UIButton or UIGestureRecognizer (which is attached to a GeneralUILabel), so we attempt to unwrap the sender as both
        let senderProperties = (sender as? GeneralUIProtocol)?.properties ?? ((sender as? UITapGestureRecognizer)?.view as? GeneralUILabel)?.properties
        let dogUUID = UUID.fromString(forUUIDString: senderProperties?[KeyConstant.dogUUID.rawValue] as? String)
        
        if let dogUUID = dogUUID {
            self.shouldOpenReminderMenu(forDogUUID: dogUUID, forReminder: nil)
        }
        else {
            self.shouldOpenDogMenu(forDogUUID: nil)
        }
    }

    private func openCreateNewDogOrReminder() {
        guard createNewMenuIsOpen == false else {
            return
        }
        createNewMenuIsOpen = true

        createNewMenuScreenDimmer.isUserInteractionEnabled = true

        let createNewDogOrReminderButtonSmallestDimension: CGFloat = createNewDogOrReminderButton.frame.width < createNewDogOrReminderButton.frame.height ? createNewDogOrReminderButton.frame.width : createNewDogOrReminderButton.frame.height

        let createNewButtonSize: CGFloat = createNewDogOrReminderButtonSmallestDimension * 0.65
        let totalAvailableYSpaceForCreateNewButtons: CGFloat = createNewDogOrReminderButton.frame.origin.y - view.safeAreaLayoutGuide.layoutFrame.origin.y
        let maximumNumberOfCreateNewButtons: Int = Int(totalAvailableYSpaceForCreateNewButtons / ( createNewButtonSize + createNewButtonPadding))

        let createNewButtonXOrigin = createNewDogOrReminderButton.frame.maxX - createNewButtonSize
        let createNewButtonYOrigin = createNewDogOrReminderButton.frame.origin.y - createNewButtonPadding - createNewButtonSize

        // Creates the "add new dog" button to tap
        let createNewDogButton = GeneralUIButton(frame: CGRect(
            x: createNewButtonXOrigin, y: createNewButtonYOrigin,
            width: createNewButtonSize, height: createNewButtonSize))
        createNewDogButton.setImage(UIImage(systemName: "plus.circle"), for: .normal)
        createNewDogButton.tintColor = .systemBlue
        createNewDogButton.backgroundCircleTintColor = .systemBackground
        
        // TODO RT make these buttons "create dog, create reminder, and create trigger". if multile dogs, then display dialog to select dog

        let createNewDogLabel = createCreateAddLabel(relativeToFrame: createNewDogButton.frame, text: "Create New Dog")
        let createNewDogLabelBackground = createCreateAddBackgroundLabel(forLabel: createNewDogLabel)

        createNewDogButton.addTarget(self, action: #selector(willOpenMenu(sender:)), for: .touchUpInside)
        createNewDogLabel.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(willOpenMenu(sender:))))

        view.insertSubview(createNewDogLabelBackground, belowSubview: createNewDogOrReminderButton)
        view.insertSubview(createNewDogLabel, belowSubview: createNewDogOrReminderButton)
        view.insertSubview(createNewDogButton, belowSubview: createNewDogOrReminderButton)
        createNewBackgroundLabels.append(createNewDogLabelBackground)
        createNewLabels.append(createNewDogLabel)
        createNewButtons.append(createNewDogButton)

        // Iterate through each dog to create corresponding "Create New Reminder for dogName" button and label.
        for dog in dogManager.dogs {
            guard createNewButtons.count < maximumNumberOfCreateNewButtons else {
                break
            }

            // Use the last createNewButton in createNewButtons as a position reference for the next button.
            // createNewButtons shouldn't be empty at this point. It should have the button for 'Create New Dog' or for one of the 'Create New Reminder for dogName'
            guard let lastCreateNewButton = createNewButtons.last else {
                break
            }

            let createNewReminderButton = GeneralUIButton(frame: CGRect(
                origin: CGPoint(x: lastCreateNewButton.frame.origin.x, y: lastCreateNewButton.frame.origin.y - createNewButtonPadding - createNewButtonSize),
                size: CGSize(width: createNewButtonSize, height: createNewButtonSize)))
            createNewReminderButton.setImage(UIImage(systemName: "plus.circle"), for: .normal)
            createNewReminderButton.tintColor = .systemBlue
            createNewReminderButton.backgroundCircleTintColor = .systemBackground

            let createNewReminderLabel = createCreateAddLabel(relativeToFrame: createNewReminderButton.frame, text: "Create New Reminder For \(dog.dogName)")
            let createNewReminderLabelBackground = createCreateAddBackgroundLabel(forLabel: createNewReminderLabel)

            createNewReminderButton.properties[KeyConstant.dogUUID.rawValue] = dog.dogUUID.uuidString
            createNewReminderButton.addTarget(self, action: #selector(willOpenMenu(sender:)), for: .touchUpInside)
            
            createNewReminderLabel.properties[KeyConstant.dogUUID.rawValue] = dog.dogUUID.uuidString
            createNewReminderLabel.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(willOpenMenu(sender:))))

            view.insertSubview(createNewReminderLabelBackground, belowSubview: createNewDogOrReminderButton)
            view.insertSubview(createNewReminderLabel, belowSubview: createNewDogOrReminderButton)
            view.insertSubview(createNewReminderButton, belowSubview: createNewDogOrReminderButton)

            createNewBackgroundLabels.append(createNewReminderLabelBackground)
            createNewLabels.append(createNewReminderLabel)
            createNewButtons.append(createNewReminderButton)
        }

        // Animate dimming the screen for when the menu opens and rotate createNewDogOrReminderButton slightly
        UIView.animate(withDuration: VisualConstant.AnimationConstant.openOrCloseCreateNewDogOrReminder) {
            self.createNewDogOrReminderButton.transform = CGAffineTransform(rotationAngle: -.pi / 4)
            self.createNewDogOrReminderButton.tintColor = .systemRed

            self.createNewMenuScreenDimmer.alpha = 0.5
            self.tabBarController?.tabBar.alpha = 0.05
        }

        // Conceal createNewButton inside of createNewDogOrReminderButton, then animate them back to their original positions
        createNewButtons.forEach { createNewButton in
            let originalCreateNewButtonOrigin = createNewButton.frame.origin

            // move createNewButton vertically so that it sits vertically aligned inside of createNewDogOrReminderButton. This will conceal createNewButton below createNewDogOrReminderButton
            createNewButton.frame.origin.y = createNewDogOrReminderButton.frame.midY - (createNewButton.frame.height / 2)
            // the buttons' right edges slightly stick out under createNewDogOrReminderButton. Therefore, we must shift them ever so slightly in
            createNewButton.frame.origin.x -= (createNewDogOrReminderButton.frame.width * 0.025)

            UIView.animate(withDuration: VisualConstant.AnimationConstant.openOrCloseCreateNewDogOrReminder) {
                createNewButton.frame.origin = originalCreateNewButtonOrigin
            }
        }

        // Conceal createNewLabel by shifting it directly right off screen, then animate them back into their original positons
        createNewLabels.forEach { createNewLabel in
            let originalCreateNewLabelOrigin = createNewLabel.frame.origin

            // move createNewLabel horizontally so that it sits out of view to the right
            createNewLabel.frame.origin.x = view.safeAreaLayoutGuide.layoutFrame.maxX

            UIView.animate(withDuration: VisualConstant.AnimationConstant.openOrCloseCreateNewDogOrReminder) {
                createNewLabel.frame.origin = originalCreateNewLabelOrigin
            }
        }

        // same as above
        createNewBackgroundLabels.forEach { createNewBackgroundLabel in
            let originalCreateNewBackgroundLabelOrigin = createNewBackgroundLabel.frame.origin

            // move createNewLabel horizontally so that it sits out of view to the right
            createNewBackgroundLabel.frame.origin.x = view.safeAreaLayoutGuide.layoutFrame.maxX

            UIView.animate(withDuration: VisualConstant.AnimationConstant.openOrCloseCreateNewDogOrReminder) {
                createNewBackgroundLabel.frame.origin = originalCreateNewBackgroundLabelOrigin
            }
        }
    }

    @objc private func closeCreateNewDogOrReminder() {
        guard createNewMenuIsOpen == true else {
            return
        }
        createNewMenuIsOpen = false

        createNewMenuScreenDimmer.isUserInteractionEnabled = false

        UIView.animate(withDuration: VisualConstant.AnimationConstant.openOrCloseCreateNewDogOrReminder) {
            self.createNewDogOrReminderButton.transform = .identity
            self.createNewDogOrReminderButton.tintColor = .systemBlue
            self.createNewMenuScreenDimmer.alpha = 0

            self.tabBarController?.tabBar.alpha = 1
        }

        // animate the labels back into origina, opening positions then remove after delay
        createNewButtons.forEach { createNewButton in
            UIView.animate(withDuration: VisualConstant.AnimationConstant.openOrCloseCreateNewDogOrReminder) {
                // move createNewButton vertically so that it sits vertically aligned inside of createNewDogOrReminderButton. This will conceal createNewButton below createNewDogOrReminderButton
                createNewButton.frame.origin.y = self.createNewDogOrReminderButton.frame.midY - (createNewButton.frame.height / 2)
                // the buttons' right edges slightly stick out under createNewDogOrReminderButton. Therefore, we must shift them ever so slightly in
                createNewButton.frame.origin.x -= (self.createNewDogOrReminderButton.frame.width * 0.025)

            } completion: { _ in
                DispatchQueue.main.asyncAfter(deadline: .now() + VisualConstant.AnimationConstant.removeFromViewCreateNewDogOrReminderDelay) {
                    createNewButton.removeFromSuperview()
                }
            }
        }

        // animate the labels back into original, opening position then remove after delay
        createNewLabels.forEach { createNewLabel in
            UIView.animate(withDuration: VisualConstant.AnimationConstant.openOrCloseCreateNewDogOrReminder) {
                // move createNewLabel horizontally so that it sits out of view to the right
                createNewLabel.frame.origin.x = self.view.safeAreaLayoutGuide.layoutFrame.maxX

            } completion: { _ in
                DispatchQueue.main.asyncAfter(deadline: .now() + VisualConstant.AnimationConstant.removeFromViewCreateNewDogOrReminderDelay) {
                    createNewLabel.removeFromSuperview()
                }
            }
        }

        // same as above
        createNewBackgroundLabels.forEach { createNewBackgroundLabel in
            UIView.animate(withDuration: VisualConstant.AnimationConstant.openOrCloseCreateNewDogOrReminder) {
                // move createNewLabel horizontally so that it sits out of view to the right
                createNewBackgroundLabel.frame.origin.x = self.view.safeAreaLayoutGuide.layoutFrame.maxX

            } completion: { _ in
                DispatchQueue.main.asyncAfter(deadline: .now() + VisualConstant.AnimationConstant.removeFromViewCreateNewDogOrReminderDelay) {
                    createNewBackgroundLabel.removeFromSuperview()
                }
            }
        }

        createNewButtons = []
        createNewLabels = []
        createNewBackgroundLabels = []
    }

    private func createCreateAddLabel(relativeToFrame frame: CGRect, text: String) -> GeneralUILabel {
        let font = VisualConstant.FontConstant.emphasizedPrimaryRegularLabel
        let createNewLabelSize = text.bounding(font: font)

        let createNewLabel = GeneralUILabel(frame: CGRect(
            x: frame.origin.x - createNewLabelSize.width,
            y: frame.midY - (createNewLabelSize.height / 2),
            width: createNewLabelSize.width,
            height: createNewLabelSize.height))
        // we can't afford to shrink the label here, already small
        createNewLabel.minimumScaleFactor = 1.0
        createNewLabel.font = font
        createNewLabel.text = text
        createNewLabel.textColor = .systemBackground
        createNewLabel.isUserInteractionEnabled = true

        let overshootDistance: CGFloat = createNewButtonPadding - createNewLabel.frame.origin.x
        // Check to make sure the label didn't overshoot the allowed bounds
        if overshootDistance > 0 {
            createNewLabel.frame = CGRect(
                x: createNewButtonPadding,
                y: createNewLabel.frame.origin.y,
                width: createNewLabel.frame.width - overshootDistance,
                height: createNewLabel.frame.height
            )
        }

        return createNewLabel
    }

    private func createCreateAddBackgroundLabel(forLabel label: GeneralUILabel) -> GeneralUILabel {
        let createNewBackgroundLabel = GeneralUILabel(frame: label.frame)
        // we can't afford to shrink the label here, already small
        createNewBackgroundLabel.minimumScaleFactor = 1.0

        let precalculatedDynamicText = label.text ?? ""
        let precalculatedDynamicFont = label.font
        createNewBackgroundLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            return NSAttributedString(string: precalculatedDynamicText, attributes: [
                .strokeColor: UIColor.systemBlue,
                .foregroundColor: UIColor.systemBlue,
                .strokeWidth: 15.0,
                .font: precalculatedDynamicFont as Any
            ])
        }

        createNewBackgroundLabel.isUserInteractionEnabled = false

        return createNewBackgroundLabel
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .secondarySystemBackground
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        embedChild(dogsTableViewController)
        
        view.addSubview(noDogsRecordedLabel)
        view.addSubview(createNewDogOrReminderButton)
        
        createNewDogOrReminderButton.addTarget(self, action: #selector(didTouchUpInsideCreateNewDogOrReminder), for: .touchUpInside)
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        // McreateNewDogOrReminderButton constraints
        let createNewDogOrReminderBottom = createNewDogOrReminderButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -ConstraintConstant.Button.circleInset)
        let createNewDogOrReminderTrailing = createNewDogOrReminderButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Button.circleInset)
        let createNewDogOrReminderWidthMultiplier = createNewDogOrReminderButton.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: ConstraintConstant.Button.circleHeightMultiplier)
        createNewDogOrReminderWidthMultiplier.priority = .defaultHigh
        let createNewDogOrReminderMaxWidth = createNewDogOrReminderButton.widthAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.circleMaxHeight)
        let createNewDogOrReminderSquare = createNewDogOrReminderButton.createSquareConstraint()

        // noDogsRecordedLabel
        let noDogsRecordedLabelTop = noDogsRecordedLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
        let noDogsRecordedLabelBottom = noDogsRecordedLabel.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        let noDogsRecordedLabelLeading = noDogsRecordedLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let noDogsRecordedLabelTrailing = noDogsRecordedLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        // dogsTableViewController
        let dogsTableViewControllerViewTop = dogsTableViewController.view.topAnchor.constraint(equalTo: view.topAnchor)
        let dogsTableViewControllerViewBottom = dogsTableViewController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        let dogsTableViewControllerViewLeading = dogsTableViewController.view.leadingAnchor.constraint(equalTo: view.leadingAnchor)
        let dogsTableViewControllerViewTrailing = dogsTableViewController.view.trailingAnchor.constraint(equalTo: view.trailingAnchor)
        
        NSLayoutConstraint.activate([
            createNewDogOrReminderBottom,
            createNewDogOrReminderTrailing,
            createNewDogOrReminderWidthMultiplier,
            createNewDogOrReminderMaxWidth,
            createNewDogOrReminderSquare,
            
            noDogsRecordedLabelTop,
            noDogsRecordedLabelBottom,
            noDogsRecordedLabelLeading,
            noDogsRecordedLabelTrailing,
            
            dogsTableViewControllerViewTop,
            dogsTableViewControllerViewBottom,
            dogsTableViewControllerViewLeading,
            dogsTableViewControllerViewTrailing
        ])
    }

}
//
//  DogsTableViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/1/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsTableViewControllerDelegate: AnyObject {
    func shouldOpenDogMenu(forDogUUID: UUID?)
    func shouldOpenReminderMenu(forDogUUID: UUID, forReminder: Reminder?)
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager)
    func shouldUpdateAlphaForButtons(forAlpha: Double)
}

final class DogsTableViewController: GeneralUITableViewController {
    
    // MARK: - UIScrollViewDelegate
    
    override func scrollViewDidScroll(_ scrollView: UIScrollView) {
        guard let referenceContentOffsetY = referenceContentOffsetY else {
            return
        }
        
        // Sometimes the default contentOffset.y isn't 0.0, in testing it was -47.0, so we want to adjust that value to 0.0
        let adjustedContentOffsetY = scrollView.contentOffset.y - referenceContentOffsetY
        // When scrollView.contentOffset.y reaches the value of alphaConstant, the UI element's alpha is set to 0 and is hidden.
        let alphaConstant: Double = 100.0
        let alpha: Double = max(1.0 - (adjustedContentOffsetY / alphaConstant), 0.0)
        delegate?.shouldUpdateAlphaForButtons(forAlpha: alpha)
    }
    
    // MARK: - Properties
    
    private weak var delegate: DogsTableViewControllerDelegate?
    
    private var loopTimer: Timer?
    
    /// dummyTableTableHeaderViewHeight conflicts with our tableView. By adding it, we set our content inset to -dummyTableTableHeaderViewHeight. This change, when scrollViewDidScroll is invoked, makes it appear that we are scrolled dummyTableTableHeaderViewHeight down further than we are. Additionally, there is always some constant contentOffset, normally about -47.0, that is applied because of our tableView being constrainted to the superview and not safe area. Therefore, we have to track and correct for these.
    private(set) var referenceContentOffsetY: Double?
    
    // MARK: - Dog Manager
    
    private(set) var dogManager: DogManager = DogManager()
    
    func setDogManager(sender: Sender, forDogManager: DogManager) {
        dogManager = forDogManager
        
        // possible senders
        // DogsAddDogDisplayReminderTVC
        // DogsDogTVC
        // DogsViewController
        if !(sender.localized is DogsViewController) {
            delegate?.didUpdateDogManager(sender: Sender(origin: sender, localized: self), forDogManager: dogManager)
        }
        if !(sender.localized is DogsReminderTVC) && !(sender.origin is DogsTableViewController) {
            self.tableView.reloadData()
        }
        if sender.localized is DogsReminderTVC {
            self.reloadVisibleCellsNextAlarmLabels()
        }
        
        // start up loop timer, normally done in view will appear but sometimes view has appeared and doesn't need a loop but then it can get a dogManager update which requires a loop. This happens due to reminder added in DogsIntroduction page.
        if viewIsBeingViewed == true && loopTimer == nil {
            loopTimer = Timer(fireAt: Date(), interval: 1.0, target: self, selector: #selector(self.reloadVisibleCellsNextAlarmLabels), userInfo: nil, repeats: true)
            
            if let loopTimer = loopTimer {
                RunLoop.main.add(loopTimer, forMode: .common)
            }
        }
        
        tableView.allowsSelection = !dogManager.dogs.isEmpty
        tableView.rowHeight = dogManager.dogs.isEmpty ? 65.5 : -1.0
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.tableView.register(DogsDogTVC.self, forCellReuseIdentifier: DogsDogTVC.reuseIdentifier)
        self.tableView.register(DogsReminderTVC.self, forCellReuseIdentifier: DogsReminderTVC.reuseIdentifier)
        self.tableView.allowsSelection = !dogManager.dogs.isEmpty
        // allow for refreshing of the information from the server
        self.tableView.refreshControl = UIRefreshControl()
        self.tableView.refreshControl?.addTarget(self, action: #selector(refreshTableData), for: .valueChanged)
        
        // By default the tableView pads a header, even of height 0.0, by about 20.0 points
        self.tableView.sectionHeaderTopPadding = 0.0
        self.tableView.separatorStyle = .none
    }
    
    private var viewIsBeingViewed: Bool = false
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        viewIsBeingViewed = true
        
        self.tableView.reloadData()
        
        loopTimer = Timer(fireAt: Date(), interval: 1.0, target: self, selector: #selector(self.reloadVisibleCellsNextAlarmLabels), userInfo: nil, repeats: true)
        
        if let loopTimer = loopTimer {
            RunLoop.main.add(loopTimer, forMode: .common)
        }
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        let dummyTableTableHeaderViewHeight = 100.0
        // Adding a tableHeaderView prevents section headers from sticking and floating at the top of the page when we scroll up. This is because we are basically adding a large blank space to the top of the screen, allowing a space for the header to scroll into
        tableView.tableHeaderView = UIView(frame: CGRect(x: 0, y: 0, width: self.tableView.bounds.size.width, height: dummyTableTableHeaderViewHeight))
        tableView.contentInset = UIEdgeInsets(top: -dummyTableTableHeaderViewHeight, left: 0, bottom: 0, right: 0)
        
        if referenceContentOffsetY == nil {
            referenceContentOffsetY = tableView.contentOffset.y
        }
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        viewIsBeingViewed = false
        
        loopTimer?.invalidate()
        loopTimer = nil
    }
    
    // MARK: - Setup
    
    func setup(forDelegate: DogsTableViewControllerDelegate) {
        self.delegate = forDelegate
    }
    
    // MARK: - Functions
    
    @objc private func reloadVisibleCellsNextAlarmLabels() {
        guard tableView.visibleCells.isEmpty == false else {
            loopTimer?.invalidate()
            loopTimer = nil
            return
        }
        
        for cell in tableView.visibleCells {
            (cell as? DogsReminderTVC)?.reloadReminderNextAlarmLabel()
        }
    }
    
    /// Makes a query to the server to retrieve new information then refreshed the tableView
    @objc private func refreshTableData() {
        PresentationManager.beginFetchingInformationIndicator()
        DogsRequest.get(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogManager: dogManager) { newDogManager, responseStatus, _ in
            PresentationManager.endFetchingInformationIndicator {
                // end refresh first otherwise there will be a weird visual issue
                self.tableView.refreshControl?.endRefreshing()
                
                guard responseStatus != .failureResponse, let newDogManager = newDogManager else {
                    return
                }
                
                if responseStatus == .successResponse {
                    PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.successRefreshRemindersTitle, forSubtitle: VisualConstant.BannerTextConstant.successRefreshRemindersSubtitle, forStyle: .success)
                }
                else {
                    if OfflineModeManager.shared.hasDisplayedOfflineModeBanner == true {
                        // If OfflineModeManager has displayed its banner that indicates its turning on, then we are safe to display this banner. Otherwise, we would run the risk of both of these banners displaying if its the first time enterin offline mode.
                        PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.infoRefreshOnHoldTitle, forSubtitle: VisualConstant.BannerTextConstant.infoRefreshOnHoldSubtitle, forStyle: .info)
                    }
                }
                
                self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: newDogManager)
                // manually reload table as the self sender doesn't do that
                self.tableView.reloadData()
            }
        }
    }
    
    private func willShowDogActionSheet(forCell cell: DogsDogTVC, forIndexPath indexPath: IndexPath) {
        guard let dogName = cell.dog?.dogName, let dogUUID = cell.dog?.dogUUID, let section = self.dogManager.dogs.firstIndex(where: { dog in
            dog.dogUUID == dogUUID
        }) else {
            return
        }
        
        let alertController = UIAlertController(title: "You Selected: \(dogName)", message: nil, preferredStyle: .actionSheet)
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        let addAlertAction = UIAlertAction(title: "Add Reminder", style: .default) { _ in
            self.delegate?.shouldOpenReminderMenu(forDogUUID: dogUUID, forReminder: nil)
        }
        
        let editAlertAction = UIAlertAction(
            title: "Edit Dog",
            style: .default,
            handler: { (_: UIAlertAction!)  in
                self.delegate?.shouldOpenDogMenu(forDogUUID: dogUUID)
            })
        
        let removeAlertAction = UIAlertAction(title: "Delete Dog", style: .destructive) { _ in
            
            // REMOVE CONFIRMATION
            let removeDogConfirmation = UIAlertController(title: "Are you sure you want to delete \(dogName)?", message: nil, preferredStyle: .alert)
            
            let confirmRemoveDogAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
                DogsRequest.delete(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: dogUUID) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    self.dogManager.removeDog(forDogUUID: dogUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                    self.tableView.deleteSections([section], with: .automatic)
                    
                }
            }
            
            let confirmCancelRemoveDogAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            
            removeDogConfirmation.addAction(confirmRemoveDogAlertAction)
            removeDogConfirmation.addAction(confirmCancelRemoveDogAlertAction)
            
            PresentationManager.enqueueAlert(removeDogConfirmation)
        }
        
        alertController.addAction(addAlertAction)
        
        alertController.addAction(editAlertAction)
        
        alertController.addAction(removeAlertAction)
        
        alertController.addAction(cancelAlertAction)
        
        PresentationManager.enqueueActionSheet(alertController, sourceView: cell)
    }
    
    /// Called when a reminder is tapped by the user, display an action sheet of possible modifcations to the alarm/reminder.
    private func willShowReminderActionSheet(forCell cell: DogsReminderTVC, forIndexPath indexPath: IndexPath) {
        guard let dogUUID = cell.dogUUID, let dog = dogManager.findDog(forDogUUID: dogUUID) else {
            return
        }
        
        guard let reminder = cell.reminder else {
            return
        }
        
        let selectedReminderAlertController = UIAlertController(title: "You Selected: \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName)) for \(dog.dogName)", message: nil, preferredStyle: .actionSheet)
        
        let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        
        let editAlertAction = UIAlertAction(title: "Edit Reminder", style: .default) { _ in
            self.delegate?.shouldOpenReminderMenu(forDogUUID: dogUUID, forReminder: reminder)
        }
        
        // REMOVE BUTTON
        let removeAlertAction = UIAlertAction(title: "Delete Reminder", style: .destructive) { _ in
            
            // REMOVE CONFIRMATION
            let removeReminderConfirmation = UIAlertController(title: "Are you sure you want to delete \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))?", message: nil, preferredStyle: .alert)
            
            let removeReminderConfirmationRemove = UIAlertAction(title: "Delete", style: .destructive) { _ in
                RemindersRequest.delete(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: dog.dogUUID, forReminderUUIDs: [reminder.reminderUUID]) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    
                    dog.dogReminders.removeReminder(forReminderUUID: reminder.reminderUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                    self.tableView.deleteRows(at: [indexPath], with: .automatic)
                }
                
            }
            
            let removeReminderConfirmationCancel = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            
            removeReminderConfirmation.addAction(removeReminderConfirmationRemove)
            removeReminderConfirmation.addAction(removeReminderConfirmationCancel)
            
            PresentationManager.enqueueAlert(removeReminderConfirmation)
            
        }
        
        let skipOnceAlertAction = UIAlertAction(
            title: "Skip Once",
            style: .default,
            handler: { _ in
                self.userSkippedReminderOnce(forDogUUID: dog.dogUUID, forReminder: reminder)
                PresentationManager.enqueueBanner(forTitle: "Skipped \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName)) Once", forSubtitle: nil, forStyle: .success)
            })
        
        // DETERMINES IF ITS A LOG BUTTON OR UNDO LOG BUTTON
        let shouldUndoLogOrUnskip: Bool = {
            guard reminder.reminderIsEnabled == true && reminder.snoozeComponents.executionInterval == nil else {
                return false
            }
            
            return (reminder.reminderType == .weekly && reminder.weeklyComponents.isSkipping) || (reminder.reminderType == .monthly && reminder.monthlyComponents.isSkipping)
        }()
        
        let shouldShowSkipOnceAction: Bool = {
            guard shouldUndoLogOrUnskip == false else {
                return false
            }
            
            guard reminder.reminderType != .oneTime else {
                return false
            }
            
            return true
        }()
        
        // STORES LOG BUTTON(S)
        var alertActionsForLog: [UIAlertAction] = []
        
        // ADD LOG BUTTONS (MULTIPLE IF POTTY OR OTHER SPECIAL CASE)
        if shouldUndoLogOrUnskip == true {
            let logToUndo = findLogFromSkippedReminder(forDog: dog, forReminder: reminder)
            
            let logAlertAction = UIAlertAction(
                title:
                    (logToUndo != nil
                     ? "Undo Log "
                     : "Undo Skip ")
                + "for \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))",
                style: .default,
                handler: { (_: UIAlertAction!)  in
                    self.userSelectedUnskipReminder(forDog: dog, forReminder: reminder)
                    
                    let bannerTitle = (logToUndo != nil
                                       ? "Undid "
                                       : "Unskipped ")
                    + (reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))
                    PresentationManager.enqueueBanner(forTitle: bannerTitle, forSubtitle: nil, forStyle: .success)
                    
                })
            alertActionsForLog.append(logAlertAction)
        }
        else {
            // Cant convert a reminderActionType of potty directly to logActionType, as it has serveral possible outcomes. Otherwise, logActionType and reminderActionType 1:1
            let logActionTypes: [LogActionType] = reminder.reminderActionType.associatedLogActionTypes
            
            for logActionType in logActionTypes {
                let fullReadableName = logActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName)
                let logAlertAction = UIAlertAction(
                    title: "Log \(fullReadableName)",
                    style: .default,
                    handler: { _ in
                        self.userPreemptivelyLoggedReminder(forDogUUID: dog.dogUUID, forReminder: reminder, forLogActionType: logActionType)
                        PresentationManager.enqueueBanner(forTitle: "Logged \(fullReadableName)", forSubtitle: nil, forStyle: .success)
                    })
                alertActionsForLog.append(logAlertAction)
            }
        }
        
        for logAlertAction in alertActionsForLog {
            selectedReminderAlertController.addAction(logAlertAction)
        }
        
        if shouldShowSkipOnceAction == true {
            selectedReminderAlertController.addAction(skipOnceAlertAction)
        }
        
        selectedReminderAlertController.addAction(editAlertAction)
        
        selectedReminderAlertController.addAction(removeAlertAction)
        
        selectedReminderAlertController.addAction(cancelAlertAction)
        
        PresentationManager.enqueueActionSheet(selectedReminderAlertController, sourceView: cell)
        
    }
    
    /// The user went to log/skip a reminder on the reminders page. Must updating skipping data and add a log.
    private func userPreemptivelyLoggedReminder(forDogUUID: UUID, forReminder: Reminder, forLogActionType: LogActionType) {
        let log = Log(forLogActionTypeId: forLogActionType.logActionTypeId, forLogCustomActionName: forReminder.reminderCustomActionName, forLogStartDate: Date())
        
        // special case. Once a oneTime reminder executes/ is skipped, it must be delete. Therefore there are special server queries.
        if forReminder.reminderType == .oneTime {
            // make request to add log, then (if successful) make request to delete reminder
            
            // delete the reminder on the server
            RemindersRequest.delete(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forReminderUUIDs: [forReminder.reminderUUID]) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }
                
                self.dogManager.findDog(forDogUUID: forDogUUID)?.dogReminders.removeReminder(forReminderUUID: forReminder.reminderUUID)
                self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                // manually reload table as the self sender doesn't do that
                self.tableView.reloadData()
                
                LogsRequest.create(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forLog: log) { responseStatusLogCreate, _ in
                    guard responseStatusLogCreate != .failureResponse else {
                        return
                    }
                    
                    self.dogManager.findDog(forDogUUID: forDogUUID)?.dogLogs.addLog(forLog: log)
                    self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                }
            }
        }
        // Nest all the other cases inside this else statement as otherwise .oneTime alarms would make request with the above code then again down here.
        else {
            forReminder.enableIsSkipping(forSkippedDate: Date())
            
            // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
            RemindersRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forReminders: [forReminder]) { responseStatusReminderUpdate, _ in
                guard responseStatusReminderUpdate != .failureResponse else {
                    return
                }
                
                self.dogManager.findDog(forDogUUID: forDogUUID)?.dogReminders.addReminder(forReminder: forReminder)
                self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                
                LogsRequest.create(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forLog: log) { responseStatusLogCreate, _ in
                    guard responseStatusLogCreate != .failureResponse else {
                        return
                    }
                    
                    self.dogManager.findDog(forDogUUID: forDogUUID)?.dogLogs.addLog(forLog: log)
                    self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                }
            }
        }
    }
    
    /// The user went to log/skip a reminder on the reminders page. Must updating skipping data and add a log.
    private func userSkippedReminderOnce(forDogUUID: UUID, forReminder: Reminder) {
        guard forReminder.reminderType != .oneTime else {
            return
        }
        
        forReminder.enableIsSkipping(forSkippedDate: Date())
        
        // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
        RemindersRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forReminders: [forReminder]) { responseStatusReminderUpdate, _ in
            guard responseStatusReminderUpdate != .failureResponse else {
                return
            }
            
            self.dogManager.findDog(forDogUUID: forDogUUID)?.dogReminders.addReminder(forReminder: forReminder)
            self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
        }
    }
    
    /// If a reminder was skipped, it could have either been a preemptive log (meaning there was a log created) or it was skipped without a log. Thus, locate the log if it exists.
    private func findLogFromSkippedReminder(forDog: Dog, forReminder: Reminder) -> Log? {
        // this is the time that the reminder's next alarm was skipped. at this same moment, a log was added. If this log is still there, with it's date unmodified by the user, then we remove it.
        let dateOfLogToRemove: Date? = {
            if forReminder.reminderType == .weekly {
                return forReminder.weeklyComponents.skippedDate
            }
            else if forReminder.reminderType == .monthly {
                return forReminder.monthlyComponents.skippedDate
            }
            
            return nil
        }()
        
        guard let dateOfLogToRemove = dateOfLogToRemove else {
            return nil
        }
        
        // find log that is incredibly close the time where the reminder was skipped, once found, then we delete it.
        let logToRemove = forDog.dogLogs.dogLogs.first(where: { log in
            return abs(dateOfLogToRemove.distance(to: log.logStartDate)) < 0.001
        })
        
        return logToRemove
    }
    
    /// The user went to unlog/unskip a reminder on the reminders page. Must update skipping information. Note: only weekly/monthly reminders can be skipped therefore only they can be unskipped.
    private func userSelectedUnskipReminder(forDog: Dog, forReminder: Reminder) {
        // we can only unskip a weekly/monthly reminder that is currently isSkipping == true
        guard (forReminder.reminderType == .weekly && forReminder.weeklyComponents.isSkipping == true) || (forReminder.reminderType == .monthly && forReminder.monthlyComponents.isSkipping == true) else {
            return
        }
        
        forReminder.disableIsSkipping()
        
        // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
        RemindersRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDog.dogUUID, forReminders: [forReminder]) { responseStatusReminderUpdate, _ in
            guard responseStatusReminderUpdate != .failureResponse else {
                return
            }
            
            self.dogManager.findDog(forDogUUID: forDog.dogUUID)?.dogReminders.addReminder(forReminder: forReminder)
            self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
            
            // find log that is incredibly close the time where the reminder was skipped, once found, then we delete it.
            guard let logToRemove = self.findLogFromSkippedReminder(forDog: forDog, forReminder: forReminder) else {
                return
            }
            
            // log to remove from unlog event. Attempt to delete the log server side
            LogsRequest.delete(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDog.dogUUID, forLogUUID: logToRemove.logUUID) { responseStatusLogDelete, _ in
                guard responseStatusLogDelete != .failureResponse else {
                    return
                }
                
                self.dogManager.findDog(forDogUUID: forDog.dogUUID)?.dogLogs.removeLog(forLogUUID: logToRemove.logUUID)
                self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
            }
            
        }
    }
    
    // MARK: - Table View Data Source
    
    override func numberOfSections(in tableView: UITableView) -> Int {
        dogManager.dogs.count
    }
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        guard dogManager.dogs.isEmpty == false else {
            return 0
        }
        
        return dogManager.dogs[section].dogReminders.dogReminders.count + 1
    }
    
    override func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        // Set the spacing between sections by configuring the header height
        return 25.0
    }
    
    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        // Make a blank headerView so that there is a header view
        return GeneralUIView()
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard dogManager.dogs.isEmpty == false else {
            return GeneralUITableViewCell()
        }
        
        let cell = indexPath.row == 0
        ? tableView.dequeueReusableCell(withIdentifier: DogsDogTVC.reuseIdentifier, for: indexPath)
        : tableView.dequeueReusableCell(withIdentifier: DogsReminderTVC.reuseIdentifier, for: indexPath)
        
        if let castedCell = cell as? DogsDogTVC {
            castedCell.setup(forDog: dogManager.dogs[indexPath.section])
            castedCell.containerView.roundCorners(setCorners: .all)
            
            if dogManager.dogs[indexPath.section].dogReminders.dogReminders.isEmpty {
                // if there is a reminder cell below this cell, we want to the white background of the reminder cell to "continuously" flow from the reminder cell to under this cell. the only way we can make that happen, is having a white background layer below out blue table view cell (which appears if there is a cell below this)
                castedCell.containerExtraBackgroundView.isHidden = true
            }
            else {
                castedCell.containerExtraBackgroundView.isHidden = false
            }
        }
        else if let castedCell = cell as? DogsReminderTVC {
            castedCell.setup(forDogUUID: dogManager.dogs[indexPath.section].dogUUID, forReminder: dogManager.dogs[indexPath.section].dogReminders.dogReminders[indexPath.row - 1])
            
            // This cell is a bottom cell
            if indexPath.row == dogManager.dogs[indexPath.section].dogReminders.dogReminders.count {
                castedCell.containerView.roundCorners(setCorners: .bottom)
            }
            else {
                castedCell.containerView.roundCorners(setCorners: .none)
            }
        }
        
        return cell
    }
    
    override func tableView(_ tableView: UITableView, shouldHighlightRowAt indexPath: IndexPath) -> Bool {
        // None of the rows should highlight. Either they have specific controls in them or open an external view controller
        return false
    }
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        
        tableView.deselectRow(at: indexPath, animated: true)
        
        guard dogManager.dogs.isEmpty == false else {
            return
        }
        
        if indexPath.row == 0, let dogsDogDisplayTableViewCell = tableView.cellForRow(at: indexPath) as? DogsDogTVC {
            willShowDogActionSheet(forCell: dogsDogDisplayTableViewCell, forIndexPath: indexPath)
        }
        else if indexPath.row > 0, let dogsReminderDisplayTableViewCell = tableView.cellForRow(at: indexPath) as? DogsReminderTVC {
            willShowReminderActionSheet(forCell: dogsReminderDisplayTableViewCell, forIndexPath: indexPath)
        }
        
    }
    
    override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
        
        guard editingStyle == .delete && dogManager.dogs.isEmpty == false else {
            return
        }
        var removeConfirmation: UIAlertController?
        
        // delete dog
        if indexPath.row == 0, let dogCell = tableView.cellForRow(at: indexPath) as?  DogsDogTVC, let dog = dogCell.dog {
            // cell in question
            
            removeConfirmation = UIAlertController(title: "Are you sure you want to delete \(dog.dogName)?", message: nil, preferredStyle: .alert)
            
            let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
                DogsRequest.delete(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: dog.dogUUID) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    
                    self.dogManager.removeDog(forDogUUID: dog.dogUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                    self.tableView.deleteSections([indexPath.section], with: .automatic)
                    
                }
                
            }
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            removeConfirmation?.addAction(removeAlertAction)
            removeConfirmation?.addAction(cancelAlertAction)
        }
        // delete reminder
        if indexPath.row > 0, let reminderCell = tableView.cellForRow(at: indexPath) as? DogsReminderTVC, let dogUUID = reminderCell.dogUUID, let dog: Dog = dogManager.findDog(forDogUUID: dogUUID), let reminder = reminderCell.reminder {
            removeConfirmation = UIAlertController(title: "Are you sure you want to delete \(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))?", message: nil, preferredStyle: .alert)
            
            let removeAlertAction = UIAlertAction(title: "Delete", style: .destructive) { _ in
                RemindersRequest.delete(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: dogUUID, forReminderUUIDs: [reminder.reminderUUID]) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        return
                    }
                    
                    dog.dogReminders.removeReminder(forReminderUUID: reminder.reminderUUID)
                    self.setDogManager(sender: Sender(origin: self, localized: self), forDogManager: self.dogManager)
                    self.tableView.deleteRows(at: [indexPath], with: .automatic)
                    
                }
                
            }
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            removeConfirmation?.addAction(removeAlertAction)
            removeConfirmation?.addAction(cancelAlertAction)
        }
        
        if let removeConfirmation = removeConfirmation {
            PresentationManager.enqueueAlert(removeConfirmation)
        }
    }
    
    override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        dogManager.dogs.count >= 1
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        tableView.backgroundColor = .secondarySystemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
    }
    
    override func setupConstraints() {
        super.setupConstraints()
    }
    
}
//
//  DogsMainScreenTableViewCellReminder.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/2/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class DogsReminderTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        return view
    }()
    
    private let reminderActionIconLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 370, compressionResistancePriority: 370)
        label.textAlignment = .center
        label.font = .systemFont(ofSize: 40, weight: .medium)
        
        label.shouldRoundCorners = true
        label.isRoundingToCircle = true
        return label
    }()
    
    private let reminderActionTextLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 330, compressionResistancePriority: 330)
        label.font = .systemFont(ofSize: 30, weight: .semibold)
        return label
    }()
    
    private let reminderRecurranceLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 360, compressionResistancePriority: 360)
        label.textAlignment = .right
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        return label
    }()
    
    private let reminderTimeOfDayBottomConstraintConstant: CGFloat = -5
    private weak var reminderTimeOfDayBottomConstraint: NSLayoutConstraint!
    private let reminderTimeOfDayLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 340, compressionResistancePriority: 340)
        label.textAlignment = .right
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        return label
    }()
    
    private let reminderNextAlarmHeightConstraintConstant: CGFloat = 25
    private weak var reminderNextAlarmHeightConstraint: NSLayoutConstraint!
    private let reminderNextAlarmLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 300, compressionResistancePriority: 300)
        label.backgroundColor = .secondarySystemBackground
        label.font = VisualConstant.FontConstant.tertiaryRegularLabel
        
        label.shouldRoundCorners = true
        return label
    }()

    private let chevonImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 290, compressionResistancePriority: 290)
       
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = .systemGray4
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "DogsReminderTVC"
    
    var dogUUID: UUID?
    var reminder: Reminder?
    
    private let reminderEnabledElementAlpha: CGFloat = 1.0
    private let reminderDisabledElementAlpha: CGFloat = 0.4
    
    // MARK: - Setup
    
    // Setup function that sets up the different IBOutlet properties
    func setup(forDogUUID: UUID, forReminder: Reminder) {
        self.dogUUID = forDogUUID
        self.reminder = forReminder
        
        reminderActionIconLabel.text = forReminder.reminderActionType.emoji
        reminderActionIconLabel.alpha = forReminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
        
        reminderActionTextLabel.text = forReminder.reminderActionType.convertToReadableName(customActionName: forReminder.reminderCustomActionName)
        reminderActionTextLabel.alpha = forReminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
        
        reminderRecurranceLabel.text = {
            switch forReminder.reminderType {
            case .countdown:
                return forReminder.countdownComponents.readableRecurranceInterval
            case .weekly:
                return forReminder.weeklyComponents.readableRecurranceInterval
            case .monthly:
                return forReminder.monthlyComponents.readableRecurranceInterval
            case .oneTime:
                return forReminder.oneTimeComponents.readableRecurranceInterval
            }
        }()
        reminderRecurranceLabel.alpha = forReminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
        
        reminderTimeOfDayLabel.text = {
            switch forReminder.reminderType {
            case .countdown:
                return forReminder.countdownComponents.readableTimeOfDayInterval
            case .weekly:
                return forReminder.weeklyComponents.readableTimeOfDayInterval
            case .monthly:
                return forReminder.monthlyComponents.readableTimeOfDayInterval
            case .oneTime:
                return forReminder.oneTimeComponents.readableTimeOfDayInterval
            }
        }()
        reminderTimeOfDayLabel.alpha = forReminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
        
        reloadReminderNextAlarmLabel()
        
        chevonImageView.alpha = forReminder.reminderIsEnabled ? reminderEnabledElementAlpha : reminderDisabledElementAlpha
    }
    
    // MARK: - Function
    
    func reloadReminderNextAlarmLabel() {
        guard let reminder = reminder else {
            return
        }
        
        guard reminder.reminderIsEnabled == true, let executionDate = reminder.reminderExecutionDate else {
            // The reminder is disabled, therefore don't show the next alarm label or padding for it as there is nothing to display
            reminderNextAlarmLabel.isHidden = true
            reminderTimeOfDayBottomConstraint.constant = 0.0
            reminderNextAlarmHeightConstraint.constant = 0.0
            return
        }
        
        // Reminder is enabled, therefore show the next alarm label
        reminderNextAlarmLabel.isHidden = false
        reminderTimeOfDayBottomConstraint.constant = reminderTimeOfDayBottomConstraintConstant
        reminderNextAlarmHeightConstraint.constant = reminderNextAlarmHeightConstraintConstant
        
        let nextAlarmHeaderFont = VisualConstant.FontConstant.emphasizedTertiaryRegularLabel
        let nextAlarmBodyFont = VisualConstant.FontConstant.tertiaryRegularLabel
        
        guard Date().distance(to: executionDate) > 0 else {
            reminderNextAlarmLabel.attributedTextClosure = {
                // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
                
                // Add extra spaces at the start and end so the text visually sits properly with its alternative background color and bordered edges
                return NSAttributedString(string: "  No More Time Left  ", attributes: [.font: nextAlarmHeaderFont])
            }
            return
        }
        
        let precalculatedDynamicIsSnoozing = reminder.snoozeComponents.executionInterval != nil
        let precalculatedDynamicText = Date().distance(to: executionDate).readable(capitalizeWords: true, abreviateWords: false)
        
        reminderNextAlarmLabel.attributedTextClosure = {
            // NOTE: ANY NON-STATIC VARIABLES, WHICH CAN CHANGE BASED UPON EXTERNAL FACTORS, MUST BE PRECALCULATED. This code is run everytime the UITraitCollection is updated. Therefore, all of this code is recalculated. If we have dynamic variable inside, the text, font, color... could change to something unexpected when the user simply updates their app to light/dark mode
            
            // Add extra spaces at the start and end so the text visually sits properly with its alternative background color and bordered edges
            let message = NSMutableAttributedString(
                string: precalculatedDynamicIsSnoozing ? "  Finish Snoozing In: " : "  Remind In: ",
                attributes: [.font: nextAlarmHeaderFont]
            )
            
            // Add extra spaces at the start and end so the text visually sits properly with its alternative background color and bordered edges
            message.append(NSAttributedString(string: "\(precalculatedDynamicText)  ", attributes: [.font: nextAlarmBodyFont]))
            
            return message
            
        }
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        selectionStyle = .none
        backgroundColor = .clear
        contentView.backgroundColor = .clear
        selectedBackgroundView?.backgroundColor = .clear
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerView)
        containerView.addSubview(reminderActionIconLabel)
        containerView.addSubview(reminderActionTextLabel)
        containerView.addSubview(reminderRecurranceLabel)
        containerView.addSubview(reminderTimeOfDayLabel)
        containerView.addSubview(reminderNextAlarmLabel)
        containerView.addSubview(chevonImageView)
        
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        reminderActionIconLabel.backgroundColor = .systemPink

        // reminderActionIconLabel
        let reminderActionIconLabelLeading = reminderActionIconLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 25)
        let reminderActionIconLabelWidth = reminderActionIconLabel.widthAnchor.constraint(equalToConstant: 50)
        let reminderActionIconLabelAspect = reminderActionIconLabel.widthAnchor.constraint(equalTo: reminderActionIconLabel.heightAnchor)
        reminderActionIconLabelAspect.priority = .defaultLow // Prefer breaking aspect ratio

        // reminderRecurranceLabel
        let reminderRecurranceLabelTop = reminderRecurranceLabel.topAnchor.constraint(equalTo: reminderActionIconLabel.topAnchor, constant: 5)
        let reminderRecurranceLabelTopToContainer = reminderRecurranceLabel.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 7.5)
        let reminderRecurranceLabelLeading = reminderRecurranceLabel.leadingAnchor.constraint(equalTo: reminderActionTextLabel.trailingAnchor, constant: 10)
        let reminderRecurranceLabelTrailing = reminderRecurranceLabel.trailingAnchor.constraint(equalTo: reminderTimeOfDayLabel.trailingAnchor)

        // reminderActionTextLabel
        let reminderActionTextLabelTop = reminderActionTextLabel.topAnchor.constraint(equalTo: reminderRecurranceLabel.topAnchor, constant: 2.5)
        let reminderActionTextLabelBottom = reminderActionTextLabel.bottomAnchor.constraint(equalTo: reminderTimeOfDayLabel.bottomAnchor, constant: -2.5)
        let reminderActionTextLabelLeading = reminderActionTextLabel.leadingAnchor.constraint(equalTo: reminderActionIconLabel.trailingAnchor, constant: 5)

        // reminderTimeOfDayLabel
        let reminderTimeOfDayLabelTop = reminderTimeOfDayLabel.topAnchor.constraint(equalTo: reminderRecurranceLabel.bottomAnchor)
        reminderTimeOfDayBottomConstraint = reminderTimeOfDayLabel.bottomAnchor.constraint(equalTo: reminderActionIconLabel.bottomAnchor, constant: reminderTimeOfDayBottomConstraintConstant)
        let reminderTimeOfDayLabelLeading = reminderTimeOfDayLabel.leadingAnchor.constraint(equalTo: reminderRecurranceLabel.leadingAnchor)
        let reminderTimeOfDayLabelHeight = reminderTimeOfDayLabel.heightAnchor.constraint(equalTo: reminderRecurranceLabel.heightAnchor)

        // reminderNextAlarmLabel
        let reminderNextAlarmLabelTop = reminderNextAlarmLabel.topAnchor.constraint(equalTo: reminderTimeOfDayLabel.bottomAnchor, constant: 5)
        let reminderNextAlarmLabelBottom = reminderNextAlarmLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -7.5)
        let reminderNextAlarmLabelLeading = reminderNextAlarmLabel.leadingAnchor.constraint(equalTo: reminderActionTextLabel.leadingAnchor)
        let reminderNextAlarmLabelTrailing = reminderNextAlarmLabel.trailingAnchor.constraint(equalTo: reminderRecurranceLabel.trailingAnchor)
        reminderNextAlarmHeightConstraint = reminderNextAlarmLabel.heightAnchor.constraint(equalToConstant: reminderNextAlarmHeightConstraintConstant)

        // chevonImageView
        let chevonImageViewLeading = chevonImageView.leadingAnchor.constraint(equalTo: reminderRecurranceLabel.trailingAnchor, constant: 15)
        let chevonImageViewTrailing = chevonImageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -15)
        let chevonImageViewCenterY = chevonImageView.centerYAnchor.constraint(equalTo: containerView.centerYAnchor)
        let chevonImageViewWidthToHeight = chevonImageView.widthAnchor.constraint(equalTo: chevonImageView.heightAnchor, multiplier: 1 / 1.5)
        let chevonImageViewHeight = chevonImageView.heightAnchor.constraint(equalTo: reminderActionTextLabel.heightAnchor, multiplier: 30 / 35)

        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: contentView.topAnchor)
        let containerViewBottom = containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let containerViewTrailing = containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)

        NSLayoutConstraint.activate([
            // reminderActionIconLabel
            reminderActionIconLabelLeading,
            reminderActionIconLabelWidth,
            reminderActionIconLabelAspect,

            // reminderRecurranceLabel
            reminderRecurranceLabelTop,
            reminderRecurranceLabelTopToContainer,
            reminderRecurranceLabelLeading,
            reminderRecurranceLabelTrailing,

            // reminderActionTextLabel
            reminderActionTextLabelTop,
            reminderActionTextLabelBottom,
            reminderActionTextLabelLeading,

            // reminderTimeOfDayLabel
            reminderTimeOfDayLabelTop,
            reminderTimeOfDayBottomConstraint,
            reminderTimeOfDayLabelLeading,
            reminderTimeOfDayLabelHeight,

            // reminderNextAlarmLabel
            reminderNextAlarmLabelTop,
            reminderNextAlarmLabelBottom,
            reminderNextAlarmLabelLeading,
            reminderNextAlarmLabelTrailing,
            reminderNextAlarmHeightConstraint,

            // chevonImageView
            chevonImageViewLeading,
            chevonImageViewTrailing,
            chevonImageViewCenterY,
            chevonImageViewWidthToHeight,
            chevonImageViewHeight,

            // containerView
            containerViewTop,
            containerViewBottom,
            containerViewLeading,
            containerViewTrailing
        ])
    }

}
//
//  DogsMainScreenTableViewCellDogDescription.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/11/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class DogsDogTVC: GeneralUITableViewCell {
    
    // MARK: - Elements
    
    let containerExtraBackgroundView: GeneralUIView = {
        // When the cell/containerView is rounded and there is a reminder below it, we dont want a weird lapse in color
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        view.isHidden = true
        return view
    }()
    
    let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBlue
        return view
    }()
    
    private let dogIconEdgeConstraintConstant = 12.5
    private weak var dogIconLeadingConstraint: NSLayoutConstraint!
    private weak var dogIconTrailingConstraint: NSLayoutConstraint!
    private weak var dogIconTopConstraint: NSLayoutConstraint!
    private weak var dogIconBottomConstraint: NSLayoutConstraint!
    private let dogIconWidthConstraintConstant: CGFloat = 55
    private weak var dogIconWidthConstraint: NSLayoutConstraint!
    private let dogIconImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView()
        
        imageView.image = UIImage(named: "whitePawWithHands")
        imageView.shouldRoundCorners = true
        
        return imageView
    }()
    
    private let dogNameLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.font = .systemFont(ofSize: 47.5, weight: .bold)
        label.textColor = .systemBackground
        return label
    }()
    
    private let chevonImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 290, compressionResistancePriority: 290)

        imageView.alpha = 0.75
        imageView.image = UIImage(systemName: "chevron.right")
        imageView.tintColor = .systemBackground
        
        return imageView
    }()
    
    // MARK: - Properties
    
    static let reuseIdentifier = "DogsDogTVC"
    
    var dog: Dog?
    
    // MARK: - Setup
    
    func setup(forDog: Dog) {
        self.dog = forDog
        
        dogIconImageView.image = forDog.dogIcon ?? (
            UITraitCollection.current.userInterfaceStyle == .dark
            ? ClassConstant.DogConstant.blackPawWithHands
            : ClassConstant.DogConstant.whitePawWithHands)
        dogIconImageView.shouldRoundCorners = forDog.dogIcon != nil
        
        // Make the dogIconImageView 5.0 wider if it has a dogIcon and not the placeholder
        dogIconWidthConstraint.constant = (dogIconWidthConstraint.constant) + (forDog.dogIcon == nil ? 0.0 : 5.0)
        
        // Counteract the expansion on the dogIconImageView with a contraction of these
        let constraintAdjustment = forDog.dogIcon == nil ? 0 : 2.5
        dogIconLeadingConstraint.constant = (dogIconEdgeConstraintConstant) - constraintAdjustment
        dogIconTrailingConstraint.constant = (dogIconEdgeConstraintConstant) - constraintAdjustment
        dogIconTopConstraint.constant = (dogIconEdgeConstraintConstant) - constraintAdjustment
        dogIconBottomConstraint.constant = (dogIconEdgeConstraintConstant) - constraintAdjustment
        
        // Dog Name Label Configuration
        dogNameLabel.text = forDog.dogName
    }
    
    // MARK: - Functions
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        
        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            dogIconImageView.image = dog?.dogIcon ?? (
                UITraitCollection.current.userInterfaceStyle == .dark
                ? ClassConstant.DogConstant.blackPawWithHands
                : ClassConstant.DogConstant.whitePawWithHands)
        }
    }
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        selectionStyle = .none
        backgroundColor = .clear
        contentView.backgroundColor = .clear
        selectedBackgroundView?.backgroundColor = .clear
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(containerExtraBackgroundView)
        contentView.addSubview(containerView)
        containerView.addSubview(dogIconImageView)
        containerView.addSubview(chevonImageView)
        containerView.addSubview(dogNameLabel)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // dogIconImageView
        dogIconLeadingConstraint = dogIconImageView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: dogIconEdgeConstraintConstant)
        dogIconTrailingConstraint = dogNameLabel.leadingAnchor.constraint(equalTo: dogIconImageView.trailingAnchor, constant: dogIconEdgeConstraintConstant)
        dogIconTopConstraint = dogIconImageView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: dogIconEdgeConstraintConstant)
        dogIconBottomConstraint = containerView.bottomAnchor.constraint(equalTo: dogIconImageView.bottomAnchor, constant: dogIconEdgeConstraintConstant)
        dogIconWidthConstraint = dogIconImageView.widthAnchor.constraint(equalToConstant: dogIconWidthConstraintConstant)
        let dogIconAspectRatioConstraint = dogIconImageView.widthAnchor.constraint(equalTo: dogIconImageView.heightAnchor)
        dogIconAspectRatioConstraint.priority = .defaultHigh
        
        // dogNameLabel
        let dogNameLabelCenterY = dogNameLabel.centerYAnchor.constraint(equalTo: containerView.centerYAnchor)
        let dogNameLabelHeight = dogNameLabel.heightAnchor.constraint(equalToConstant: 55)
        
        // chevonImageView
        let chevonImageViewLeading = chevonImageView.leadingAnchor.constraint(equalTo: dogNameLabel.trailingAnchor, constant: 15)
        let chevonImageViewTrailing = chevonImageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -15)
        let chevonImageViewCenterY = chevonImageView.centerYAnchor.constraint(equalTo: containerView.centerYAnchor)
        let chevonImageViewWidthToHeight = chevonImageView.widthAnchor.constraint(equalTo: chevonImageView.heightAnchor, multiplier: 1 / 1.5)
        let chevonImageViewWidthToNameHeight = chevonImageView.widthAnchor.constraint(equalTo: dogNameLabel.heightAnchor, multiplier: 20 / 55)
        chevonImageViewWidthToNameHeight.priority = .defaultHigh
        
        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: contentView.topAnchor)
        let containerViewBottom = containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let containerViewTrailing = containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        
        // containerExtraBackgroundView
        let containerExtraBackgroundViewTop = containerExtraBackgroundView.topAnchor.constraint(equalTo: containerView.centerYAnchor)
        let containerExtraBackgroundViewBottom = containerExtraBackgroundView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let containerExtraBackgroundViewLeading = containerExtraBackgroundView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor)
        let containerExtraBackgroundViewTrailing = containerExtraBackgroundView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        
        NSLayoutConstraint.activate([
            dogIconLeadingConstraint,
            dogIconTrailingConstraint,
            dogIconTopConstraint,
            dogIconBottomConstraint,
            dogIconWidthConstraint,
            dogIconAspectRatioConstraint,
            
            dogNameLabelCenterY,
            dogNameLabelHeight,
            
            chevonImageViewLeading,
            chevonImageViewTrailing,
            chevonImageViewCenterY,
            chevonImageViewWidthToHeight,
            chevonImageViewWidthToNameHeight,
            
            containerExtraBackgroundViewTop,
            containerExtraBackgroundViewBottom,
            containerExtraBackgroundViewLeading,
            containerExtraBackgroundViewTrailing,
            
            containerViewTop,
            containerViewBottom,
            containerViewLeading,
            containerViewTrailing
        ])
    }

}
//
//  DogsAddReminderWeeklyViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/28/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddReminderWeeklyViewControllerDelegate: AnyObject {
    func willDismissKeyboard()
}

final class DogsAddReminderWeeklyViewController: GeneralUIViewController {

    // MARK: - Elements

    private var interDayOfWeekConstraints: [NSLayoutConstraint]!

    private let sundayButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.setImage(UIImage(systemName: "s.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        button.tintColor = UIColor.systemGray4
        button.tag = VisualConstant.ViewTagConstant.weekdayDisabled
        
        return button
    }()

    private let mondayButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "m.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        button.tintColor = UIColor.systemGray4
        button.tag = VisualConstant.ViewTagConstant.weekdayDisabled
        
        return button
    }()

    private let tuesdayButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "t.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        button.tintColor = UIColor.systemGray4
        button.tag = VisualConstant.ViewTagConstant.weekdayDisabled
        
        return button
    }()

    private let wednesdayButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "w.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        button.tintColor = UIColor.systemGray4
        button.tag = VisualConstant.ViewTagConstant.weekdayDisabled
        
        return button
    }()

    private let thursdayButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "t.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        button.tintColor = UIColor.systemGray4
        button.tag = VisualConstant.ViewTagConstant.weekdayDisabled
        
        return button
    }()

    private let fridayButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "f.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        button.tintColor = UIColor.systemGray4
        button.tag = VisualConstant.ViewTagConstant.weekdayDisabled
        
        return button
    }()

    private let saturdayButton: GeneralUIButton = {
        let button = GeneralUIButton()
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "s.circle.fill"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        button.tintColor = UIColor.systemGray4
        button.tag = VisualConstant.ViewTagConstant.weekdayDisabled
        
        return button
    }()

    @objc private func didToggleWeekdayButton(_ sender: Any) {
        delegate?.willDismissKeyboard()

        guard let senderButton = sender as? GeneralUIButton else {
            return
        }
        var targetColor: UIColor!

        if senderButton.tag == VisualConstant.ViewTagConstant.weekdayEnabled {
            targetColor = UIColor.systemGray4
            senderButton.tag = VisualConstant.ViewTagConstant.weekdayDisabled
        }
        else {
            targetColor = UIColor.systemBlue
            senderButton.tag = VisualConstant.ViewTagConstant.weekdayEnabled
        }

        senderButton.isUserInteractionEnabled = false
        UIView.animate(withDuration: VisualConstant.AnimationConstant.toggleSelectUIElement) {
            senderButton.tintColor = targetColor
        } completion: { _ in
            senderButton.isUserInteractionEnabled = true
        }

    }

    private let timeOfDayDatePicker: GeneralUIDatePicker = {
        let datePicker = GeneralUIDatePicker(huggingPriority: 240, compressionResistancePriority: 240)
        datePicker.datePickerMode = .time
        datePicker.minuteInterval = DevelopmentConstant.reminderMinuteInterval
        datePicker.preferredDatePickerStyle = .wheels
       
        return datePicker
    }()

    @objc private func didUpdateTimeOfDay(_ sender: Any) {
        delegate?.willDismissKeyboard()
    }

    // MARK: - Properties

    private weak var delegate: DogsAddReminderWeeklyViewControllerDelegate?

    /// Converts enabled buttons to an array of day of weeks according to CalendarComponents.weekdays, 1 being sunday and 7 being saturday
    var currentWeekdays: [Int]? {
        var days: [Int] = []
        let dayOfWeekButtons = [sundayButton, mondayButton, tuesdayButton, wednesdayButton, thursdayButton, fridayButton, saturdayButton]

        for dayOfWeekIndex in 0..<dayOfWeekButtons.count where dayOfWeekButtons[dayOfWeekIndex].tag == VisualConstant.ViewTagConstant.weekdayEnabled {
            days.append(dayOfWeekIndex + 1)
        }

        if days.isEmpty == true {
            return nil
        }
        else {
            return days
        }
    }
    /// timeOfDayDatePicker.date
    var currentTimeOfDay: Date? {
        timeOfDayDatePicker.date
    }

    private var initialWeekdays: [Int] = [1, 2, 3, 4, 5, 6, 7]
    private var initialTimeOfDayDate: Date?
    var didUpdateInitialValues: Bool {
        if currentWeekdays != initialWeekdays {
            return true
        }
        if timeOfDayDatePicker.date != initialTimeOfDayDate {
            return true
        }

        return false
    }

    // MARK: - Main

    override func viewDidLoad() {
        super.viewDidLoad()

        // Make all the dayOfWeekButtons look enabled (if they are in the array)
        for dayOfWeek in initialWeekdays {
            switch dayOfWeek {
            case 1:
                sundayButton.tintColor = .systemBlue
                sundayButton.tag = VisualConstant.ViewTagConstant.weekdayEnabled
            case 2:
                mondayButton.tintColor = .systemBlue
                mondayButton.tag = VisualConstant.ViewTagConstant.weekdayEnabled
            case 3:
                tuesdayButton.tintColor = .systemBlue
                tuesdayButton.tag = VisualConstant.ViewTagConstant.weekdayEnabled
            case 4:
                wednesdayButton.tintColor = .systemBlue
                wednesdayButton.tag = VisualConstant.ViewTagConstant.weekdayEnabled
            case 5:
                thursdayButton.tintColor = .systemBlue
                thursdayButton.tag = VisualConstant.ViewTagConstant.weekdayEnabled
            case 6:
                fridayButton.tintColor = .systemBlue
                fridayButton.tag = VisualConstant.ViewTagConstant.weekdayEnabled
            case 7:
                saturdayButton.tintColor = .systemBlue
                saturdayButton.tag = VisualConstant.ViewTagConstant.weekdayEnabled
            default:
                break
            }
        }
        initialWeekdays = currentWeekdays ?? initialWeekdays

        timeOfDayDatePicker.date = initialTimeOfDayDate ?? Date.roundDate(targetDate: Date(), roundingInterval: Double(60 * timeOfDayDatePicker.minuteInterval), roundingMethod: .up)
        initialTimeOfDayDate = timeOfDayDatePicker.date

        // fix bug with datePicker value changed not triggering on first go
        DispatchQueue.main.asyncAfter(deadline: .now()) {
            self.timeOfDayDatePicker.date = self.timeOfDayDatePicker.date
        }
    }

    private var didSetupCustomSubviews: Bool = false
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        
        guard didSetupCustomSubviews == false else {
            return
        }

        didSetupCustomSubviews = true

        // TODO GPT What is the best way to this?
        for constraint in interDayOfWeekConstraints {
            // the distance between week day buttons should be 8 points on a 414 point screen, so this adjusts that ratio to fit any width of screen
            constraint.constant = (8.0 / 414.0) * self.view.safeAreaLayoutGuide.layoutFrame.width
        }
    }

    // MARK: - Setup

    func setup(forDelegate: DogsAddReminderWeeklyViewControllerDelegate, forTimeOfDay: Date?, forWeekdays: [Int]?) {
        delegate = forDelegate
        initialTimeOfDayDate = forTimeOfDay
        initialWeekdays = forWeekdays ?? initialWeekdays
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(timeOfDayDatePicker)
        timeOfDayDatePicker.addTarget(self, action: #selector(didUpdateTimeOfDay), for: .valueChanged)
        view.addSubview(sundayButton)
        sundayButton.addTarget(self, action: #selector(didToggleWeekdayButton), for: .touchUpInside)
        view.addSubview(mondayButton)
        mondayButton.addTarget(self, action: #selector(didToggleWeekdayButton), for: .touchUpInside)
        view.addSubview(tuesdayButton)
        tuesdayButton.addTarget(self, action: #selector(didToggleWeekdayButton), for: .touchUpInside)
        view.addSubview(wednesdayButton)
        wednesdayButton.addTarget(self, action: #selector(didToggleWeekdayButton), for: .touchUpInside)
        view.addSubview(thursdayButton)
        thursdayButton.addTarget(self, action: #selector(didToggleWeekdayButton), for: .touchUpInside)
        view.addSubview(fridayButton)
        fridayButton.addTarget(self, action: #selector(didToggleWeekdayButton), for: .touchUpInside)
        view.addSubview(saturdayButton)
        saturdayButton.addTarget(self, action: #selector(didToggleWeekdayButton), for: .touchUpInside)
        
    }

    override func setupConstraints() {
        super.setupConstraints()

        // sundayButton
        let sundayButtonTop = sundayButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 10)
        let sundayButtonBottomToWednesday = sundayButton.bottomAnchor.constraint(equalTo: wednesdayButton.bottomAnchor)
        let sundayButtonBottomToTuesday = sundayButton.bottomAnchor.constraint(equalTo: tuesdayButton.bottomAnchor)
        let sundayButtonBottomToMonday = sundayButton.bottomAnchor.constraint(equalTo: mondayButton.bottomAnchor)
        let sundayButtonBottomToSaturday = sundayButton.bottomAnchor.constraint(equalTo: saturdayButton.bottomAnchor)
        let sundayButtonBottomToFriday = sundayButton.bottomAnchor.constraint(equalTo: fridayButton.bottomAnchor)
        let sundayButtonBottomToThursday = sundayButton.bottomAnchor.constraint(equalTo: thursdayButton.bottomAnchor)
        let sundayButtonLeading = sundayButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let sundayButtonWidthToHeight = sundayButton.widthAnchor.constraint(equalTo: sundayButton.heightAnchor)

        // mondayButton
        let mondayButtonTop = mondayButton.topAnchor.constraint(equalTo: sundayButton.topAnchor)
        let mondayButtonWidthToHeight = mondayButton.widthAnchor.constraint(equalTo: mondayButton.heightAnchor)
        let mondayButtonWidthToSunday = mondayButton.widthAnchor.constraint(equalTo: sundayButton.widthAnchor)
        
        // tuesdayButton
        let tuesdayButtonTop = tuesdayButton.topAnchor.constraint(equalTo: sundayButton.topAnchor)
        let tuesdayButtonWidthToHeight = tuesdayButton.widthAnchor.constraint(equalTo: tuesdayButton.heightAnchor)
        let tuesdayButtonWidthToSunday = tuesdayButton.widthAnchor.constraint(equalTo: sundayButton.widthAnchor)

        // wednesdayButton
        let wednesdayButtonTop = wednesdayButton.topAnchor.constraint(equalTo: sundayButton.topAnchor)
        let wednesdayButtonWidthToHeight = wednesdayButton.widthAnchor.constraint(equalTo: wednesdayButton.heightAnchor)
        let wednesdayButtonWidthToSunday = wednesdayButton.widthAnchor.constraint(equalTo: sundayButton.widthAnchor)

        // thursdayButton
        let thursdayButtonTop = thursdayButton.topAnchor.constraint(equalTo: sundayButton.topAnchor)
        let thursdayButtonWidthToHeight = thursdayButton.widthAnchor.constraint(equalTo: thursdayButton.heightAnchor)
        let thursdayButtonWidthToSunday = thursdayButton.widthAnchor.constraint(equalTo: sundayButton.widthAnchor)

        // fridayButton
        let fridayButtonTop = fridayButton.topAnchor.constraint(equalTo: sundayButton.topAnchor)
        let fridayButtonWidthToHeight = fridayButton.widthAnchor.constraint(equalTo: fridayButton.heightAnchor)
        let fridayButtonWidthToSunday = fridayButton.widthAnchor.constraint(equalTo: sundayButton.widthAnchor)

        // saturdayButton
        let saturdayButtonTop = saturdayButton.topAnchor.constraint(equalTo: sundayButton.topAnchor)
        let saturdayButtonTrailing = saturdayButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)
        let saturdayButtonWidthToHeight = saturdayButton.widthAnchor.constraint(equalTo: saturdayButton.heightAnchor)
        let saturdayButtonWidthToSunday = saturdayButton.widthAnchor.constraint(equalTo: sundayButton.widthAnchor)
        
        // interDayOfWeekConstraints
        interDayOfWeekConstraints = [
            mondayButton.leadingAnchor.constraint(equalTo: sundayButton.trailingAnchor, constant: 8),
            tuesdayButton.leadingAnchor.constraint(equalTo: mondayButton.trailingAnchor, constant: 8),
            wednesdayButton.leadingAnchor.constraint(equalTo: tuesdayButton.trailingAnchor, constant: 8),
            thursdayButton.leadingAnchor.constraint(equalTo: wednesdayButton.trailingAnchor, constant: 8),
            fridayButton.leadingAnchor.constraint(equalTo: thursdayButton.trailingAnchor, constant: 8),
            saturdayButton.leadingAnchor.constraint(equalTo: fridayButton.trailingAnchor, constant: 8)
        ]

        // timeOfDayDatePicker
        let timeOfDayDatePickerTop = timeOfDayDatePicker.topAnchor.constraint(equalTo: sundayButton.bottomAnchor, constant: 10)
        let timeOfDayDatePickerBottom = timeOfDayDatePicker.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        let timeOfDayDatePickerLeading = timeOfDayDatePicker.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let timeOfDayDatePickerTrailing = timeOfDayDatePicker.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)

        NSLayoutConstraint.activate([
            // sundayButton
            sundayButtonTop,
            sundayButtonBottomToWednesday,
            sundayButtonBottomToTuesday,
            sundayButtonBottomToMonday,
            sundayButtonBottomToSaturday,
            sundayButtonBottomToFriday,
            sundayButtonBottomToThursday,
            sundayButtonLeading,
            sundayButtonWidthToHeight,

            // mondayButton
            mondayButtonTop,
            mondayButtonWidthToHeight,
            mondayButtonWidthToSunday,

            // tuesdayButton
            tuesdayButtonTop,
            tuesdayButtonWidthToHeight,
            tuesdayButtonWidthToSunday,

            // wednesdayButton
            wednesdayButtonTop,
            wednesdayButtonWidthToHeight,
            wednesdayButtonWidthToSunday,

            // thursdayButton
            thursdayButtonTop,
            thursdayButtonWidthToHeight,
            thursdayButtonWidthToSunday,

            // fridayButton
            fridayButtonTop,
            fridayButtonWidthToHeight,
            fridayButtonWidthToSunday,

            // saturdayButton
            saturdayButtonTop,
            saturdayButtonTrailing,
            saturdayButtonWidthToHeight,
            saturdayButtonWidthToSunday,

            // timeOfDayDatePicker
            timeOfDayDatePickerTop,
            timeOfDayDatePickerBottom,
            timeOfDayDatePickerLeading,
            timeOfDayDatePickerTrailing
        ] + interDayOfWeekConstraints)
    }

}
//
//  DogsAddReminderViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/26/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddReminderViewControllerDelegate: AnyObject {
    /// If a dogUUID is provided, then the reminder is added, updated, or deleted on the Hound server,
    /// and both a dogUUID and reminder is returned. If a dogUUID is not returned, the reminder has only
    /// been added, updated, or deleted locally.
    func didAddReminder(sender: Sender, forDogUUID: UUID?, forReminder: Reminder)
    func didUpdateReminder(sender: Sender, forDogUUID: UUID?, forReminder: Reminder)
    func didRemoveReminder(sender: Sender, forDogUUID: UUID?, forReminderUUID: UUID)
}

final class DogsAddReminderViewController: GeneralUIViewController {
    
    // MARK: - Elements
    
    private let pageTitleLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 320, compressionResistancePriority: 320)
        label.textAlignment = .center
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        label.textColor = .systemBlue
        return label
    }()
    
    private let saveReminderButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 260, compressionResistancePriority: 260)
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "checkmark.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        
        return button
    }()
    
    private let duplicateReminderButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 310, compressionResistancePriority: 310)
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "doc.on.doc"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        
        return button
    }()
    
    private let removeReminderButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 310, compressionResistancePriority: 310)
        
        button.tintColor = .systemBlue
        button.setImage(UIImage(systemName: "trash"), for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        
        return button
    }()
    
    private let backButton: GeneralUIButton = {
        let button = GeneralUIButton(huggingPriority: 260, compressionResistancePriority: 260)
        
        button.tintColor = .systemGray2
        button.setImage(UIImage(systemName: "arrow.backward.circle.fill"), for: .normal)
        button.setTitleColor(.systemBackground, for: .normal)
        button.backgroundCircleTintColor = .systemBackground
        
        return button
    }()
    
    private let dogsAddDogReminderManagerViewController: DogsAddDogReminderManagerViewController = {
        let vc = DogsAddDogReminderManagerViewController()
        return vc
    }()
    
    /// Container where DogsAddDogReminderManagerViewController will be embedded
    private let containerView: UIView = GeneralUIView()
    
    // MARK: - Properties
    
    private weak var delegate: DogsAddReminderViewControllerDelegate?
    
    private var reminderToUpdate: Reminder?
    private var reminderToUpdateDogUUID: UUID?
    
    /// Use this to track whether initial values changed, so we can confirm before dismissing
    private var didUpdateInitialValues: Bool {
        return dogsAddDogReminderManagerViewController.didUpdateInitialValues
    }
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.eligibleForGlobalPresenter = true
        
        // Configure white background, title text, and embedded child VC
        if reminderToUpdate == nil {
            pageTitleLabel.text = "Create Reminder"
            duplicateReminderButton.removeFromSuperview()
            removeReminderButton.removeFromSuperview()
        }
        else {
            pageTitleLabel.text = "Edit Reminder"
        }
        
        dogsAddDogReminderManagerViewController.setup(forReminderToUpdate: self.reminderToUpdate)
    }
    
    // MARK: - Setup
    
    func setup(
        forDelegate delegate: DogsAddReminderViewControllerDelegate,
        forReminderToUpdateDogUUID dogUUID: UUID?,
        forReminderToUpdate reminder: Reminder?
    ) {
        self.delegate = delegate
        self.reminderToUpdateDogUUID = dogUUID
        self.reminderToUpdate = reminder
    }
    
    // MARK: - Functions
    
    @objc private func didTouchUpInsideSaveReminder(_ sender: Any) {
        guard let reminder = dogsAddDogReminderManagerViewController.currentReminder else {
            return
        }
        
        // Persist custom action name locally
        LocalConfiguration.addReminderCustomAction(
            forReminderActionType: reminder.reminderActionType,
            forReminderCustomActionName: reminder.reminderCustomActionName
        )
        
        // If there's no dogUUID, notify delegate locally and dismiss
        guard let reminderToUpdateDogUUID = reminderToUpdateDogUUID else {
            if reminderToUpdate == nil {
                delegate?.didAddReminder(
                    sender: Sender(origin: self, localized: self),
                    forDogUUID: nil,
                    forReminder: reminder
                )
            }
            else {
                delegate?.didUpdateReminder(
                    sender: Sender(origin: self, localized: self),
                    forDogUUID: nil,
                    forReminder: reminder
                )
            }
            self.dismiss(animated: true)
            return
        }
        
        // Otherwise, call API to create/update on server
        toggleUserInteractionForSaving(isUserInteractionEnabled: false)
        saveReminderButton.beginSpinning()
        
        let completionHandler: (ResponseStatus, HoundError?) -> Void = { [weak self] responseStatus, _ in
            guard let self = self else { return }
            self.toggleUserInteractionForSaving(isUserInteractionEnabled: true)
            self.saveReminderButton.endSpinning()
            guard responseStatus != .failureResponse else { return }
            
            if self.reminderToUpdate != nil {
                self.delegate?.didUpdateReminder(
                    sender: Sender(origin: self, localized: self),
                    forDogUUID: reminderToUpdateDogUUID,
                    forReminder: reminder
                )
            }
            else {
                self.delegate?.didAddReminder(
                    sender: Sender(origin: self, localized: self),
                    forDogUUID: reminderToUpdateDogUUID,
                    forReminder: reminder
                )
            }
            self.dismiss(animated: true)
        }
        
        if reminderToUpdate != nil {
            RemindersRequest.update(
                forErrorAlert: .automaticallyAlertOnlyForFailure,
                forDogUUID: reminderToUpdateDogUUID,
                forReminders: [reminder],
                completionHandler: completionHandler
            )
        }
        else {
            RemindersRequest.create(
                forErrorAlert: .automaticallyAlertOnlyForFailure,
                forDogUUID: reminderToUpdateDogUUID,
                forReminders: [reminder],
                completionHandler: completionHandler
            )
        }
    }
    
    @objc private func didTouchUpInsideDuplicateReminder(_ sender: Any) {
        guard let duplicateReminder = dogsAddDogReminderManagerViewController.currentReminder?.duplicate() else {
            return
        }
        
        // If no dogUUID, notify delegate locally
        guard let reminderToUpdateDogUUID = reminderToUpdateDogUUID else {
            delegate?.didAddReminder(
                sender: Sender(origin: self, localized: self),
                forDogUUID: nil,
                forReminder: duplicateReminder
            )
            self.dismiss(animated: true)
            return
        }
        
        toggleUserInteractionForSaving(isUserInteractionEnabled: false)
        saveReminderButton.beginSpinning()
        
        RemindersRequest.create(
            forErrorAlert: .automaticallyAlertOnlyForFailure,
            forDogUUID: reminderToUpdateDogUUID,
            forReminders: [duplicateReminder]
        ) { [weak self] responseStatus, _ in
            guard let self = self else { return }
            self.toggleUserInteractionForSaving(isUserInteractionEnabled: true)
            self.saveReminderButton.endSpinning()
            guard responseStatus != .failureResponse else { return }
            
            self.delegate?.didAddReminder(
                sender: Sender(origin: self, localized: self),
                forDogUUID: reminderToUpdateDogUUID,
                forReminder: duplicateReminder
            )
            self.dismiss(animated: true)
        }
    }
    
    @objc private func didTouchUpInsideRemoveReminder(_ sender: Any) {
        guard let reminderToUpdate = reminderToUpdate else {
            return
        }
        guard let reminderToUpdateDogUUID = reminderToUpdateDogUUID else {
            delegate?.didRemoveReminder(
                sender: Sender(origin: self, localized: self),
                forDogUUID: nil,
                forReminderUUID: reminderToUpdate.reminderUUID
            )
            self.dismiss(animated: true)
            return
        }
        
        let actionName = dogsAddDogReminderManagerViewController
            .reminderActionTypeSelected?
            .convertToReadableName(customActionName: reminderToUpdate.reminderCustomActionName)
            ?? reminderToUpdate.reminderActionType.convertToReadableName(customActionName: reminderToUpdate.reminderCustomActionName)
        
        let alert = UIAlertController(
            title: "Are you sure you want to delete \(actionName)?",
            message: nil,
            preferredStyle: .alert
        )
        
        let deleteAction = UIAlertAction(title: "Delete", style: .destructive) { [weak self] _ in
            guard let self = self else { return }
            self.toggleUserInteractionForSaving(isUserInteractionEnabled: false)
            
            RemindersRequest.delete(
                forErrorAlert: .automaticallyAlertOnlyForFailure,
                forDogUUID: reminderToUpdateDogUUID,
                forReminderUUIDs: [reminderToUpdate.reminderUUID]
            ) { responseStatus, _ in
                self.toggleUserInteractionForSaving(isUserInteractionEnabled: true)
                guard responseStatus != .failureResponse else { return }
                
                self.delegate?.didRemoveReminder(
                    sender: Sender(origin: self, localized: self),
                    forDogUUID: reminderToUpdateDogUUID,
                    forReminderUUID: reminderToUpdate.reminderUUID
                )
                self.dismiss(animated: true)
            }
        }
        
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        alert.addAction(deleteAction)
        alert.addAction(cancelAction)
        PresentationManager.enqueueAlert(alert)
    }
    
    @objc private func didTouchUpInsideBack(_ sender: Any) {
        guard didUpdateInitialValues else {
            self.dismiss(animated: true)
            return
        }
        
        let alert = UIAlertController(
            title: "Are you sure you want to exit?",
            message: nil,
            preferredStyle: .alert
        )
        let exitAction = UIAlertAction(title: "Yes, I don't want to save changes", style: .default) { [weak self] _ in
            self?.dismiss(animated: true)
        }
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        alert.addAction(exitAction)
        alert.addAction(cancelAction)
        PresentationManager.enqueueAlert(alert)
    }
    
    /// Enables/disables the bottom buttons during network activity
    private func toggleUserInteractionForSaving(isUserInteractionEnabled: Bool) {
        duplicateReminderButton.isUserInteractionEnabled = isUserInteractionEnabled
        removeReminderButton.isUserInteractionEnabled = isUserInteractionEnabled
        saveReminderButton.isUserInteractionEnabled = isUserInteractionEnabled
        backButton.isUserInteractionEnabled = isUserInteractionEnabled
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(containerView)
        view.addSubview(saveReminderButton)
        view.addSubview(backButton)
        view.addSubview(pageTitleLabel)
        view.addSubview(removeReminderButton)
        view.addSubview(duplicateReminderButton)
        
        embedChild(dogsAddDogReminderManagerViewController)
        
        saveReminderButton.addTarget(self, action: #selector(didTouchUpInsideSaveReminder), for: .touchUpInside)
        backButton.addTarget(self, action: #selector(didTouchUpInsideBack), for: .touchUpInside)
        removeReminderButton.addTarget(self, action: #selector(didTouchUpInsideRemoveReminder), for: .touchUpInside)
        duplicateReminderButton.addTarget(self, action: #selector(didTouchUpInsideDuplicateReminder), for: .touchUpInside)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // saveReminderButton
        let saveReminderButtonBottom = saveReminderButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -10)
        let saveReminderButtonTrailing = saveReminderButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)
        let saveReminderButtonWidthToHeight = saveReminderButton.widthAnchor.constraint(equalTo: saveReminderButton.heightAnchor)
        let saveReminderButtonWidth = saveReminderButton.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 100.0 / 414.0)
        let saveReminderButtonHeightMin = saveReminderButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 50)
        let saveReminderButtonHeightMax = saveReminderButton.heightAnchor.constraint(lessThanOrEqualToConstant: 150)
        saveReminderButtonWidth.priority = .defaultHigh
        
        // backButton
        let backButtonBottom = backButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -10)
        let backButtonLeading = backButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let backButtonWidthToHeight = backButton.widthAnchor.constraint(equalTo: backButton.heightAnchor)
        let backButtonWidth = backButton.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 100.0 / 414.0)
        let backButtonHeightMin = backButton.heightAnchor.constraint(greaterThanOrEqualToConstant: 50)
        let backButtonHeightMax = backButton.heightAnchor.constraint(lessThanOrEqualToConstant: 150)
        backButtonWidth.priority = .defaultHigh
        
        // pageTitleLabel
        let pageTitleLabelTop = pageTitleLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 10)
        let pageTitleLabelCenterX = pageTitleLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor)
        let pageTitleLabelHeight = pageTitleLabel.heightAnchor.constraint(equalToConstant: 40)
        
        // duplicateReminderButton
        let duplicateReminderButtonCenterY = duplicateReminderButton.centerYAnchor.constraint(equalTo: pageTitleLabel.centerYAnchor)
        let duplicateReminderButtonLeading = duplicateReminderButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset)
        let duplicateReminderButtonWidthToHeight = duplicateReminderButton.widthAnchor.constraint(equalTo: duplicateReminderButton.heightAnchor)
        
        // removeReminderButton
        let removeReminderButtonCenterY = removeReminderButton.centerYAnchor.constraint(equalTo: pageTitleLabel.centerYAnchor)
        let removeReminderButtonTrailing = removeReminderButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        let removeReminderButtonWidthToHeight = removeReminderButton.widthAnchor.constraint(equalTo: removeReminderButton.heightAnchor)
        
        // dogsAddDogReminderManagerViewController.view
        let managerViewTop = dogsAddDogReminderManagerViewController.view.topAnchor.constraint(equalTo: containerView.topAnchor)
        let managerViewBottom = dogsAddDogReminderManagerViewController.view.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let managerViewLeading = dogsAddDogReminderManagerViewController.view.leadingAnchor.constraint(equalTo: containerView.leadingAnchor)
        let managerViewTrailing = dogsAddDogReminderManagerViewController.view.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)
        
        // containerView
        let containerViewTop = containerView.topAnchor.constraint(equalTo: pageTitleLabel.bottomAnchor, constant: 15)
        let containerViewLeading = containerView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor)
        let containerViewTrailing = containerView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor)
        let containerViewBottom = containerView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        
        NSLayoutConstraint.activate([
            // saveReminderButton
            saveReminderButtonBottom,
            saveReminderButtonTrailing,
            saveReminderButtonWidthToHeight,
            saveReminderButtonWidth,
            saveReminderButtonHeightMin,
            saveReminderButtonHeightMax,
            // backButton
            backButtonBottom,
            backButtonLeading,
            backButtonWidthToHeight,
            backButtonWidth,
            backButtonHeightMin,
            backButtonHeightMax,
            // pageTitleLabel
            pageTitleLabelTop,
            pageTitleLabelCenterX,
            pageTitleLabelHeight,
            // duplicateReminderButton
            duplicateReminderButtonCenterY,
            duplicateReminderButtonLeading,
            duplicateReminderButtonWidthToHeight,
            // removeReminderButton
            removeReminderButtonCenterY,
            removeReminderButtonTrailing,
            removeReminderButtonWidthToHeight,
            // dogsAddDogReminderManagerViewController.view
            managerViewTop,
            managerViewBottom,
            managerViewLeading,
            managerViewTrailing,
            // containerView
            containerViewTop,
            containerViewLeading,
            containerViewTrailing,
            containerViewBottom
        ])
    }

}
//
//  DogsAddReminderCountdownViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/28/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddReminderCountdownViewControllerDelegate: AnyObject {
    func willDismissKeyboard()
}

final class DogsAddReminderCountdownViewController: GeneralUIViewController {

    // MARK: - Elements

    private let countdownDatePicker: GeneralUIDatePicker = {
        let datePicker = GeneralUIDatePicker(huggingPriority: 240, compressionResistancePriority: 240)
        datePicker.datePickerMode = .countDownTimer
        return datePicker
    }()
    
    private let countdownDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "A recurring reminder sounds an alarm at countdown's end and then automatically restarts"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.textColor = .systemGray
        return label
    }()
    @objc private func didUpdateCountdown(_ sender: Any) {
        delegate?.willDismissKeyboard()
    }

    // MARK: - Properties

    private weak var delegate: DogsAddReminderCountdownViewControllerDelegate?

    /// countdownDatePicker.countDownDuration
    var currentCountdownDuration: Double? {
        countdownDatePicker.countDownDuration
    }

    private var initialCountdownDuration: Double?
    var didUpdateInitialValues: Bool {
        if countdownDatePicker.countDownDuration != initialCountdownDuration {
            return true
        }

        return false
    }

    // MARK: - Main

    override func viewDidLoad() {
        super.viewDidLoad()
        
        countdownDatePicker.minuteInterval = DevelopmentConstant.reminderMinuteInterval
        countdownDatePicker.countDownDuration = initialCountdownDuration ?? ClassConstant.ReminderComponentConstant.defaultCountdownExecutionInterval
        initialCountdownDuration = countdownDatePicker.countDownDuration

        // fix bug with datePicker value changed not triggering on first go
        DispatchQueue.main.asyncAfter(deadline: .now()) {
            self.countdownDatePicker.countDownDuration = self.countdownDatePicker.countDownDuration
        }
    }

    // MARK: - Setup

    func setup(forDelegate: DogsAddReminderCountdownViewControllerDelegate, forCountdownDuration: Double?) {
        delegate = forDelegate
        initialCountdownDuration = forCountdownDuration
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(countdownDatePicker)
        countdownDatePicker.addTarget(self, action: #selector(didUpdateCountdown), for: .editingChanged)
        countdownDatePicker.addTarget(self, action: #selector(didUpdateCountdown), for: .valueChanged)
        view.addSubview(countdownDescriptionLabel)
    }

    override func setupConstraints() {
        super.setupConstraints()

        // countdownDescriptionLabel
        let countdownDescriptionLabelTop = countdownDescriptionLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 10)
        let countdownDescriptionLabelLeading = countdownDescriptionLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let countdownDescriptionLabelTrailing = countdownDescriptionLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)

        // countdownDatePicker
        let countdownDatePickerTop = countdownDatePicker.topAnchor.constraint(equalTo: countdownDescriptionLabel.bottomAnchor, constant: 10)
        let countdownDatePickerBottom = countdownDatePicker.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        let countdownDatePickerLeading = countdownDatePicker.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let countdownDatePickerTrailing = countdownDatePicker.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)

        NSLayoutConstraint.activate([
            // countdownDescriptionLabel
            countdownDescriptionLabelTop,
            countdownDescriptionLabelLeading,
            countdownDescriptionLabelTrailing,

            // countdownDatePicker
            countdownDatePickerTop,
            countdownDatePickerBottom,
            countdownDatePickerLeading,
            countdownDatePickerTrailing
        ])
    }

}
//
//  DogsAddDogReminderManagerViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/28/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class DogsAddDogReminderManagerViewController: GeneralUIViewController, UITextFieldDelegate, UIGestureRecognizerDelegate, DogsAddReminderCountdownViewControllerDelegate, DogsAddReminderWeeklyViewControllerDelegate, DropDownUIViewDataSource, DogsAddReminderMonthlyViewControllerDelegate, DogsAddReminderOneTimeViewControllerDelegate {
    
    // MARK: - DogsAddReminderCountdownViewControllerDelegate and DogsAddReminderWeeklyViewControllerDelegate
    
    func willDismissKeyboard() {
        dismissKeyboard()
    }
    
    // MARK: - UIGestureRecognizerDelegate
    
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        true
    }
    
    // MARK: - UITextFieldDelegate
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        dismissKeyboard()
        return false
    }
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        
        // attempt to read the range they are trying to change
        guard let currentText = textField.text, let stringRange = Range(range, in: currentText) else {
            return true
        }
        
        // add their new text to the existing text
        let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
        
        // make sure the result is under reminderCustomActionNameCharacterLimit
        return updatedText.count <= ClassConstant.ReminderConstant.reminderCustomActionNameCharacterLimit
    }
    
    // MARK: - Elements
    
    private let containerView: GeneralUIView = {
        let view = GeneralUIView()
        view.backgroundColor = .systemBackground
        return view
    }()
    
    private let onceContainerView: GeneralUIView = GeneralUIView()
    private let countdownContainerView: GeneralUIView = GeneralUIView()
    private let weeklyContainerView: GeneralUIView = GeneralUIView()
    private let monthlyContainerView: GeneralUIView = GeneralUIView()
    
    private let reminderActionLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.borderWidth = 0.5
        label.borderColor = .systemGray2
        label.shouldRoundCorners = true
        return label
    }()
    
    private let reminderCustomActionNameHeightConstraintConstaint: CGFloat = 45
    private weak var reminderCustomActionNameHeightConstraint: NSLayoutConstraint!
    private let reminderCustomActionNameBottomConstraintConstant: CGFloat = 15
    private weak var reminderCustomActionNameBottomConstraint: NSLayoutConstraint!
    private let reminderCustomActionNameTextField: GeneralUITextField = {
        let textField = GeneralUITextField()
        
        textField.borderWidth = 0.5
        textField.borderColor = .systemGray2
        textField.shouldRoundCorners = true
        
        return textField
    }()
    
    private let reminderIsEnabledSwitch: GeneralUISwitch = {
        let uiSwitch = GeneralUISwitch()
        uiSwitch.isOn = true
        return uiSwitch
    }()
    
    private let reminderTypeSegmentedControl: UISegmentedControl = {
        let segmentedControl = UISegmentedControl()
        segmentedControl.contentMode = .scaleToFill
        segmentedControl.contentHorizontalAlignment = .left
        segmentedControl.contentVerticalAlignment = .top
        segmentedControl.apportionsSegmentWidthsByContent = true
        segmentedControl.selectedSegmentIndex = 1
        segmentedControl.translatesAutoresizingMaskIntoConstraints = false
        segmentedControl.selectedSegmentTintColor = .systemBlue
        
        return segmentedControl
    }()
    
    @objc private func didUpdateReminderType(_ sender: UISegmentedControl) {
        onceContainerView.isHidden = !(sender.selectedSegmentIndex == 0)
        countdownContainerView.isHidden = !(sender.selectedSegmentIndex == 1)
        weeklyContainerView.isHidden = !(sender.selectedSegmentIndex == 2)
        monthlyContainerView.isHidden = !(sender.selectedSegmentIndex == 3)
    }
    
    // MARK: - Properties
    
    private var dogsReminderOneTimeViewController: DogsAddReminderOneTimeViewController?
    private var dogsAddReminderCountdownViewController: DogsAddReminderCountdownViewController?
    private var dogsAddReminderWeeklyViewController: DogsAddReminderWeeklyViewController?
    private var dogsAddReminderMonthlyViewController: DogsAddReminderMonthlyViewController?
    
    private var reminderToUpdate: Reminder?
    private var initialReminderActionType: ReminderActionType!
    private var initialReminderCustomActionName: String?
    private var initialReminderIsEnabled: Bool!
    private var initialReminderTypeSegmentedControlIndex: Int!
    
    /// Given the reminderToUpdate provided, construct a new reminder or updates the one provided with the settings selected inside this view and its subviews. If there are invalid settings (e.g. no weekdays), an error message is sent to the user and nil is returned. If the reminder is valid, a reminder is returned that is ready to be sent to the server.
    var currentReminder: Reminder? {
        do {
            guard let reminderActionTypeSelected = reminderActionTypeSelected else {
                throw ErrorConstant.ReminderError.reminderActionMissing()
            }
            
            guard let reminder: Reminder = reminderToUpdate != nil ? reminderToUpdate?.copy() as? Reminder : Reminder() else {
                return nil
            }
            
            reminder.reminderActionTypeId = reminderActionTypeSelected.reminderActionTypeId
            
            if reminderActionTypeSelected.allowsCustom {
                // if the trimmedReminderCustomActionName is not "", meaning it has text, then we save it. Otherwise, the trimmedReminderCustomActionName is "" or nil so we save its value as nil
                reminder.reminderCustomActionName = reminderCustomActionNameTextField.text?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
            }
            reminder.reminderIsEnabled = reminderIsEnabledSwitch.isOn
            
            switch reminderTypeSegmentedControl.selectedSegmentIndex {
            case 0:
                reminder.changeReminderType(forReminderType: .oneTime)
                reminder.oneTimeComponents.oneTimeDate = dogsReminderOneTimeViewController?.oneTimeDate ?? reminder.oneTimeComponents.oneTimeDate
            case 1:
                reminder.changeReminderType(forReminderType: .countdown)
                reminder.countdownComponents.executionInterval = dogsAddReminderCountdownViewController?.currentCountdownDuration ?? reminder.countdownComponents.executionInterval
            case 2:
                guard let weekdays = dogsAddReminderWeeklyViewController?.currentWeekdays else {
                    throw ErrorConstant.WeeklyComponentsError.weekdayArrayInvalid()
                }
                
                reminder.changeReminderType(forReminderType: .weekly)
                
                try reminder.weeklyComponents.changeWeekdays(forWeekdays: weekdays)
                guard let date = dogsAddReminderWeeklyViewController?.currentTimeOfDay else {
                    break
                }
                reminder.weeklyComponents.changeUTCHour(forDate: date)
                reminder.weeklyComponents.changeUTCMinute(forDate: date)
            case 3:
                reminder.changeReminderType(forReminderType: .monthly)
                guard let date = dogsAddReminderMonthlyViewController?.currentTimeOfDay else {
                    break
                }
                reminder.monthlyComponents.changeUTCDay(forDate: date)
                reminder.monthlyComponents.changeUTCHour(forDate: date)
                reminder.monthlyComponents.changeUTCMinute(forDate: date)
            default: break
            }
            
            // Check if we are updating a reminder
            guard let reminderToUpdate = reminderToUpdate else {
                // Not updating an existing reminder, therefore created a reminder and prepare it for use
                reminder.resetForNextAlarm()
                return reminder
            }
            
            // Updating an existing reminder
            
            // Checks for differences in time of day, execution interval, weekdays, or time of month. If one is detected then we reset the reminder's whole timing to default
            // If you were 5 minutes in to a 1 hour countdown but then change it to 30 minutes, you would want to be 0 minutes into the new timer and not 5 minutes in like previously.
            switch reminder.reminderType {
            case .oneTime:
                // execution date changed
                if reminder.oneTimeComponents.oneTimeDate != reminderToUpdate.oneTimeComponents.oneTimeDate {
                    reminder.resetForNextAlarm()
                }
            case .countdown:
                // execution interval changed
                if reminder.countdownComponents.executionInterval != reminderToUpdate.countdownComponents.executionInterval {
                    reminder.resetForNextAlarm()
                }
            case .weekly:
                // time of day or weekdays changed
                if reminder.weeklyComponents.weekdays != reminderToUpdate.weeklyComponents.weekdays || reminder.weeklyComponents.UTCHour != reminderToUpdate.weeklyComponents.UTCHour || reminder.weeklyComponents.UTCMinute != reminderToUpdate.weeklyComponents.UTCMinute {
                    reminder.resetForNextAlarm()
                }
            case .monthly:
                // time of day or day of month changed
                if reminder.monthlyComponents.UTCDay != reminderToUpdate.monthlyComponents.UTCDay || reminder.monthlyComponents.UTCHour != reminderToUpdate.monthlyComponents.UTCHour || reminder.monthlyComponents.UTCMinute != reminderToUpdate.monthlyComponents.UTCMinute {
                    reminder.resetForNextAlarm()
                }
            }
            
            return reminder
        }
        catch {
            (error as? HoundError)?.alert() ?? ErrorConstant.UnknownError.unknown().alert()
            return nil
        }
    }
    var didUpdateInitialValues: Bool {
        if initialReminderActionType != reminderActionTypeSelected {
            return true
        }
        if reminderActionTypeSelected?.allowsCustom == true && initialReminderCustomActionName != reminderCustomActionNameTextField.text {
            return true
        }
        if initialReminderIsEnabled != reminderIsEnabledSwitch.isOn {
            return true
        }
        if initialReminderTypeSegmentedControlIndex != reminderTypeSegmentedControl.selectedSegmentIndex {
            return true
        }
        
        switch reminderTypeSegmentedControl.selectedSegmentIndex {
        case 0:
            return dogsReminderOneTimeViewController?.didUpdateInitialValues ?? false
        case 1:
            return dogsAddReminderCountdownViewController?.didUpdateInitialValues ?? false
        case 2:
            return dogsAddReminderWeeklyViewController?.didUpdateInitialValues ?? false
        case 3:
            return dogsAddReminderMonthlyViewController?.didUpdateInitialValues ?? false
        default:
            return false
        }
    }
    private(set) var reminderActionTypeSelected: ReminderActionType?
    
    private var reminderActionDropDown: DropDownUIView?
    private var dropDownSelectedIndexPath: IndexPath?
    
    // MARK: - Main
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Values
        if let reminderToUpdate = reminderToUpdate, let reminderActionIndex = GlobalTypes.shared.reminderActionTypes.firstIndex(of: reminderToUpdate.reminderActionType) {
            dropDownSelectedIndexPath = IndexPath(row: reminderActionIndex, section: 0)
            // this is for the label for the reminderActionType dropdown, so we only want the names to be the defaults. I.e. if our reminder is "Custom" with "someCustomActionName", the reminderActionLabel should only show "Custom" and then the logCustomActionNameTextField should be "someCustomActionName".
            reminderActionLabel.text = reminderToUpdate.reminderActionType.convertToReadableName(customActionName: nil)
        }
        else {
            reminderActionLabel.text = ""
        }
        
        reminderActionLabel.placeholder = "Select an action..."
        reminderActionTypeSelected = reminderToUpdate?.reminderActionType
        initialReminderActionType = reminderActionTypeSelected
        
        reminderCustomActionNameTextField.text = reminderToUpdate?.reminderCustomActionName
        initialReminderCustomActionName = reminderCustomActionNameTextField.text
        // This placeholder is dynamic, so its set elsewhere
        reminderCustomActionNameTextField.delegate = self
        
        reminderIsEnabledSwitch.isOn = reminderToUpdate?.reminderIsEnabled ?? ClassConstant.ReminderConstant.defaultReminderIsEnabled
        initialReminderIsEnabled = reminderIsEnabledSwitch.isOn
        
        // This should be called after all values are setup
        updateDynamicUIElements()
        
        // Gestures
        let dismissKeyboardAndDropDownTapGesture: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(dismissKeyboardAndDropDown))
        dismissKeyboardAndDropDownTapGesture.delegate = self
        dismissKeyboardAndDropDownTapGesture.cancelsTouchesInView = false
        containerView.addGestureRecognizer(dismissKeyboardAndDropDownTapGesture)
        
        reminderActionLabel.isUserInteractionEnabled = true
        let reminderActionTapGesture = UITapGestureRecognizer(target: self, action: #selector(reminderActionTapped))
        reminderActionTapGesture.delegate = self
        reminderActionTapGesture.cancelsTouchesInView = false
        reminderActionLabel.addGestureRecognizer(reminderActionTapGesture)
        
        // Segmented Control
        reminderTypeSegmentedControl.setTitleTextAttributes([.font: VisualConstant.FontConstant.emphasizedPrimaryRegularLabel], for: .normal)
        reminderTypeSegmentedControl.backgroundColor = .systemGray4
        
        onceContainerView.isHidden = true
        countdownContainerView.isHidden = true
        weeklyContainerView.isHidden = true
        monthlyContainerView.isHidden = true
        
        // editing current
        if let reminderToUpdate = reminderToUpdate {
            switch reminderToUpdate.reminderType {
            case .oneTime:
                reminderTypeSegmentedControl.selectedSegmentIndex = 0
                onceContainerView.isHidden = false
            case .countdown:
                reminderTypeSegmentedControl.selectedSegmentIndex = 1
                countdownContainerView.isHidden = false
            case .weekly:
                reminderTypeSegmentedControl.selectedSegmentIndex = 2
                weeklyContainerView.isHidden = false
            case .monthly:
                reminderTypeSegmentedControl.selectedSegmentIndex = 3
                monthlyContainerView.isHidden = false
            }
        }
        else {
            reminderTypeSegmentedControl.selectedSegmentIndex = 1
            countdownContainerView.isHidden = false
        }
        initialReminderTypeSegmentedControlIndex = reminderTypeSegmentedControl.selectedSegmentIndex
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        reminderActionDropDown?.hideDropDown(animated: false)
    }
    
    // MARK: - Setup
    
    func setup(forReminderToUpdate: Reminder?) {
        reminderToUpdate = forReminderToUpdate
    }
    
    // MARK: - Functions
    
    private func updateDynamicUIElements() {
        let reminderCustomActionNameIsHidden = reminderActionTypeSelected?.allowsCustom != true
        
        reminderCustomActionNameHeightConstraint.constant = reminderCustomActionNameIsHidden ? 0.0 : reminderCustomActionNameHeightConstraintConstaint
        reminderCustomActionNameBottomConstraint.constant = reminderCustomActionNameIsHidden ? 0.0 : reminderCustomActionNameBottomConstraintConstant
        reminderCustomActionNameTextField.isHidden = reminderCustomActionNameIsHidden
        
        reminderCustomActionNameTextField.placeholder = " Add a custom action name..."
        
        containerView.setNeedsLayout()
        containerView.layoutIfNeeded()
    }
    
    @objc private func reminderActionTapped() {
        dismissKeyboard()
        
        if reminderActionDropDown == nil {
            let dropDown = DropDownUIView()
            dropDown.setupDropDown(
                forDropDownUIViewIdentifier: "DROP_DOWN",
                forDataSource: self,
                forViewPositionReference: reminderActionLabel.frame,
                forOffset: 2.5,
                forRowHeight: DropDownUIView.rowHeightForGeneralUILabel
            )
            view.addSubview(dropDown)
            reminderActionDropDown = dropDown
        }
        
        reminderActionDropDown?.showDropDown(numberOfRowsToShow: 6.5, animated: true)
    }
    
    @objc override func dismissKeyboard() {
        super.dismissKeyboard()
        
        // DogsDogReminderManagerVC is embedded in DogsNestedReminderViewController which is embedded in UINavigationController which is embedded in DogsAddDogViewController.
        (self.parent?.parent?.parent as? DogsAddDogViewController)?.dismissKeyboard()
    }
    
    @objc private func dismissKeyboardAndDropDown() {
        dismissKeyboard()
        reminderActionDropDown?.hideDropDown(animated: true)
    }
    
    // MARK: - Drop Down Data Source
    
    func setupCellForDropDown(cell: UITableViewCell, indexPath: IndexPath, dropDownUIViewIdentifier: String) {
        guard let customCell = cell as? DropDownTVC else {
            return
        }
        customCell.adjustLeadingTrailing(newConstant: DropDownUIView.insetForGeneralUILabel)
        
        if dropDownSelectedIndexPath == indexPath {
            customCell.setCustomSelectedTableViewCell(forSelected: true)
        }
        else {
            customCell.setCustomSelectedTableViewCell(forSelected: false)
        }
        
        // inside of the predefined ReminderActionType
        if indexPath.row < GlobalTypes.shared.reminderActionTypes.count {
            customCell.label.text = GlobalTypes.shared.reminderActionTypes[indexPath.row].convertToReadableName(customActionName: nil)
        }
        // a user generated custom name
        else {
            let previousReminderCustomActionName = LocalConfiguration.localPreviousReminderCustomActionNames[indexPath.row - GlobalTypes.shared.reminderActionTypes.count]
            let reminderActionType = ReminderActionType.find(forReminderActionTypeId: previousReminderCustomActionName.reminderActionTypeId)
            customCell.label.text = reminderActionType.convertToReadableName(customActionName: previousReminderCustomActionName.reminderCustomActionName)
        }
    }
    
    func numberOfRows(forSection: Int, dropDownUIViewIdentifier: String) -> Int {
        GlobalTypes.shared.reminderActionTypes.count + LocalConfiguration.localPreviousReminderCustomActionNames.count
    }
    
    func numberOfSections(dropDownUIViewIdentifier: String) -> Int {
        1
    }
    
    func selectItemInDropDown(indexPath: IndexPath, dropDownUIViewIdentifier: String) {
        if let selectedCell = reminderActionDropDown?.dropDownTableView?.cellForRow(at: indexPath) as? DropDownTVC {
            selectedCell.setCustomSelectedTableViewCell(forSelected: true)
        }
        dropDownSelectedIndexPath = indexPath
        
        // inside of the predefined LogActionType
        if indexPath.row < GlobalTypes.shared.reminderActionTypes.count {
            reminderActionLabel.text = GlobalTypes.shared.reminderActionTypes[indexPath.row].convertToReadableName(customActionName: nil)
            reminderActionTypeSelected = GlobalTypes.shared.reminderActionTypes[indexPath.row]
        }
        // a user generated custom name
        else {
            let previousReminderCustomActionName = LocalConfiguration.localPreviousReminderCustomActionNames[indexPath.row - GlobalTypes.shared.reminderActionTypes.count]
            let previousReminderReminderActionType = ReminderActionType.find(forReminderActionTypeId: previousReminderCustomActionName.reminderActionTypeId)
            
            reminderActionLabel.text = previousReminderReminderActionType.convertToReadableName(customActionName: previousReminderCustomActionName.reminderCustomActionName)
            reminderActionTypeSelected = previousReminderReminderActionType
            reminderCustomActionNameTextField.text = previousReminderCustomActionName.reminderCustomActionName
        }
        
        dismissKeyboardAndDropDown()
        updateDynamicUIElements()
    }
    
    // MARK: - Navigation
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let dogsAddReminderCountdownViewController = segue.destination as?  DogsAddReminderCountdownViewController {
            self.dogsAddReminderCountdownViewController = dogsAddReminderCountdownViewController
            dogsAddReminderCountdownViewController.setup(forDelegate: self, forCountdownDuration: reminderToUpdate?.reminderType == .countdown ? reminderToUpdate?.countdownComponents.executionInterval : nil)
        }
        else if let dogsAddReminderWeeklyViewController = segue.destination as? DogsAddReminderWeeklyViewController {
            self.dogsAddReminderWeeklyViewController = dogsAddReminderWeeklyViewController
            let timeOfDay = reminderToUpdate?.reminderType == .weekly
            ? reminderToUpdate?.weeklyComponents.notSkippingExecutionDate(forReminderExecutionBasis: reminderToUpdate?.reminderExecutionBasis ?? Date())
            : nil
            let weekdays = reminderToUpdate?.reminderType == .weekly
            ? reminderToUpdate?.weeklyComponents.weekdays
            : nil
            
            dogsAddReminderWeeklyViewController.setup(forDelegate: self, forTimeOfDay: timeOfDay, forWeekdays: weekdays)
        }
        else if let dogsAddReminderMonthlyViewController = segue.destination as? DogsAddReminderMonthlyViewController {
            self.dogsAddReminderMonthlyViewController = dogsAddReminderMonthlyViewController
            let timeOfDay = reminderToUpdate?.reminderType == .monthly
            ? reminderToUpdate?.monthlyComponents.notSkippingExecutionDate(forReminderExecutionBasis: reminderToUpdate?.reminderExecutionBasis ?? Date())
            : nil
            
            dogsAddReminderMonthlyViewController.setup(forDelegate: self, forTimeOfDay: timeOfDay)
        }
        else if let dogsReminderOneTimeViewController = segue.destination as? DogsAddReminderOneTimeViewController {
            self.dogsReminderOneTimeViewController = dogsReminderOneTimeViewController
            let oneTimeDate = reminderToUpdate?.reminderType == .oneTime && Date().distance(to: reminderToUpdate?.oneTimeComponents.oneTimeDate ?? Date()) > 0
            ? reminderToUpdate?.oneTimeComponents.oneTimeDate
            : nil
            
            dogsReminderOneTimeViewController.setup(forDelegate: self, forOneTimeDate: oneTimeDate)
        }
        
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        view.addSubview(containerView)
        view.addSubview(reminderActionLabel)
        containerView.addSubview(onceContainerView)
        containerView.addSubview(reminderIsEnabledSwitch)
        containerView.addSubview(reminderTypeSegmentedControl)
        reminderTypeSegmentedControl.addTarget(self, action: #selector(didUpdateReminderType), for: .valueChanged)
        containerView.addSubview(countdownContainerView)
        containerView.addSubview(weeklyContainerView)
        containerView.addSubview(monthlyContainerView)
        containerView.addSubview(reminderCustomActionNameTextField)
        
    }
    
    override func setupConstraints() {
        super.setupConstraints()

        // reminderCustomActionNameTextField
        reminderCustomActionNameHeightConstraint = reminderCustomActionNameTextField.heightAnchor.constraint(equalToConstant: reminderCustomActionNameHeightConstraintConstaint)
        let reminderCustomActionNameTextFieldTop = reminderCustomActionNameTextField.topAnchor.constraint(equalTo: reminderActionLabel.bottomAnchor, constant: 15)
        let reminderCustomActionNameTextFieldLeading = reminderCustomActionNameTextField.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 10)
        let reminderCustomActionNameTextFieldTrailing = reminderCustomActionNameTextField.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -10)
        let reminderCustomActionNameTextFieldTrailingToSegmented = reminderCustomActionNameTextField.trailingAnchor.constraint(equalTo: reminderTypeSegmentedControl.trailingAnchor, constant: -2.5)

        // reminderCustomActionNameBottomConstraint (for segmented control positioning)
        reminderCustomActionNameBottomConstraint = reminderTypeSegmentedControl.topAnchor.constraint(equalTo: reminderCustomActionNameTextField.bottomAnchor, constant: reminderCustomActionNameBottomConstraintConstant)

        // reminderTypeSegmentedControl
        let reminderTypeSegmentedControlLeading = reminderTypeSegmentedControl.leadingAnchor.constraint(equalTo: reminderCustomActionNameTextField.leadingAnchor, constant: -2.5)
        let reminderTypeSegmentedControlHeight = reminderTypeSegmentedControl.heightAnchor.constraint(equalToConstant: 40)

        // weeklyContainerView
        let weeklyContainerViewTop = weeklyContainerView.topAnchor.constraint(equalTo: reminderTypeSegmentedControl.bottomAnchor)
        let weeklyContainerViewBottom = weeklyContainerView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let weeklyContainerViewLeading = weeklyContainerView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor)
        let weeklyContainerViewTrailing = weeklyContainerView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)

        // countdownContainerView
        let countdownContainerViewTop = countdownContainerView.topAnchor.constraint(equalTo: reminderTypeSegmentedControl.bottomAnchor)
        let countdownContainerViewBottom = countdownContainerView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let countdownContainerViewLeading = countdownContainerView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor)
        let countdownContainerViewTrailing = countdownContainerView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)

        // monthlyContainerView
        let monthlyContainerViewTop = monthlyContainerView.topAnchor.constraint(equalTo: reminderTypeSegmentedControl.bottomAnchor)
        let monthlyContainerViewBottom = monthlyContainerView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let monthlyContainerViewLeading = monthlyContainerView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor)
        let monthlyContainerViewTrailing = monthlyContainerView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)

        // onceContainerView
        let onceContainerViewTop = onceContainerView.topAnchor.constraint(equalTo: reminderTypeSegmentedControl.bottomAnchor)
        let onceContainerViewBottom = onceContainerView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        let onceContainerViewLeading = onceContainerView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor)
        let onceContainerViewTrailing = onceContainerView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor)

        // reminderIsEnabledSwitch
        let reminderIsEnabledSwitchLeading = reminderIsEnabledSwitch.leadingAnchor.constraint(equalTo: reminderActionLabel.trailingAnchor, constant: 15)
        let reminderIsEnabledSwitchTrailing = reminderIsEnabledSwitch.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -40)
        let reminderIsEnabledSwitchCenterY = reminderIsEnabledSwitch.centerYAnchor.constraint(equalTo: reminderActionLabel.centerYAnchor)

        // reminderActionLabel
        let reminderActionLabelTop = reminderActionLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 15)
        let reminderActionLabelLeading = reminderActionLabel.leadingAnchor.constraint(equalTo: reminderCustomActionNameTextField.leadingAnchor)
        let reminderActionLabelHeight = reminderActionLabel.heightAnchor.constraint(equalToConstant: 45)

        // containerView (to safeArea)
        let containerViewTop = view.safeAreaLayoutGuide.topAnchor.constraint(equalTo: containerView.topAnchor)
        let containerViewLeading = view.safeAreaLayoutGuide.leadingAnchor.constraint(equalTo: containerView.leadingAnchor)
        let containerViewBottom = containerView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        let containerViewTrailing = containerView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor)

        NSLayoutConstraint.activate([
            // reminderCustomActionNameTextField
            reminderCustomActionNameTextFieldTop,
            reminderCustomActionNameTextFieldLeading,
            reminderCustomActionNameTextFieldTrailing,
            reminderCustomActionNameTextFieldTrailingToSegmented,
            reminderCustomActionNameHeightConstraint,
            // reminderTypeSegmentedControl
            reminderCustomActionNameBottomConstraint,
            reminderTypeSegmentedControlLeading,
            reminderTypeSegmentedControlHeight,
            // weeklyContainerView
            weeklyContainerViewTop,
            weeklyContainerViewBottom,
            weeklyContainerViewLeading,
            weeklyContainerViewTrailing,
            // countdownContainerView
            countdownContainerViewTop,
            countdownContainerViewBottom,
            countdownContainerViewLeading,
            countdownContainerViewTrailing,
            // monthlyContainerView
            monthlyContainerViewTop,
            monthlyContainerViewBottom,
            monthlyContainerViewLeading,
            monthlyContainerViewTrailing,
            // onceContainerView
            onceContainerViewTop,
            onceContainerViewBottom,
            onceContainerViewLeading,
            onceContainerViewTrailing,
            // reminderIsEnabledSwitch
            reminderIsEnabledSwitchLeading,
            reminderIsEnabledSwitchTrailing,
            reminderIsEnabledSwitchCenterY,
            // reminderActionLabel
            reminderActionLabelTop,
            reminderActionLabelLeading,
            reminderActionLabelHeight,
            // containerView (safeArea)
            containerViewTop,
            containerViewLeading,
            containerViewBottom,
            containerViewTrailing
        ])
    }

}
//
//  DogsAddReminderMonthlyViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/13/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddReminderMonthlyViewControllerDelegate: AnyObject {
    func willDismissKeyboard()
}

final class DogsAddReminderMonthlyViewController: GeneralUIViewController {

    // MARK: - Elements

    private let timeOfDayDatePicker: GeneralUIDatePicker = {
        let datePicker = GeneralUIDatePicker(huggingPriority: 260, compressionResistancePriority: 260)
        datePicker.datePickerMode = .dateAndTime
        datePicker.preferredDatePickerStyle = .wheels
        datePicker.minuteInterval = DevelopmentConstant.reminderMinuteInterval
        
        return datePicker
    }()
    
    // MARK: - Additional UI Elements
    private let monthlyDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.text = "A monthly reminder sounds an alarm consistently on the same day each month"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.textColor = .systemGray
        
        return label
    }()

    @objc private func didUpdateTimeOfDay(_ sender: Any) {
        delegate?.willDismissKeyboard()
    }

    // MARK: - Properties

    private weak var delegate: DogsAddReminderMonthlyViewControllerDelegate?

    // timeOfDayDatePicker.date
    var currentTimeOfDay: Date? {
        timeOfDayDatePicker.date
    }

    private var initialTimeOfDay: Date?
    var didUpdateInitialValues: Bool {
        if currentTimeOfDay != initialTimeOfDay {
            return true
        }

        return currentTimeOfDay != initialTimeOfDay
    }

    // MARK: - Main

    override func viewDidLoad() {
        super.viewDidLoad()
        
        timeOfDayDatePicker.date = initialTimeOfDay ?? Date.roundDate(targetDate: Date(), roundingInterval: Double(60 * timeOfDayDatePicker.minuteInterval), roundingMethod: .up)
        initialTimeOfDay = timeOfDayDatePicker.date

        // fix bug with datePicker value changed not triggering on first go
        DispatchQueue.main.asyncAfter(deadline: .now()) {
            self.timeOfDayDatePicker.date = self.timeOfDayDatePicker.date
        }
    }

    // MARK: - Setup

    func setup(forDelegate: DogsAddReminderMonthlyViewControllerDelegate, forTimeOfDay: Date?) {
        delegate = forDelegate
        initialTimeOfDay = forTimeOfDay
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(timeOfDayDatePicker)
        timeOfDayDatePicker.addTarget(self, action: #selector(didUpdateTimeOfDay), for: .valueChanged)
        view.addSubview(monthlyDescriptionLabel)
        
    }

    override func setupConstraints() {
        super.setupConstraints()

        // timeOfDayDatePicker
        let timeOfDayDatePickerTop = timeOfDayDatePicker.topAnchor.constraint(equalTo: monthlyDescriptionLabel.bottomAnchor, constant: 10)
        let timeOfDayDatePickerBottom = timeOfDayDatePicker.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        let timeOfDayDatePickerLeading = timeOfDayDatePicker.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let timeOfDayDatePickerTrailing = timeOfDayDatePicker.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)

        // monthlyDescriptionLabel
        let monthlyDescriptionLabelTop = monthlyDescriptionLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 10)
        let monthlyDescriptionLabelLeading = monthlyDescriptionLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let monthlyDescriptionLabelTrailing = monthlyDescriptionLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)

        NSLayoutConstraint.activate([
            // timeOfDayDatePicker
            timeOfDayDatePickerTop,
            timeOfDayDatePickerBottom,
            timeOfDayDatePickerLeading,
            timeOfDayDatePickerTrailing,

            // monthlyDescriptionLabel
            monthlyDescriptionLabelTop,
            monthlyDescriptionLabelLeading,
            monthlyDescriptionLabelTrailing
        ])
    }

}
//
//  DogsAddReminderOneTimeViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/30/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogsAddReminderOneTimeViewControllerDelegate: AnyObject {
    func willDismissKeyboard()
}

final class DogsAddReminderOneTimeViewController: GeneralUIViewController {

    // MARK: - Elements

    private let oneTimeDatePicker: GeneralUIDatePicker = {
        let datePicker = GeneralUIDatePicker(huggingPriority: 240, compressionResistancePriority: 260)
        datePicker.datePickerMode = .dateAndTime
        datePicker.preferredDatePickerStyle = .wheels
        datePicker.minuteInterval = DevelopmentConstant.reminderMinuteInterval
        
        return datePicker
    }()
    
    private let oneTimeDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.text = "A single-use reminder sounds one alarm and then automatically deletes"
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.textColor = .systemGray
        return label
    }()

    @objc private func didUpdateOneTimeDatePicker(_ sender: Any) {
        delegate?.willDismissKeyboard()
    }

    // MARK: - Properties

    private weak var delegate: DogsAddReminderOneTimeViewControllerDelegate?

    var oneTimeDate: Date? {
        oneTimeDatePicker.date
    }

    private var initialOneTimeDate: Date?
    var didUpdateInitialValues: Bool {
        if oneTimeDate != initialOneTimeDate {
            return true
        }

        return oneTimeDate != initialOneTimeDate
    }

    // MARK: - Main

    override func viewDidLoad() {
        super.viewDidLoad()

        oneTimeDatePicker.date = initialOneTimeDate ?? Date.roundDate(targetDate: Date(), roundingInterval: Double(60 * oneTimeDatePicker.minuteInterval), roundingMethod: .up)
        initialOneTimeDate = oneTimeDatePicker.date

        // they can't choose a one time alarm that isn't in the future, otherwise there is no point
        oneTimeDatePicker.minimumDate = Date.roundDate(targetDate: Date(), roundingInterval: Double(60 * oneTimeDatePicker.minuteInterval), roundingMethod: .up)
        
        // fix bug with datePicker value changed not triggering on first go
        DispatchQueue.main.asyncAfter(deadline: .now()) {
            self.oneTimeDatePicker.date = self.oneTimeDatePicker.date
        }
    }

    // MARK: - Setup

    func setup(forDelegate: DogsAddReminderOneTimeViewControllerDelegate, forOneTimeDate: Date?) {
        delegate = forDelegate
        initialOneTimeDate = forOneTimeDate
    }

    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        view.backgroundColor = .systemBackground
        
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        view.addSubview(oneTimeDatePicker)
        oneTimeDatePicker.addTarget(self, action: #selector(didUpdateOneTimeDatePicker), for: .valueChanged)
        view.addSubview(oneTimeDescriptionLabel)
        
    }

    override func setupConstraints() {
        super.setupConstraints()
        
        // oneTimeDescriptionLabel
        let oneTimeDescriptionLabelTop = oneTimeDescriptionLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 10)
        let oneTimeDescriptionLabelLeading = oneTimeDescriptionLabel.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let oneTimeDescriptionLabelTrailing = oneTimeDescriptionLabel.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)

        // oneTimeDatePicker
        let oneTimeDatePickerTop = oneTimeDatePicker.topAnchor.constraint(equalTo: oneTimeDescriptionLabel.bottomAnchor)
        let oneTimeDatePickerBottom = oneTimeDatePicker.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        let oneTimeDatePickerLeading = oneTimeDatePicker.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 10)
        let oneTimeDatePickerTrailing = oneTimeDatePicker.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -10)
        
        NSLayoutConstraint.activate([
            // oneTimeDescriptionLabel
            oneTimeDescriptionLabelTop,
            oneTimeDescriptionLabelLeading,
            oneTimeDescriptionLabelTrailing,
            
            // oneTimeDatePicker
            oneTimeDatePickerTop,
            oneTimeDatePickerBottom,
            oneTimeDatePickerLeading,
            oneTimeDatePickerTrailing
        ])
    }

}
//
//  MappingLogActionTypeLogUnitType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class MappingLogActionTypeLogUnitType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: MappingLogActionTypeLogUnitType, rhs: MappingLogActionTypeLogUnitType) -> Bool {
        return lhs.mappingId < rhs.mappingId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? MappingLogActionTypeLogUnitType else {
            return false
        }
        return object.mappingId == self.mappingId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let mappingId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.mappingId.rawValue),
            let logActionTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.logActionTypeId.rawValue),
            let logUnitTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.logUnitTypeId.rawValue)
        else {
            return nil
        }
        self.init(
            forMappingId: mappingId,
            forLogActionTypeId: logActionTypeId,
            forLogUnitTypeId: logUnitTypeId
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(mappingId, forKey: KeyConstant.mappingId.rawValue)
        aCoder.encode(logActionTypeId, forKey: KeyConstant.logActionTypeId.rawValue)
        aCoder.encode(logUnitTypeId, forKey: KeyConstant.logUnitTypeId.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var mappingId: Int
    private(set) var logActionTypeId: Int
    private(set) var logUnitTypeId: Int
    
    // MARK: - Initialization
    
    init(
        forMappingId: Int,
        forLogActionTypeId: Int,
        forLogUnitTypeId: Int
    ) {
        self.mappingId = forMappingId
        self.logActionTypeId = forLogActionTypeId
        self.logUnitTypeId = forLogUnitTypeId
        super.init()
    }
    
    convenience init?(fromBody: [String: Any?]) {
        guard
            let mappingIdVal = fromBody[KeyConstant.mappingId.rawValue] as? Int,
            let logActionTypeIdVal = fromBody[KeyConstant.logActionTypeId.rawValue] as? Int,
            let logUnitTypeIdVal = fromBody[KeyConstant.logUnitTypeId.rawValue] as? Int
        else {
            return nil
        }
        
        self.init(
            forMappingId: mappingIdVal,
            forLogActionTypeId: logActionTypeIdVal,
            forLogUnitTypeId: logUnitTypeIdVal
        )
    }
}
//
//  ReminderActionType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class ReminderActionType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: ReminderActionType, rhs: ReminderActionType) -> Bool {
        if lhs.sortOrder != rhs.sortOrder {
            return lhs.sortOrder < rhs.sortOrder
        }
        return lhs.reminderActionTypeId < rhs.reminderActionTypeId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? ReminderActionType else {
            return false
        }
        return object.reminderActionTypeId == self.reminderActionTypeId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let decodedReminderActionTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.reminderActionTypeId.rawValue),
            let decodedInternalValue = aDecoder.decodeOptionalString(forKey: KeyConstant.internalValue.rawValue),
            let decodedReadableValue = aDecoder.decodeOptionalString(forKey: KeyConstant.readableValue.rawValue),
            let decodedEmoji = aDecoder.decodeOptionalString(forKey: KeyConstant.emoji.rawValue),
            let decodedSortOrder = aDecoder.decodeOptionalInteger(forKey: KeyConstant.sortOrder.rawValue),
            let decodedIsDefault = aDecoder.decodeOptionalBool(forKey: KeyConstant.isDefault.rawValue),
            let decodedAllowsCustom = aDecoder.decodeOptionalBool(forKey: KeyConstant.allowsCustom.rawValue)
        else {
            return nil
        }

        self.init(
            forReminderActionTypeId: decodedReminderActionTypeId,
            forInternalValue: decodedInternalValue,
            forReadableValue: decodedReadableValue,
            forEmoji: decodedEmoji,
            forSortOrder: decodedSortOrder,
            forIsDefault: decodedIsDefault,
            forAllowsCustom: decodedAllowsCustom
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(reminderActionTypeId, forKey: KeyConstant.reminderActionTypeId.rawValue)
        aCoder.encode(internalValue, forKey: KeyConstant.internalValue.rawValue)
        aCoder.encode(readableValue, forKey: KeyConstant.readableValue.rawValue)
        aCoder.encode(emoji, forKey: KeyConstant.emoji.rawValue)
        aCoder.encode(sortOrder, forKey: KeyConstant.sortOrder.rawValue)
        aCoder.encode(isDefault, forKey: KeyConstant.isDefault.rawValue)
        aCoder.encode(allowsCustom, forKey: KeyConstant.allowsCustom.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var reminderActionTypeId: Int
    private(set) var internalValue: String
    private(set) var readableValue: String
    private(set) var emoji: String
    private(set) var sortOrder: Int
    private(set) var isDefault: Bool
    private(set) var allowsCustom: Bool
    
    var associatedLogActionTypes: [LogActionType] {
        let matchingMappings = GlobalTypes.shared.mappingLogActionTypeReminderActionType.filter {
            $0.reminderActionTypeId == self.reminderActionTypeId
        }
        
        let logIds = matchingMappings.map { $0.logActionTypeId }
        
        let results = GlobalTypes.shared.logActionTypes.filter {
            logIds.contains($0.logActionTypeId)
        }
        
        // all reminder actions should map to at least one log action type
        if results.count < 1 {
            AppDelegate.generalLogger.warning("Expected to find >= 1 LogActionType for ReminderActionType \(self.reminderActionTypeId), but found \(results.count).")
            return []
        }
        
        return results
    }
    
    // MARK: - Initialization
    
    init(
        forReminderActionTypeId: Int,
        forInternalValue: String,
        forReadableValue: String,
        forEmoji: String,
        forSortOrder: Int,
        forIsDefault: Bool,
        forAllowsCustom: Bool
    ) {
        self.reminderActionTypeId = forReminderActionTypeId
        self.internalValue = forInternalValue
        self.readableValue = forReadableValue
        self.emoji = forEmoji
        self.sortOrder = forSortOrder
        self.isDefault = forIsDefault
        self.allowsCustom = forAllowsCustom
        super.init()
    }
    
    convenience init?(fromBody: [String: Any?]) {
        guard
            let idVal = fromBody[KeyConstant.reminderActionTypeId.rawValue] as? Int,
            let internalVal = fromBody[KeyConstant.internalValue.rawValue] as? String,
            let readableVal = fromBody[KeyConstant.readableValue.rawValue] as? String,
            let emojiVal = fromBody[KeyConstant.emoji.rawValue] as? String,
            let sortOrderVal = fromBody[KeyConstant.sortOrder.rawValue] as? Int,
            let isDefaultVal = fromBody[KeyConstant.isDefault.rawValue] as? Bool,
            let allowsCustomVal = fromBody[KeyConstant.allowsCustom.rawValue] as? Bool
        else {
            return nil
        }
        
        self.init(
            forReminderActionTypeId: idVal,
            forInternalValue: internalVal,
            forReadableValue: readableVal,
            forEmoji: emojiVal,
            forSortOrder: sortOrderVal,
            forIsDefault: isDefaultVal,
            forAllowsCustom: allowsCustomVal
        )
    }
    
    // MARK: - Readable Conversion
    
    static func find(forReminderActionTypeId: Int) -> ReminderActionType {
        return GlobalTypes.shared.reminderActionTypes.first { $0.reminderActionTypeId == forReminderActionTypeId } ?? GlobalTypes.shared.reminderActionTypes[0]
    }
    
    func convertToReadableName(
        customActionName: String?,
        includeMatchingEmoji: Bool = false,
    ) -> String {
        var result = ""
        
        if allowsCustom, let name = customActionName?.trimmingCharacters(in: .whitespacesAndNewlines), !name.isEmpty {
            result += name
        }
        else {
            result += readableValue
        }
        
        if includeMatchingEmoji {
            result += " " + emoji
        }
        
        return result
    }
}
//
//  MappingLogActionTypeReminderActionType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class MappingLogActionTypeReminderActionType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: MappingLogActionTypeReminderActionType, rhs: MappingLogActionTypeReminderActionType) -> Bool {
        return lhs.mappingId < rhs.mappingId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? MappingLogActionTypeReminderActionType else {
            return false
        }
        return object.mappingId == self.mappingId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let mappingId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.mappingId.rawValue),
            let logActionTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.logActionTypeId.rawValue),
            let reminderActionTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.reminderActionTypeId.rawValue)
        else {
            return nil
        }
        self.init(
            forMappingId: mappingId,
            forLogActionTypeId: logActionTypeId,
            forReminderActionTypeId: reminderActionTypeId
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(mappingId, forKey: KeyConstant.mappingId.rawValue)
        aCoder.encode(logActionTypeId, forKey: KeyConstant.logActionTypeId.rawValue)
        aCoder.encode(reminderActionTypeId, forKey: KeyConstant.reminderActionTypeId.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var mappingId: Int
    private(set) var logActionTypeId: Int
    private(set) var reminderActionTypeId: Int
    
    // MARK: - Initialization
    
    init(
        forMappingId: Int,
        forLogActionTypeId: Int,
        forReminderActionTypeId: Int
    ) {
        self.mappingId = forMappingId
        self.logActionTypeId = forLogActionTypeId
        self.reminderActionTypeId = forReminderActionTypeId
        super.init()
    }
    
    convenience init?(fromBody: [String: Any?]) {
        guard
            let mappingIdVal = fromBody[KeyConstant.mappingId.rawValue] as? Int,
            let logActionTypeIdVal = fromBody[KeyConstant.logActionTypeId.rawValue] as? Int,
            let reminderActionTypeIdVal = fromBody[KeyConstant.reminderActionTypeId.rawValue] as? Int
        else {
            return nil
        }
        
        self.init(
            forMappingId: mappingIdVal,
            forLogActionTypeId: logActionTypeIdVal,
            forReminderActionTypeId: reminderActionTypeIdVal
        )
    }
}
//
//  LogUnitType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/1/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class LogUnitType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: LogUnitType, rhs: LogUnitType) -> Bool {
        if lhs.sortOrder != rhs.sortOrder {
            return lhs.sortOrder < rhs.sortOrder
        }
        return lhs.logUnitTypeId < rhs.logUnitTypeId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? LogUnitType else {
            return false
        }
        return object.logUnitTypeId == self.logUnitTypeId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let logUnitTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.logUnitTypeId.rawValue),
            let unitSymbol = aDecoder.decodeOptionalString(forKey: KeyConstant.unitSymbol.rawValue),
            let readableValue = aDecoder.decodeOptionalString(forKey: KeyConstant.readableValue.rawValue),
            let isImperial = aDecoder.decodeOptionalBool(forKey: KeyConstant.isImperial.rawValue),
            let isMetric = aDecoder.decodeOptionalBool(forKey: KeyConstant.isMetric.rawValue),
            let isUnitMass = aDecoder.decodeOptionalBool(forKey: KeyConstant.isUnitMass.rawValue),
            let isUnitVolume = aDecoder.decodeOptionalBool(forKey: KeyConstant.isUnitVolume.rawValue),
            let isUnitLength = aDecoder.decodeOptionalBool(forKey: KeyConstant.isUnitLength.rawValue),
            let sortOrder = aDecoder.decodeOptionalInteger(forKey: KeyConstant.sortOrder.rawValue)
        else {
            return nil
        }
        
        self.init(
            forLogUnitTypeId: logUnitTypeId,
            forUnitSymbol: unitSymbol,
            forReadableValue: readableValue,
            forIsImperial: isImperial,
            forIsMetric: isMetric,
            forIsUnitMass: isUnitMass,
            forIsUnitVolume: isUnitVolume,
            forIsUnitLength: isUnitLength,
            forSortOrder: sortOrder
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(logUnitTypeId, forKey: KeyConstant.logUnitTypeId.rawValue)
        aCoder.encode(unitSymbol, forKey: KeyConstant.unitSymbol.rawValue)
        aCoder.encode(readableValue, forKey: KeyConstant.readableValue.rawValue)
        aCoder.encode(isImperial, forKey: KeyConstant.isImperial.rawValue)
        aCoder.encode(isMetric, forKey: KeyConstant.isMetric.rawValue)
        aCoder.encode(isUnitMass, forKey: KeyConstant.isUnitMass.rawValue)
        aCoder.encode(isUnitVolume, forKey: KeyConstant.isUnitVolume.rawValue)
        aCoder.encode(isUnitLength, forKey: KeyConstant.isUnitLength.rawValue)
        aCoder.encode(sortOrder, forKey: KeyConstant.sortOrder.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var logUnitTypeId: Int
    private(set) var unitSymbol: String
    private(set) var readableValue: String
    private(set) var isImperial: Bool
    private(set) var isMetric: Bool
    private(set) var isUnitMass: Bool
    private(set) var isUnitVolume: Bool
    private(set) var isUnitLength: Bool
    private(set) var sortOrder: Int
    
    // MARK: - Initialization
    
    init(
        forLogUnitTypeId: Int,
        forUnitSymbol: String,
        forReadableValue: String,
        forIsImperial: Bool,
        forIsMetric: Bool,
        forIsUnitMass: Bool,
        forIsUnitVolume: Bool,
        forIsUnitLength: Bool,
        forSortOrder: Int
    ) {
        self.logUnitTypeId = forLogUnitTypeId
        self.unitSymbol = forUnitSymbol
        self.readableValue = forReadableValue
        self.isImperial = forIsImperial
        self.isMetric = forIsMetric
        self.isUnitMass = forIsUnitMass
        self.isUnitVolume = forIsUnitVolume
        self.isUnitLength = forIsUnitLength
        self.sortOrder = forSortOrder
        super.init()
    }
    
    convenience init?(fromBody: [String: Any?]) {
        guard
            let idVal = fromBody[KeyConstant.logUnitTypeId.rawValue] as? Int,
            let symbolVal = fromBody[KeyConstant.unitSymbol.rawValue] as? String,
            let readableVal = fromBody[KeyConstant.readableValue.rawValue] as? String,
            let isImperialVal = fromBody[KeyConstant.isImperial.rawValue] as? Bool,
            let isMetricVal = fromBody[KeyConstant.isMetric.rawValue] as? Bool,
            let isMassVal = fromBody[KeyConstant.isUnitMass.rawValue] as? Bool,
            let isVolumeVal = fromBody[KeyConstant.isUnitVolume.rawValue] as? Bool,
            let isLengthVal = fromBody[KeyConstant.isUnitLength.rawValue] as? Bool,
            let sortOrderVal = fromBody[KeyConstant.sortOrder.rawValue] as? Int
        else {
            return nil
        }
        
        self.init(
            forLogUnitTypeId: idVal,
            forUnitSymbol: symbolVal,
            forReadableValue: readableVal,
            forIsImperial: isImperialVal,
            forIsMetric: isMetricVal,
            forIsUnitMass: isMassVal,
            forIsUnitVolume: isVolumeVal,
            forIsUnitLength: isLengthVal,
            forSortOrder: sortOrderVal
        )
    }
    
    // MARK: - Functions
    
    static func find(forLogUnitTypeId: Int) -> LogUnitType {
        return GlobalTypes.shared.logUnitTypes.first { $0.logUnitTypeId == forLogUnitTypeId } ?? GlobalTypes.shared.logUnitTypes[0]
    }
    
    /// Produces a logNumberOfLogUnits that is more readable to the user. We accomplish this by rounding the double to two decimal places. Additionally, the decimal separator is varied based on locale (e.g. period in U.S.)
    static func convertDoubleToRoundedString(forLogNumberOfLogUnits logNumberOfLogUnits: Double?) -> String? {
        guard let logNumberOfLogUnits = logNumberOfLogUnits, logNumberOfLogUnits >= 0.01 else {
            // If logNumberOfLogUnits isn't greater than 0.01, we have nothing to display, return nil
            return nil
        }
        
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.locale = Locale.current
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 2
        
        return formatter.string(from: logNumberOfLogUnits as NSNumber)
    }
    
    static func convertStringToDouble(forLogNumberOfLogUnits logNumberOfLogUnits: String?) -> Double? {
        guard let logNumberOfLogUnits = logNumberOfLogUnits else {
            return nil
        }
        
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.locale = Locale.current
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 2
        let doubleValue = formatter.number(from: logNumberOfLogUnits)?.doubleValue
        
        // If logNumberOfLogUnits isn't greater than 0.01, we have nothing to display, return nil
        return (doubleValue ?? 0.0) >= 0.01 ? doubleValue : nil
    }
    
    /// Produces a logUnitType that is more readable to the user. We accomplish this by changing the plurality of a log unit if needed : "cup" -> "cups" (changed needed if numberOfUnits != 1); "g" -> "g" (no change needed ever).
    func convertDoubleToPluralityString(forLogNumberOfLogUnits: Double?) -> String? {
        let logNumberOfLogUnits = forLogNumberOfLogUnits ?? 0.0
        
        return (abs(logNumberOfLogUnits - 1.0) < 0.0001) ? self.readableValue : self.readableValue.appending("s")
    }
    
    /// Produces a logUnitType and logNumberOfLogUnits that is more readable to the user. Converts the unit and value of units into the correct system.For example: .cup, 1.5 -> "1.5 cups"; .g, 1.0 -> "1g"
    func convertedMeasurementString(forLogNumberOfLogUnits: Double, toTargetSystem: MeasurementSystem) -> String? {
        let (convertedLogUnit, convertedLogNumberOfLogUnits) = LogUnitTypeConverter.convert(forLogUnitType: self, forNumberOfLogUnits: forLogNumberOfLogUnits, toTargetSystem: toTargetSystem)
        
        // Take our raw values and convert them to something more readable
        let convertDoubleToPluralityString = convertedLogUnit.convertDoubleToPluralityString(forLogNumberOfLogUnits: convertedLogNumberOfLogUnits)
        let readableIndividualLogNumberOfLogUnits = LogUnitType.convertDoubleToRoundedString(forLogNumberOfLogUnits: convertedLogNumberOfLogUnits)
        
        guard let convertDoubleToPluralityString = convertDoubleToPluralityString, let readableIndividualLogNumberOfLogUnits = readableIndividualLogNumberOfLogUnits else {
            // If we reach this point it likely measure that readableIndividualLogNumberOfLogUnits was < 0.01, which would wouldn't be displayed, so nil was returned
            return nil
        }
        
        return "\(readableIndividualLogNumberOfLogUnits) \(convertDoubleToPluralityString)"
    }
}
//
//  GlobalTypes.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class GlobalTypes: NSObject, NSCoding, UserDefaultPersistable {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let logActionTypes: [LogActionType] = aDecoder.decodeOptionalObject(forKey: KeyConstant.logActionType.rawValue),
            let reminderActionTypes: [ReminderActionType] = aDecoder.decodeOptionalObject(forKey: KeyConstant.reminderActionType.rawValue),
            let mappingLogActionTypeReminderActionType: [MappingLogActionTypeReminderActionType] = aDecoder.decodeOptionalObject(forKey: KeyConstant.mappingLogActionTypeReminderActionType.rawValue),
            let logUnitTypes: [LogUnitType] = aDecoder.decodeOptionalObject(forKey: KeyConstant.logUnitType.rawValue),
            let mappingLogActionTypeLogUnitType: [MappingLogActionTypeLogUnitType] = aDecoder.decodeOptionalObject(forKey: KeyConstant.mappingLogActionTypeLogUnitType.rawValue)
        else {
            return nil
        }
        self.init(
            forLogActionTypes: logActionTypes,
            forReminderActionTypes: reminderActionTypes,
            forMappingLogActionTypeReminderActionType: mappingLogActionTypeReminderActionType,
            forLogUnitTypes: logUnitTypes,
            forMappingLogActionTypeLogUnitType: mappingLogActionTypeLogUnitType
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(logActionTypes, forKey: KeyConstant.logActionType.rawValue)
        aCoder.encode(reminderActionTypes, forKey: KeyConstant.reminderActionType.rawValue)
        aCoder.encode(mappingLogActionTypeReminderActionType, forKey: KeyConstant.mappingLogActionTypeReminderActionType.rawValue)
        aCoder.encode(logUnitTypes, forKey: KeyConstant.logUnitType.rawValue)
        aCoder.encode(mappingLogActionTypeLogUnitType, forKey: KeyConstant.mappingLogActionTypeLogUnitType.rawValue)
    }
    
    // MARK: - UserDefaultPersistable
    
    /// Persists all of the LocalConfiguration variables and the globalGlobalTypes to the specified UserDefaults
    static func persist(toUserDefaults: UserDefaults) {
        guard let globalTypes = GlobalTypes.shared else {
            AppDelegate.generalLogger.error("GlobalTypes.shared is nil, cannot persist to UserDefaults")
            return
        }
        
        do {
            let dataGlobalTypes = try NSKeyedArchiver.archivedData(withRootObject: globalTypes, requiringSecureCoding: false)
            toUserDefaults.set(dataGlobalTypes, forKey: KeyConstant.globalTypes.rawValue)
        }
        catch {
            AppDelegate.generalLogger.error("Failed to persist globalTypes with NSKeyedArchiver: \(error)")
        }
    }
    
    /// Load all of the LocalConfiguration variables and the globalGlobalTypes from the specified UserDefaults
    static func load(fromUserDefaults: UserDefaults) {
        guard let dataGlobalTypes = fromUserDefaults.data(forKey: KeyConstant.globalTypes.rawValue) else {
            AppDelegate.generalLogger.error("No data found for globalTypes in UserDefaults")
            GlobalTypes.shared = nil
            return
        }
        do {
            let unarchiver = try NSKeyedUnarchiver(forReadingFrom: dataGlobalTypes)
            unarchiver.requiresSecureCoding = false
            if let globalTypes = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? GlobalTypes {
                GlobalTypes.shared = globalTypes
            }
            else {
                AppDelegate.generalLogger.error("Failed to decode globalTypes with unarchiver")
                GlobalTypes.shared = nil
                // clear dogManager and previousDogManagerSynchronization as if those try to init without global types, the app will crash
                // client needs to fetch global types from server
                UserDefaults.standard.set(nil, forKey: KeyConstant.previousDogManagerSynchronization.rawValue)
                UserDefaults.standard.set(nil, forKey: KeyConstant.dogManager.rawValue)
            }
        }
        catch {
            AppDelegate.generalLogger.error("Failed to unarchive globalTypes: \(error)")
            GlobalTypes.shared = nil
            // clear dogManager and previousDogManagerSynchronization as if those try to init without global types, the app will crash
            // client needs to fetch global types from server
            UserDefaults.standard.set(nil, forKey: KeyConstant.previousDogManagerSynchronization.rawValue)
            UserDefaults.standard.set(nil, forKey: KeyConstant.dogManager.rawValue)
        }
    }
    
    // MARK: - Properties
    
    private(set) var logActionTypes: [LogActionType]
    private(set) var reminderActionTypes: [ReminderActionType]
    private(set) var mappingLogActionTypeReminderActionType: [MappingLogActionTypeReminderActionType]
    private(set) var logUnitTypes: [LogUnitType]
    private(set) var mappingLogActionTypeLogUnitType: [MappingLogActionTypeLogUnitType]
    
    // TODO RT save a version of this so that the app can open from complete close. attempt to fetch updated GT when app launches but if not just use persisted version
    static var shared: GlobalTypes!
    
    // MARK: - Initialization
    
    init(
        forLogActionTypes: [LogActionType],
        forReminderActionTypes: [ReminderActionType],
        forMappingLogActionTypeReminderActionType: [MappingLogActionTypeReminderActionType],
        forLogUnitTypes: [LogUnitType],
        forMappingLogActionTypeLogUnitType: [MappingLogActionTypeLogUnitType]
    ) {
        self.logActionTypes = forLogActionTypes.sorted()
        self.reminderActionTypes = forReminderActionTypes.sorted()
        self.mappingLogActionTypeReminderActionType = forMappingLogActionTypeReminderActionType.sorted()
        self.logUnitTypes = forLogUnitTypes.sorted()
        self.mappingLogActionTypeLogUnitType = forMappingLogActionTypeLogUnitType.sorted()
        if logActionTypes.isEmpty {
            AppDelegate.generalLogger.error("logActionTypes is empty for GlobalTypes")
        }
        if reminderActionTypes.isEmpty {
            AppDelegate.generalLogger.error("reminderActionTypes is empty for GlobalTypes")
        }
        if mappingLogActionTypeReminderActionType.isEmpty {
            AppDelegate.generalLogger.error("mappingLogActionTypeReminderActionType is empty for GlobalTypes")
        }
        if logUnitTypes.isEmpty {
            AppDelegate.generalLogger.error("logUnitTypes is empty for GlobalTypes")
        }
        if mappingLogActionTypeLogUnitType.isEmpty {
            AppDelegate.generalLogger.error("mappingLogActionTypeLogUnitType is empty for GlobalTypes")
        }
        super.init()
    }
    
    convenience init?(fromBody: [String: Any?]) {
        guard
            let logActionTypeArr = fromBody[KeyConstant.logActionType.rawValue] as? [[String: Any?]],
            let reminderActionTypeArr = fromBody[KeyConstant.reminderActionType.rawValue] as? [[String: Any?]],
            let mappingLogActionTypeReminderActionTypeArr = fromBody[KeyConstant.mappingLogActionTypeReminderActionType.rawValue] as? [[String: Any?]],
            let logUnitTypesArr = fromBody[KeyConstant.logUnitType.rawValue] as? [[String: Any?]],
            let mappingLogActionTypeLogUnitTypeArr = fromBody[KeyConstant.mappingLogActionTypeLogUnitType.rawValue] as? [[String: Any?]]
        else {
            AppDelegate.generalLogger.error("Unable to decode types for GlobalTypes. fromBody is as follows \(fromBody)")
            return nil
        }
        
        let latMapped = logActionTypeArr.compactMap { LogActionType(fromBody: $0) }
        let ratMapped = reminderActionTypeArr.compactMap { ReminderActionType(fromBody: $0) }
        let mlatratMapped = mappingLogActionTypeReminderActionTypeArr.compactMap { MappingLogActionTypeReminderActionType(fromBody: $0) }
        let lutMapped = logUnitTypesArr.compactMap { LogUnitType(fromBody: $0) }
        let mlatlutMapped = mappingLogActionTypeLogUnitTypeArr.compactMap { MappingLogActionTypeLogUnitType(fromBody: $0) }
        
        self.init(
            forLogActionTypes: latMapped,
            forReminderActionTypes: ratMapped,
            forMappingLogActionTypeReminderActionType: mlatratMapped,
            forLogUnitTypes: lutMapped,
            forMappingLogActionTypeLogUnitType: mlatlutMapped
        )
    }
}
//
//  LogActionType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 06/01/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class LogActionType: NSObject, Comparable, NSCoding {
    
    // MARK: - Comparable
    
    static func < (lhs: LogActionType, rhs: LogActionType) -> Bool {
        if lhs.sortOrder != rhs.sortOrder {
            return lhs.sortOrder < rhs.sortOrder
        }
        return lhs.logActionTypeId < rhs.logActionTypeId
    }
    
    override func isEqual(_ object: Any?) -> Bool {
        guard let object = object as? LogActionType else {
            return false
        }
        return object.logActionTypeId == self.logActionTypeId
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let decodedLogActionTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.logActionTypeId.rawValue),
            let decodedInternalValue = aDecoder.decodeOptionalString(forKey: KeyConstant.internalValue.rawValue),
            let decodedReadableValue = aDecoder.decodeOptionalString(forKey: KeyConstant.readableValue.rawValue),
            let decodedEmoji = aDecoder.decodeOptionalString(forKey: KeyConstant.emoji.rawValue),
            let decodedSortOrder = aDecoder.decodeOptionalInteger(forKey: KeyConstant.sortOrder.rawValue),
            let decodedIsDefault = aDecoder.decodeOptionalBool(forKey: KeyConstant.isDefault.rawValue),
            let decodedAllowsCustom = aDecoder.decodeOptionalBool(forKey: KeyConstant.allowsCustom.rawValue)
        else {
            return nil
        }
        
        self.init(
            forLogActionTypeId: decodedLogActionTypeId,
            forInternalValue: decodedInternalValue,
            forReadableValue: decodedReadableValue,
            forEmoji: decodedEmoji,
            forSortOrder: decodedSortOrder,
            forIsDefault: decodedIsDefault,
            forAllowsCustom: decodedAllowsCustom
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(logActionTypeId, forKey: KeyConstant.logActionTypeId.rawValue)
        aCoder.encode(internalValue, forKey: KeyConstant.internalValue.rawValue)
        aCoder.encode(readableValue, forKey: KeyConstant.readableValue.rawValue)
        aCoder.encode(emoji, forKey: KeyConstant.emoji.rawValue)
        aCoder.encode(sortOrder, forKey: KeyConstant.sortOrder.rawValue)
        aCoder.encode(isDefault, forKey: KeyConstant.isDefault.rawValue)
        aCoder.encode(allowsCustom, forKey: KeyConstant.allowsCustom.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var logActionTypeId: Int
    private(set) var internalValue: String
    private(set) var readableValue: String
    private(set) var emoji: String
    private(set) var sortOrder: Int
    private(set) var isDefault: Bool
    private(set) var allowsCustom: Bool
    
    var associatedReminderActionType: ReminderActionType {
        let matchingMappings = GlobalTypes.shared.mappingLogActionTypeReminderActionType.filter {
            $0.logActionTypeId == self.logActionTypeId
        }
        
        let reminderIds = matchingMappings.map { $0.reminderActionTypeId }
        
        let reminderActionTypes = GlobalTypes.shared.reminderActionTypes.filter {
            reminderIds.contains($0.reminderActionTypeId)
        }
        
        // should only be 1 reverse mapping
        // not all log actions have an associated reminder action type
        
        return reminderActionTypes[0]
    }
    
    var associatedLogUnitTypes: [LogUnitType] {
        let matchingMappings = GlobalTypes.shared.mappingLogActionTypeLogUnitType.filter {
            $0.logActionTypeId == self.logActionTypeId
        }
        
        let unitIds = matchingMappings.map { $0.logUnitTypeId }
        
        var logUnitTypes = GlobalTypes.shared.logUnitTypes.filter {
            unitIds.contains($0.logUnitTypeId)
        }
        
        logUnitTypes = logUnitTypes.filter { logUnitType in
            switch UserConfiguration.measurementSystem {
            case .imperial:
                return logUnitType.isImperial
            case .metric:
                return logUnitType.isMetric
            case .both:
                // .both should never happen, but if it does, fall through to metric
                return logUnitType.isMetric
            }
        }
        
        return logUnitTypes
    }
    
    // MARK: - Initialization
    
    init(
        forLogActionTypeId: Int,
        forInternalValue: String,
        forReadableValue: String,
        forEmoji: String,
        forSortOrder: Int,
        forIsDefault: Bool,
        forAllowsCustom: Bool
    ) {
        self.logActionTypeId = forLogActionTypeId
        self.internalValue = forInternalValue
        self.readableValue = forReadableValue
        self.emoji = forEmoji
        self.sortOrder = forSortOrder
        self.isDefault = forIsDefault
        self.allowsCustom = forAllowsCustom
        super.init()
    }
    
    convenience init?(fromBody: [String: Any?]) {
        guard
            let idVal = fromBody[KeyConstant.logActionTypeId.rawValue] as? Int,
            let internalVal = fromBody[KeyConstant.internalValue.rawValue] as? String,
            let readableVal = fromBody[KeyConstant.readableValue.rawValue] as? String,
            let emojiVal = fromBody[KeyConstant.emoji.rawValue] as? String,
            let sortOrderVal = fromBody[KeyConstant.sortOrder.rawValue] as? Int,
            let isDefaultVal = fromBody[KeyConstant.isDefault.rawValue] as? Bool,
            let allowsCustomVal = fromBody[KeyConstant.allowsCustom.rawValue] as? Bool
        else {
            return nil
        }
        
        self.init(
            forLogActionTypeId: idVal,
            forInternalValue: internalVal,
            forReadableValue: readableVal,
            forEmoji: emojiVal,
            forSortOrder: sortOrderVal,
            forIsDefault: isDefaultVal,
            forAllowsCustom: allowsCustomVal
        )
    }
    
    // MARK: - Readable Conversion
    
    static func find(forLogActionTypeId: Int) -> LogActionType {
        return GlobalTypes.shared.logActionTypes.first { $0.logActionTypeId == forLogActionTypeId } ?? GlobalTypes.shared.logActionTypes[0]
    }
    
    func convertToReadableName(
        customActionName: String?,
        includeMatchingEmoji: Bool = false
    ) -> String {
        var result = ""
        
        if allowsCustom, let name = customActionName?.trimmingCharacters(in: .whitespacesAndNewlines), !name.isEmpty {
            result += name
        }
        else {
            result += readableValue
        }
        
        if includeMatchingEmoji {
            result += " " + emoji
        }
        
        return result
    }
}
//
//  Completion.swift
//  Hound
//
//  Created by Jonathan Xakellis on 9/16/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// CompletionTracker helps manage the progress of multiple async API queries. It checks that these tasks were all successful in order to invoke successfulCompletionHandler or otherwise invokes failureCompletionHandler
final class CompletionTracker: NSObject {
    
    // MARK: - Properties

    /// Number of completions of current tasks
    private var numberOfCompletions: Int = 0

    /// Number of tasks that need to be successful in order to invoke successfulCompletionHandler
    private var numberOfTasks: Int

    /// Once a completedAllTasksCompletionHandler or failedTaskCompletionHandler is invoked, we track it here. This indicates that the CompletionTracker has completed/failed and it should execute no more code
    private var completionTrackerFinished = false

    /// Completion handler invoked every time a task successfully completes
    private var completedTaskCompletionHandler: (() -> Void)

    /// Completion handler invoked if all tasks successfully complete
    private var completedAllTasksCompletionHandler: (() -> Void)

    /// Completion handler invoked if one or more of the tasks failed
    private var failedTaskCompletionHandler: (() -> Void)

    // MARK: - Main

    init(numberOfTasks: Int, completedTaskCompletionHandler: @escaping (() -> Void), completedAllTasksCompletionHandler: @escaping (() -> Void), failedTaskCompletionHandler: @escaping (() -> Void)) {
        self.numberOfTasks = max(numberOfTasks, 0)
        self.completedTaskCompletionHandler = completedTaskCompletionHandler
        self.completedAllTasksCompletionHandler = completedAllTasksCompletionHandler
        self.failedTaskCompletionHandler = failedTaskCompletionHandler
        super.init()
    }
    
    // MARK: - Computed Properties
    
    /// Returns true if either a task has failed or all tasks have completed, meaning the CompletionTracker invoked the corresponding completionHandler and will invoke no further action
    var isFinished: Bool {
        return completionTrackerFinished
    }

    // MARK: - Functions

    /// If a task has been failed or all tasks have been completed, then this function does nothing. Otherwise, this function invokes completedTaskCompletionHandler then if numberOfCompeltion == numberOfTasks, then function also invokes completedAllTasksCompletionHandler
    func completedTask() {
        guard completionTrackerFinished == false else {
            return
        }

        numberOfCompletions += 1
        completedTaskCompletionHandler()

        guard numberOfCompletions >= numberOfTasks else {
            return
        }

        completionTrackerFinished = true
        completedAllTasksCompletionHandler()
    }

    /// If a task has been failed or all tasks have been completed, then this function does nothing. Otherwise, this function invokes failedTaskCompletionHandler
    func failedTask() {
        guard completionTrackerFinished == false else {
            return
        }

        completionTrackerFinished = true
        failedTaskCompletionHandler()
    }
}
//
//  OfflineModeDeletedObject.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/11/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

class OfflineModeDeletedObject: NSObject, NSCoding {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(deletedDate, forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    /// Two OfflineModeDeletedObject are only equal if they are subclasses of OfflineModeDeletedObject whp's overriden == method says they are equal
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedObject else {
            return false
        }
        
        guard type(of: self) == type(of: rhs) else {
            return false
        }
        
        if let lhs = self as? OfflineModeDeletedDog, let rhs = rhs as? OfflineModeDeletedDog {
            return lhs == rhs
        }
        else if let lhs = self as? OfflineModeDeletedReminder, let rhs = rhs as? OfflineModeDeletedReminder {
            return lhs == rhs
        }
        else if let lhs = self as? OfflineModeDeletedLog, let rhs = rhs as? OfflineModeDeletedLog {
            return lhs == rhs
        }
        else if let lhs = self as? OfflineModeDeletedTrigger, let rhs = rhs as? OfflineModeDeletedTrigger {
            return lhs == rhs
        }
        
        return false
    }
    
    // MARK: - Properties
    
    var deletedDate: Date
    
    // MARK: - Main
    
    init(deletedDate: Date) {
        self.deletedDate = deletedDate
    }
}

final class OfflineModeDeletedDog: OfflineModeDeletedObject {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.dogUUID.rawValue))
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            dogUUID: decodedDogUUID ?? VisualConstant.TextConstant.unknownUUID,
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    override func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogUUID.uuidString, forKey: KeyConstant.dogUUID.rawValue)
        aCoder.encode(deletedDate, forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedDog else {
            return false
        }
        
        return self.dogUUID == rhs.dogUUID
    }
    
    // MARK: - Properties
    
    var dogUUID: UUID
    
    // MARK: - Main
    
    init(dogUUID: UUID, deletedDate: Date) {
        self.dogUUID = dogUUID
        super.init(deletedDate: deletedDate)
    }
}

final class OfflineModeDeletedReminder: OfflineModeDeletedObject {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.dogUUID.rawValue))
        let decodedReminderUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.reminderUUID.rawValue))
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            dogUUID: decodedDogUUID ?? VisualConstant.TextConstant.unknownUUID,
            reminderUUID: decodedReminderUUID ?? VisualConstant.TextConstant.unknownUUID,
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    override func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogUUID.uuidString, forKey: KeyConstant.dogUUID.rawValue)
        aCoder.encode(reminderUUID.uuidString, forKey: KeyConstant.reminderUUID.rawValue)
        aCoder.encode(deletedDate, forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedReminder else {
            return false
        }
        
        return self.dogUUID == rhs.dogUUID && self.reminderUUID == rhs.reminderUUID
    }
    
    // MARK: - Properties
    
    var dogUUID: UUID
    var reminderUUID: UUID
    
    // MARK: - Main
    
    init(dogUUID: UUID, reminderUUID: UUID, deletedDate: Date) {
        self.dogUUID = dogUUID
        self.reminderUUID = reminderUUID
        super.init(deletedDate: deletedDate)
    }
}

final class OfflineModeDeletedLog: OfflineModeDeletedObject {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.dogUUID.rawValue))
        let decodedLogUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.logUUID.rawValue))
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            dogUUID: decodedDogUUID ?? VisualConstant.TextConstant.unknownUUID,
            logUUID: decodedLogUUID ?? VisualConstant.TextConstant.unknownUUID,
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    override func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogUUID.uuidString, forKey: KeyConstant.dogUUID.rawValue)
        aCoder.encode(logUUID.uuidString, forKey: KeyConstant.logUUID.rawValue)
        aCoder.encode(deletedDate, forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedLog else {
            return false
        }
        
        return self.dogUUID == rhs.dogUUID && self.logUUID == rhs.logUUID
    }
    
    // MARK: - Properties
    
    var dogUUID: UUID
    var logUUID: UUID
    
    // MARK: - Main
    
    init(dogUUID: UUID, logUUID: UUID, deletedDate: Date) {
        self.dogUUID = dogUUID
        self.logUUID = logUUID
        super.init(deletedDate: deletedDate)
    }
}

final class OfflineModeDeletedTrigger: OfflineModeDeletedObject {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.dogUUID.rawValue))
        let decodedTriggerUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.triggerUUID.rawValue))
        let decodedDeletedDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
        self.init(
            dogUUID: decodedDogUUID ?? VisualConstant.TextConstant.unknownUUID,
            triggerUUID: decodedTriggerUUID ?? VisualConstant.TextConstant.unknownUUID,
            deletedDate: decodedDeletedDate ?? Date()
        )
    }
    
    override func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogUUID.uuidString, forKey: KeyConstant.dogUUID.rawValue)
        aCoder.encode(triggerUUID.uuidString, forKey: KeyConstant.triggerUUID.rawValue)
        aCoder.encode(deletedDate, forKey: KeyConstant.offlineModeDeletedObjectDeletedDate.rawValue)
    }
    
    // MARK: - Equatable
    
    override func isEqual(_ rhs: Any?) -> Bool {
        guard let rhs = rhs as? OfflineModeDeletedTrigger else {
            return false
        }
        
        return self.dogUUID == rhs.dogUUID && self.triggerUUID == rhs.triggerUUID
    }
    
    // MARK: - Properties
    
    var dogUUID: UUID
    var triggerUUID: UUID
    
    // MARK: - Main
    
    init(dogUUID: UUID, triggerUUID: UUID, deletedDate: Date) {
        self.dogUUID = dogUUID
        self.triggerUUID = triggerUUID
        super.init(deletedDate: deletedDate)
    }
}
//
//  Dog.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/18/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class Dog: NSObject, NSCoding, NSCopying, Comparable, DogLogManagerDelegate {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = try! Dog(forDogName: self.dogName) // swiftlint:disable:this force_try
        
        copy.dogId = self.dogId
        copy.dogUUID = self.dogUUID
        copy.dogName = self.dogName
        copy.dogIcon = self.dogIcon?.copy() as? UIImage
        copy.dogReminders = self.dogReminders.copy() as? DogReminderManager ?? DogReminderManager()
        copy.dogLogs = self.dogLogs.copy() as? DogLogManager ?? DogLogManager(forDelegate: nil)
        copy.dogLogs.delegate = self
        copy.dogTriggers = self.dogTriggers.copy() as? DogTriggerManager ?? DogTriggerManager()
        copy.offlineModeComponents = self.offlineModeComponents.copy() as? OfflineModeComponents ?? OfflineModeComponents()
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedDogId: Int? = aDecoder.decodeOptionalInteger(forKey: KeyConstant.dogId.rawValue)
        let decodedDogUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.dogUUID.rawValue))
        let decodedDogName: String? = aDecoder.decodeOptionalString(forKey: KeyConstant.dogName.rawValue)
        let decodedDogReminders: DogReminderManager? = aDecoder.decodeOptionalObject(forKey: KeyConstant.dogReminders.rawValue)
        let decodedDogLogs: DogLogManager? = aDecoder.decodeOptionalObject(forKey: KeyConstant.dogLogs.rawValue)
        let decodedDogTriggers: DogTriggerManager? = aDecoder.decodeOptionalObject(forKey: KeyConstant.dogTriggers.rawValue)
        let decodedOfflineModeComponents: OfflineModeComponents? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeComponents.rawValue)
        do {
            try self.init(
                forDogId: decodedDogId,
                forDogUUID: decodedDogUUID,
                forDogName: decodedDogName,
                forDogReminders: decodedDogReminders,
                forDogLogs: decodedDogLogs,
                forDogTriggers: decodedDogTriggers,
                forOfflineModeComponents: decodedOfflineModeComponents
            )
        }
        catch {
            // dogName made last init fail, so init without the dog name
            self.init(
                forDogId: decodedDogId,
                forDogUUID: decodedDogUUID,
                forDogReminders: decodedDogReminders,
                forDogLogs: decodedDogLogs,
                forDogTriggers: decodedDogTriggers,
                forOfflineModeComponents: decodedOfflineModeComponents
            )
        }
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        if let dogId = dogId {
            aCoder.encode(dogId, forKey: KeyConstant.dogId.rawValue)
        }
        aCoder.encode(dogUUID.uuidString, forKey: KeyConstant.dogUUID.rawValue)
        aCoder.encode(dogName, forKey: KeyConstant.dogName.rawValue)
        aCoder.encode(dogReminders, forKey: KeyConstant.dogReminders.rawValue)
        aCoder.encode(dogLogs, forKey: KeyConstant.dogLogs.rawValue)
        aCoder.encode(dogTriggers, forKey: KeyConstant.dogTriggers.rawValue)
        aCoder.encode(offlineModeComponents, forKey: KeyConstant.offlineModeComponents.rawValue)
    }
    
    // MARK: - Comparable
    
    static func < (lhs: Dog, rhs: Dog) -> Bool {
        guard let lhsDogId = lhs.dogId else {
            guard rhs.dogId != nil else {
                // Neither have an id
                return lhs.dogUUID.uuidString < rhs.dogUUID.uuidString
            }
            
            // lhs doesn't have a dogId but rhs does. rhs should come first
            return false
        }
        
        guard let rhsDogId = rhs.dogId else {
            // lhs has a dogId but rhs doesn't. lhs should come first
            return true
        }
        
        return lhsDogId <= rhsDogId
    }
    
    // MARK: - DogLogManagerDelegate
    
    func didAddLogs(forLogs logs: [Log]) {
        logs.forEach { log in
            var activatedTriggers = dogTriggers.matchingActivatedTriggers(forLog: log)
            
            activatedTriggers.forEach { activatedTrigger in
                let executionDate = activatedTrigger.nextReminderDate(afterLog: log)
                let resultReminderActionTypeId = activatedTrigger.resultReminderActionTypeId
                
            }
            
        }
        
        // TODO RT check log against triggers
    }
    
    // MARK: - Properties
    
    var dogId: Int?
    
    var dogUUID: UUID = UUID()
    
    var dogIcon: UIImage?
    
    private(set) var dogName: String = ClassConstant.DogConstant.defaultDogName
    
    /// DogReminderManager that handles all specified reminders for a dog, e.g. being taken to the outside every time interval or being fed.
    private(set) var dogReminders: DogReminderManager = DogReminderManager()
    
    /// DogLogManager that handles all the logs for a dog. forDelegate is set to nil, as it is set in the init method
    private(set) var dogLogs: DogLogManager = DogLogManager(forDelegate: nil)
    
    /// DogTriggerManager that handles all the dogTriggers for a dog
    private(set) var dogTriggers: DogTriggerManager = DogTriggerManager()
    
    /// Components that are used to track an object to determine whether it was synced with the Hound server and whether it needs to be when the device comes back online
    private(set) var offlineModeComponents: OfflineModeComponents = OfflineModeComponents()
    
    // MARK: - Main
    
    init(
        forDogId: Int? = nil,
        forDogUUID: UUID? = nil,
        forDogReminders: DogReminderManager? = nil,
        forDogLogs: DogLogManager? = nil,
        forDogTriggers: DogTriggerManager? = nil,
        forOfflineModeComponents: OfflineModeComponents? = nil
    ) {
        super.init()
        self.dogId = forDogId ?? dogId
        self.dogUUID = forDogUUID ?? dogUUID
        self.dogIcon = DogIconManager.getIcon(forDogUUID: dogUUID)
        self.dogReminders = forDogReminders ?? dogReminders
        self.dogLogs = forDogLogs ?? dogLogs
        self.dogLogs.delegate = self
        self.dogTriggers = forDogTriggers ?? dogTriggers
        self.offlineModeComponents = forOfflineModeComponents ?? offlineModeComponents
    }
    
    convenience init(
        forDogId: Int? = nil,
        forDogUUID: UUID? = nil,
        forDogName: String? = nil,
        forDogReminders: DogReminderManager? = nil,
        forDogLogs: DogLogManager? = nil,
        forDogTriggers: DogTriggerManager? = nil,
        forOfflineModeComponents: OfflineModeComponents? = nil
    ) throws {
        self.init(forDogId: forDogId, forDogUUID: forDogUUID, forDogReminders: forDogReminders, forDogLogs: forDogLogs, forDogTriggers: forDogTriggers, forOfflineModeComponents: forOfflineModeComponents)
        try changeDogName(forDogName: forDogName)
    }
    
    /// Provide a dictionary literal of dog properties to instantiate dog. Optionally, provide a dog to override with new properties from fromBody.
    convenience init?(fromBody: [String: Any?], dogToOverride: Dog?) {
        // Don't pull dogId or dogIsDeleted from dogToOverride. A valid fromBody needs to provide this itself
        let dogId: Int? = fromBody[KeyConstant.dogId.rawValue] as? Int
        let dogUUID: UUID? = UUID.fromString(forUUIDString: fromBody[KeyConstant.dogUUID.rawValue] as? String)
        let dogLastModified: Date? = (fromBody[KeyConstant.dogLastModified.rawValue] as? String)?.formatISO8601IntoDate()
        let dogIsDeleted: Bool? = fromBody[KeyConstant.dogIsDeleted.rawValue] as? Bool
        
        // The body needs an id, uuid, and isDeleted to be intrepreted as same, updated, or deleted. Otherwise, it is invalid
        guard let dogId = dogId, let dogUUID = dogUUID, let dogLastModified = dogLastModified, let dogIsDeleted = dogIsDeleted else {
            return nil
        }
        
        guard dogIsDeleted == false else {
            // The dog has been deleted. Doesn't matter if our offline mode made any changes
            return nil
        }
        
        // If we have pulled an update from the server which is more outdated than our local change, then ignore the data from the server. Otherwise, the newer update takes precedence over our update
        if let dogToOverride = dogToOverride, let initialAttemptedSyncDate = dogToOverride.offlineModeComponents.initialAttemptedSyncDate, initialAttemptedSyncDate >= dogLastModified {
            do {
                try self.init(
                    forDogId: dogToOverride.dogId,
                    forDogUUID: dogToOverride.dogUUID,
                    forDogName: dogToOverride.dogName,
                    forDogReminders: dogToOverride.dogReminders,
                    forDogLogs: dogToOverride.dogLogs,
                    forDogTriggers: dogToOverride.dogTriggers,
                    // Verified that the update from the server happened more recently than our local changes, so no need to offline sync anymore
                    forOfflineModeComponents: nil
                )
            }
            catch {
                // dogName made last init fail, so init without the dog name
                self.init(
                    forDogId: dogToOverride.dogId,
                    forDogUUID: dogToOverride.dogUUID,
                    forDogReminders: dogToOverride.dogReminders,
                    forDogLogs: dogToOverride.dogLogs,
                    forDogTriggers: dogToOverride.dogTriggers,
                    // Verified that the update from the server happened more recently than our local changes, so no need to offline sync anymore
                    forOfflineModeComponents: nil
                )
            }
            return
        }
        
        // if the dog is the same, then we pull values from dogToOverride
        // if the dog is updated, then we pull values from fromBody
        let dogName: String? = fromBody[KeyConstant.dogName.rawValue] as? String ?? dogToOverride?.dogName
        
        let dogReminders: DogReminderManager? = {
            guard let reminderBodies = fromBody[KeyConstant.dogReminders.rawValue] as? [[String: Any?]] else {
                return nil
            }
            
            return DogReminderManager(fromReminderBodies: reminderBodies, dogReminderManagerToOverride: dogToOverride?.dogReminders)
        }()
        
        let dogLogs: DogLogManager? = {
            guard let logBodies = fromBody[KeyConstant.dogLogs.rawValue] as? [[String: Any?]] else {
                return nil
            }
            
            // forDelegate is set to nil, as it is set in the init method
            return DogLogManager(fromLogBodies: logBodies, dogLogManagerToOverride: dogToOverride?.dogLogs, forDelegate: nil)
        }()
        
        let dogTriggers: DogTriggerManager? = {
            guard let triggerBodies = fromBody[KeyConstant.dogTriggers.rawValue] as? [[String: Any?]] else {
                return nil
            }
            
            return DogTriggerManager(fromTriggerBodies: triggerBodies, dogTriggerManagerToOverride: dogToOverride?.dogTriggers)
        }()
        
        do {
            try self.init(
                forDogId: dogId,
                forDogUUID: dogUUID,
                forDogName: dogName,
                forDogReminders: dogReminders,
                forDogLogs: dogLogs,
                forDogTriggers: dogTriggers,
                // Verified that the update from the server happened more recently than our local changes, so no need to offline sync anymore
                forOfflineModeComponents: nil
            )
        }
        catch {
            // dogName made last init fail, so init without the dog name
            self.init(
                forDogId: dogId,
                forDogUUID: dogUUID,
                forDogReminders: dogReminders,
                forDogLogs: dogLogs,
                forDogTriggers: dogTriggers,
                // Verified that the update from the server happened more recently than our local changes, so no need to offline sync anymore
                forOfflineModeComponents: nil
            )
        }
        
    }
    
    // MARK: - Function
    
    func changeDogName(forDogName: String?) throws {
        guard let forDogName = forDogName, forDogName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false else {
            throw ErrorConstant.DogError.dogNameMissing()
        }
        
        dogName = String(forDogName.prefix(ClassConstant.DogConstant.dogNameCharacterLimit))
    }
    
    /// For a given logActionType and logCustomActionName, finds all enabled reminders that match these two properties. We attempt to translate LogActionType into ReminderActionType, but that can possibly fail, as the mapping isn't 1:1 (some LogActionTypes have no corresponding ReminderActionType), therefore in that case we return nothing
    func matchingReminders(forLogActionType: LogActionType, forLogCustomActionName: String?) -> [Reminder] {
        // Must have a reminder action and our conversion failed as no corresponding reminderActionType exists for the logActionType
        let associatedReminderActionType = forLogActionType.associatedReminderActionType
        
        let matchingReminders = dogReminders.dogReminders.filter { dogReminder in
            guard dogReminder.reminderIsEnabled == true else {
                // Reminder needs to be enabled to be considered
                return false
            }
            
            guard dogReminder.reminderActionTypeId == associatedReminderActionType.reminderActionTypeId else {
                // Both reminderActionTypes need to match
                return false
            }
            
            // If the reminderActionType can have customActionName, then the customActionName need to also match.
            return associatedReminderActionType.allowsCustom == false
            || (dogReminder.reminderCustomActionName == forLogCustomActionName)
        }
        
        return matchingReminders
    }
    
    /// Returns an array literal of the dog's properties (does not include nested properties, e.g. logs or reminders). This is suitable to be used as the JSON body for a HTTP request
    func createBody() -> [String: CompatibleDataTypeForJSON?] {
        var body: [String: CompatibleDataTypeForJSON?] = [:]
        body[KeyConstant.dogId.rawValue] = dogId
        body[KeyConstant.dogUUID.rawValue] = dogUUID.uuidString
        body[KeyConstant.dogName.rawValue] = dogName
        return body
    }
}
//
//  OfflineModeComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/9/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class OfflineModeComponents: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        return OfflineModeComponents(
            forInitialAttemptedSyncDate: self.initialAttemptedSyncDate,
            forInitialCreationDate: self.initialCreationDate
        )
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedInitialAttemptedSyncDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeComponentsInitialAttemptedSyncDate.rawValue)
        let decodedInitialCreationDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeComponentsInitialCreationDate.rawValue)
        
        self.init(
            forInitialAttemptedSyncDate: decodedInitialAttemptedSyncDate,
            forInitialCreationDate: decodedInitialCreationDate
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(initialAttemptedSyncDate, forKey: KeyConstant.offlineModeComponentsInitialAttemptedSyncDate.rawValue)
        aCoder.encode(initialCreationDate, forKey: KeyConstant.offlineModeComponentsInitialCreationDate.rawValue)
    }
    
    // MARK: - Properties
    
    /// If this flag is true, the offline manager will attempt to sync this object at a later date when connectivity is restored. The values of this flag depends on whether or not initialAttemptedSyncDate is nil
    var needsSyncedWithHoundServer: Bool {
        return initialAttemptedSyncDate != nil
    }
    
    /// This is the date which the object was attempted to be synced with the Hound server but failed due to no connection. If this is set to a
    private(set) var initialAttemptedSyncDate: Date?
    /// Function used externally to manage initialAttemptedSyncDate
    func updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: Date?) {
        guard let forInitialAttemptedSyncDate = forInitialAttemptedSyncDate else {
            // Override initialAttemptedSyncDate to set it to nil
            initialAttemptedSyncDate = forInitialAttemptedSyncDate
            return
        }
        
        guard initialAttemptedSyncDate != nil else {
            // forInitialAttemptedSyncDate isn't nil but initialAttemptedSyncDate is, override initialAttemptedSyncDate with the value
            initialAttemptedSyncDate = forInitialAttemptedSyncDate
            return
        }
        
        // Both forInitialAttemptedSyncDate and initialAttemptedSyncDate aren't nil, therefore do nothing as the initialAttemptedSyncDate shouldn't be overriden with another value.
    }
    
    /// This is the date which the object was created by the user
    private(set) var initialCreationDate: Date = Date()
    
    // MARK: - Main
    
    init(
        forInitialAttemptedSyncDate: Date? = nil,
        forInitialCreationDate: Date? = nil
    ) {
        self.initialAttemptedSyncDate = forInitialAttemptedSyncDate ?? initialAttemptedSyncDate
        self.initialCreationDate = forInitialCreationDate ?? initialCreationDate
    }
}
//
//  trigger.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/14/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum TriggerType: String, CaseIterable {
    
    init?(rawValue: String) {
        for type in TriggerType.allCases where type.rawValue.lowercased() == rawValue.lowercased() {
            self = type
            return
        }
        
        self = .timeDelay
        return
    }
    case timeDelay
    case fixedTime
}

enum TriggerFixedTimeType: String, CaseIterable {
    
    init?(rawValue: String) {
        for type in TriggerFixedTimeType.allCases where type.rawValue.lowercased() == rawValue.lowercased() {
            self = type
            return
        }
        
        self = .day
        return
    }
    
    case day
    case week
    case month
    
    var calendarComponent: Calendar.Component {
        switch self {
        case .day:
            return .day
        case .week:
            return .weekOfYear
        case .month:
            return .month
        }
    }
}

final class Trigger: NSObject, NSCoding, NSCopying, Comparable {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = Trigger()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        copy.triggerId = self.triggerId
        copy.triggerUUID = self.triggerUUID
        copy.triggerCustomName = self.triggerCustomName
        copy.reactionLogActionTypeIds = self.reactionLogActionTypeIds
        copy.reactionLogCustomActionNames = self.reactionLogCustomActionNames
        copy.resultReminderActionTypeId = self.resultReminderActionTypeId
        copy.triggerType = self.triggerType
        copy.triggerTimeDelay = self.triggerTimeDelay
        copy.triggerFixedTimeType = self.triggerFixedTimeType
        copy.triggerFixedTimeTypeAmount = self.triggerFixedTimeTypeAmount
        copy.triggerFixedTimeUTCHour = self.triggerFixedTimeUTCHour
        copy.triggerFixedTimeUTCMinute = self.triggerFixedTimeUTCMinute
        copy.offlineModeComponents = self.offlineModeComponents.copy() as? OfflineModeComponents ?? OfflineModeComponents()
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedTriggerId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.triggerId.rawValue)
        let decodedTriggerUUID = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.triggerUUID.rawValue))
        let decodedTriggerCustomName = aDecoder.decodeOptionalString(forKey: KeyConstant.triggerCustomName.rawValue)
        let decodedReactionLogActionTypeIds: [Int]? = aDecoder.decodeOptionalObject(forKey: KeyConstant.reactionLogActionTypeIds.rawValue)
        let decodedLogCustomActionNamesReactions: [String]? = aDecoder.decodeOptionalObject(forKey: KeyConstant.reactionLogCustomActionNames.rawValue)
        let decodedResultReminderActionTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.resultReminderActionTypeId.rawValue)
        let decodedTriggerType = TriggerType(rawValue: aDecoder.decodeOptionalString(forKey: KeyConstant.triggerType.rawValue) ?? ClassConstant.TriggerConstant.defaultTriggerType.rawValue)
        let decodedTriggerTimeDelay = aDecoder.decodeOptionalDouble(forKey: KeyConstant.triggerTimeDelay.rawValue)
        let decodedTriggerFixedTimeType = TriggerFixedTimeType(rawValue: aDecoder.decodeOptionalString(forKey: KeyConstant.triggerFixedTimeType.rawValue) ?? ClassConstant.TriggerConstant.defaultTriggerFixedTimeType.rawValue)
        let decodedTriggerFixedTimeTypeAmount = aDecoder.decodeOptionalInteger(forKey: KeyConstant.triggerFixedTimeTypeAmount.rawValue)
        let decodedTriggerFixedTimeUTCHour = aDecoder.decodeOptionalInteger(forKey: KeyConstant.triggerFixedTimeUTCHour.rawValue)
        let decodedTriggerFixedTimeUTCMinute = aDecoder.decodeOptionalInteger(forKey: KeyConstant.triggerFixedTimeUTCMinute.rawValue)
        let decodedOfflineModeComponents: OfflineModeComponents? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeComponents.rawValue)

        self.init(
            forTriggerId: decodedTriggerId,
            forTriggerUUID: decodedTriggerUUID,
            forTriggerCustomName: decodedTriggerCustomName,
            forReactionLogActionTypeIds: decodedReactionLogActionTypeIds,
            forLogCustomActionNamesReactions: decodedLogCustomActionNamesReactions,
            forResultReminderActionTypeId: decodedResultReminderActionTypeId,
            forTriggerType: decodedTriggerType,
            forTriggerTimeDelay: decodedTriggerTimeDelay,
            forTriggerFixedTimeType: decodedTriggerFixedTimeType,
            forTriggerFixedTimeTypeAmount: decodedTriggerFixedTimeTypeAmount,
            forTriggerFixedTimeUTCHour: decodedTriggerFixedTimeUTCHour,
            forTriggerFixedTimeUTCMinute: decodedTriggerFixedTimeUTCMinute,
            forOfflineModeComponents: decodedOfflineModeComponents
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(triggerId, forKey: KeyConstant.triggerId.rawValue)
        aCoder.encode(triggerUUID.uuidString, forKey: KeyConstant.triggerUUID.rawValue)
        aCoder.encode(reactionLogActionTypeIds, forKey: KeyConstant.reactionLogActionTypeIds.rawValue)
        aCoder.encode(reactionLogCustomActionNames, forKey: KeyConstant.reactionLogCustomActionNames.rawValue)
        aCoder.encode(resultReminderActionTypeId, forKey: KeyConstant.resultReminderActionTypeId.rawValue)
        aCoder.encode(triggerCustomName, forKey: KeyConstant.triggerCustomName.rawValue)
        aCoder.encode(triggerType.rawValue, forKey: KeyConstant.triggerType.rawValue)
        aCoder.encode(triggerTimeDelay, forKey: KeyConstant.triggerTimeDelay.rawValue)
        aCoder.encode(triggerFixedTimeType.rawValue, forKey: KeyConstant.triggerFixedTimeType.rawValue)
        aCoder.encode(triggerFixedTimeTypeAmount, forKey: KeyConstant.triggerFixedTimeTypeAmount.rawValue)
        aCoder.encode(triggerFixedTimeUTCHour, forKey: KeyConstant.triggerFixedTimeUTCHour.rawValue)
        aCoder.encode(triggerFixedTimeUTCMinute, forKey: KeyConstant.triggerFixedTimeUTCMinute.rawValue)
        aCoder.encode(offlineModeComponents, forKey: KeyConstant.offlineModeComponents.rawValue)
    }
    
    // MARK: - Comparable
    
    static func < (lhs: Trigger, rhs: Trigger) -> Bool {
        // 1. timeDelay comes before fixedTime
        switch (lhs.triggerType, rhs.triggerType) {
        case (.timeDelay, .fixedTime): return true
        case (.fixedTime, .timeDelay): return false
        case (.timeDelay, .timeDelay):
            // 2a. if both timeDelay, smaller time delay comes first (if one is smaller)
            if lhs.triggerTimeDelay < rhs.triggerTimeDelay {
                return true
            }
            else if lhs.triggerTimeDelay > rhs.triggerTimeDelay {
                return false
            }
        case (.fixedTime, .fixedTime):
            // 2a. if both fixedTime, smaller fixed time comes first (if one is smaller)
            // If they are of the same fixed time type, ignore this check
            // If diff fixed time types, the smaller one comes first
            switch (lhs.triggerFixedTimeType, rhs.triggerFixedTimeType) {
            case let (lhsType, rhsType) where lhsType == rhsType: break
            case (.day, _): return true
            case (.week, .day): return false
            case (.week, .month): return true
            case (.month, _): return false
            default: break
            }
            
            // One with smaller fixed time type amount comes first
            // If equal, need a different tie breaker
            if lhs.triggerFixedTimeTypeAmount < rhs.triggerFixedTimeTypeAmount {
                return true
            }
            else if lhs.triggerFixedTimeTypeAmount > rhs.triggerFixedTimeTypeAmount {
                return false
            }
            
            // One with smaller fixed time UTC hour comes first
            // If equal, need a different tie breaker
            if lhs.triggerFixedTimeUTCHour < rhs.triggerFixedTimeUTCHour {
                return true
            }
            else if lhs.triggerFixedTimeUTCHour > rhs.triggerFixedTimeUTCHour {
                return false
            }
            
            // One with smaller fixed time UTC minute comes first
            // If equal, need a different tie breaker
            if lhs.triggerFixedTimeUTCMinute < rhs.triggerFixedTimeUTCMinute {
                return true
            }
            else if lhs.triggerFixedTimeUTCMinute > rhs.triggerFixedTimeUTCMinute {
                return false
            }
        }
        
        // 3. compare trigger id, the smaller/oldest one should come first
        switch (lhs.triggerId, rhs.triggerId) {
        case let (lhsId, rhsId) where lhsId == nil && rhsId == nil: break
        case let (lhsId, _) where lhsId == nil: return false
        case let (_, rhsId) where rhsId == nil: return true
        case let (lhsId, rhsId) where lhsId! <= rhsId!: return true // swiftlint:disable:this force_unwrapping
        default: break
        }
        
        // If all else fails, compare triggerUUID
        return lhs.triggerUUID.uuidString <= rhs.triggerUUID.uuidString
        
    }
    
    // MARK: - Properties
    
    /// The triggerId given to this trigger from the Hound database
    var triggerId: Int?
    
    /// The UUID of this dynamic log that is generated locally upon creation. Useful in identifying the dynamic log before/in the process of creating it
    var triggerUUID: UUID = UUID()
    
    private(set) var triggerCustomName: String = ""
    func changeTriggerCustomName(forName: String) {
        triggerCustomName = String((forName.trimmingCharacters(in: .whitespacesAndNewlines)).prefix(ClassConstant.TriggerConstant.triggerCustomNameCharacterLimit))
    }
    
    private(set) var reactionLogActionTypeIds: [Int] = []
    func setLogActionReactions(forLogActionReactions: [Int]) {
        var seen = Set<Int>()
        reactionLogActionTypeIds = forLogActionReactions.filter { seen.insert($0).inserted }
    }
    private(set) var reactionLogCustomActionNames: [String] = []
    func setLogCustomActionNameReactions(forLogCustomActionNameReactions: [String]) {
        var seen = Set<String>()
        reactionLogCustomActionNames = forLogCustomActionNameReactions.filter { seen.insert($0).inserted }
    }
    
    var resultReminderActionTypeId: Int = ClassConstant.TriggerConstant.defaultTriggerResultReminderActionTypeId
    
    var triggerType: TriggerType = ClassConstant.TriggerConstant.defaultTriggerType
    private(set) var triggerTimeDelay: Double = ClassConstant.TriggerConstant.defaultTriggerTimeDelay
    func changeTriggerTimeDelay(forTimeDelay: Double) {
        if forTimeDelay > 0 {
            return
        }
        triggerTimeDelay = forTimeDelay
    }
    
    var triggerFixedTimeType: TriggerFixedTimeType = ClassConstant.TriggerConstant.defaultTriggerFixedTimeType
    private(set) var triggerFixedTimeTypeAmount: Int = ClassConstant.TriggerConstant.defaultTriggerFixedTimeTypeAmount
    func changeTriggerFixedTimeTypeAmount(forAmount: Int) {
        if forAmount >= 0 {
            return
        }
        triggerFixedTimeTypeAmount = forAmount
    }
    
    /// Hour of the day that that the trigger should fire in GMT+0000. [0, 23]
    private(set) var triggerFixedTimeUTCHour: Int = ClassConstant.ReminderComponentConstant.defaultUTCHour
    /// UTCHour but converted to the hour in the user's timezone
    var triggerFixedTimeLocalHour: Int {
        let hoursFromUTC = Calendar.current.timeZone.secondsFromGMT() / 3600
        
        var localHour = triggerFixedTimeUTCHour + hoursFromUTC
        // localHour could be negative, so roll over into positive
        localHour += 24
        // Make sure localHour [0, 23]
        localHour = localHour % 24
        return localHour
    }
    /// Takes a given date and extracts the UTC Hour (GMT+0000) from it.
    func changeTriggerFixedTimeUTCHour(forDate: Date) {
        triggerFixedTimeUTCHour = Calendar.UTCCalendar.component(.hour, from: forDate)
    }
    
    /// Minute of the day that that the reminder should fire in GMT+0000. [0, 59]
    private(set) var triggerFixedTimeUTCMinute: Int = ClassConstant.ReminderComponentConstant.defaultUTCMinute
    /// UTCMinute but converted to the minute in the user's timezone
    var triggerFixedTimeLocalMinute: Int {
        let minutesFromUTC = (Calendar.current.timeZone.secondsFromGMT() % 3600) / 60
        var localMinute = triggerFixedTimeUTCMinute + minutesFromUTC
        // localMinute could be negative, so roll over into positive
        localMinute += 60
        // Make sure localMinute [0, 59]
        localMinute = localMinute % 60
        return localMinute
    }
    /// Takes a given date and extracts the UTC minute (GMT+0000) from it.
    func changeTriggerFixedTimeUTCMinute(forDate: Date) {
        triggerFixedTimeUTCMinute = Calendar.UTCCalendar.component(.minute, from: forDate)
    }
    
    /// Components that are used to track an object to determine whether it was synced with the Hound server and whether it needs to be when the device comes back online
    private(set) var offlineModeComponents: OfflineModeComponents = OfflineModeComponents()
    
    // MARK: - Main
    
    init(
        forTriggerId: Int? = nil,
        forTriggerUUID: UUID? = nil,
        forTriggerCustomName: String? = nil,
        forReactionLogActionTypeIds: [Int]? = nil,
        forLogCustomActionNamesReactions: [String]? = nil,
        forResultReminderActionTypeId: Int? = nil,
        forTriggerType: TriggerType? = nil,
        forTriggerTimeDelay: Double? = nil,
        forTriggerFixedTimeType: TriggerFixedTimeType? = nil,
        forTriggerFixedTimeTypeAmount: Int? = nil,
        forTriggerFixedTimeUTCHour: Int? = nil,
        forTriggerFixedTimeUTCMinute: Int? = nil,
        forOfflineModeComponents: OfflineModeComponents? = nil
    ) {
        super.init()
        self.triggerId = forTriggerId ?? triggerId
        self.triggerUUID = forTriggerUUID ?? triggerUUID
        self.triggerCustomName = forTriggerCustomName ?? self.triggerCustomName
        self.reactionLogActionTypeIds = forReactionLogActionTypeIds ?? self.reactionLogActionTypeIds
        self.reactionLogCustomActionNames = forLogCustomActionNamesReactions ?? self.reactionLogCustomActionNames
        self.resultReminderActionTypeId = forResultReminderActionTypeId ?? self.resultReminderActionTypeId
        self.triggerType = forTriggerType ?? self.triggerType
        self.triggerTimeDelay = forTriggerTimeDelay ?? self.triggerTimeDelay
        self.triggerFixedTimeType = forTriggerFixedTimeType ?? self.triggerFixedTimeType
        self.triggerFixedTimeTypeAmount = forTriggerFixedTimeTypeAmount ?? self.triggerFixedTimeTypeAmount
        self.triggerFixedTimeUTCHour = forTriggerFixedTimeUTCHour ?? self.triggerFixedTimeUTCHour
        self.triggerFixedTimeUTCMinute = forTriggerFixedTimeUTCMinute ?? self.triggerFixedTimeUTCMinute
        self.offlineModeComponents = forOfflineModeComponents ?? self.offlineModeComponents
    }
    
    /// Provide a dictionary literal of reminder trigger properties to instantiate reminder trigger. Optionally, provide a reminder trigger to override with new properties from fromBody.
    convenience init?(fromBody: [String: Any?], triggerToOverride: Trigger?) {
        // Don't pull triggerId or triggerIsDeleted from triggerToOverride. A valid fromBody needs to provide this itself
        let triggerId = fromBody[KeyConstant.triggerId.rawValue] as? Int
        let triggerUUID = UUID.fromString(forUUIDString: fromBody[KeyConstant.triggerUUID.rawValue] as? String)
        // TODO RT make sure last modified and deleted are properly implemented on server side functions
        let triggerLastModified = (fromBody[KeyConstant.triggerLastModified.rawValue] as? String)?.formatISO8601IntoDate()
        let reminderIsDeleted = fromBody[KeyConstant.triggerIsDeleted.rawValue] as? Bool
        
        // The body needs an id, uuid, and isDeleted to be intrepreted as same, updated, or deleted. Otherwise, it is invalid
        guard let triggerId = triggerId, let triggerUUID = triggerUUID, let triggerLastModified = triggerLastModified, let reminderIsDeleted = reminderIsDeleted else {
            return nil
        }
        
        guard reminderIsDeleted == false else {
            // The reminder trigger has been deleted. Doesn't matter if our offline mode made any changes
            return nil
        }
        
        // If we have pulled an update from the server which is more outdated than our local change, then ignore the data from the server. Otherwise, the newer server update takes precedence over our offline update
        if let triggerToOverride = triggerToOverride, let initialAttemptedSyncDate = triggerToOverride.offlineModeComponents.initialAttemptedSyncDate, initialAttemptedSyncDate >= triggerLastModified {
            self.init(
                forTriggerId: triggerToOverride.triggerId,
                forTriggerUUID: triggerToOverride.triggerUUID,
                forTriggerCustomName: triggerToOverride.triggerCustomName,
                forReactionLogActionTypeIds: triggerToOverride.reactionLogActionTypeIds,
                forLogCustomActionNamesReactions: triggerToOverride.reactionLogCustomActionNames,
                forResultReminderActionTypeId: triggerToOverride.resultReminderActionTypeId,
                forTriggerType: triggerToOverride.triggerType,
                forTriggerTimeDelay: triggerToOverride.triggerTimeDelay,
                forTriggerFixedTimeType: triggerToOverride.triggerFixedTimeType,
                forTriggerFixedTimeTypeAmount: triggerToOverride.triggerFixedTimeTypeAmount,
                forTriggerFixedTimeUTCHour: triggerToOverride.triggerFixedTimeUTCHour,
                forTriggerFixedTimeUTCMinute: triggerToOverride.triggerFixedTimeUTCMinute,
                forOfflineModeComponents: triggerToOverride.offlineModeComponents
            )
            return
        }
        
        // if the reminder trigger is the same, then we pull values from triggerToOverride
        // if the reminder trigger is updated, then we pull values from fromBody
        
        let triggerCustomName = fromBody[KeyConstant.triggerCustomName.rawValue] as? String ?? triggerToOverride?.triggerCustomName
        let reactionLogActionTypeIds = fromBody[KeyConstant.reactionLogActionTypeIds.rawValue] as? [Int] ?? triggerToOverride?.reactionLogActionTypeIds
        let reactionLogCustomActionNames = fromBody[KeyConstant.reactionLogCustomActionNames.rawValue] as? [String] ?? triggerToOverride?.reactionLogCustomActionNames
        let resultReminderActionTypeId: Int? = fromBody[KeyConstant.resultReminderActionTypeId.rawValue] as? Int ?? triggerToOverride?.resultReminderActionTypeId
        
        let triggerType: TriggerType? = {
            guard let triggerTypeString = fromBody[KeyConstant.triggerType.rawValue] as? String else {
                return nil
            }
            return TriggerType(rawValue: triggerTypeString)
        }() ?? triggerToOverride?.triggerType
        let triggerTimeDelay = fromBody[KeyConstant.triggerTimeDelay.rawValue] as? Double ?? triggerToOverride?.triggerTimeDelay
        
        let triggerFixedTimeType: TriggerFixedTimeType? = {
            guard let triggerFixedTimeTypeString = fromBody[KeyConstant.triggerFixedTimeType.rawValue] as? String else {
                return nil
            }
            return TriggerFixedTimeType(rawValue: triggerFixedTimeTypeString)
        }() ?? triggerToOverride?.triggerFixedTimeType
        
        let triggerFixedTimeTypeAmount = fromBody[KeyConstant.triggerFixedTimeTypeAmount.rawValue] as? Int ?? triggerToOverride?.triggerFixedTimeTypeAmount
        let triggerFixedTimeUTCHour = fromBody[KeyConstant.triggerFixedTimeUTCHour.rawValue] as? Int ?? triggerToOverride?.triggerFixedTimeUTCHour
        let triggerFixedTimeUTCMinute = fromBody[KeyConstant.triggerFixedTimeUTCMinute.rawValue] as? Int ?? triggerToOverride?.triggerFixedTimeUTCMinute
        
        self.init(
            forTriggerId: triggerId,
            forTriggerUUID: triggerUUID,
            forTriggerCustomName: triggerCustomName,
            forReactionLogActionTypeIds: reactionLogActionTypeIds,
            forLogCustomActionNamesReactions: reactionLogCustomActionNames,
            forResultReminderActionTypeId: resultReminderActionTypeId,
            forTriggerType: triggerType,
            forTriggerTimeDelay: triggerTimeDelay,
            forTriggerFixedTimeType: triggerFixedTimeType,
            forTriggerFixedTimeTypeAmount: triggerFixedTimeTypeAmount,
            forTriggerFixedTimeUTCHour: triggerFixedTimeUTCHour,
            forTriggerFixedTimeUTCMinute: triggerFixedTimeUTCMinute,
            forOfflineModeComponents: nil
        )
    }
    
    // MARK: - Functions
    
    func shouldActivateTrigger(forLog log: Log) -> Bool {
        guard reactionLogActionTypeIds.contains(log.logActionTypeId) else {
            return false
        }
        
        if log.logActionType.allowsCustom {
            guard reactionLogCustomActionNames.contains(log.logCustomActionName) else {
                return false
            }
        }
        
        return true
    }
    
    func nextReminderDate(afterLog log: Log) -> Date? {
        let date = log.logEndDate ?? log.logStartDate
        
        switch triggerType {
        case .timeDelay:
            return date.addingTimeInterval(triggerTimeDelay)
        case .fixedTime:
            let delayedDay = Calendar.UTCCalendar.date(byAdding: triggerFixedTimeType.calendarComponent, value: triggerFixedTimeTypeAmount, to: date) ?? ClassConstant.DateConstant.default1970Date
            var components = Calendar.UTCCalendar.dateComponents([.day, .hour, .minute], from: delayedDay)
            components.hour = triggerFixedTimeUTCHour
            components.minute = triggerFixedTimeUTCMinute
            components.second = 0
            
            return Calendar.UTCCalendar.date(from: components)
        }
    }
    
    /// Returns an array literal of the triggers's properties. This is suitable to be used as the JSON body for a HTTP request
    func createBody(forDogUUID: UUID) -> [String: CompatibleDataTypeForJSON?] {
        var body: [String: CompatibleDataTypeForJSON?] = [:]
        body[KeyConstant.dogUUID.rawValue] = forDogUUID.uuidString
        body[KeyConstant.triggerId.rawValue] = triggerId
        body[KeyConstant.triggerUUID.rawValue] = triggerUUID.uuidString
        body[KeyConstant.triggerCustomName.rawValue] = triggerCustomName
        body[KeyConstant.reactionLogActionTypeIds.rawValue] = reactionLogActionTypeIds
        body[KeyConstant.reactionLogCustomActionNames.rawValue] = reactionLogCustomActionNames
        body[KeyConstant.resultReminderActionTypeId.rawValue] = resultReminderActionTypeId
        body[KeyConstant.triggerType.rawValue] = triggerType.rawValue
        body[KeyConstant.triggerTimeDelay.rawValue] = triggerTimeDelay
        body[KeyConstant.triggerFixedTimeType.rawValue] = triggerFixedTimeType.rawValue
        body[KeyConstant.triggerFixedTimeTypeAmount.rawValue] = triggerFixedTimeTypeAmount
        body[KeyConstant.triggerFixedTimeUTCHour.rawValue] = triggerFixedTimeUTCHour
        body[KeyConstant.triggerFixedTimeUTCMinute.rawValue] = triggerFixedTimeUTCMinute
        return body
        
    }
}
//
//  DogTriggerManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/14/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class DogTriggerManager: NSObject, NSCoding, NSCopying {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = DogTriggerManager()
        for trigger in dogTriggers {
            if let triggerCopy = trigger.copy() as? Trigger {
                copy.dogTriggers.append(triggerCopy)
            }
        }
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard let dogTriggers: [Trigger] = aDecoder.decodeOptionalObject(forKey: KeyConstant.dogTriggers.rawValue) else {
            return nil
        }
        
        self.init(forDogTriggers: dogTriggers)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogTriggers,
                      forKey: KeyConstant.dogTriggers.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var dogTriggers: [Trigger] = []
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    init(forDogTriggers: [Trigger] = []) {
        super.init()
        addTriggers(forDogTriggers: forDogTriggers)
    }
    
    convenience init(
        fromTriggerBodies: [[String: Any?]],
        dogTriggerManagerToOverride: DogTriggerManager?
    ) {
        self.init(forDogTriggers:
                    dogTriggerManagerToOverride?.dogTriggers ?? []
        )
        
        for fromBody in fromTriggerBodies {
            let triggerId = fromBody[KeyConstant.triggerId.rawValue] as? Int
            let triggerUUID = UUID.fromString(
                forUUIDString: fromBody[KeyConstant.triggerUUID.rawValue] as? String
            )
            let triggerIsDeleted = fromBody[KeyConstant.triggerIsDeleted.rawValue] as? Bool
            
            guard triggerId != nil,
                  let triggerUUID = triggerUUID,
                  let triggerIsDeleted = triggerIsDeleted
            else {
                continue
            }
            
            guard triggerIsDeleted == false else {
                removeTrigger(forTriggerUUID: triggerUUID)
                continue
            }
            
            if let trigger = Trigger(
                fromBody: fromBody,
                triggerToOverride: findTrigger(forTriggerUUID: triggerUUID)
            ) {
                addTrigger(forTrigger: trigger)
            }
        }
    }
    
    // MARK: - Functions
    
    /// finds and returns the reference of a trigger matching the given UUID
    func findTrigger(
        forTriggerUUID: UUID
    ) -> Trigger? {
        dogTriggers.first {
            $0.triggerUUID == forTriggerUUID
        }
    }
    
    /// Helper function: remove existing then append without sorting
    private func addTriggerWithoutSorting(
        forTrigger: Trigger
    ) {
        dogTriggers.removeAll {
            $0.triggerUUID == forTrigger.triggerUUID
        }
        dogTriggers.append(forTrigger)
    }
    
    /// If a trigger with the same UUID exists, replaces it, then sorts
    func addTrigger(forTrigger: Trigger) {
        addTriggerWithoutSorting(forTrigger: forTrigger)
        dogTriggers.sort(by: { $0 <= $1 })
    }
    
    /// Invokes addTrigger(forTrigger:) for each, sorting once
    func addTriggers(
        forDogTriggers: [Trigger]
    ) {
        for trigger in forDogTriggers {
            addTriggerWithoutSorting(forTrigger: trigger)
        }
        dogTriggers.sort(by: { $0 <= $1 })
    }
    
    /// Returns true if at least one trigger was removed by UUID
    @discardableResult
    func removeTrigger(
        forTriggerUUID: UUID
    ) -> Bool {
        var didRemoveObject = false
        /// finds and returns the reference of a trigger matching the given UUID
        dogTriggers.removeAll { trigger in
            guard trigger.triggerUUID == forTriggerUUID else {
                return false
            }
            didRemoveObject = true
            return true
        }
        
        return didRemoveObject
    }
    
    func matchingActivatedTriggers(forLog log: Log) -> [Trigger] {
        return dogTriggers.filter { trigger in trigger.shouldActivateTrigger(forLog: log) }
    }
}
//
//  Remindert.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/21/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ReminderType: String, CaseIterable {
    
    init?(rawValue: String) {
        for type in ReminderType.allCases where type.rawValue.lowercased() == rawValue.lowercased() {
            self = type
            return
        }
        
        self = .countdown
        return
    }
    case oneTime
    case countdown
    case weekly
    case monthly
}

final class Reminder: NSObject, NSCoding, NSCopying, Comparable {
    
    // TODO RT diable editting of reminder if its a isTriggerResult
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = Reminder()
        
        copy.reminderId = self.reminderId
        copy.reminderUUID = self.reminderUUID
        copy.reminderActionTypeId = self.reminderActionTypeId
        copy.reminderCustomActionName = self.reminderCustomActionName
        copy.reminderType = self.reminderType
        copy.reminderExecutionBasis = self.reminderExecutionBasis
        copy.reminderIsTriggerResult = self.reminderIsTriggerResult
        copy.storedReminderIsEnabled = self.storedReminderIsEnabled
        
        copy.countdownComponents = self.countdownComponents.copy() as? CountdownComponents ?? CountdownComponents()
        copy.weeklyComponents = self.weeklyComponents.copy() as? WeeklyComponents ?? WeeklyComponents()
        copy.monthlyComponents = self.monthlyComponents.copy() as? MonthlyComponents ?? MonthlyComponents()
        copy.oneTimeComponents = self.oneTimeComponents.copy() as? OneTimeComponents ?? OneTimeComponents()
        copy.snoozeComponents = self.snoozeComponents.copy() as? SnoozeComponents ?? SnoozeComponents()
        copy.offlineModeComponents = self.offlineModeComponents.copy() as? OfflineModeComponents ?? OfflineModeComponents()
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedReminderId: Int? = aDecoder.decodeOptionalInteger(forKey: KeyConstant.reminderId.rawValue)
        let decodedReminderUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.reminderUUID.rawValue))
        let decodedReminderActionTypeId: Int? = aDecoder.decodeOptionalInteger(forKey: KeyConstant.reminderActionTypeId.rawValue)
        let decodedReminderCustomActionName: String? = aDecoder.decodeOptionalString(forKey: KeyConstant.reminderCustomActionName.rawValue)
        let decodedReminderType: ReminderType? = ReminderType(rawValue: aDecoder.decodeOptionalString(forKey: KeyConstant.reminderType.rawValue) ?? ClassConstant.ReminderConstant.defaultReminderType.rawValue)
        let decodedReminderExecutionBasis: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.reminderExecutionBasis.rawValue)
        let decodedReminderIsTriggerResult: Bool? = aDecoder.decodeOptionalBool(forKey: KeyConstant.reminderIsTriggerResult.rawValue)
        let decodedReminderIsEnabled: Bool? = aDecoder.decodeOptionalBool(forKey: KeyConstant.reminderIsEnabled.rawValue)
        let decodedCountdownComponents: CountdownComponents? = aDecoder.decodeOptionalObject(forKey: KeyConstant.countdownComponents.rawValue)
        let decodedWeeklyComponents: WeeklyComponents? = aDecoder.decodeOptionalObject(forKey: KeyConstant.weeklyComponents.rawValue)
        let decodedMonthlyComponents: MonthlyComponents? = aDecoder.decodeOptionalObject(forKey: KeyConstant.monthlyComponents.rawValue)
        let decodedOneTimeComponents: OneTimeComponents? = aDecoder.decodeOptionalObject(forKey: KeyConstant.oneTimeComponents.rawValue)
        let decodedSnoozeComponents: SnoozeComponents? = aDecoder.decodeOptionalObject(forKey: KeyConstant.snoozeComponents.rawValue)
        let decodedOfflineModeComponents: OfflineModeComponents? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeComponents.rawValue)

        self.init(
            forReminderId: decodedReminderId,
            forReminderUUID: decodedReminderUUID,
            forReminderActionTypeId: decodedReminderActionTypeId,
            forReminderCustomActionName: decodedReminderCustomActionName,
            forReminderType: decodedReminderType,
            forReminderExecutionBasis: decodedReminderExecutionBasis,
            forReminderIsTriggerResult: decodedReminderIsTriggerResult,
            forReminderIsEnabled: decodedReminderIsEnabled,
            forCountdownComponents: decodedCountdownComponents,
            forWeeklyComponents: decodedWeeklyComponents,
            forMonthlyComponents: decodedMonthlyComponents,
            forOneTimeComponents: decodedOneTimeComponents,
            forSnoozeComponents: decodedSnoozeComponents,
            forOfflineModeComponents: decodedOfflineModeComponents
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        if let reminderId = reminderId {
            aCoder.encode(reminderId, forKey: KeyConstant.reminderId.rawValue)
        }
        aCoder.encode(reminderUUID.uuidString, forKey: KeyConstant.reminderUUID.rawValue)
        aCoder.encode(reminderActionTypeId, forKey: KeyConstant.reminderActionTypeId.rawValue)
        aCoder.encode(reminderCustomActionName, forKey: KeyConstant.reminderCustomActionName.rawValue)
        aCoder.encode(reminderType.rawValue, forKey: KeyConstant.reminderType.rawValue)
        aCoder.encode(reminderExecutionBasis, forKey: KeyConstant.reminderExecutionBasis.rawValue)
        aCoder.encode(reminderIsTriggerResult, forKey: KeyConstant.reminderIsTriggerResult.rawValue)
        aCoder.encode(reminderIsEnabled, forKey: KeyConstant.reminderIsEnabled.rawValue)
        aCoder.encode(countdownComponents, forKey: KeyConstant.countdownComponents.rawValue)
        aCoder.encode(weeklyComponents, forKey: KeyConstant.weeklyComponents.rawValue)
        aCoder.encode(monthlyComponents, forKey: KeyConstant.monthlyComponents.rawValue)
        aCoder.encode(oneTimeComponents, forKey: KeyConstant.oneTimeComponents.rawValue)
        aCoder.encode(snoozeComponents, forKey: KeyConstant.snoozeComponents.rawValue)
        aCoder.encode(offlineModeComponents, forKey: KeyConstant.offlineModeComponents.rawValue)
    }
    
    // MARK: - Comparable
    
    static func < (lhs: Reminder, rhs: Reminder) -> Bool {
        // if one reminder is a trigger result and the other isn't, trigger should come second
        switch (lhs.reminderIsTriggerResult, rhs.reminderIsTriggerResult) {
        case (true, false):
            return false
        case (false, true):
            return true
        default:
            break
        }
        
        guard lhs.reminderType == rhs.reminderType else {
            // lhs and rhs are known to be different styles
            switch lhs.reminderType {
            case .countdown:
                // rhs can't be .countdown and .countdown always comes first, so lhs comes first
                return true
            case .weekly:
                // rhs can't be weekly. Therefore, the only way it can come before is if its .countdown
                return (rhs.reminderType == .countdown) ? false : true
            case .monthly:
                // rhs can't be monthly. Therefore, the only way it can come before is if its .countdown or .weekly
                return (rhs.reminderType == .countdown || rhs.reminderType == .weekly) ? false : true
            case .oneTime:
                // rhs can't be oneTime. Therefore, it will come before as it has to be one of the other types
                return false
            }
        }
        
        /// Analyzes both the reminderId and reminderUUID, finding which reminder is lessor than the other reminder.
        func isLHSReminderBeforeRHSReminder(lhs: Reminder, rhs: Reminder) -> Bool {
            guard let lhsReminderId = lhs.reminderId else {
                guard rhs.reminderId != nil else {
                    // neither lhs nor rhs has a reminderId. The one that was created first should come first
                    return lhs.offlineModeComponents.initialCreationDate.distance(to: rhs.offlineModeComponents.initialCreationDate) >= 0
                }
                
                // lhs doesn't have a reminderId but rhs does. rhs should come first
                return false
            }
            
            guard let rhsReminderId = rhs.reminderId else {
                // lhs has a reminderId but rhs doesn't. lhs should come first
                return true
            }
            
            return lhsReminderId <= rhsReminderId
        }
        
        switch lhs.reminderType {
        case .countdown:
            // both countdown
            let lhsExecutionInterval = lhs.countdownComponents.executionInterval
            let rhsExecutionInterval = rhs.countdownComponents.executionInterval
            
            guard lhsExecutionInterval != rhsExecutionInterval else {
                // if equal, then smaller reminderId comes first
                return isLHSReminderBeforeRHSReminder(lhs: lhs, rhs: rhs)
            }
            // shorter executionInterval comes first
            return lhsExecutionInterval < rhsExecutionInterval
        case .weekly:
            // both weekly
            // earlier in the day is listed first
            let lhsHour = lhs.weeklyComponents.localHour
            let rhsHour = rhs.weeklyComponents.localHour
            
            guard lhsHour != rhsHour else {
                // hours are equal
                let lhsMinute = lhs.weeklyComponents.localMinute
                let rhsMinute = rhs.weeklyComponents.localMinute
                
                guard lhsMinute != rhsMinute else {
                    // if equal, then smaller reminderId comes first
                    return isLHSReminderBeforeRHSReminder(lhs: lhs, rhs: rhs)
                }
                
                // smaller minute comes first
                return lhsMinute < rhsMinute
            }
            
            // smaller hour comes first
            return lhsHour < rhsHour
        case .monthly:
            // both monthly
            let lhsDay = lhs.monthlyComponents.UTCDay
            let rhsDay = rhs.monthlyComponents.UTCDay
            
            guard lhsDay != rhsDay else {
                // earliest in day comes first if same days
                let lhsHour = lhs.monthlyComponents.localHour
                let rhsHour = rhs.monthlyComponents.localHour
                
                guard lhsHour != rhsHour else {
                    // earliest in hour comes first if same hour
                    let lhsMinute = lhs.monthlyComponents.localMinute
                    let rhsMinute = rhs.monthlyComponents.localMinute
                    
                    guard lhsMinute != rhsMinute else {
                        // smaller remidnerId comes first
                        return isLHSReminderBeforeRHSReminder(lhs: lhs, rhs: rhs)
                    }
                    // smaller minute comes first
                    return lhsMinute < rhsMinute
                }
                
                // smaller hour comes first
                return lhsHour < rhsHour
            }
            // smaller day comes first
            return lhsDay < rhsDay
        case .oneTime:
            // both oneTime
            let lhsDistanceToPast = Date().distance(to: lhs.oneTimeComponents.oneTimeDate)
            let rhsDistanceToPast = Date().distance(to: rhs.oneTimeComponents.oneTimeDate)
            
            guard lhsDistanceToPast != rhsDistanceToPast else {
                // if equal, then smaller reminderId comes first
                return isLHSReminderBeforeRHSReminder(lhs: lhs, rhs: rhs)
            }
            // not equal, the oldest one comes first
            return lhsDistanceToPast < rhsDistanceToPast
        }
    }
    
    // MARK: - Properties
    
    /// The reminderId given to this log from the Hound database
    var reminderId: Int?
    
    /// The UUID of this reminder that is generated locally upon creation. Useful in identifying the reminder before/in the process of creating it
    var reminderUUID: UUID = UUID()
    
    /// This is a user selected label for the reminder. It dictates the name that is displayed in the UI for this reminder.
    var reminderActionTypeId: Int = ClassConstant.ReminderConstant.defaultReminderActionTypeId
    
    var reminderActionType: ReminderActionType {
        return ReminderActionType.find(forReminderActionTypeId: reminderActionTypeId)
    }
    
    private var storedReminderCustomActionName: String = ""
    var reminderCustomActionName: String {
        get {
            return storedReminderCustomActionName
        }
        set {
            storedReminderCustomActionName = String((newValue.trimmingCharacters(in: .whitespacesAndNewlines)).prefix(ClassConstant.ReminderConstant.reminderCustomActionNameCharacterLimit))
        }
    }
    
    /// Tells the reminder what components to use to make sure its in the correct timing style. Changing this changes between countdown, weekly, monthly, and oneTime mode.
    private(set) var reminderType: ReminderType = ClassConstant.ReminderConstant.defaultReminderType
    /// Changes reminderType invokes resetForNextAlarm if reminderType is different than the current one
    func changeReminderType(forReminderType: ReminderType) {
        reminderType = forReminderType
        
        if forReminderType != reminderType {
            // If switching to a different reminder type, reset all of thew components
            resetForNextAlarm()
        }
    }
    
    /// This is what the reminder should base its timing off it. This is either the last time a user responded to a reminder alarm or the last time a user changed a timing related property of the reminder. For example, 5 minutes into the timer you change the countdown from 30 minutes to 15. To start the timer fresh, having it count down from the moment it was changed, reset reminderExecutionBasis to Date()
    private(set) var reminderExecutionBasis: Date = ClassConstant.ReminderConstant.defaultReminderExecutionBasis
    
    private(set) var reminderIsTriggerResult: Bool = false
    
    private var storedReminderIsEnabled: Bool = ClassConstant.ReminderConstant.defaultReminderIsEnabled
    /// Whether or not the reminder  is enabled, if disabled all reminders will not fire.
    var reminderIsEnabled: Bool {
        get {
            storedReminderIsEnabled
        }
        set {
            // going from disable to enabled
            if reminderIsEnabled == false && newValue == true {
                resetForNextAlarm()
            }
            
            storedReminderIsEnabled = newValue
        }
    }
    
    // Reminder Components
    
    private(set) var countdownComponents: CountdownComponents = CountdownComponents()
    
    private(set) var weeklyComponents: WeeklyComponents = WeeklyComponents()
    
    private(set) var monthlyComponents: MonthlyComponents = MonthlyComponents()
    
    private(set) var oneTimeComponents: OneTimeComponents = OneTimeComponents()
    
    private(set) var snoozeComponents: SnoozeComponents = SnoozeComponents()
    
    /// Components that are used to track an object to determine whether it was synced with the Hound server and whether it needs to be when the device comes back online
    private(set) var offlineModeComponents: OfflineModeComponents = OfflineModeComponents()
    
    // MARK: - Main
    
    init(
        forReminderId: Int? = nil,
        forReminderUUID: UUID? = nil,
        forReminderActionTypeId: Int? = nil,
        forReminderCustomActionName: String? = nil,
        forReminderType: ReminderType? = nil,
        forReminderExecutionBasis: Date? = nil,
        forReminderIsTriggerResult: Bool? = nil,
        forReminderIsEnabled: Bool? = nil,
        forCountdownComponents: CountdownComponents? = nil,
        forWeeklyComponents: WeeklyComponents? = nil,
        forMonthlyComponents: MonthlyComponents? = nil,
        forOneTimeComponents: OneTimeComponents? = nil,
        forSnoozeComponents: SnoozeComponents? = nil,
        forOfflineModeComponents: OfflineModeComponents? = nil
    ) {
        super.init()
        
        self.reminderId = forReminderId ?? reminderId
        self.reminderUUID = forReminderUUID ?? reminderUUID
        self.reminderActionTypeId = forReminderActionTypeId ?? reminderActionTypeId
        self.reminderCustomActionName = forReminderCustomActionName ?? reminderCustomActionName
        self.reminderType = forReminderType ?? reminderType
        self.reminderExecutionBasis = forReminderExecutionBasis ?? reminderExecutionBasis
        self.reminderIsTriggerResult = forReminderIsTriggerResult ?? reminderIsTriggerResult
        self.reminderIsEnabled = forReminderIsEnabled ?? reminderIsEnabled
        
        self.countdownComponents = forCountdownComponents ?? countdownComponents
        self.weeklyComponents = forWeeklyComponents ?? weeklyComponents
        self.monthlyComponents = forMonthlyComponents ?? monthlyComponents
        self.oneTimeComponents = forOneTimeComponents ?? oneTimeComponents
        self.snoozeComponents = forSnoozeComponents ?? snoozeComponents
        self.offlineModeComponents = forOfflineModeComponents ?? offlineModeComponents
    }
    
    /// Provide a dictionary literal of reminder properties to instantiate reminder. Optionally, provide a reminder to override with new properties from fromBody.
    convenience init?(fromBody: [String: Any?], reminderToOverride: Reminder?) {
        // Don't pull reminderId or reminderIsDeleted from reminderToOverride. A valid fromBody needs to provide this itself
        let reminderId: Int? = fromBody[KeyConstant.reminderId.rawValue] as? Int
        let reminderUUID: UUID? = UUID.fromString(forUUIDString: fromBody[KeyConstant.reminderUUID.rawValue] as? String)
        let reminderLastModified: Date? = (fromBody[KeyConstant.reminderLastModified.rawValue] as? String)?.formatISO8601IntoDate()
        let reminderIsDeleted: Bool? = fromBody[KeyConstant.reminderIsDeleted.rawValue] as? Bool
        
        // The body needs an id, uuid, and isDeleted to be intrepreted as same, updated, or deleted. Otherwise, it is invalid
        guard let reminderId = reminderId, let reminderUUID = reminderUUID, let reminderLastModified = reminderLastModified, let reminderIsDeleted = reminderIsDeleted else {
            return nil
        }
        
        guard reminderIsDeleted == false else {
            // The reminder has been deleted. Doesn't matter if our offline mode any changes
            return nil
        }
        
        // If we have pulled an update from the server which is more outdated than our local change, then ignore the data from the server. Otherwise, the newer update takes precedence over our update
        if let reminderToOverride = reminderToOverride, let initialAttemptedSyncDate = reminderToOverride.offlineModeComponents.initialAttemptedSyncDate, initialAttemptedSyncDate >= reminderLastModified {
            self.init(
                forReminderId: reminderToOverride.reminderId,
                forReminderUUID: reminderToOverride.reminderUUID,
                forReminderActionTypeId: reminderToOverride.reminderActionTypeId,
                forReminderCustomActionName: reminderToOverride.reminderCustomActionName,
                forReminderType: reminderToOverride.reminderType,
                forReminderExecutionBasis: reminderToOverride.reminderExecutionBasis,
                forReminderIsTriggerResult: reminderToOverride.reminderIsTriggerResult,
                forReminderIsEnabled: reminderToOverride.reminderIsEnabled,
                forCountdownComponents: reminderToOverride.countdownComponents,
                forWeeklyComponents: reminderToOverride.weeklyComponents,
                forMonthlyComponents: reminderToOverride.monthlyComponents,
                forOneTimeComponents: reminderToOverride.oneTimeComponents,
                forSnoozeComponents: reminderToOverride.snoozeComponents,
                forOfflineModeComponents: reminderToOverride.offlineModeComponents
            )
            return
        }
        
        // if the reminder is the same, then we pull values from reminderToOverride
        // if the reminder is updated, then we pull values from fromBody
        // reminder
        let reminderActionTypeId: Int? = fromBody[KeyConstant.reminderActionTypeId.rawValue] as? Int ?? reminderToOverride?.reminderActionTypeId
        let reminderCustomActionName: String? = fromBody[KeyConstant.reminderCustomActionName.rawValue] as? String
        let reminderType: ReminderType? = {
            guard let reminderTypeString = fromBody[KeyConstant.reminderType.rawValue] as? String else {
                return nil
            }
            return ReminderType(rawValue: reminderTypeString)
        }() ?? reminderToOverride?.reminderType
        let reminderExecutionBasis: Date? = {
            guard let reminderExecutionBasisString = fromBody[KeyConstant.reminderExecutionBasis.rawValue] as? String else {
                return nil
            }
            return reminderExecutionBasisString.formatISO8601IntoDate()
        }() ?? reminderToOverride?.reminderExecutionBasis
        let reminderIsTriggerResult: Bool? = fromBody[KeyConstant.reminderIsTriggerResult.rawValue] as? Bool ?? reminderToOverride?.reminderIsTriggerResult
        let reminderIsEnabled: Bool? = fromBody[KeyConstant.reminderIsEnabled.rawValue] as? Bool ?? reminderToOverride?.reminderIsEnabled
        
        // no properties should be nil. Either a complete fromBody should be provided (i.e. no previousDogManagerSynchronization was used in query) or a potentially partial fromBody (i.e. previousDogManagerSynchronization used in query) should be passed with an dogReminderManagerToOverride
        // reminderCustomActionName can be nil
        guard let reminderActionTypeId = reminderActionTypeId, let reminderCustomActionName = reminderCustomActionName, let reminderType = reminderType, let reminderExecutionBasis = reminderExecutionBasis, let reminderIsTriggerResult = reminderIsTriggerResult, let reminderIsEnabled = reminderIsEnabled else {
            // halt and don't do anything more, reached an invalid state
            return nil
        }
        
        // countdown
        let countdownExecutionInterval: Double? = fromBody[KeyConstant.countdownExecutionInterval.rawValue] as? Double ?? reminderToOverride?.countdownComponents.executionInterval
        
        guard let countdownExecutionInterval = countdownExecutionInterval else {
            // halt and don't do anything more, reached an invalid state
            return nil
        }
        
        // weekly
        let weeklyUTCHour: Int? = fromBody[KeyConstant.weeklyUTCHour.rawValue] as? Int ?? reminderToOverride?.weeklyComponents.UTCHour
        let weeklyUTCMinute: Int? = fromBody[KeyConstant.weeklyUTCMinute.rawValue] as? Int ?? reminderToOverride?.weeklyComponents.UTCMinute
        let weeklySkippedDate: Date? = {
            guard let weeklySkippedDateString = fromBody[KeyConstant.weeklySkippedDate.rawValue] as? String else {
                return nil
            }
            return weeklySkippedDateString.formatISO8601IntoDate()
        }() ?? reminderToOverride?.weeklyComponents.skippedDate
        let weeklySunday: Bool? = fromBody[KeyConstant.weeklySunday.rawValue] as? Bool ?? reminderToOverride?.weeklyComponents.weekdays.contains(1)
        let weeklyMonday: Bool? = fromBody[KeyConstant.weeklyMonday.rawValue] as? Bool ?? reminderToOverride?.weeklyComponents.weekdays.contains(2)
        let weeklyTuesday: Bool? = fromBody[KeyConstant.weeklyTuesday.rawValue] as? Bool ?? reminderToOverride?.weeklyComponents.weekdays.contains(3)
        let weeklyWednesday: Bool? = fromBody[KeyConstant.weeklyWednesday.rawValue] as? Bool ?? reminderToOverride?.weeklyComponents.weekdays.contains(4)
        let weeklyThursday: Bool? = fromBody[KeyConstant.weeklyThursday.rawValue] as? Bool ?? reminderToOverride?.weeklyComponents.weekdays.contains(5)
        let weeklyFriday: Bool? = fromBody[KeyConstant.weeklyFriday.rawValue] as? Bool ?? reminderToOverride?.weeklyComponents.weekdays.contains(6)
        let weeklySaturday: Bool? = fromBody[KeyConstant.weeklySaturday.rawValue] as? Bool ?? reminderToOverride?.weeklyComponents.weekdays.contains(7)
        
        // weeklySkippedDate can be nil
        guard let weeklyUTCHour = weeklyUTCHour, let weeklyUTCMinute = weeklyUTCMinute, let weeklySunday = weeklySunday, let weeklyMonday = weeklyMonday, let weeklyTuesday = weeklyTuesday, let weeklyWednesday = weeklyWednesday, let weeklyThursday = weeklyThursday, let weeklyFriday = weeklyFriday, let weeklySaturday = weeklySaturday else {
            // halt and don't do anything more, reached an invalid state
            return nil
        }
        
        // monthly
        let monthlyUTCDay: Int? = fromBody[KeyConstant.monthlyUTCDay.rawValue] as? Int ?? reminderToOverride?.monthlyComponents.UTCDay
        let monthlyUTCHour: Int? = fromBody[KeyConstant.monthlyUTCHour.rawValue] as? Int ?? reminderToOverride?.monthlyComponents.UTCHour
        let monthlyUTCMinute: Int? = fromBody[KeyConstant.monthlyUTCMinute.rawValue] as? Int ?? reminderToOverride?.monthlyComponents.UTCMinute
        let monthlySkippedDate: Date? = {
            guard let monthlySkippedDateString = fromBody[KeyConstant.monthlySkippedDate.rawValue] as? String else {
                return nil
            }
            return monthlySkippedDateString.formatISO8601IntoDate()
        }() ?? reminderToOverride?.monthlyComponents.skippedDate
        
        // monthlySkippedDate can be nil
        guard let monthlyUTCDay = monthlyUTCDay, let monthlyUTCHour = monthlyUTCHour, let monthlyUTCMinute = monthlyUTCMinute else {
            // halt and don't do anything more, reached an invalid state
            return nil
        }
        
        // one time
        let oneTimeDate: Date? = {
            guard let oneTimeDateString = fromBody[KeyConstant.oneTimeDate.rawValue] as? String else {
                return nil
            }
            return oneTimeDateString.formatISO8601IntoDate()
        }() ?? reminderToOverride?.oneTimeComponents.oneTimeDate
        
        guard let oneTimeDate = oneTimeDate else {
            // halt and don't do anything more, reached an invalid state
            return nil
        }
        
        // snooze
        
        let snoozeExecutionInterval = fromBody[KeyConstant.snoozeExecutionInterval.rawValue] as? Double ?? reminderToOverride?.snoozeComponents.executionInterval
        
        // snoozeExecutionInterval can be nil
        
        self.init(
            forReminderId: reminderId,
            forReminderUUID: reminderUUID,
            forReminderActionTypeId: reminderActionTypeId,
            forReminderCustomActionName: reminderCustomActionName,
            forReminderType: reminderType,
            forReminderExecutionBasis: reminderExecutionBasis,
            forReminderIsTriggerResult: reminderIsTriggerResult,
            forReminderIsEnabled: reminderIsEnabled,
            forCountdownComponents: CountdownComponents(forExecutionInterval: countdownExecutionInterval),
            forWeeklyComponents: WeeklyComponents(
                UTCHour: weeklyUTCHour,
                UTCMinute: weeklyUTCMinute,
                skippedDate: weeklySkippedDate,
                sunday: weeklySunday,
                monday: weeklyMonday,
                tuesday: weeklyTuesday,
                wednesday: weeklyWednesday,
                thursday: weeklyThursday,
                friday: weeklyFriday,
                saturday: weeklySaturday
            ), forMonthlyComponents: MonthlyComponents(
                UTCDay: monthlyUTCDay,
                UTCHour: monthlyUTCHour,
                UTCMinute: monthlyUTCMinute,
                skippedDate: monthlySkippedDate
            ), forOneTimeComponents: OneTimeComponents(
                date: oneTimeDate
            ), forSnoozeComponents: SnoozeComponents(
                executionInterval: snoozeExecutionInterval
                // Verified that the update from the server happened more recently than our local changes, so no need to offline sync anymore
            ), forOfflineModeComponents: nil
        )
    }
    
    // MARK: - Timing
    
    var intervalRemaining: Double? {
        guard snoozeComponents.executionInterval == nil else {
            return snoozeComponents.executionInterval
        }
        
        switch reminderType {
        case .oneTime:
            return Date().distance(to: oneTimeComponents.oneTimeDate)
        case .countdown:
            // the time is supposed to countdown for minus the time it has countdown
            return countdownComponents.executionInterval
        case .weekly:
            if self.reminderExecutionBasis.distance(to: self.weeklyComponents.previousExecutionDate(forReminderExecutionBasis: self.reminderExecutionBasis)) > 0 {
                return nil
            }
            else {
                return Date().distance(to: self.weeklyComponents.nextExecutionDate(forReminderExecutionBasis: self.reminderExecutionBasis))
            }
        case .monthly:
            if self.reminderExecutionBasis.distance(to:
                                                        self.monthlyComponents.previousExecutionDate(forReminderExecutionBasis: self.reminderExecutionBasis)) > 0 {
                return nil
            }
            else {
                return Date().distance(to: self.monthlyComponents.nextExecutionDate(forReminderExecutionBasis: self.reminderExecutionBasis))
            }
        }
    }
    
    var reminderExecutionDate: Date? {
        // the reminder will not go off if disabled or the family is paused
        guard reminderIsEnabled == true else {
            return nil
        }
        
        guard let intervalRemaining = intervalRemaining else {
            // If the intervalRemaining is nil than means there is no time left
            return Date()
        }
        
        guard snoozeComponents.executionInterval == nil else {
            return Date(timeInterval: intervalRemaining, since: reminderExecutionBasis)
        }
        
        switch reminderType {
        case .oneTime:
            return oneTimeComponents.oneTimeDate
        case .countdown:
            return Date(timeInterval: intervalRemaining, since: reminderExecutionBasis)
        case .weekly:
            return weeklyComponents.nextExecutionDate(forReminderExecutionBasis: self.reminderExecutionBasis)
        case .monthly:
            return monthlyComponents.nextExecutionDate(forReminderExecutionBasis: self.reminderExecutionBasis)
        }
    }
    
    /// Restores the reminder to a state where it is ready for its next alarm. This resets reminderExecutionBasis, clears skippedDates, and clears snooze. Typically use if reminder's alarm executed and user responded to it or if reminder's timing has updated and needs a complete reset.
    func resetForNextAlarm() {
        reminderExecutionBasis = Date()
        
        snoozeComponents.executionInterval = nil
        weeklyComponents.skippedDate = nil
        monthlyComponents.skippedDate = nil
    }
    
    /// Finds the date which the reminder should be transformed from isSkipping to not isSkipping. This is the date at which the skipped reminder would have occured.
    var disableIsSkippingDate: Date? {
        guard reminderIsEnabled && snoozeComponents.executionInterval == nil else {
            return nil
        }
        
        if reminderType == .monthly && monthlyComponents.isSkipping == true {
            return monthlyComponents.notSkippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis)
        }
        else if reminderType == .weekly && weeklyComponents.isSkipping == true {
            return weeklyComponents.notSkippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis)
        }
        else {
            return nil
        }
    }
    
    /// Call this function when a user driven action directly intends to enable the skip status of the weekly or monthy components. This function only timing related data, no logs are added or removed. Additioanlly, if oneTime is getting skipped, it must be deleted externally.
    func enableIsSkipping(forSkippedDate: Date?) {
        // can't change is skipping on a disabled reminder. nothing to skip.
        guard reminderIsEnabled == true else {
            return
        }
        
        switch reminderType {
        case .oneTime: break
            // oneTime can't skip
        case .countdown:
            // countdown can skip
            resetForNextAlarm()
        case .weekly:
            // weekly can skip
            weeklyComponents.skippedDate = forSkippedDate
        case .monthly:
            // monthly can skip
            monthlyComponents.skippedDate = forSkippedDate
        }
    }
    
    /// Call this function when a user driven action directly intends to disable the skip status of the weekly or monthy components. This function only timing related data, no logs are added or removed.
    func disableIsSkipping() {
        // can't change is skipping on a disabled reminder. nothing to unskip.
        guard reminderIsEnabled == true else {
            return
        }
        
        switch reminderType {
        case .oneTime: break
            // oneTim can't unskip
        case .countdown: break
            // countdown can't unskip, only way to skip a countdown reminder is to reset it to restart its countdown
        case .weekly:
            // weekly can unskip
            weeklyComponents.skippedDate = nil
        case .monthly:
            // monthly can unskip
            monthlyComponents.skippedDate = nil
        }
    }
    
}

extension Reminder {
    
    // MARK: - Duplicate
    
    /// Copys a reminder then removes/resets certain properties. This allows a reminder to be an independent copy of a reminder (aka a duplicate) instead of an exact 1:1 clone
    func duplicate() -> Reminder? {
        guard let duplicate = self.copy() as? Reminder else {
            return nil
        }
        
        duplicate.reminderId = nil
        duplicate.reminderUUID = UUID()
        duplicate.reminderExecutionBasis = ClassConstant.ReminderConstant.defaultReminderExecutionBasis
        
        duplicate.snoozeComponents = SnoozeComponents()
        duplicate.offlineModeComponents = OfflineModeComponents()
        
        duplicate.resetForNextAlarm()
        
        return duplicate
    }
    
    // MARK: - Compare
    
    /// Returns true if all the server synced properties for the reminder are the same. This includes all the base properties here (yes the reminderId too) and the reminder components for the corresponding reminderActionTypeId
    func isSame(asReminder reminder: Reminder) -> Bool {
        if reminderId != reminder.reminderId {
            return false
        }
        else if reminderUUID != reminder.reminderUUID {
            return false
        }
        else if reminderActionTypeId != reminder.reminderActionTypeId {
            return false
        }
        else if reminderCustomActionName != reminder.reminderCustomActionName {
            return false
        }
        // reminder types (countdown, weekly, monthly, one time)
        else if reminderType != reminder.reminderType {
            return false
        }
        else if reminderExecutionBasis != reminder.reminderExecutionBasis {
            return false
        }
        else if reminderIsEnabled != reminder.reminderIsEnabled {
            return false
        }
        
        // known at this point that the reminderTypes are the same
        switch reminderType {
        case .countdown:
            if countdownComponents.executionInterval != reminder.countdownComponents.executionInterval {
                return false
            }
        case .weekly:
            if weeklyComponents.UTCHour != reminder.weeklyComponents.UTCHour {
                return false
            }
            else if weeklyComponents.UTCMinute != reminder.weeklyComponents.UTCMinute {
                return false
            }
            else if weeklyComponents.weekdays != reminder.weeklyComponents.weekdays {
                return false
            }
            else if weeklyComponents.isSkipping != reminder.weeklyComponents.isSkipping {
                return false
            }
            else if weeklyComponents.skippedDate != reminder.weeklyComponents.skippedDate {
                return false
            }
        case .monthly:
            if monthlyComponents.UTCHour != reminder.monthlyComponents.UTCHour {
                return false
            }
            else if monthlyComponents.UTCMinute != reminder.monthlyComponents.UTCMinute {
                return false
            }
            else if monthlyComponents.UTCDay != reminder.monthlyComponents.UTCDay {
                return false
            }
            else if monthlyComponents.isSkipping != reminder.monthlyComponents.isSkipping {
                return false
            }
            else if monthlyComponents.skippedDate != reminder.monthlyComponents.skippedDate {
                return false
            }
        case .oneTime:
            if oneTimeComponents.oneTimeDate != reminder.oneTimeComponents.oneTimeDate {
                return false
            }
        }
        
        if snoozeComponents.executionInterval != reminder.snoozeComponents.executionInterval {
            return false
        }
        
        return true
    }
    
    // MARK: - Request
    
    /// Returns an array literal of the reminders's properties. This is suitable to be used as the JSON body for a HTTP request
    func createBody(forDogUUID: UUID) -> [String: CompatibleDataTypeForJSON?] {
        var body: [String: CompatibleDataTypeForJSON?] = [:]
        body[KeyConstant.dogUUID.rawValue] = forDogUUID.uuidString
        body[KeyConstant.reminderId.rawValue] = reminderId
        body[KeyConstant.reminderUUID.rawValue] = reminderUUID.uuidString
        body[KeyConstant.reminderActionTypeId.rawValue] = reminderActionTypeId
        body[KeyConstant.reminderCustomActionName.rawValue] = reminderCustomActionName
        body[KeyConstant.reminderType.rawValue] = reminderType.rawValue
        body[KeyConstant.reminderExecutionBasis.rawValue] = reminderExecutionBasis.ISO8601FormatWithFractionalSeconds()
        body[KeyConstant.reminderExecutionDate.rawValue] = reminderExecutionDate?.ISO8601FormatWithFractionalSeconds()
        body[KeyConstant.reminderIsTriggerResult.rawValue] = reminderIsTriggerResult
        body[KeyConstant.reminderIsEnabled.rawValue] = reminderIsEnabled
        
        // snooze
        body[KeyConstant.snoozeExecutionInterval.rawValue] = snoozeComponents.executionInterval
        
        // countdown
        body[KeyConstant.countdownExecutionInterval.rawValue] = countdownComponents.executionInterval
        
        // weekly
        body[KeyConstant.weeklyUTCHour.rawValue] = weeklyComponents.UTCHour
        body[KeyConstant.weeklyUTCMinute.rawValue] = weeklyComponents.UTCMinute
        body[KeyConstant.weeklySkippedDate.rawValue] = weeklyComponents.skippedDate?.ISO8601FormatWithFractionalSeconds()
        
        body[KeyConstant.weeklySunday.rawValue] = false
        body[KeyConstant.weeklyMonday.rawValue] = false
        body[KeyConstant.weeklyTuesday.rawValue] = false
        body[KeyConstant.weeklyWednesday.rawValue] = false
        body[KeyConstant.weeklyThursday.rawValue] = false
        body[KeyConstant.weeklyFriday.rawValue] = false
        body[KeyConstant.weeklySaturday.rawValue] = false
        
        for weekday in weeklyComponents.weekdays {
            switch weekday {
            case 1:
                body[KeyConstant.weeklySunday.rawValue] = true
            case 2:
                body[KeyConstant.weeklyMonday.rawValue] = true
            case 3:
                body[KeyConstant.weeklyTuesday.rawValue] = true
            case 4:
                body[KeyConstant.weeklyWednesday.rawValue] = true
            case 5:
                body[KeyConstant.weeklyThursday.rawValue] = true
            case 6:
                body[KeyConstant.weeklyFriday.rawValue] = true
            case 7:
                body[KeyConstant.weeklySaturday.rawValue] = true
            default:
                continue
            }
        }
        
        // monthly
        body[KeyConstant.monthlyUTCDay.rawValue] = monthlyComponents.UTCDay
        body[KeyConstant.monthlyUTCHour.rawValue] = monthlyComponents.UTCHour
        body[KeyConstant.monthlyUTCMinute.rawValue] = monthlyComponents.UTCMinute
        body[KeyConstant.monthlySkippedDate.rawValue] = monthlyComponents.skippedDate?.ISO8601FormatWithFractionalSeconds()
        
        // one time
        body[KeyConstant.oneTimeDate.rawValue] = oneTimeComponents.oneTimeDate.ISO8601FormatWithFractionalSeconds()
        
        return body
    }
}
//
//  Reminder.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/20/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class DogReminderManager: NSObject, NSCoding, NSCopying {

    // MARK: - NSCopying

    func copy(with zone: NSZone? = nil) -> Any {
        let copy = DogReminderManager()
        for dogReminder in dogReminders {
            if let reminderCopy = dogReminder.copy() as? Reminder {
                copy.dogReminders.append(reminderCopy)            }
        }
        return copy
    }

    // MARK: - NSCoding

    required init?(coder aDecoder: NSCoder) {
        dogReminders = aDecoder.decodeOptionalObject(forKey: KeyConstant.dogReminders.rawValue) ?? dogReminders
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogReminders, forKey: KeyConstant.dogReminders.rawValue)
    }

    // MARK: - Properties

    /// Array of dogReminders
    private(set) var dogReminders: [Reminder] = []

    // MARK: - Main

    override init() {
        super.init()
    }

    init(forReminders: [Reminder] = []) {
        super.init()
        addReminders(forReminders: forReminders)
    }

    /// Provide an array of dictionary literal of reminder properties to instantiate dogReminders. Provide a reminderManager to have the dogReminders add themselves into, update themselves in, or delete themselves from.
    convenience init(fromReminderBodies: [[String: Any?]], dogReminderManagerToOverride: DogReminderManager?) {
        self.init(forReminders: dogReminderManagerToOverride?.dogReminders ?? [])

        for fromBody in fromReminderBodies {
            // Don't pull properties from reminderToOverride. A valid fromBody needs to provide this itself
            let reminderId = fromBody[KeyConstant.reminderId.rawValue] as? Int
            let reminderUUID = UUID.fromString(forUUIDString: fromBody[KeyConstant.reminderUUID.rawValue] as? String)
            let reminderIsDeleted = fromBody[KeyConstant.reminderIsDeleted.rawValue] as? Bool

            guard reminderId != nil, let reminderUUID = reminderUUID, let reminderIsDeleted = reminderIsDeleted else {
                // couldn't construct essential components to intrepret reminder
                continue
            }

            guard reminderIsDeleted == false else {
                removeReminder(forReminderUUID: reminderUUID)
                continue
            }

            if let reminder = Reminder(fromBody: fromBody, reminderToOverride: findReminder(forReminderUUID: reminderUUID)) {
                addReminder(forReminder: reminder)
            }
        }
    }

    // MARK: - Functions
    
    /// finds and returns the reference of a reminder matching the given forReminderUUID
    func findReminder(forReminderUUID: UUID) -> Reminder? {
        dogReminders.first(where: { $0.reminderUUID == forReminderUUID })
    }

    /// Helper function allows us to use the same logic for addReminder and addReminders and allows us to only sort at the end. Without this function, addReminders would invoke addReminder repeadly and sortReminders() with each call.
    private func addReminderWithoutSorting(forReminder: Reminder) {
        dogReminders.removeAll { reminder in
            return reminder.reminderUUID == forReminder.reminderUUID
        }

        dogReminders.append(forReminder)
    }

    /// If a reminder with the same UUID is already present, removes it. Then adds the new dogReminders
    func addReminder(forReminder: Reminder) {

        addReminderWithoutSorting(forReminder: forReminder)

        dogReminders.sort(by: { $0 <= $1 })
    }

    /// Invokes addReminder(forReminder: Reminder) for newReminder.count times (but only sorts once at the end to be more efficent)
    func addReminders(forReminders: [Reminder]) {
        for forReminder in forReminders {
            addReminderWithoutSorting(forReminder: forReminder)
        }

        dogReminders.sort(by: { $0 <= $1 })
    }

    /// Returns true if it removed at least one reminder with the same reminderUUID
    @discardableResult func removeReminder(forReminderUUID: UUID) -> Bool {
        var didRemoveObject = false
        
        dogReminders.removeAll { reminder in
            guard reminder.reminderUUID == forReminderUUID else {
                return false
            }
            
            didRemoveObject = true
            return true
        }
        
        return didRemoveObject
    }
}
//
//  PreviousReminderCustomActionName.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/6/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

class PreviousReminderCustomActionName: NSObject, NSCoding {

    // MARK: - NSCoding

    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let decodedReminderActionTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.reminderActionTypeId.rawValue),
            let decodedReminderCustomActionName = aDecoder.decodeOptionalString(forKey: KeyConstant.reminderCustomActionName.rawValue)
        else {
            return nil
        }
        self.init(reminderActionTypeId: decodedReminderActionTypeId, reminderCustomActionName: decodedReminderCustomActionName)
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(reminderActionTypeId, forKey: KeyConstant.reminderActionTypeId.rawValue)
        aCoder.encode(reminderCustomActionName, forKey: KeyConstant.reminderCustomActionName.rawValue)
    }

    // MARK: - Properties
    
    private(set) var reminderActionTypeId: Int
    private(set) var reminderCustomActionName: String
    
    // MARK: - Main
    
    init(reminderActionTypeId: Int, reminderCustomActionName: String) {
        self.reminderActionTypeId = reminderActionTypeId
        self.reminderCustomActionName = reminderCustomActionName
        super.init()
    }
    
}
//
//  ReminderComponent.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

protocol ReminderComponent {
    /// The overarching interval that determines when the reminder repeats. For example: the "Every" in "Every 2 hours" or the "Monday" in "Monday at 8:00AM".
    var readableRecurranceInterval: String { get }
    /// The time of day interval that determines when the reminder repeats. For example: the "2 hours" in "Every 2 hours" or the "8:00AM" in "Monday at 8:00AM".
    var readableTimeOfDayInterval: String { get }
    /// The full interval that determines when the reminder repeats: For example: "Every 2 hours" or "Monday at 8:00AM"
    var readableInterval: String { get }
}
//
//  countdownComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class CountdownComponents: NSObject, NSCoding, NSCopying, ReminderComponent {

    // MARK: - NSCopying

    func copy(with zone: NSZone? = nil) -> Any {
        let copy = CountdownComponents()
        copy.executionInterval = executionInterval
        return copy
    }

    // MARK: - NSCoding

    required convenience init?(coder aDecoder: NSCoder) {
        let decodedExecutionInterval: Double? = aDecoder.decodeOptionalDouble(forKey: KeyConstant.countdownExecutionInterval.rawValue)
        self.init(forExecutionInterval: decodedExecutionInterval)
    }

    func encode(with aCoder: NSCoder) {
        aCoder.encode(executionInterval, forKey: KeyConstant.countdownExecutionInterval.rawValue)
    }

    // MARK: - Properties

    var readableRecurranceInterval: String {
        return "Every"
    }
    
    var readableTimeOfDayInterval: String {
        return executionInterval.readable(capitalizeWords: true, abreviateWords: false)
    }
    
    var readableInterval: String {
        return readableRecurranceInterval.appending(" \(readableTimeOfDayInterval)")
    }

    /// Interval at which a countdown should be last for reminder
    var executionInterval: Double

    // MARK: - Main

    init(
        forExecutionInterval: Double? = nil
    ) {
        self.executionInterval = forExecutionInterval ?? ClassConstant.ReminderComponentConstant.defaultCountdownExecutionInterval
        super.init()
    }

}
//
//  SnoozeComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class SnoozeComponents: NSObject, NSCoding, NSCopying {

    // MARK: - NSCopying

    func copy(with zone: NSZone? = nil) -> Any {
        let copy = SnoozeComponents()
        copy.executionInterval = executionInterval
        return copy
    }

    // MARK: - NSCoding

    required init?(coder aDecoder: NSCoder) {
        executionInterval = aDecoder.decodeOptionalDouble(forKey: KeyConstant.snoozeExecutionInterval.rawValue)
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        if let executionInterval = executionInterval {
            aCoder.encode(executionInterval, forKey: KeyConstant.snoozeExecutionInterval.rawValue)
        }
    }

    // MARK: - Properties

    /// Interval at which a snooze should be last for reminder. If this value isn't nil, then the reminder is snoozing.
    var executionInterval: Double?

    // MARK: - Main

    override init() {
        super.init()
    }

    convenience init(executionInterval: Double?) {
        self.init()

        self.executionInterval = executionInterval
    }

}
//
//  MonthlyComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class MonthlyComponents: NSObject, NSCoding, NSCopying, ReminderComponent {

    // MARK: - NSCopying

    func copy(with zone: NSZone? = nil) -> Any {
        let copy = MonthlyComponents()
        copy.UTCDay = self.UTCDay
        copy.UTCHour = self.UTCHour
        copy.UTCMinute = self.UTCMinute
        copy.skippedDate = self.skippedDate
        return copy
    }

    // MARK: - NSCoding

    required init?(coder aDecoder: NSCoder) {
        UTCDay = aDecoder.decodeOptionalInteger(forKey: KeyConstant.monthlyUTCDay.rawValue) ?? UTCDay
        UTCHour = aDecoder.decodeOptionalInteger(forKey: KeyConstant.monthlyUTCHour.rawValue) ?? UTCHour
        UTCMinute = aDecoder.decodeOptionalInteger(forKey: KeyConstant.monthlyUTCMinute.rawValue) ?? UTCMinute
        skippedDate = aDecoder.decodeOptionalObject(forKey: KeyConstant.monthlySkippedDate.rawValue)
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        aCoder.encode(UTCDay, forKey: KeyConstant.monthlyUTCDay.rawValue)
        aCoder.encode(UTCHour, forKey: KeyConstant.monthlyUTCHour.rawValue)
        aCoder.encode(UTCMinute, forKey: KeyConstant.monthlyUTCMinute.rawValue)
        if let skippedDate = skippedDate {
            aCoder.encode(skippedDate, forKey: KeyConstant.monthlySkippedDate.rawValue)
        }
    }

    // MARK: - Properties
    
    var readableRecurranceInterval: String {
        return "Every \(UTCDay)\(UTCDay.daySuffix())"
    }
    
    var readableTimeOfDayInterval: String {
        return String.convertToReadable(fromUTCHour: UTCHour, fromUTCMinute: UTCMinute)
    }
    
    var readableInterval: String {
        return readableRecurranceInterval.appending(" \(readableTimeOfDayInterval)")
    }

    /// Hour of the day that that the reminder should fire in GMT+0000. [1, 31]
    private(set) var UTCDay: Int = ClassConstant.ReminderComponentConstant.defaultUTCDay
    /// Throws if not within the range of [1,31]
    func changeUTCDay(forDate: Date) {
        UTCDay = Calendar.UTCCalendar.component(.day, from: forDate)
    }

    /// Hour of the day that that the reminder should fire in GMT+0000. [0, 23]
    private(set) var UTCHour: Int = ClassConstant.ReminderComponentConstant.defaultUTCHour
    /// UTCHour but converted to the hour in the user's timezone
    var localHour: Int {
        let hoursFromUTC = Calendar.current.timeZone.secondsFromGMT() / 3600
        var localHour = UTCHour + hoursFromUTC
        // localHour could be negative, so roll over into positive
        localHour += 24
        // Make sure localHour [0, 23]
        localHour = localHour % 24
        return localHour
    }
    /// Takes a given date and extracts the UTC Hour (GMT+0000) from it.
    func changeUTCHour(forDate: Date) {
        UTCHour = Calendar.UTCCalendar.component(.hour, from: forDate)
    }

    /// Minute of the day that that the reminder should fire in GMT+0000. [0, 59]
    private(set) var UTCMinute: Int = ClassConstant.ReminderComponentConstant.defaultUTCMinute
    /// UTCMinute but converted to the minute in the user's timezone
    var localMinute: Int {
        let minutesFromUTC = (Calendar.current.timeZone.secondsFromGMT() % 3600) / 60
        var localMinute = UTCMinute + minutesFromUTC
        // localMinute could be negative, so roll over into positive
        localMinute += 60
        // Make sure localMinute [0, 59]
        localMinute = localMinute % 60
        return localMinute
    }
    /// Takes a given date and extracts the UTC minute (GMT+0000) from it.
    func changeUTCMinute(forDate: Date) {
        UTCMinute = Calendar.UTCCalendar.component(.minute, from: forDate)
    }

    /// Whether or not the next alarm will be skipped
    var isSkipping: Bool {
        skippedDate != nil
    }

    /// The date at which the user changed the isSkipping to true.  If is skipping is true, then a certain log date was appended. If unskipped, then we have to remove that previously added log. Slight caveat: if the skip log was modified (by the user changing its date) we don't remove it.
    var skippedDate: Date?

    // MARK: - Main

    override init() {
        super.init()
    }

    convenience init(UTCDay: Int, UTCHour: Int, UTCMinute: Int, skippedDate: Date?) {
        self.init()
        self.UTCDay = UTCDay
        self.UTCHour = UTCHour
        self.UTCMinute = UTCMinute
        self.skippedDate = skippedDate

    }

    // MARK: - Functions

    /// This find the next execution date that takes place after the reminderExecutionBasis. It purposelly not factoring in isSkipping.
    func notSkippingExecutionDate(forReminderExecutionBasis reminderExecutionBasis: Date) -> Date {
        // there will only be two future executions dates for a day, so we take the first one is the one.
        return futureExecutionDates(forReminderExecutionBasis: reminderExecutionBasis).first ?? ClassConstant.DateConstant.default1970Date
    }

    func previousExecutionDate(forReminderExecutionBasis reminderExecutionBasis: Date) -> Date {
        let nextExecutionDate = notSkippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis)

        return fallShortCorrection(forDate:
                                    Calendar.UTCCalendar.date(byAdding: .month, value: -1, to: nextExecutionDate) ?? ClassConstant.DateConstant.default1970Date
        )
    }

    /// Factors in isSkipping to figure out the next time of day
    func nextExecutionDate(forReminderExecutionBasis reminderExecutionBasis: Date) -> Date {
        isSkipping ? skippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis) : notSkippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis)
    }

    // MARK: - Private Helper Functions

    //// If we add a month to the date, then it might be incorrect and lose accuracy. For example, our day is 31. We are in April so there is only 30 days. Therefore we get a calculated date of April 30th. After adding a month, the result date is May 30th, but it should be 31st because of our day and that May has 31 days. This corrects that.
    private func fallShortCorrection(forDate date: Date) -> Date {

        guard UTCDay > Calendar.UTCCalendar.component(.day, from: date) else {
            // when adding a month, the day did not fall short of what was needed
            return date
        }

        // when adding a month to the date, the day of month needed fell short of the intented day of month

        // We need to find the maximum possible day to set the date to without having it accidentially roll into the next month.
        let targetDayOfMonth: Int = {
            let neededDay = UTCDay
            guard let maximumDay = Calendar.UTCCalendar.range(of: .day, in: .month, for: date)?.count else {
                return neededDay
            }

            return neededDay <= maximumDay ? neededDay : maximumDay
        }()

        // We have the correct day to set the date to, now we can change it.
        return Calendar.UTCCalendar.date(bySetting: .day, value: targetDayOfMonth, of: date) ?? ClassConstant.DateConstant.default1970Date

    }

    /// Produces an array of at least two with all of the future dates that the reminder will fire given the day of month, hour, and minute
    private func futureExecutionDates(forReminderExecutionBasis reminderExecutionBasis: Date) -> [Date] {

        var futureExecutionDate = reminderExecutionBasis

        // finds number of days in the calculated date's month, used for roll over calculations
        guard let numberOfDaysInMonth = Calendar.UTCCalendar.range(of: .day, in: .month, for: futureExecutionDate)?.count else {
            return [ClassConstant.DateConstant.default1970Date, ClassConstant.DateConstant.default1970Date]
        }

        // We want to make sure that the day of month we are using isn't greater that the number of days in the target month. If it is, then we could accidentily roll over into the next month. For example, without this functionality, setting the day of Feburary to 31 would cause the date to roll into the next month. But, targetDayOfMonth limits the set to 28/29

        let targetDayOfMonth: Int = UTCDay <= numberOfDaysInMonth ? UTCDay : numberOfDaysInMonth

        // Set futureExecutionDate to the proper day of month
        futureExecutionDate = Calendar.UTCCalendar.date(bySetting: .day, value: targetDayOfMonth, of: futureExecutionDate) ?? ClassConstant.DateConstant.default1970Date

        // Set futureExecutionDate to the proper day of week
        futureExecutionDate = Calendar.UTCCalendar.date(bySettingHour: UTCHour, minute: UTCMinute, second: 0, of: futureExecutionDate, matchingPolicy: .nextTime, repeatedTimePolicy: .first, direction: .forward) ?? ClassConstant.DateConstant.default1970Date

        // We are looking for future dates, not past. Correct dates in past to make them in the future

        if reminderExecutionBasis.distance(to: futureExecutionDate) < 0 {
            // Correct for falling short when we add a month
            futureExecutionDate = fallShortCorrection(forDate: Calendar.UTCCalendar.date(byAdding: .month, value: 1, to: futureExecutionDate) ?? ClassConstant.DateConstant.default1970Date)
        }
        var futureExecutionDates = [futureExecutionDate]

        // futureExecutionDates should have at least two dates
        futureExecutionDates.append(
            fallShortCorrection(forDate:
                                    Calendar.UTCCalendar.date(byAdding: .month, value: 1, to: futureExecutionDate) ?? ClassConstant.DateConstant.default1970Date
                               )
        )

        futureExecutionDates.sort()

        return futureExecutionDates
    }

    /// If a reminder is skipping, then we must find the next soonest reminderExecutionDate. We have to find the execution date that takes place after the skipped execution date (but before any other execution date).
    private func skippingExecutionDate(forReminderExecutionBasis reminderExecutionBasis: Date) -> Date {

        let nextExecutionDate = notSkippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis)

        let futureExecutionDates = futureExecutionDates(forReminderExecutionBasis: reminderExecutionBasis)
        var soonestFutureExecutionDate: Date = futureExecutionDates.first(where: { futureExecutionDate in
            nextExecutionDate.distance(to: futureExecutionDate) > 0
        }) ?? ClassConstant.DateConstant.default1970Date

        // Attempt to find futureExecutionDates that are further in the future than nextExecutionDate while being closer to nextExecutionDate than soonestFutureExecutionDate
        for futureExecutionDate in futureExecutionDates where
        nextExecutionDate.distance(to: futureExecutionDate) > 0
        && nextExecutionDate.distance(to: futureExecutionDate) < nextExecutionDate.distance(to: soonestFutureExecutionDate) {
            soonestFutureExecutionDate = futureExecutionDate
        }

        return soonestFutureExecutionDate
    }

}
//
//  OneTimeComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class OneTimeComponents: NSObject, NSCoding, NSCopying, ReminderComponent {

    // MARK: - NSCopying

    func copy(with zone: NSZone? = nil) -> Any {
        let copy = OneTimeComponents()
        copy.oneTimeDate = self.oneTimeDate
        return copy
    }

    // MARK: - NSCoding

    required init?(coder aDecoder: NSCoder) {
        oneTimeDate = aDecoder.decodeOptionalObject(forKey: KeyConstant.oneTimeDate.rawValue) ?? oneTimeDate
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeInteger, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(oneTimeDate, forKey: KeyConstant.oneTimeDate.rawValue)
    }

    // MARK: - Properties
    
    var readableRecurranceInterval: String {
        let dateYear = Calendar.current.component(.year, from: oneTimeDate)
        let currentYear = Calendar.current.component(.year, from: Date())
        
        let dateFormatter = DateFormatter()
        // January 25 OR January 25, 2023
        dateFormatter.setLocalizedDateFormatFromTemplate(dateYear == currentYear ? "MMMMd" : "MMMMdyyyy")

        return dateFormatter.string(from: oneTimeDate)
    }
    
    var readableTimeOfDayInterval: String {
        let dateFormatter = DateFormatter()
        // 7:53 AM
        dateFormatter.setLocalizedDateFormatFromTemplate("hma")

        return dateFormatter.string(from: oneTimeDate)
    }
    
    var readableInterval: String {
        return readableRecurranceInterval.appending(" \(readableTimeOfDayInterval)")
    }

    /// The Date that the alarm should fire
    var oneTimeDate: Date = Date()

    // MARK: - Main

    override init() {
        super.init()
    }

    convenience init(date: Date) {
        self.init()
        self.oneTimeDate = date
    }

}
//
//  WeeklyComponents.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class WeeklyComponents: NSObject, NSCoding, NSCopying, ReminderComponent {
    
    // MARK: - NSCopying
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = WeeklyComponents()
        copy.weekdays = self.weekdays
        copy.UTCHour = self.UTCHour
        copy.UTCMinute = self.UTCMinute
        copy.skippedDate = self.skippedDate
        
        return copy
    }
    
    // MARK: - NSCoding
    
    required init?(coder aDecoder: NSCoder) {
        weekdays = aDecoder.decodeOptionalObject(forKey: KeyConstant.weeklyWeekdays.rawValue) ?? weekdays
        UTCHour = aDecoder.decodeOptionalInteger(forKey: KeyConstant.weeklyUTCHour.rawValue) ?? UTCHour
        UTCMinute = aDecoder.decodeOptionalInteger(forKey: KeyConstant.weeklyUTCMinute.rawValue) ?? UTCMinute
        skippedDate = aDecoder.decodeOptionalObject(forKey: KeyConstant.weeklySkippedDate.rawValue)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(weekdays, forKey: KeyConstant.weeklyWeekdays.rawValue)
        aCoder.encode(UTCHour, forKey: KeyConstant.weeklyUTCHour.rawValue)
        aCoder.encode(UTCMinute, forKey: KeyConstant.weeklyUTCMinute.rawValue)
        if let skippedDate = skippedDate {
            aCoder.encode(skippedDate, forKey: KeyConstant.weeklySkippedDate.rawValue)
        }
    }
    
    // MARK: - Properties
    
    var readableRecurranceInterval: String {
        switch weekdays {
        case [1, 2, 3, 4, 5, 6, 7]:
            return "Everyday"
        case [1, 7]:
            return "Weekends"
        case [2, 3, 4, 5, 6]:
            return "Weekdays"
        default:
            var string = ""
            
            let shouldAbreviateWeekday = weekdays.count > 1
            for weekdayInt in weekdays {
                switch weekdayInt {
                case 1:
                    string.append(shouldAbreviateWeekday ? "Su, " : "Sunday ")
                case 2:
                    string.append(shouldAbreviateWeekday ? "M, " : "Monday ")
                case 3:
                    string.append(shouldAbreviateWeekday ? "Tu, " : "Tuesday ")
                case 4:
                    string.append(shouldAbreviateWeekday ? "W, " : "Wednesday ")
                case 5:
                    string.append(shouldAbreviateWeekday ? "Th, " : "Thursday ")
                case 6:
                    string.append(shouldAbreviateWeekday ? "F, " : "Friday ")
                case 7:
                    string.append(shouldAbreviateWeekday ? "Sa, " : "Saturday ")
                default:
                    continue
                }
            }
            
            // Check for case of "Su, M, Tu, " to correct to "Su, M, Tu ", replacing last occurance of ", " with " "
            let lastTwoCharactersIndex = string.index(string.endIndex, offsetBy: -2)
            let lastTwoCharacters = String(string[lastTwoCharactersIndex...])
            if lastTwoCharacters == ", " {
                string.removeLast()
                string.removeLast()
            }
            
            return string.trimmingCharacters(in: .whitespacesAndNewlines)
        }
    }
    
    var readableTimeOfDayInterval: String {
        return String.convertToReadable(fromUTCHour: UTCHour, fromUTCMinute: UTCMinute)
    }
    
    var readableInterval: String {
        return readableRecurranceInterval.appending(" at \(readableTimeOfDayInterval)")
    }
    
    /// The weekdays on which the reminder should fire. 1 - 7, where 1 is sunday and 7 is saturday.
    private(set) var weekdays: [Int] = [1, 2, 3, 4, 5, 6, 7]
    /// Changes the weekdays, if empty throws an error due to the fact that there needs to be at least one time of week.
    func changeWeekdays(forWeekdays: [Int]) throws {
        let acceptableWeekdays = [1, 2, 3, 4, 5, 6, 7]
        // remove duplicates from forWeekdays
        // remove weekdays that aren't valid from weekdays
        // sort weekdays
        
        let filteredWeekdays = Array(Set(forWeekdays)).filter({ forWeekday in
            acceptableWeekdays.contains(forWeekday)
        }).sorted()
        
        if filteredWeekdays.isEmpty {
            throw ErrorConstant.WeeklyComponentsError.weekdayArrayInvalid()
        }
        
        weekdays = filteredWeekdays
    }
    
    /// Hour of the day that that the reminder should fire in GMT+0000. [0, 23]
    private(set) var UTCHour: Int = ClassConstant.ReminderComponentConstant.defaultUTCHour
    /// UTCHour but converted to the hour in the user's timezone
    var localHour: Int {
        let hoursFromUTC = Calendar.current.timeZone.secondsFromGMT() / 3600
        
        var localHour = UTCHour + hoursFromUTC
        // localHour could be negative, so roll over into positive
        localHour += 24
        // Make sure localHour [0, 23]
        localHour = localHour % 24
        return localHour
    }
    
    /// Takes a given date and extracts the UTC Hour (GMT+0000) from it.
    func changeUTCHour(forDate: Date) {
        UTCHour = Calendar.UTCCalendar.component(.hour, from: forDate)
    }
    
    /// Minute of the day that that the reminder should fire in GMT+0000. [0, 59]
    private(set) var UTCMinute: Int = ClassConstant.ReminderComponentConstant.defaultUTCMinute
    /// UTCMinute but converted to the minute in the user's timezone
    var localMinute: Int {
        let minutesFromUTC = (Calendar.current.timeZone.secondsFromGMT() % 3600) / 60
        var localMinute = UTCMinute + minutesFromUTC
        // localMinute could be negative, so roll over into positive
        localMinute += 60
        // Make sure localMinute [0, 59]
        localMinute = localMinute % 60
        return localMinute
    }
    /// Takes a given date and extracts the UTC minute (GMT+0000) from it.
    func changeUTCMinute(forDate: Date) {
        UTCMinute = Calendar.UTCCalendar.component(.minute, from: forDate)
    }
    
    /// Whether or not the next alarm will be skipped
    var isSkipping: Bool {
        skippedDate != nil
    }
    
    /// The date at which the user changed the isSkipping to true.  If is skipping is true, then a certain log date was appended. If unskipped, then we have to remove that previously added log. Slight caveat: if the skip log was modified (by the user changing its date) we don't remove it.
    var skippedDate: Date?
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    convenience init(UTCHour: Int, UTCMinute: Int, skippedDate: Date?, sunday: Bool, monday: Bool, tuesday: Bool, wednesday: Bool, thursday: Bool, friday: Bool, saturday: Bool) {
        self.init()
        self.UTCHour = UTCHour
        self.UTCMinute = UTCMinute
        self.skippedDate = skippedDate
        
        weekdays = []
        if sunday == true {
            weekdays.append(1)
        }
        if monday == true {
            weekdays.append(2)
        }
        if tuesday == true {
            weekdays.append(3)
        }
        if wednesday == true {
            weekdays.append(4)
        }
        if thursday == true {
            weekdays.append(5)
        }
        if friday == true {
            weekdays.append(6)
        }
        if saturday == true {
            weekdays.append(7)
        }
        
        if weekdays.isEmpty {
            weekdays = [1, 2, 3, 4, 5, 6, 7]
        }
    }
    
    // MARK: - Functions
    
    /// This find the next execution date that takes place after the reminderExecutionBasis. It purposelly not factoring in isSkipping.
    func notSkippingExecutionDate(forReminderExecutionBasis reminderExecutionBasis: Date) -> Date {
        
        let futureExecutionDates = futureExecutionDates(forReminderExecutionBasis: reminderExecutionBasis)
        
        // Default to the first item in the array, as it is most likely the closest to the present
        var soonestFutureExecutionDate: Date = futureExecutionDates.first ?? ClassConstant.DateConstant.default1970Date
        
        // Find any dates that are closer to the present that the current soonestFutureExecutionDate. If a date is closer to the present that soonestFutureExecutionDate, set soonestFutureExecutionDate to its value
        for futureExecutionDate in futureExecutionDates where reminderExecutionBasis.distance(to: futureExecutionDate) < reminderExecutionBasis.distance(to: soonestFutureExecutionDate) {
            soonestFutureExecutionDate = futureExecutionDate
        }
        
        return soonestFutureExecutionDate
    }
    
    /// Returns the date that the reminder should have last sounded an alarm at. This helps in finding alarms that might have been missed
    func previousExecutionDate(forReminderExecutionBasis reminderExecutionBasis: Date) -> Date {
        
        let nextExecutionDate = notSkippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis)
        
        guard weekdays.count > 1 else {
            // only 1 day of week so simply subtract a week
            return Calendar.UTCCalendar.date(byAdding: .day, value: -7, to: nextExecutionDate) ?? ClassConstant.DateConstant.default1970Date
        }
        
        let futureExecutionDates = futureExecutionDates(forReminderExecutionBasis: reminderExecutionBasis)
        
        var pastExecutionDates: [Date] = []
        
        // Take every date and shift it back a week
        for futureExecutionDate in futureExecutionDates {
            pastExecutionDates.append(Calendar.UTCCalendar.date(byAdding: .day, value: -7, to: futureExecutionDate) ?? ClassConstant.DateConstant.default1970Date)
        }
        
        // Choose date that is likely to be the closest to the present
        var soonestExecutionDate: Date = pastExecutionDates.first ?? ClassConstant.DateConstant.default1970Date
        
        // Find date that are before the nextExecutionDate while also being closer to nextExecutionDate that soonestExecutionDate
        for pastExecutionDate in pastExecutionDates where
        nextExecutionDate.distance(to: pastExecutionDate) < 0
        && nextExecutionDate.distance(to: pastExecutionDate) > nextExecutionDate.distance(to: soonestExecutionDate) {
            // pastExecutionDate comes before nextExecutionDate while being closer to nextExecutionDate than soonestExecutionDate
            soonestExecutionDate = pastExecutionDate
        }
        
        return soonestExecutionDate
    }
    
    /// Factors in isSkipping to figure out the next time of day
    func nextExecutionDate(forReminderExecutionBasis reminderExecutionBasis: Date) -> Date {
        isSkipping ? skippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis) : notSkippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis)
    }
    
    // MARK: - Private Helper Functions
    
    /// Produces an array of at least two with all of the future dates that the reminder will fire given the weekday(s), hour, and minute
    private func futureExecutionDates(forReminderExecutionBasis reminderExecutionBasis: Date) -> [Date] {
        
        // the dates calculated to be reminderExecutionDates
        var futureExecutionDates: [Date] = {
            var futureExecutionDates: [Date] = []
            
            // iterate throguh all weekdays
            for weekday in weekdays {
                // Add the target weekday to reminderExecutionBasis
                var futureExecutionDate = Calendar.UTCCalendar.date(bySetting: .weekday, value: weekday, of: reminderExecutionBasis) ?? ClassConstant.DateConstant.default1970Date
                
                // Iterate the futureExecutionDate forward until the first result that matches UTCHour and UTCMinute is found
                futureExecutionDate = Calendar.UTCCalendar.date(bySettingHour: UTCHour, minute: UTCMinute, second: 0, of: futureExecutionDate, matchingPolicy: .nextTime, repeatedTimePolicy: .first, direction: .forward) ?? ClassConstant.DateConstant.default1970Date
                
                // Make sure futureExecutionDate is after reminderExecutionBasis
                // Correction for setting components to the same day. e.g. if its 11:00Am friday and you apply 8:30AM Friday to the current date, then it is in the past, this gets around this by making it 8:30AM Next Friday
                if reminderExecutionBasis.distance(to: futureExecutionDate) < 0 {
                    futureExecutionDate = Calendar.UTCCalendar.date(byAdding: .day, value: 7, to: futureExecutionDate) ?? ClassConstant.DateConstant.default1970Date
                }
                
                futureExecutionDates.append(futureExecutionDate)
            }
            return futureExecutionDates
        }()
        
        // futureExecutionDates should have at least two dates
        if futureExecutionDates.count <= 1 {
            if let futureExecutionDate = futureExecutionDates.first {
                // Only one weekday is active. Take the execution date for that single weekday and add a duplicate, but a week in the future
                futureExecutionDates.append(Calendar.UTCCalendar.date(byAdding: .day, value: 7, to: futureExecutionDate) ?? ClassConstant.DateConstant.default1970Date)
            }
            else {
                // No weekdays active. Shouldn't happen. Handle by adding 1 week and 2 weeks to reminderExecutionBasis
                futureExecutionDates.append(Calendar.UTCCalendar.date(byAdding: .day, value: 7, to: reminderExecutionBasis) ?? ClassConstant.DateConstant.default1970Date)
                futureExecutionDates.append(Calendar.UTCCalendar.date(byAdding: .day, value: 14, to: reminderExecutionBasis) ?? ClassConstant.DateConstant.default1970Date)
            }
        }
        
        futureExecutionDates.sort()
        
        return futureExecutionDates
    }
    
    /// If a reminder is skipping, then we must find the next soonest reminderExecutionDate. We have to find the execution date that takes place after the skipped execution date (but before any other execution date).
    private func skippingExecutionDate(forReminderExecutionBasis reminderExecutionBasis: Date) -> Date {
        
        let nextExecutionDate = notSkippingExecutionDate(forReminderExecutionBasis: reminderExecutionBasis)
        
        guard weekdays.count > 1 else {
            // If only 1 day of week selected so simply add 1 week.
            return Calendar.UTCCalendar.date(byAdding: .day, value: 7, to: nextExecutionDate) ?? ClassConstant.DateConstant.default1970Date
        }
        
        // If there are multiple dates to be sorted through to find the date that is closer in time to traditionalNextTimeOfDay but still in the future
        let futureExecutionDates = futureExecutionDates(forReminderExecutionBasis: reminderExecutionBasis)
        
        // Find the futureExecutionDate that is after nextExecutionDate
        var soonestFutureExecutionDate: Date = futureExecutionDates.first(where: { futureExecutionDate in
            nextExecutionDate.distance(to: futureExecutionDate) > 0
        }) ?? ClassConstant.DateConstant.default1970Date
        
        // Attempt to find futureExecutionDates that are further in the future than nextExecutionDate while being closer to nextExecutionDate than soonestFutureExecutionDate. Doing this will give us the first executionDate that is directly after nextExecutionDate
        for futureExecutionDate in futureExecutionDates where
        nextExecutionDate.distance(to: futureExecutionDate) > 0
        && nextExecutionDate.distance(to: futureExecutionDate) < nextExecutionDate.distance(to: soonestFutureExecutionDate) {
            soonestFutureExecutionDate = futureExecutionDate
        }
        
        return soonestFutureExecutionDate
    }
}
//
//  PreviousLogCustomActionName.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/6/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

class PreviousLogCustomActionName: NSObject, NSCoding {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        guard
            let decodedLogActionTypeId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.logActionTypeId.rawValue),
            let decodedLogCustomActionName = aDecoder.decodeOptionalString(forKey: KeyConstant.logCustomActionName.rawValue)
        else {
            return nil
        }
        self.init(logActionTypeId: decodedLogActionTypeId, logCustomActionName: decodedLogCustomActionName)
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(logActionTypeId, forKey: KeyConstant.logActionTypeId.rawValue)
        aCoder.encode(logCustomActionName, forKey: KeyConstant.logCustomActionName.rawValue)
    }
    
    // MARK: - Properties
    
    private(set) var logActionTypeId: Int
    private(set) var logCustomActionName: String
    
    // MARK: - Main
    
    init(logActionTypeId: Int, logCustomActionName: String) {
        self.logActionTypeId = logActionTypeId
        self.logCustomActionName = logCustomActionName
        super.init()
    }
    
}
//
//  ReminderLog.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/25/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class Log: NSObject, NSCoding, NSCopying, Comparable {
    
    // MARK: - NSCopying

    func copy(with zone: NSZone? = nil) -> Any {
        let copy = Log()
        // IMPORTANT: The setter method for properties may modify values. We want to clone exactly what is stored, so access stored properties directly.
        copy.logId = self.logId
        copy.logUUID = self.logUUID
        copy.userId = self.userId
        copy.logActionTypeId = self.logActionTypeId
        copy.storedLogCustomActionName = self.logCustomActionName
        copy.logStartDate = self.logStartDate
        copy.logEndDate = self.logEndDate
        copy.storedLogNote = self.logNote
        copy.logUnitTypeId = self.logUnitTypeId
        copy.logNumberOfLogUnits = self.logNumberOfLogUnits
        copy.offlineModeComponents = self.offlineModeComponents.copy() as? OfflineModeComponents ?? OfflineModeComponents()
        
        return copy
    }

    // MARK: - NSCoding

    required convenience init?(coder aDecoder: NSCoder) {
        let decodedLogId: Int? = aDecoder.decodeOptionalInteger(forKey: KeyConstant.logId.rawValue)
        let decodedLogUUID: UUID? = UUID.fromString(forUUIDString: aDecoder.decodeOptionalString(forKey: KeyConstant.logUUID.rawValue))
        let decodedUserId: String? = aDecoder.decodeOptionalString(forKey: KeyConstant.userId.rawValue)
        let decodedLogActionTypeId: Int = aDecoder.decodeOptionalInteger(forKey: KeyConstant.logActionTypeId.rawValue) ?? ClassConstant.LogConstant.defaultLogActionTypeId
        let decodedLogCustomActionName: String? = aDecoder.decodeOptionalString(forKey: KeyConstant.logCustomActionName.rawValue)
        let decodedLogStartDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.logStartDate.rawValue)
        let decodedLogEndDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.logEndDate.rawValue)
        let decodedLogNote: String? = aDecoder.decodeOptionalString(forKey: KeyConstant.logNote.rawValue)
        let decodedLogUnitTypeId: Int? = aDecoder.decodeOptionalInteger(forKey: KeyConstant.logUnitTypeId.rawValue)
        let decodedLogNumberOfLogUnits: Double? = aDecoder.decodeOptionalDouble(forKey: KeyConstant.logNumberOfLogUnits.rawValue)
        let decodedOfflineModeComponents: OfflineModeComponents? = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeComponents.rawValue)

        self.init(
            forLogId: decodedLogId,
            forLogUUID: decodedLogUUID,
            forUserId: decodedUserId,
            forLogActionTypeId: decodedLogActionTypeId,
            forLogCustomActionName: decodedLogCustomActionName,
            forLogStartDate: decodedLogStartDate,
            forLogEndDate: decodedLogEndDate,
            forLogNote: decodedLogNote,
            forLogUnitTypeId: decodedLogUnitTypeId,
            forLogNumberOfUnits: decodedLogNumberOfLogUnits,
            forOfflineModeComponents: decodedOfflineModeComponents
        )
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.

        if let logId = logId {
            aCoder.encode(logId, forKey: KeyConstant.logId.rawValue)
        }
        aCoder.encode(logUUID.uuidString, forKey: KeyConstant.logUUID.rawValue)
        aCoder.encode(userId, forKey: KeyConstant.userId.rawValue)
        aCoder.encode(logActionTypeId, forKey: KeyConstant.logActionTypeId.rawValue)
        aCoder.encode(logCustomActionName, forKey: KeyConstant.logCustomActionName.rawValue)
        aCoder.encode(logStartDate, forKey: KeyConstant.logStartDate.rawValue)
        if let logEndDate = logEndDate {
            aCoder.encode(logEndDate, forKey: KeyConstant.logEndDate.rawValue)
        }
        aCoder.encode(logNote, forKey: KeyConstant.logNote.rawValue)
        if let logUnitTypeId = logUnitTypeId {
            aCoder.encode(logUnitTypeId, forKey: KeyConstant.logUnitTypeId.rawValue)
        }
        if let logNumberOfLogUnits = logNumberOfLogUnits {
            aCoder.encode(logNumberOfLogUnits, forKey: KeyConstant.logNumberOfLogUnits.rawValue)
        }
        aCoder.encode(offlineModeComponents, forKey: KeyConstant.offlineModeComponents.rawValue)
    }
    
    // MARK: - Comparable
    
    static func < (lhs: Log, rhs: Log) -> Bool {
        guard lhs.logStartDate != rhs.logStartDate else {
            // If same logStartDate, then one with lesser logId comes first
            guard let lhsLogId = lhs.logId else {
                guard rhs.logId != nil else {
                    // Neither have an id
                    return lhs.logUUID.uuidString < rhs.logUUID.uuidString
                }
                
                // lhs doesn't have a logId but rhs does. rhs should come first
                return false
            }
            
            guard let rhsLogId = rhs.logId else {
                // lhs has a logId but rhs doesn't. lhs should come first
                return true
            }
            
            return lhsLogId <= rhsLogId
        }
        // Returning true means item1 comes before item2, false means item2 before item1

        // Returns true if lhs is earlier in time than rhs

        // If lhs's distance to date2 is positive, i.e. rhs is later in time, returns false as date2 should be ordered first (most recent (to current Date()) dates first)
        // If date1 is later in time than date2, returns true as it should come before date2
        return lhs.logStartDate.distance(to: rhs.logStartDate) <= 0
    }

    // MARK: - Properties

    /// The logId given to this log from the Hound database
    var logId: Int?
    
    /// The UUID of this log that is generated locally upon creation. Useful in identifying the log before/in the process of creating it
    var logUUID: UUID = UUID()

    /// The userId of the user that created this log
    var userId: String = ClassConstant.LogConstant.defaultUserId

    var logActionTypeId: Int = ClassConstant.LogConstant.defaultLogActionTypeId {
        didSet {
            // Check to see if logUnitTypeId are compatible with the new logActionTypeId
            let logUnitTypeIds = LogActionType.find(forLogActionTypeId: logActionTypeId).associatedLogUnitTypes.map { $0.logUnitTypeId }
            
            guard let logUnitTypeId = logUnitTypeId else {
                self.logNumberOfLogUnits = nil
                self.logUnitTypeId = nil
                return
            }
            
            if logUnitTypeIds.contains(logUnitTypeId) == false {
                self.logNumberOfLogUnits = nil
                self.logUnitTypeId = nil
            }
        }
    }
    
    var logActionType: LogActionType {
        return LogActionType.find(forLogActionTypeId: logActionTypeId)
    }

    private var storedLogCustomActionName: String = ""
    var logCustomActionName: String {
        get {
            return storedLogCustomActionName
        }
        set {
            storedLogCustomActionName = String((newValue.trimmingCharacters(in: .whitespacesAndNewlines)).prefix(ClassConstant.LogConstant.logCustomActionNameCharacterLimit))
        }
    }
    
    private(set) var logStartDate: Date = ClassConstant.LogConstant.defaultLogStartDate
    private(set) var logEndDate: Date?

    private var storedLogNote: String = ""
    var logNote: String {
        get {
            return storedLogNote
        }
        set {
            storedLogNote = String(newValue.prefix(ClassConstant.LogConstant.logNoteCharacterLimit))
        }
    }
    
    private(set) var logUnitTypeId: Int?
    
    var logUnitType: LogUnitType? {
        guard let logUnitTypeId = logUnitTypeId else {
            return nil
        }
        return LogUnitType.find(forLogUnitTypeId: logUnitTypeId)
    }
    
    private(set) var logNumberOfLogUnits: Double?
    
    /// Components that are used to track an object to determine whether it was synced with the Hound server and whether it needs to be when the device comes back online
    private(set) var offlineModeComponents: OfflineModeComponents = OfflineModeComponents()
    
    // MARK: - Main
    
    init(
        forLogId: Int? = nil,
        forLogUUID: UUID? = nil,
        forUserId: String? = nil,
        forLogActionTypeId: Int? = nil,
        forLogCustomActionName: String? = nil,
        forLogStartDate: Date? = nil,
        forLogEndDate: Date? = nil,
        forLogNote: String? = nil,
        forLogUnitTypeId: Int? = nil,
        forLogNumberOfUnits: Double? = nil,
        forOfflineModeComponents: OfflineModeComponents? = nil
    ) {
        super.init()
        self.logId = forLogId ?? logId
        self.logUUID = forLogUUID ?? logUUID
        self.userId = forUserId ?? userId
        self.logActionTypeId = forLogActionTypeId ?? logActionTypeId
        self.logCustomActionName = forLogCustomActionName ?? logCustomActionName
        self.logStartDate = forLogStartDate ?? logStartDate
        self.logEndDate = forLogEndDate
        self.logNote = forLogNote ?? logNote
        self.changeLogUnit(forLogUnitTypeId: forLogUnitTypeId, forLogNumberOfLogUnits: forLogNumberOfUnits)
        self.offlineModeComponents = forOfflineModeComponents ?? offlineModeComponents
    }

    /// Provide a dictionary literal of log properties to instantiate log. Optionally, provide a log to override with new properties from fromBody.
    convenience init?(fromBody: [String: Any?], logToOverride: Log?) {
        // Don't pull logId or logIsDeleted from logToOverride. A valid fromBody needs to provide this itself
        let logId: Int? = fromBody[KeyConstant.logId.rawValue] as? Int
        let logUUID: UUID? = UUID.fromString(forUUIDString: fromBody[KeyConstant.logUUID.rawValue] as? String)
        let logLastModified: Date? = (fromBody[KeyConstant.logLastModified.rawValue] as? String)?.formatISO8601IntoDate()
        let logIsDeleted: Bool? = fromBody[KeyConstant.logIsDeleted.rawValue] as? Bool

        // The body needs an id, uuid, and isDeleted to be intrepreted as same, updated, or deleted. Otherwise, it is invalid
        guard let logId = logId, let logUUID = logUUID, let logLastModified = logLastModified, let logIsDeleted = logIsDeleted else {
            return nil
        }
        
        guard logIsDeleted == false else {
            // The log has been deleted. Doesn't matter if our offline mode made any changes
            return nil
        }
        
        // If we have pulled an update from the server which is more outdated than our local change, then ignore the data from the server. Otherwise, the newer server update takes precedence over our offline update
        if let logToOverride = logToOverride, let initialAttemptedSyncDate = logToOverride.offlineModeComponents.initialAttemptedSyncDate, initialAttemptedSyncDate >= logLastModified {
            self.init(
                forLogId: logToOverride.logId,
                forLogUUID: logToOverride.logUUID,
                forUserId: logToOverride.userId,
                forLogActionTypeId: logToOverride.logActionTypeId,
                forLogCustomActionName: logToOverride.logCustomActionName,
                forLogStartDate: logToOverride.logStartDate,
                forLogEndDate: logToOverride.logEndDate,
                forLogNote: logToOverride.logNote,
                forLogUnitTypeId: logToOverride.logUnitTypeId,
                forLogNumberOfUnits: logToOverride.logNumberOfLogUnits,
                forOfflineModeComponents: logToOverride.offlineModeComponents
            )
            return
        }

        // if the log is the same, then we pull values from logToOverride
        // if the log is updated, then we pull values from fromBody
        let userId: String? = fromBody[KeyConstant.userId.rawValue] as? String ?? logToOverride?.userId
        
        let logActionTypeId: Int? = fromBody[KeyConstant.logActionTypeId.rawValue] as? Int ?? logToOverride?.logActionTypeId
        
        let logCustomActionName: String? = fromBody[KeyConstant.logCustomActionName.rawValue] as? String ?? logToOverride?.logCustomActionName
        
        let logStartDate: Date? = {
            if let logStartDateString = fromBody[KeyConstant.logStartDate.rawValue] as? String {
                return logStartDateString.formatISO8601IntoDate()
            }
            return nil
        }() ?? logToOverride?.logStartDate
        
        let logEndDate: Date? = {
            if let logEndDateString = fromBody[KeyConstant.logEndDate.rawValue] as? String {
                return logEndDateString.formatISO8601IntoDate()
            }
            return nil
        }() ?? logToOverride?.logEndDate
        
        let logNote: String? = fromBody[KeyConstant.logNote.rawValue] as? String ?? logToOverride?.logNote
        
        let logUnitTypeId: Int? = fromBody[KeyConstant.logUnitTypeId.rawValue] as? Int ?? logToOverride?.logUnitTypeId
        
        let logNumberOfLogUnits: Double? = fromBody[KeyConstant.logNumberOfLogUnits.rawValue] as? Double ?? logToOverride?.logNumberOfLogUnits

        self.init(
            forLogId: logId,
            forLogUUID: logUUID,
            forUserId: userId,
            forLogActionTypeId: logActionTypeId,
            forLogCustomActionName: logCustomActionName,
            forLogStartDate: logStartDate,
            forLogEndDate: logEndDate,
            forLogNote: logNote,
            forLogUnitTypeId: logUnitTypeId,
            forLogNumberOfUnits: logNumberOfLogUnits,
            // Verified that the update from the server happened more recently than our local changes, so no need to offline sync anymore
            forOfflineModeComponents: nil
        )
    }
    
    // MARK: - Functions
    
    /// logStartDate takes precendence over logEndDate. Therefore, if the times overlap incorrectly, i.e. logStartDate is after logEndDate, then logStartDate is set its value, then logEndDate is adjusted so that it is later than logStartDate.
    func changeLogDate(forLogStartDate: Date, forLogEndDate: Date?) {
        logStartDate = forLogStartDate
        
        if let forLogEndDate = forLogEndDate {
            // If forLogStartDate is after forLogEndDate, that is incorrect. Therefore, disregard it
            logEndDate = forLogStartDate >= forLogEndDate ? nil : forLogEndDate
        }
        else {
            logEndDate = nil
        }
    }
    
    /// If forNumberOfUnits or forLogUnitTypeId is nil, both are set to nil. The forLogUnitTypeId provided must be in the array of LogUnitTypes that are valid for this log's logActionTypeId.
    func changeLogUnit(forLogUnitTypeId: Int?, forLogNumberOfLogUnits: Double?) {
        guard let forLogUnitTypeId = forLogUnitTypeId, let forLogNumberOfLogUnits = forLogNumberOfLogUnits else {
            logNumberOfLogUnits = nil
            logUnitTypeId = nil
            return
        }
        
        let logUnitTypeIds = logActionType.associatedLogUnitTypes.map { $0.logUnitTypeId }
        
        guard logUnitTypeIds.contains(forLogUnitTypeId) else {
            logNumberOfLogUnits = nil
            logUnitTypeId = nil
            return
        }
        
        logNumberOfLogUnits = round(forLogNumberOfLogUnits * 100.0) / 100.0
        logUnitTypeId = forLogUnitTypeId
    }

    /// Returns an array literal of the logs's properties. This is suitable to be used as the JSON body for a HTTP request
    func createBody(forDogUUID: UUID) -> [String: CompatibleDataTypeForJSON?] {
        var body: [String: CompatibleDataTypeForJSON?] = [:]
        body[KeyConstant.dogUUID.rawValue] = forDogUUID.uuidString
        body[KeyConstant.logId.rawValue] = logId
        body[KeyConstant.logUUID.rawValue] = logUUID.uuidString
        body[KeyConstant.logActionTypeId.rawValue] = logActionTypeId
        body[KeyConstant.logCustomActionName.rawValue] = logCustomActionName
        body[KeyConstant.logStartDate.rawValue] = logStartDate.ISO8601FormatWithFractionalSeconds()
        body[KeyConstant.logEndDate.rawValue] = logEndDate?.ISO8601FormatWithFractionalSeconds()
        body[KeyConstant.logNote.rawValue] = logNote
        body[KeyConstant.logUnitTypeId.rawValue] = logUnitTypeId
        body[KeyConstant.logNumberOfLogUnits.rawValue] = logNumberOfLogUnits
        return body

    }
}
//
//  LogsFilter.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/28/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

class LogsFilter: NSObject {
    
    // MARK: - Properties
    
    private var dogManager: DogManager = DogManager()
    
    /// Dogs that the user's has selected to filter by. If empty, all logs by all dogs are included. Otherwise, only logs with their dogUUID in this array are included
    private(set) var filterDogs: [Dog] = [] {
        didSet {
            filterDogs.sort(by: { $0 <= $1})
            storedAvailableDogs = nil
        }
    }
    
    /// Increases efficiency by storing this result. Only invalidate if the filters are updated
    private var storedAvailableDogs: [Dog]?
    
    /// Log actions that the user's has selected to filter by. If empty, all logs by all log actions are included. Otherwise, only logs with their log action in this array are included
    private(set) var filterLogActions: [LogActionType] = [] {
        didSet {
            filterLogActions.sort(by: { $0 <= $1})
            storedAvailableLogActions = nil
        }
    }
    
    /// Increases efficiency by storing this result. Only invalidate if the filters are updated
    private var storedAvailableLogActions: [LogActionType]?
    
    /// Family members that the user's has selected to filter by. If empty, all logs by all familyMembers are included. Otherwise, only logs with their familyMembers in this array are included
    private(set) var filterFamilyMembers: [FamilyMember] = [] {
        didSet {
            filterFamilyMembers.sort(by: { $0 <= $1})
            storedAvailableFamilyMembers = nil
        }
    }
    
    /// Increases efficiency by storing this result. Only invalidate if the filters are updated
    private var storedAvailableFamilyMembers: [FamilyMember]?
    
    /// Returns true if filterDogs, filterLogActions, and filterFamilyMembers are all empty
    var isEmpty: Bool {
        return filterDogs.isEmpty && filterLogActions.isEmpty && filterFamilyMembers.isEmpty
    }
    
    // MARK: - Main
    
    init(forDogManager: DogManager) {
        super.init()
        apply(forDogManager: dogManager)
    }
    
    // MARK: - Computed Properties
    
    /// All the dogs that it is currently possible for a user to filter by (given the other filters currently applied). This means that the dog must have at least 1 log in the first place, and at least one of its logs must also be adhere to both the filters
    var availableDogs: [Dog] {
        if let storedAvailableDogs = storedAvailableDogs {
            return storedAvailableDogs
        }
        
        var availableDogUUIDs: Set<UUID> = []
        for dog in dogManager.dogs {
            for log in dog.dogLogs.dogLogs {
                if (filterLogActions.isEmpty == false && filterLogActions.contains(where: { $0 == log.logActionType}) == false) {
                    // We are filtering by log actions and this is not one of them, therefore, this log action is not available
                    continue
                }
                if (filterFamilyMembers.isEmpty == false && filterFamilyMembers.contains(where: { $0.userId == log.userId}) == false) {
                    // We are filtering by family members and this is not one of them, therefore, this family member is no available
                    continue
                }
                
                // This dog is available because it exists for some log action / family member currently filtered by
                availableDogUUIDs.insert(dog.dogUUID)
                // We can break here as we only need this to trigger once for a given dog
                break
            }
        }
        
        var availableDogs: [Dog] = []
        availableDogUUIDs.forEach { availableDogUUID in
            guard let dog = dogManager.findDog(forDogUUID: availableDogUUID) else {
                return
            }
            
            availableDogs.append(dog)
        }
        
        availableDogs.sort()
        storedAvailableDogs = availableDogs
        return availableDogs
    }
    
    /// All the log actions that it is currently possible for a user to filter by (given the other filters currently applied).
    var availableLogActions: [LogActionType] {
        if let storedAvailableLogActions = storedAvailableLogActions {
            return storedAvailableLogActions
        }
        
        var availableLogActions: Set<LogActionType> = []
        for dog in dogManager.dogs {
            if (filterDogs.isEmpty == false && filterDogs.contains(where: {$0.dogUUID == dog.dogUUID}) == false) {
                // We are filtering by dogs and this is not one of them, therefore, this dog is no available
                continue
            }
            
            for log in dog.dogLogs.dogLogs {
                if (filterFamilyMembers.isEmpty == false && filterFamilyMembers.contains(where: { $0.userId == log.userId}) == false) {
                    // We are filtering by family members and this is not one of them, therefore, this family member is no available
                    continue
                }
                
                // This log action is available because it exists for some dog / family member currently filtered by
                availableLogActions.insert(log.logActionType)
            }
        }
        
        storedAvailableLogActions = Array(availableLogActions).sorted()
        return storedAvailableLogActions ?? Array(availableLogActions).sorted()
        
    }
    
    /// All the family members that it is currently possible for a user to filter by (given the other filters currently applied).
    var availableFamilyMembers: [FamilyMember] {
        if let storedAvailableFamilyMembers = storedAvailableFamilyMembers {
            return storedAvailableFamilyMembers
        }
        
        var availableFamilyMemberUserIds: Set<String> = []
        for dog in dogManager.dogs {
            if (filterDogs.isEmpty == false && filterDogs.contains(where: {$0.dogUUID == dog.dogUUID}) == false) {
                // We are filtering by dogs and this is not one of them, therefore, this dog is no available
                continue
            }
            
            for log in dog.dogLogs.dogLogs {
                if (filterLogActions.isEmpty == false && filterLogActions.contains(where: { $0 == log.logActionType}) == false) {
                    // We are filtering by log actions and this is not one of them, therefore, this log action is not available
                    continue
                }
                
                // This family member is available because it exists for some dog / log action currently filtered by
                availableFamilyMemberUserIds.insert(log.userId)
            }
        }
        
        var availableFamilyMembers: [FamilyMember] = []
        availableFamilyMemberUserIds.forEach { availableFamilyMemberUserId in
            guard let familyMember = FamilyInformation.findFamilyMember(forUserId: availableFamilyMemberUserId) else {
                return
            }
            availableFamilyMembers.append(familyMember)
        }
        
        availableFamilyMembers.sort()
        storedAvailableFamilyMembers = availableFamilyMembers
        return availableFamilyMembers
    }
    
    // MARK: - Functions
    
    /// Sets all filters to empty. This means that the logs filter will no longer be filtering by anything
    func clearAll() {
        apply(forFilterDogs: [])
        apply(forFilterLogActions: [])
        apply(forFilterFamilyMembers: [])
    }
    
    /// Recalculates all the applicable filters given the new dog manager. If a filter contains invalid elements with the new dog manager, those elements are removed
    func apply(forDogManager: DogManager) {
        dogManager = forDogManager
        
        // If our current filters applied to the new dogManager would result in an empty set of logs, meaning that our filter filters our every possible element, then this filter is not valid. Therefore, clear the filter
        guard dogManager.logsForDogUUIDsGroupedByDate(forFilter: self).isEmpty == false else {
            clearAll()
            return
        }
        
        apply(forFilterDogs: filterDogs)
        apply(forFilterLogActions: filterLogActions)
        apply(forFilterFamilyMembers: filterFamilyMembers)
    }
    
    /// If we want to apply a new filterDogs, then this may invalidate the other filters. This is because it could filter out logs that were previously included, making it impossible to filter by certain log actions or family members because therre are none
    func apply(forFilterDogs: [Dog]) {
        filterDogs = forFilterDogs
        
        // If we are applying an empty filter, there are two possible cases
        // 1. the previous filter was empty as well, then nothing changes
        // 2. the previous filter wasn't empty. That means that with this new filter there are now more options. This is because a non-empty filter restricts certain elements from being included. However a empty filter restricts nothing. Therefore, all elements that are valid with a non-empty filter must be valid with an empty filter as well
        guard forFilterDogs.isEmpty == false else {
            return
        }
        
        var includedLogActions: Set<LogActionType> = []
        var includedFamilyMemberUserIds: Set<String> = []
        
        dogManager.dogs.forEach { dog in
            // Find all of the log actions and family members that are included
            // If forFilterDogs is empty, then include all of the dogs
            guard forFilterDogs.contains(where: { $0.dogUUID == dog.dogUUID }) else {
                return
            }
            
            dog.dogLogs.dogLogs.forEach { log in
                includedLogActions.insert(log.logActionType)
                includedFamilyMemberUserIds.insert(log.userId)
            }
        }
        
        // Keep all of the filter passed through by a parameter, but remove any elements from other filters that are incompatible with the new filter (i.e. they cannot exist as there is no element that would satify both of the conditions)
        filterLogActions = filterLogActions.filter({ filterLogAction in
            return includedLogActions.contains(filterLogAction)
        })
        filterFamilyMembers = filterFamilyMembers.filter({ filterFamilyMember in
            return includedFamilyMemberUserIds.contains(filterFamilyMember.userId)
        })
    }
    
    /// If we want to apply a new filterLogActions, then this may invalidate the other filters. This is because it could filter out logs that were previously included, making it impossible to filter by certain dogs or family members because therre are none
    func apply(forFilterLogActions: [LogActionType]) {
        filterLogActions = forFilterLogActions
        
        // If we are applying an empty filter, there are two possible cases
        // 1. the previous filter was empty as well, then nothing changes
        // 2. the previous filter wasn't empty. That means that with this new filter there are now more options. This is because a non-empty filter restricts certain elements from being included. However a empty filter restricts nothing. Therefore, all elements that are valid with a non-empty filter must be valid with an empty filter as well
        guard forFilterLogActions.isEmpty == false else {
            return
        }
        
        var includedDogUUIDs: Set<UUID> = []
        var includedFamilyMemberUserIds: Set<String> = []
        
        dogManager.dogs.forEach { dog in
            // Find all of the dogs and family members that are included
            // If forFilterLogActions is empty, then include all of the dogs
            dog.dogLogs.dogLogs.forEach { log in
                guard forFilterLogActions.contains(log.logActionType) else {
                    return
                }
                
                includedDogUUIDs.insert(dog.dogUUID)
                includedFamilyMemberUserIds.insert(log.userId)
            }
        }
        
        // Keep all of the filter passed through by a parameter, but remove any elements from other filters that are incompatible with the new filter (i.e. they cannot exist as there is no element that would satify both of the conditions)
        filterDogs = filterDogs.filter({ filterDog in
            return includedDogUUIDs.contains(filterDog.dogUUID)
        })
        
        filterFamilyMembers = filterFamilyMembers.filter({ filterFamilyMember in
            return includedFamilyMemberUserIds.contains(filterFamilyMember.userId)
        })
    }
    
    /// If we want to apply a new filterFamilyMembers, then this may invalidate the other filters. This is because it could filter out logs that were previously included, making it impossible to filter by certain dogs or log actions because therre are none
    func apply(forFilterFamilyMembers: [FamilyMember]) {
        filterFamilyMembers = forFilterFamilyMembers
        
        // If we are applying an empty filter, there are two possible cases
        // 1. the previous filter was empty as well, then nothing changes
        // 2. the previous filter wasn't empty. That means that with this new filter there are now more options. This is because a non-empty filter restricts certain elements from being included. However a empty filter restricts nothing. Therefore, all elements that are valid with a non-empty filter must be valid with an empty filter as well
        guard forFilterFamilyMembers.isEmpty == false else {
            return
        }
        
        var includedDogUUIDs: Set<UUID> = []
        var includedLogActions: Set<LogActionType> = []
        
        dogManager.dogs.forEach { dog in
            // Find all of the dogs and family members that are included
            // If forFilterFamilyMembers is empty, then include all of the family members
            dog.dogLogs.dogLogs.forEach { log in
                guard forFilterFamilyMembers.contains(where: { $0.userId == log.userId}) else {
                    return
                }
                
                includedDogUUIDs.insert(dog.dogUUID)
                includedLogActions.insert(log.logActionType)
            }
        }
        
        // Keep all of the filter passed through by a parameter, but remove any elements from other filters that are incompatible with the new filter (i.e. they cannot exist as there is no element that would satify both of the conditions)
        filterDogs = filterDogs.filter({ filterDog in
            return includedDogUUIDs.contains(filterDog.dogUUID)
        })
        
        filterLogActions = filterLogActions.filter({ filterLogAction in
            return includedLogActions.contains(filterLogAction)
        })
    }
}
//
//  DogLogManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/4/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol DogLogManagerDelegate: AnyObject {
    func didAddLogs(forLogs: [Log])
}

final class DogLogManager: NSObject, NSCoding, NSCopying {

    // MARK: - NSCopying
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = DogLogManager(forDelegate: delegate)
        for dogLog in dogLogs {
            if let logCopy = dogLog.copy() as? Log {
                copy.dogLogs.append(logCopy)
            }
        }
        return copy
    }

    // MARK: - NSCoding

    required init?(coder aDecoder: NSCoder) {
        let decodedDogLogs: [Log]? = aDecoder.decodeOptionalObject(forKey: KeyConstant.dogLogs.rawValue)
        dogLogs = decodedDogLogs ?? dogLogs
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogLogs, forKey: KeyConstant.dogLogs.rawValue)
    }

    // MARK: - Properties
    
    private(set) var dogLogs: [Log] = []
    
    weak var delegate: DogLogManagerDelegate?

    // MARK: - Main

    init(forLogs: [Log] = [], forDelegate: DogLogManagerDelegate?) {
        self.delegate = forDelegate
        super.init()
        addLogs(forLogs: forLogs)
    }

    /// Provide an array of dictionary literal of log properties to instantiate dogLogs. Provide a logManager to have the dogLogs add themselves into, update themselves in, or delete themselves from.
    convenience init(fromLogBodies: [[String: Any?]], dogLogManagerToOverride: DogLogManager?, forDelegate: DogLogManagerDelegate?) {
        self.init(forLogs: dogLogManagerToOverride?.dogLogs ?? [], forDelegate: forDelegate)

        for fromBody in fromLogBodies {
            // Don't pull logId or logIsDeleted from logToOverride. A valid fromBody needs to provide this itself
            let logId: Int? = fromBody[KeyConstant.logId.rawValue] as? Int
            let logUUID: UUID? = UUID.fromString(forUUIDString: fromBody[KeyConstant.logUUID.rawValue] as? String)
            let logIsDeleted: Bool? = fromBody[KeyConstant.logIsDeleted.rawValue] as? Bool

            guard logId != nil, let logUUID = logUUID, let logIsDeleted = logIsDeleted else {
                // couldn't construct essential components to intrepret log
                continue
            }

            guard logIsDeleted == false else {
                removeLog(forLogUUID: logUUID)
                continue
            }

            if let log = Log(fromBody: fromBody, logToOverride: findLog(forLogUUID: logUUID)) {
                addLog(forLog: log)
            }
        }
    }

    // MARK: - Functions
    
    /// finds and returns the reference of a log matching the given logUUID
    func findLog(forLogUUID: UUID) -> Log? {
        dogLogs.first(where: { $0.logUUID == forLogUUID })
    }

    /// Helper function allows us to use the same logic for addLog and addLogs and allows us to only sort at the end. Without this function, addLogs would invoke addLog repeadly and sortLogs() with each call.
    private func addLogWithoutSorting(forLog: Log) {
        removeLog(forLogUUID: forLog.logUUID)

        dogLogs.append(forLog)
    }

    func addLog(forLog: Log, invokeDogTriggers: Bool = true) {
        addLogWithoutSorting(forLog: forLog)

        dogLogs.sort(by: { $0 <= $1 })
        
        if invokeDogTriggers {
            delegate?.didAddLogs(forLogs: [forLog])
        }
    }

    func addLogs(forLogs: [Log], invokeDogTriggers: Bool = true) {
        for forLog in forLogs {
            addLogWithoutSorting(forLog: forLog)
        }

        dogLogs.sort(by: { $0 <= $1 })
        
        if invokeDogTriggers {
            delegate?.didAddLogs(forLogs: forLogs)
        }
    }

    /// Returns true if it removed at least one log with the same logUUID
    @discardableResult func removeLog(forLogUUID: UUID) -> Bool {
        var didRemoveObject = false
        
        dogLogs.removeAll { log in
            guard log.logUUID == forLogUUID else {
                return false
            }
            
            didRemoveObject = true
            return true
        }
        
        return didRemoveObject
    }

    /// Returns true if it removed at least a log at the specified index
    @discardableResult func removeLog(forIndex: Int) -> Bool {
        // Make sure the index is valid
        guard forIndex >= 0 && forIndex < dogLogs.count  else {
            return false
        }

        dogLogs.remove(at: forIndex)
        return true
    }
}
//
//  DogManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/21/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class DogManager: NSObject, NSCoding, NSCopying {

    // MARK: - NSCopying

    func copy(with zone: NSZone? = nil) -> Any {
        let copy = DogManager()
        for dog in dogs {
            if let dogCopy = dog.copy() as? Dog {
                copy.dogs.append(dogCopy)
            }
        }
        return copy
    }

    // MARK: - NSCoding

    required init?(coder aDecoder: NSCoder) {
        let decodedDogs: [Dog]? = aDecoder.decodeOptionalObject(forKey: KeyConstant.dogs.rawValue)
        dogs = decodedDogs ?? dogs
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(dogs, forKey: KeyConstant.dogs.rawValue)
    }
    
    // MARK: - Properties
    
    /// This dogManager is typically used for persistence. If we are passing a dogManager through area of code not easily navigated by view controllers
    static var globalDogManager: DogManager?

    /// Stores all the dogs. This is get only to make sure integrite of dogs added is kept
    private(set) var dogs: [Dog] = []

    // MARK: - Main

    override init() {
        super.init()
    }

    /// initializes, sets dogs to []
    /// Provide an array of dictionary literal of dog properties to instantiate dogs. Provide a dogManager to have the dogs add themselves into, update themselves in, or delete themselves from.
    convenience init?(fromDogBodies: [[String: Any?]], dogManagerToOverride: DogManager?) {
        self.init()
        self.addDogs(forDogs: dogManagerToOverride?.dogs ?? [])

        for fromBody in fromDogBodies {
            // Don't pull these properties from overrideDog. A valid fromBody needs to provide this itself
            let dogId: Int? = fromBody[KeyConstant.dogId.rawValue] as? Int
            let dogUUID: UUID? = UUID.fromString(forUUIDString: fromBody[KeyConstant.dogUUID.rawValue] as? String)
            let dogIsDeleted: Bool? = fromBody[KeyConstant.dogIsDeleted.rawValue] as? Bool

            guard dogId != nil, let dogUUID = dogUUID, let dogIsDeleted = dogIsDeleted else {
                // couldn't construct essential components to intrepret dog
                continue
            }

            guard dogIsDeleted == false else {
                DogIconManager.removeIcon(forDogUUID: dogUUID)
                removeDog(forDogUUID: dogUUID)
                continue
            }

            if let dog = Dog(fromBody: fromBody, dogToOverride: findDog(forDogUUID: dogUUID)) {
                addDog(forDog: dog)
            }
        }
    }
    
    // MARK: - Computed Properties
    
    /// Returns true if ANY the dogs present has at least 1 CREATED reminder
    var hasCreatedReminder: Bool {
        for dog in dogs where dog.dogReminders.dogReminders.isEmpty == false {
            return true
        }
        return false
    }

    // MARK: - Functions

    /// Returns reference of a dog with the given dogUUID
    func findDog(forDogUUID: UUID) -> Dog? {
        dogs.first(where: { $0.dogUUID == forDogUUID })
    }

    /// Helper function allows us to use the same logic for addDog and addDogs and allows us to only sort at the end. Without this function, addDogs would invoke addDog repeadly and sortDogs() with each call.
    func addDogWithoutSorting(forDog: Dog) {

        // removes any existing dogs that have the same dogUUID as they would cause problems.
        dogs.removeAll { dog in
            return dog.dogUUID == forDog.dogUUID
        }

        dogs.append(forDog)
    }

    /// Checks to see if a dog is already present. If its dogUUID is, then is removes the old dog and replaces it with the new.
    func addDog(forDog dog: Dog) {

        addDogWithoutSorting(forDog: dog)

        dogs.sort(by: { $0 <= $1 })
    }

    /// Adds array of dogs with addDog(forDog: Dog) repition  (but only sorts once at the end to be more efficent)
    func addDogs(forDogs: [Dog]) {
        for dog in forDogs {
            addDogWithoutSorting(forDog: dog)
        }

        dogs.sort(by: { $0 <= $1 })
    }

    /// Returns true if it removed at least one dog with the same dogUUID
    @discardableResult func removeDog(forDogUUID: UUID) -> Bool {
        var didRemoveObject = false
        
        dogs.removeAll { dog in
            guard dog.dogUUID == forDogUUID else {
                return false
            }
            
            didRemoveObject = true
            return true
        }
        
        return didRemoveObject
    }

    /// Returns an array of tuples [[(dogUUID, log)]]. This array has all of the logs for all of the dogs grouped what unique day/month/year they occured on, first element is furthest in the future and last element is the oldest.
    func logsForDogUUIDsGroupedByDate(forFilter: LogsFilter) -> [[(UUID, Log)]] {
        var dogUUIDLogPairs: [(UUID, Log)] = []

            for dog in dogs {
                if (forFilter.filterDogs.count >= 1 && forFilter.filterDogs.contains(where: {$0.dogUUID == dog.dogUUID}) == false) {
                    // We are filtering by dogs and this is not one of them, therefore, this dog is no available
                    continue
                }
                
                var numberOfLogsAdded = 0
                for log in dog.dogLogs.dogLogs {
                    // in total, we can only have maximumNumberOfLogs. This means that 1/2 of that limit could be from one dog, 1/4 from second dog, and 1/4 from a third dog OR all of that limit could be from one dog. Therefore, we must add maximumNumberOfLogs of logs for each dog, then eliminate excess at a later stage
                    guard numberOfLogsAdded <= LogsTableViewController.logsDisplayedLimit else {
                        break
                    }
                    
                    if (forFilter.filterLogActions.count >= 1 && forFilter.filterLogActions.contains(where: { $0 == log.logActionType}) == false) {
                        // We are filtering by log actions and this is not one of them, therefore, this log action is not available
                        continue
                    }
                    if (forFilter.filterFamilyMembers.count >= 1 && forFilter.filterFamilyMembers.contains(where: { $0.userId == log.userId}) == false) {
                        // We are filtering by family members and this is not one of them, therefore, this family member is no available
                        continue
                    }

                    dogUUIDLogPairs.append((dog.dogUUID, log))
                    numberOfLogsAdded += 1
                }
            }

        dogUUIDLogPairs.sort(by: { $0.1 <= $1.1 })

        // Splice the chronologically sorted array so that it doesn't exceed maximumNumberOfLogs elements. This will be the maximumNumberOfLogs most recent logs as the array is sorted chronologically
        dogUUIDLogPairs = dogUUIDLogPairs.count > LogsTableViewController.logsDisplayedLimit
        ? Array(dogUUIDLogPairs[..<LogsTableViewController.logsDisplayedLimit])
        : dogUUIDLogPairs

        // dogUUIDLogPairs grouped separated into different array element depending on their day, month, and year
        var logsForDogUUIDsGroupedByDate: [[(UUID, Log)]] = []

        // we will be going from oldest logs to newest logs (by logStartDate)
        for (dogUUID, log) in dogUUIDLogPairs {
            let logDay = Calendar.current.component(.day, from: log.logStartDate)
            let logMonth = Calendar.current.component(.month, from: log.logStartDate)
            let logYear = Calendar.current.component(.year, from: log.logStartDate)

            let containsDateCombination = {
                // dogUUIDLogPairs is sorted chronologically, which means everything is added in chronological order to logsForDogUUIDsGroupedByDate.
                guard let lastDateGroup = logsForDogUUIDsGroupedByDate.last, let (_, logFromLastDateGroup) = lastDateGroup.last else {
                    return false
                }

                let lastDay = Calendar.current.component(.day, from: logFromLastDateGroup.logStartDate)
                let lastMonth = Calendar.current.component(.month, from: logFromLastDateGroup.logStartDate)
                let lastYear = Calendar.current.component(.year, from: logFromLastDateGroup.logStartDate)

                // check to see if that day, month, year comboination is already present
                return lastDay == logDay && lastMonth == logMonth && lastYear == logYear
            }()

            if containsDateCombination {
                // there is already a tuple with the same day, month, and year, so we want to add this dogUUID/log combo to the array attached to that tuple
                logsForDogUUIDsGroupedByDate[logsForDogUUIDsGroupedByDate.count - 1].append((dogUUID, log))
            }
            else {
                // in the master array, there is not a matching tuple with the specified day, month, and year, so we should add an element that contains the day, month, and year plus this log since its logStartDate is on this day, month, and year
                logsForDogUUIDsGroupedByDate.append(([(dogUUID, log)]))
            }
        }

        return logsForDogUUIDsGroupedByDate
    }
    
    /// Iterates through all dogs for a given array of dogUUIDs. Finds all reminders for each of those dogs where the reminder is enabled, its reminderActionType matches, and its reminderCustomActionName matches.
    func matchingReminders(forDogUUIDs: [UUID], forLogActionType: LogActionType, forLogCustomActionName: String?) -> [(UUID, Reminder)] {
        var allMatchingReminders: [(UUID, Reminder)] = []

        // Find the dogs that are currently selected
        let dogs = dogs.filter { dog in
            forDogUUIDs.contains(dog.dogUUID)
        }
        
        // Search through all of the dogs currently selected. For each dog, find the matching reminders
        for dog in dogs {
            let matchingReminders = dog.matchingReminders(forLogActionType: forLogActionType, forLogCustomActionName: forLogCustomActionName)
            
            // We found any reminders that match, map them with their dogUUID to return them
            allMatchingReminders += matchingReminders.map({ reminder in
                (dog.dogUUID, reminder)
            })
        }
        
        return allMatchingReminders
    }
}
//
//  GeneralLayoutConstraint.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/17/25.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

/// Wrapper for NSLayoutConstraint that preserves original constant and multiplier,
/// and handles safe replacement (activation, deactivation) if the multiplier is changed.
/// All references and changes should be made through this class.
final class GeneralLayoutConstraint {
    
    // MARK: - Properties
    
    /// The minimum allowed multiplier (to avoid UIKit bugs from multiplier == 0.0)
    static let minimumMultiplier: CGFloat = 0.00000001

    /// The currently active NSLayoutConstraint managed by this wrapper.
    private(set) var constraint: NSLayoutConstraint
    
    /// The original constant value.
    let originalConstant: CGFloat
    
    /// The original multiplier value, if applicable.
    let originalMultiplier: CGFloat?
    
    /// Tracks if the constraint is in a "collapsed" state.
    var isCollapsed: Bool {
        return abs(multiplier ?? 1.0) < Self.minimumMultiplier
    }
    
    // MARK: - Init
    
    /// Wraps an existing NSLayoutConstraint, capturing its initial constant and multiplier (if any).
    init(wrapping constraint: NSLayoutConstraint) {
        self.constraint = constraint
        self.originalConstant = constraint.constant
        self.originalMultiplier = GeneralLayoutConstraint.extractMultiplier(from: constraint)
    }
    
    // MARK: - API
    
    /// The current constant.
    var constant: CGFloat {
        get { constraint.constant }
        set { constraint.constant = newValue }
    }
    
    /// The current multiplier (if any).
    var multiplier: CGFloat? {
        GeneralLayoutConstraint.extractMultiplier(from: constraint)
    }
    
    var isActive: Bool {
        get { constraint.isActive }
        set { constraint.isActive = newValue }
    }
    
    /// Change the multiplier. If a zero multiplier is passed, will coalesce to minimumMultiplier instead.
    func setMultiplier(_ newMultiplier: CGFloat) {
        // Coalesce zero to minimumMultiplier for UIKit safety
        let safeMultiplier: CGFloat = (abs(newMultiplier) < Self.minimumMultiplier) ? Self.minimumMultiplier : newMultiplier

        guard let origMultiplier = multiplier else {
            assertionFailure("Tried to set multiplier on a constraint without one (likely created with constant, not relative constraint)")
            return
        }
        guard abs(origMultiplier - safeMultiplier) > Self.minimumMultiplier else { return }
        guard let newConstraint = GeneralLayoutConstraint.rebuildConstraint(
            from: constraint, withMultiplier: safeMultiplier
        ) else {
            assertionFailure("Failed to rebuild constraint with new multiplier")
            return
        }
        swapConstraint(to: newConstraint)
    }
    
    /// Restore both constant and multiplier to original values.
    func restore() {
        constraint.constant = originalConstant
        if let origMultiplier = originalMultiplier {
            setMultiplier(origMultiplier)
        }
    }
    
    // MARK: - Internal Replacement
    
    /// Swaps the currently managed NSLayoutConstraint for a new one, activating and deactivating as needed.
    private func swapConstraint(to newConstraint: NSLayoutConstraint) {
        let wasActive = constraint.isActive
        constraint.isActive = false
        NSLayoutConstraint.deactivate([constraint])
        newConstraint.priority = constraint.priority
        newConstraint.identifier = constraint.identifier
        newConstraint.isActive = wasActive
        if wasActive {
            NSLayoutConstraint.activate([newConstraint])
        }
        self.constraint = newConstraint
    }
    
    // MARK: - Helpers
    
    /// Attempts to extract the multiplier from the constraint (KVC, as UIKit doesn't expose this).
    private static func extractMultiplier(from constraint: NSLayoutConstraint) -> CGFloat? {
        if constraint.firstAttribute != .notAnAttribute && constraint.secondItem != nil {
            return (constraint.value(forKey: "multiplier") as? CGFloat)
        }
        return nil
    }
    
    /// Build a new constraint by copying all parameters except multiplier, and using the specified multiplier.
    private static func rebuildConstraint(from old: NSLayoutConstraint, withMultiplier multiplier: CGFloat) -> NSLayoutConstraint? {
        guard let firstItem = old.firstItem else { return nil }
        let secondItem = old.secondItem
        
        if old.firstAttribute == .notAnAttribute || secondItem == nil {
            return nil
        }
        let newConstraint = NSLayoutConstraint(
            item: firstItem,
            attribute: old.firstAttribute,
            relatedBy: old.relation,
            toItem: secondItem,
            attribute: old.secondAttribute,
            multiplier: multiplier,
            constant: old.constant
        )
        newConstraint.priority = old.priority
        newConstraint.identifier = old.identifier
        return newConstraint
    }
}
//
//  Sender.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/27/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class Sender: NSObject {
    
    // MARK: - Properties

    let origin: AnyObject?
    var localized: AnyObject?
    
    // MARK: - Main

    init(origin: AnyObject, localized: AnyObject) {
        if let sender = origin as? Sender {
            self.origin = sender.origin
        }
        else {
            self.origin = origin
        }

        // localized cannot be sender, however we can let it pass
        if let sender = localized as? Sender {
            self.localized = sender.localized
        }
        else {
            self.localized = localized
        }
    }

}
//
//  HoundError.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/22/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class HoundError: Error {
    // MARK: - Properties

    /// Constant name of error. When HoundErrors are accessed from the Error Constant enum, they calculated properties. That means each time a HoundError is accessed, it's description might have changed. However, it's name and type will always be the same.
    private(set) var name: String
    /// Dynamic descripton of error. When HoundErrors are accessed from the Error Constant enum, they calculated properties. That means each time a HoundError is accessed, it's description might have changed. However, it's name and type will always be the same.
    private(set) var description: String

    /// If a HoundError is generated, a banner is shown for it, and the user taps the banner, this is the action that will be taken (after the banner is tapped).
    private(set) var onTap: (() -> Void)

    // MARK: - Main
    init(forName: String, forDescription: String, forOnTap: (() -> Void)?) {
        self.name = forName
        self.description = forDescription
        let userId = UserInformation.userId

        /// If onTap isn't specified, this is the default action to take.
        let defaultOnTap: (() -> Void) = {
            var message = "Name: \(forName)\nDescription: \(forDescription)"
            if let userId = userId {
                message.append("\nSupport ID: \(userId)")
            }

            let errorInformationAlertController = UIAlertController(title: "Error Information", message: message, preferredStyle: .alert)
            let copyAlertAction = UIAlertAction(title: "Copy to Clipboard", style: .default) { _ in
                UIPasteboard.general.setPasteboard(forString: message)
            }
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
            errorInformationAlertController.addAction(copyAlertAction)
            errorInformationAlertController.addAction(cancelAlertAction)
            PresentationManager.enqueueAlert(errorInformationAlertController)
        }

        self.onTap = forOnTap ?? defaultOnTap
    }

    // MARK: - Functions

    /// Alerts the user to this error. If the error is an appVersionOutdated error, presents a undismissable alert to update the app (bricking Hound until they update). Otherwise, presents a banner about the error
    func alert() {
        AppDelegate.generalLogger.error("Alerting user for error: \(self.description)")

        guard name != ErrorConstant.GeneralResponseError.appVersionOutdated(forRequestId: -1, forResponseId: -1).name else {
            let vc = AppVersionOutdatedViewController()
            PresentationManager.enqueueViewController(vc)
            return
        }
        
        guard name != ErrorConstant.FamilyResponseError.limitFamilyMemberExceeded(forRequestId: -1, forResponseId: -1).name else {
            let vc = LimitExceededViewController()
            PresentationManager.enqueueViewController(vc)
            return
        }

        PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.errorAlertTitle, forSubtitle: description, forStyle: .danger) {
            self.onTap()
        }
    }
}

final class HoundServerError: HoundError {

    // MARK: - Properties

    /// The requestId of a request to the Hound server that failed and generated an error
    private(set) var requestId: Int

    /// The responseId of a response from the Hound server due to a request that failed and generated an error
    private(set) var responseId: Int

    // MARK: - Main
    
    init(forName: String, forDescription: String, forOnTap: (() -> Void)?, forRequestId: Int, forResponseId: Int) {
        self.requestId = forRequestId
        self.responseId = forResponseId
        let userId = UserInformation.userId

        /// If onTap isn't specified, this is the default action to take.
        let defaultOnTap: (() -> Void) = {
            var message = "Name: \(forName)\nDescription: \(forDescription)\nRequest ID: \(forRequestId)\nResponse ID: \(forResponseId)"
            if let userId = userId {
                message.append("\nSupport ID: \(userId)")
            }

            let errorInformationAlertController = UIAlertController(title: "Error Information", message: message, preferredStyle: .alert)
            let copyAlertAction = UIAlertAction(title: "Copy to Clipboard", style: .default) { _ in
                UIPasteboard.general.setPasteboard(forString: message)
            }
            let cancelAlertAction = UIAlertAction(title: "Cancel", style: .cancel)
            errorInformationAlertController.addAction(copyAlertAction)
            errorInformationAlertController.addAction(cancelAlertAction)
            PresentationManager.enqueueAlert(errorInformationAlertController)
        }

        super.init(forName: forName, forDescription: forDescription, forOnTap: forOnTap ?? defaultOnTap)
    }
}
//
//  Subscription.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/14/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum SubscriptionGroup20965379Product: String, CaseIterable {

    // This order is specific, the lower indicies get sorted to the first positions
    case sixFamilyMembersOneYear = "com.jonathanxakellis.hound.sixfamilymembers.oneyear"
    case sixFamilyMembersSixMonth = "com.jonathanxakellis.hound.sixfamilymembers.sixmonth"
    case sixFamilyMembersOneMonth = "com.jonathanxakellis.hound.sixfamilymembers.onemonth"

    // case twoFMTwoDogs = "com.jonathanxakellis.hound.twofamilymemberstwodogs.monthly"
    // case fourFMFourDogs = "com.jonathanxakellis.hound.fourfamilymembersfourdogs.monthly"
    // case sixFMSixDogs = "com.jonathanxakellis.hound.sixfamilymemberssixdogs.monthly"
    // case tenFMTenDogs = "com.jonathanxakellis.hound.tenfamilymemberstendogs.monthly"
}

final class Subscription: NSObject, NSCoding {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedTransactionId = aDecoder.decodeOptionalInteger(forKey: KeyConstant.transactionId.rawValue)
        let decodedProductId = aDecoder.decodeOptionalString(forKey: KeyConstant.productId.rawValue)
        let decodedPurchaseDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.purchaseDate.rawValue)
        let decodedExpiresDate: Date? = aDecoder.decodeOptionalObject(forKey: KeyConstant.expiresDate.rawValue)
        let decodedNumberOfFamilyMembers = aDecoder.decodeOptionalInteger(forKey: KeyConstant.numberOfFamilyMembers.rawValue)
        let decodedIsActive = aDecoder.decodeOptionalBool(forKey: KeyConstant.isActive.rawValue)
        let decodedAutoRenewStatus = aDecoder.decodeOptionalBool(forKey: KeyConstant.autoRenewStatus.rawValue)
        let decodedAutoRenewProductId = aDecoder.decodeOptionalString(forKey: KeyConstant.autoRenewProductId.rawValue)

        self.init(
            internalTransactionId: decodedTransactionId,
            internalProductId: decodedProductId,
            internalPurchaseDate: decodedPurchaseDate,
            internalExpiresDate: decodedExpiresDate,
            internalNumberOfFamilyMembers: decodedNumberOfFamilyMembers,
            internalIsActive: decodedIsActive,
            internalAutoRenewStatus: decodedAutoRenewStatus,
            internalAutoRenewProductId: decodedAutoRenewProductId
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.

        if let transactionId = transactionId {
            aCoder.encode(transactionId, forKey: KeyConstant.transactionId.rawValue)
        }
        aCoder.encode(productId, forKey: KeyConstant.productId.rawValue)
        if let purchaseDate = purchaseDate {
            aCoder.encode(purchaseDate, forKey: KeyConstant.purchaseDate.rawValue)
        }
        if let expiresDate = expiresDate {
            aCoder.encode(expiresDate, forKey: KeyConstant.expiresDate.rawValue)
        }
        aCoder.encode(numberOfFamilyMembers, forKey: KeyConstant.numberOfFamilyMembers.rawValue)
        aCoder.encode(isActive, forKey: KeyConstant.isActive.rawValue)
        aCoder.encode(autoRenewStatus, forKey: KeyConstant.autoRenewStatus.rawValue)
        aCoder.encode(autoRenewProductId, forKey: KeyConstant.autoRenewProductId.rawValue)
    }
    
    // MARK: - Properties

    /// Transaction Id that of the subscription purchase
    private(set) var transactionId: Int?

    /// ProductId that the subscription purchase was for. No product means its a default subscription
    private(set) var productId: String

    /// Date at which the subscription was purchased and completed processing on Hound's server
    private(set) var purchaseDate: Date?

    /// Date at which the subscription will expire
    private(set) var expiresDate: Date?

    /// How many family members the subscription allows into the family
    private(set) var numberOfFamilyMembers: Int

    /// Indicates whether or not this subscription is the one thats active for the family
    var isActive: Bool

    /// Indicates whether or not this subscription will renew itself when it expires
    private(set) var autoRenewStatus: Bool

    /// The product identifier of the product that renews at the next billing period./
    private(set) var autoRenewProductId: String

    // MARK: - Main

    init(
        forTransactionId: Int?,
        forProductId: String,
        forPurchaseDate: Date?,
        forExpiresDate: Date?,
        forNumberOfFamilyMembers: Int,
        forIsActive: Bool,
        forAutoRenewStatus: Bool,
        forAutoRenewProductId: String
    ) {
        self.transactionId = forTransactionId
        self.productId = forProductId
        self.purchaseDate = forPurchaseDate
        self.expiresDate = forExpiresDate
        self.numberOfFamilyMembers = forNumberOfFamilyMembers
        self.isActive = forIsActive
        self.autoRenewStatus = forAutoRenewStatus
        self.autoRenewProductId = forAutoRenewProductId
        super.init()
    }
    
    private convenience init(
        internalTransactionId: Int?,
        internalProductId: String?,
        internalPurchaseDate: Date?,
        internalExpiresDate: Date?,
        internalNumberOfFamilyMembers: Int?,
        internalIsActive: Bool?,
        internalAutoRenewStatus: Bool?,
        internalAutoRenewProductId: String?
    ) {
        self.init(
            forTransactionId: internalTransactionId,
            forProductId: internalProductId ?? ClassConstant.SubscriptionConstant.defaultProductId,
            forPurchaseDate: internalPurchaseDate,
            forExpiresDate: internalExpiresDate,
            forNumberOfFamilyMembers: internalNumberOfFamilyMembers ?? ClassConstant.SubscriptionConstant.defaultSubscriptionNumberOfFamilyMembers,
            forIsActive: internalIsActive ?? false,
            forAutoRenewStatus: internalAutoRenewStatus ?? true,
            forAutoRenewProductId: internalAutoRenewProductId ?? internalProductId ?? ClassConstant.SubscriptionConstant.defaultProductId
        )
    }

    /// Assume array of family properties
    convenience init(fromBody body: [String: Any?]) {
        let transactionId: Int? = body[KeyConstant.transactionId.rawValue] as? Int
        let productId: String? = body[KeyConstant.productId.rawValue] as? String
        let purchaseDate: Date? = (body[KeyConstant.purchaseDate.rawValue] as? String)?.formatISO8601IntoDate()
        let expiresDate: Date? = (body[KeyConstant.expiresDate.rawValue] as? String)?.formatISO8601IntoDate()
        let numberOfFamilyMembers = body[KeyConstant.numberOfFamilyMembers.rawValue] as? Int
        let isActive = body[KeyConstant.isActive.rawValue] as? Bool
        let autoRenewStatus = body[KeyConstant.autoRenewStatus.rawValue] as? Bool
        let autoRenewProductId = body[KeyConstant.autoRenewProductId.rawValue] as? String

        self.init(
            internalTransactionId: transactionId,
            internalProductId: productId,
            internalPurchaseDate: purchaseDate,
            internalExpiresDate: expiresDate,
            internalNumberOfFamilyMembers: numberOfFamilyMembers,
            internalIsActive: isActive,
            internalAutoRenewStatus: autoRenewStatus,
            internalAutoRenewProductId: autoRenewProductId
        )
    }

}
//
//  Family.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/5/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

final class FamilyMember: NSObject, NSCoding, Comparable {
    
    // MARK: - NSCoding
    
    required convenience init?(coder aDecoder: NSCoder) {
        let decodedUserId = aDecoder.decodeOptionalString(forKey: KeyConstant.userId.rawValue)
        let decodedUserFirstName = aDecoder.decodeOptionalString(forKey: KeyConstant.userFirstName.rawValue)
        let decodedUserLastName = aDecoder.decodeOptionalString(forKey: KeyConstant.userLastName.rawValue)

        self.init(
            internalUserId: decodedUserId,
            internalFirstName: decodedUserFirstName,
            internalLastName: decodedUserLastName
        )
    }
    
    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(userId, forKey: KeyConstant.userId.rawValue)
        if let firstName = firstName {
            aCoder.encode(firstName, forKey: KeyConstant.userFirstName.rawValue)
        }
        if let lastName = lastName {
            aCoder.encode(lastName, forKey: KeyConstant.userLastName.rawValue)
        }
    }
    
    // MARK: - Comparable
    
    static func < (lhs: FamilyMember, rhs: FamilyMember) -> Bool {
        // the family head should always be first
        if lhs.isUserFamilyHead == true {
            // 1st element is head so should come before therefore return true
            return true
        }
        else if rhs.isUserFamilyHead == true {
            // 2nd element is head so should come before therefore return false
            return false
        }
        
        // Sort based upon name
        let lhsName = lhs.displayFullName ?? ""
        let rhsName = rhs.displayFullName ?? ""
        
        if lhsName.isEmpty && rhsName.isEmpty {
            // Both names are blank, use userId to determine order
            return lhs.userId <= rhs.userId
        }
        // we know one of OR both of the lhsName and rhsName are != nil &&.isEmpty == false
        else if lhsName.isEmpty {
            // no lhs name but has a rhs name
            return false
        }
        else if rhsName.isEmpty {
            // no rhs name but has lhs name
            return true
        }
        
        // Neither names are empty
        // "Bella" would come before "Zach"
        return lhsName <= rhsName
    }

    // MARK: - Properties
    
    /// The family member's userId
    private(set) var userId: String

    /// The family member's first name
    private(set) var firstName: String?

    /// The family member's last name
    private(set) var lastName: String?
    
    // MARK: - Main

    init(forUserId: String, forFirstName: String?, forLastName: String?) {
        self.userId = forUserId
        self.firstName = forFirstName
        self.lastName = forLastName
        super.init()
    }
    
    private convenience init(
        internalUserId: String?,
        internalFirstName: String?,
        internalLastName: String?
    ) {
        self.init(
            forUserId: internalUserId ?? VisualConstant.TextConstant.unknownHash,
            forFirstName: internalFirstName,
            forLastName: internalLastName
        )
    }

    /// Assume array of family properties
    convenience init(fromBody body: [String: Any?]) {
        let userId = body[KeyConstant.userId.rawValue] as? String
        let firstName = body[KeyConstant.userFirstName.rawValue] as? String
        let lastName = body[KeyConstant.userLastName.rawValue] as? String
        self.init(
            internalUserId: userId,
            internalFirstName: firstName,
            internalLastName: lastName
        )
    }
    
    // MARK: - Computed Properties
    
    /// True if this object's userId matches FamilyInformation.familyHeadUserId
    var isUserFamilyHead: Bool {
        return self.userId == FamilyInformation.familyHeadUserId
    }
    
    /// True if this object's userId matches UserInformation.userId
    var isUserSelf: Bool {
        return self.userId == UserInformation.userId
    }
    
    /// The family member's full name. Handles cases where the first name and/or last name may be ""
    var displayFullName: String? {
        let trimmedFirstName = firstName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        let trimmedLastName = lastName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""

        // check to see if anything is blank
        if trimmedFirstName.isEmpty && trimmedLastName.isEmpty {
            return nil
        }
        // we know one of OR both of the trimmedFirstName and trimmedLast name are != nil &&.isEmpty == false
        else if trimmedFirstName.isEmpty {
            // no first name but has last name
            return "\(trimmedLastName)\(isUserSelf ? " (Me)" : "")"
        }
        else if trimmedLastName.isEmpty {
            // no last name but has first name
            return "\(trimmedFirstName)\(isUserSelf ? " (Me)" : "")"
        }
        else {
            return "\(trimmedFirstName) \(trimmedLastName)\(isUserSelf ? " (Me)" : "")"
        }
    }

    /// The family member's first name. Handles cases where the first name may be "", therefore trying to use the last name to substitute
    var displayPartialName: String? {
        if let trimmedFirstName = firstName?.trimmingCharacters(in: .whitespacesAndNewlines) {
            return trimmedFirstName
        }
        else if let trimmedLastName = lastName?.trimmingCharacters(in: .whitespacesAndNewlines) {
            return trimmedLastName
        }
        
        return nil
    }
}
//
//  GenerationManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 12/5/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum GenerationManager {
    private static func generateRandomAlphanumericString(ofLength: Int) -> String {
        let characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        var randomString = ""
        
        for _ in 0..<ofLength {
            randomString.append(characters.randomElement() ?? Character(""))
        }
        
        return randomString
    }
    
    /// For a given dogManager, generates numberOfLogs of logs total and distrubutes them randomly among its dogs. Once all of these logs have been added to the Hound server, invoked completionHandler
    static func generateRandomLogs(toDogManager: DogManager, numberOfLogs: Int, completionHandler: (() -> Void)?) {
        
        let completionTracker = CompletionTracker(numberOfTasks: numberOfLogs) {
            // Do nothing if one task was completed
        } completedAllTasksCompletionHandler: {
            // Invoke completionHandler if all tasks completed
            completionHandler?()
        } failedTaskCompletionHandler: {
            // Invoke completionHandler if one task failed
            completionHandler?()
        }

        for i in 0..<numberOfLogs {
            guard let logActionType = GlobalTypes.shared.logActionTypes.randomElement() else {
                return
            }
            // If the logActionType is custom, then 50% chance for a random note and 50% chance for no note
            let logCustomActionName = logActionType.allowsCustom
            ? (Int.random(in: 0...1) == 0 ? generateRandomAlphanumericString(ofLength: Int.random(in: 0...32)) : nil)
            : nil
            
            let referenceDate = Calendar.current.date(byAdding: .month, value: -1, to: Date()) ?? Date(timeIntervalSinceReferenceDate: 0.0)
            let logStartDate = referenceDate.addingTimeInterval(
                Double.random(in: 0.0...referenceDate.distance(to: Date()))
            )
            let logEndDate = Int.random(in: 0...1) == 0
            ? nil
            : logStartDate.addingTimeInterval(Double.random(in: 0.0...logStartDate.distance(to: Date())))
            
            let logNote = Int.random(in: 0...1) == 0
            ? nil
            : generateRandomAlphanumericString(ofLength: Int.random(in: 0...100))
            
            let logUnitType = logActionType.associatedLogUnitTypes.randomElement()
            
            let logNumberOfUnits = Double.random(in: 0.0...1000.0)
            
            let log = Log(
                forLogId: nil,
                forLogActionTypeId: logActionType.logActionTypeId,
                forLogCustomActionName: logCustomActionName,
                forLogStartDate: logStartDate,
                forLogEndDate: logEndDate,
                forLogNote: logNote,
                forLogUnitTypeId: logUnitType?.logUnitTypeId,
                forLogNumberOfUnits: logNumberOfUnits
            )
            
            let dog = toDogManager.dogs.randomElement()
            
            guard let dog = dog else {
                continue
            }
            
            DispatchQueue.main.asyncAfter(deadline: .now() + (Double(i) * 1.0)) {
                guard completionTracker.isFinished == false else {
                    return
                }
                
                LogsRequest.create(forErrorAlert: .automaticallyAlertForNone, forDogUUID: dog.dogUUID, forLog: log) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        completionTracker.failedTask()
                        return
                    }
                    
                    completionTracker.completedTask()
                    dog.dogLogs.addLog(forLog: log)
                }
            }
        }
    }
}
//
//  ReminderAlarmManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/20/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol ReminderAlarmManagerDelegate: AnyObject {
    func didAddLog(sender: Sender, forDogUUID: UUID, forLog: Log)
    func didAddReminder(sender: Sender, forDogUUID: UUID, forReminder: Reminder)
    func didRemoveReminder(sender: Sender, forDogUUID: UUID, forReminderUUID: UUID)
}

final class ReminderAlarmManager {
    private class AlarmQueueItem {
        private(set) var dogName: String
        private(set) var dogUUID: UUID
        private(set) var reminder: Reminder

        init(forDogName: String, forDogUUID: UUID, forReminder: Reminder) {
            self.dogName = forDogName
            self.dogUUID = forDogUUID
            self.reminder = forReminder
        }
    }
    static weak var delegate: ReminderAlarmManagerDelegate!

    /// If the globalPresenter is not loaded, indicating that the app is in the background, we store all willCreateAndShowReminderAlarm calls in this alarmQueue. This ensures that once the app is opened, the alarm queue is executed so that it refreshes the most current information from the server.
    private static var alarmQueue: [AlarmQueueItem] = []

    /// Creates AlarmUIAlertController to show the user about their alarm going off. We query the server with the information provided first to make sure it is up to date.
    static func willCreateAndShowReminderAlarm(forDogName: String, forDogUUID: UUID, forReminder: Reminder) {
        // If the app is in the background, add the willCreateAndShowReminderAlarm to the queue. Once the app is brought to the foreground, executes synchronizeReminderAlarmQueueIfNeeded to attempt to reshow all of these alarms. This ensures that when the alarms are presented, the app is open. Otherwise, we could refresh the information for an alarm and present it, only for it to sit in the background for an hour while the app is closed, making the alarm outdated.
        guard UIApplication.shared.applicationState != .background else {
            // make sure we don't have multiple of the same alarm in the alarm queue
            alarmQueue.removeAll { alarmQueueItem in
                alarmQueueItem.dogUUID == forDogUUID && alarmQueueItem.reminder.reminderUUID == forReminder.reminderUUID
            }
            alarmQueue.append(AlarmQueueItem(forDogName: forDogName, forDogUUID: forDogUUID, forReminder: forReminder))
            return
        }

        // before presenting alarm, make sure we are up to date locally
        RemindersRequest.get(forErrorAlert: .automaticallyAlertForNone, forDogUUID: forDogUUID, forReminder: forReminder) { reminder, responseStatus, _ in
            guard responseStatus != .failureResponse else {
                return
            }

            guard let reminder = reminder else {
                // If the response was successful but no reminder was returned, that means the reminder was deleted. Therefore, tell the delegate as such.
                delegate.didRemoveReminder(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forReminderUUID: forReminder.reminderUUID)
                return
            }

            // reminderExecutionDate must not be nil, otherwise if reminderExecutionDate is nil then the reminder was potentially was disabled or the reminder's timing components are broken.
            // the distance from present to executionDate must be negitive, otherwise if the distance is negative then executionDate in past
            guard let reminderExecutionDate = reminder.reminderExecutionDate, Date().distance(to: reminderExecutionDate) < 0 else {
                // We were able to retrieve the reminder and something was wrong with it. Something was disabled, the reminder was pushed back to the future, or it simply just has invalid timing components.
                // MARK: IMPORTANT - Do not try to refresh DogManager as that can (and does) cause an infinite loop. The reminder can exist but for some reason have invalid data leading to a nil executionDate. If we refresh the DogManager, we could retrieve the same invalid reminder data which leads back to this statement (and thus starts the infinite loop)

                self.delegate.didAddReminder(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forReminder: forReminder)
                return
            }

            // the reminder exists, its executionDate exists, and its executionDate is in the past (meaning it should be valid).

            // the dogUUID and reminderUUID exist if we got a reminder back
            let title = "\(reminder.reminderActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName)) - \(forDogName)"

            let alarmAlertController = AlarmUIAlertController(
                title: title,
                message: nil,
                preferredStyle: .alert)
            alarmAlertController.setup(forDogUUID: forDogUUID, forReminder: reminder)

            var alertActionsForLog: [UIAlertAction] = []

            // Cant convert a reminderActionType of potty directly to logActionType, as it has serveral possible outcomes. Otherwise, logActionType and reminderActionType 1:1
            let logActionTypes: [LogActionType] = reminder.reminderActionType.associatedLogActionTypes

            for logActionType in logActionTypes {
                let logAlertAction = UIAlertAction(
                    title: "Log \(logActionType.convertToReadableName(customActionName: reminder.reminderCustomActionName))",
                    style: .default,
                    handler: { _ in
                        // alarmAlertController could have been absorbed into another alarmAlertController
                        let alartController = alarmAlertController.absorbedIntoAlarmAlertController ?? alarmAlertController

                        guard let alarmReminders = alartController.reminders else {
                            return
                        }

                        for alarmReminder in alarmReminders {
                            ReminderAlarmManager.userSelectedLogAlarm(forDogUUID: forDogUUID, forReminder: alarmReminder, forLogActionType: logActionType)
                            ReminderTimingManager.didCompleteForReminderTimer(forReminderUUID: alarmReminder.reminderUUID, forType: .alarmTimer)
                        }
                        
                        ShowBonusInformationManager.requestAppStoreReviewIfNeeded()
                        ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
                    })
                alertActionsForLog.append(logAlertAction)
            }

            let snoozeAlertAction = UIAlertAction(
                title: "Snooze",
                style: .default,
                handler: { (_: UIAlertAction!)  in
                    // alarmAlertController could have been absorbed into another alarmAlertController
                    let alartController = alarmAlertController.absorbedIntoAlarmAlertController ?? alarmAlertController

                    guard let alarmReminders = alartController.reminders else {
                        return
                    }

                    for alarmReminder in alarmReminders {
                        ReminderAlarmManager.userSelectedSnoozeAlarm(forDogUUID: forDogUUID, forReminder: alarmReminder)
                        ReminderTimingManager.didCompleteForReminderTimer(forReminderUUID: alarmReminder.reminderUUID, forType: .alarmTimer)
                    }
                    
                    ShowBonusInformationManager.requestAppStoreReviewIfNeeded()
                    ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
                })

            let dismissAlertAction = UIAlertAction(
                title: "Dismiss",
                style: .cancel,
                handler: { (_: UIAlertAction!)  in
                    // alarmAlertController could have been absorbed into another alarmAlertController
                    let alartController = alarmAlertController.absorbedIntoAlarmAlertController ?? alarmAlertController

                    guard let alarmReminders = alartController.reminders else {
                        return
                    }

                    for alarmReminder in alarmReminders {
                        ReminderAlarmManager.userSelectedDismissAlarm(forDogUUID: forDogUUID, forReminder: alarmReminder)
                        ReminderTimingManager.didCompleteForReminderTimer(forReminderUUID: alarmReminder.reminderUUID, forType: .alarmTimer)
                    }
                    
                    ShowBonusInformationManager.requestAppStoreReviewIfNeeded()
                    ShowBonusInformationManager.requestSurveyAppExperienceIfNeeded()
                })

            for logAlertAction in alertActionsForLog {
                alarmAlertController.addAction(logAlertAction)
            }
            
            alarmAlertController.addAction(snoozeAlertAction)
            alarmAlertController.addAction(dismissAlertAction)

            delegate.didAddReminder(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forReminder: reminder)
            
            PresentationManager.enqueueAlert(alarmAlertController)
        }
    }

    /// Once the app is brought back into the foreground, meaning the alarms in the alarm queue can be presented, call this function to iterate through and present any alarms in the alarm queue
    static func synchronizeReminderAlarmQueueIfNeeded() {

        // Only attempt to show the alarms if the app isn't in the background
        guard UIApplication.shared.applicationState != .background else {
            return
        }

        let copiedAlarmQueue = alarmQueue
        alarmQueue = []

        // We can't iterate over alarmQueue as willCreateAndShowReminderAlarm could potentially add items to alarmQueue. That means we need to empty alarmQueue before iterating over to avoid mixing.
        for (index, alarmQueueItem) in copiedAlarmQueue.enumerated() {
            // First alarm (at front of queue... should come first): execute queries right now
            // Second alarm: execute queries after 25 ms to help ensure it comes second
            // Thirds alarm: execute queries after 50 ms to help ensure it comes third
            DispatchQueue.main.asyncAfter(deadline: .now() + (0.05 * Double(index)), execute: {
                willCreateAndShowReminderAlarm(forDogName: alarmQueueItem.dogName, forDogUUID: alarmQueueItem.dogUUID, forReminder: alarmQueueItem.reminder)
            })
        }
    }
    
    /// User responded to the reminder's alarm that popped up on their screen. They selected to 'Snooze' the reminder. Therefore we modify the timing data so the reminder turns into .snooze mode, alerting them again soon. We don't add a log
    private static func userSelectedSnoozeAlarm(forDogUUID: UUID, forReminder: Reminder) {
        forReminder.resetForNextAlarm()
        forReminder.snoozeComponents.executionInterval = UserConfiguration.snoozeLength

        // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
        RemindersRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forReminders: [forReminder]) { responseStatus, _ in
            guard responseStatus != .failureResponse else {
                return
            }

            delegate.didAddReminder(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forReminder: forReminder)
        }

    }

    /// User responded to the reminder's alarm that popped up on their screen. They selected to 'Dismiss' the reminder. Therefore we reset the timing data and don't add a log.
    private static func userSelectedDismissAlarm(forDogUUID: UUID, forReminder: Reminder) {
        // special case. Once a oneTime reminder executes, it must be delete. Therefore there are special server queries.
        if forReminder.reminderType == .oneTime {
            // just make request to delete reminder for oneTime remidner
            RemindersRequest.delete(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forReminderUUIDs: [forReminder.reminderUUID]) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }

                delegate.didRemoveReminder(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forReminderUUID: forReminder.reminderUUID)
            }
        }
        // Nest all the other cases inside this else statement as otherwise .oneTime alarms would make request with the above code then again down here.
        else {
            // the reminder just executed an alarm/alert, so we want to reset its stuff
            forReminder.resetForNextAlarm()

            // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
            RemindersRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forReminders: [forReminder]) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    return
                }

                delegate.didAddReminder(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forReminder: forReminder)
            }
        }

    }

    /// User responded to the reminder's alarm that popped up on their screen. They selected to 'Log' the reminder. Therefore we reset the timing data and add a log.
    private static func userSelectedLogAlarm(forDogUUID: UUID, forReminder: Reminder, forLogActionType: LogActionType) {
        let log = Log()
        log.logActionTypeId = forLogActionType.logActionTypeId
        log.logCustomActionName = forReminder.reminderCustomActionName
        log.changeLogDate(forLogStartDate: Date(), forLogEndDate: nil)

        // special case. Once a oneTime reminder executes, it must be delete. Therefore there are special server queries.
        if forReminder.reminderType == .oneTime {
            // make request to add log, then (if successful) make request to delete reminder

            // delete the reminder on the server
            RemindersRequest.delete(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forReminderUUIDs: [forReminder.reminderUUID]) { responseStatusReminderDelete, _ in
                guard responseStatusReminderDelete != .failureResponse else {
                    return
                }

                delegate.didRemoveReminder(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forReminderUUID: forReminder.reminderUUID)
                // create log on the server and then assign it the logUUID and then add it to the dog
                LogsRequest.create(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forLog: log) { responseStatusLogCreate, _ in
                    guard responseStatusLogCreate != .failureResponse else {
                        return
                    }

                    delegate.didAddLog(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forLog: log)
                }
            }
        }
        // Nest all the other cases inside this else statement as otherwise .oneTime alarms would make request with the above code then again down here.
        else {
            // the reminder just executed an alarm/alert, so we want to reset its stuff
            forReminder.resetForNextAlarm()

            // make request to the server, if successful then we persist the data. If there is an error, then we discard to data to keep client and server in sync (as server wasn't able to update)
            RemindersRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forReminders: [forReminder]) { responseStatusReminderUpdate, _ in
                guard responseStatusReminderUpdate != .failureResponse else {
                    return
                }

                delegate.didAddReminder(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forReminder: forReminder)
                // we need to persist a log as well
                LogsRequest.create(forErrorAlert: .automaticallyAlertOnlyForFailure, forDogUUID: forDogUUID, forLog: log) { responseStatusLogCreate, _ in
                    guard responseStatusLogCreate != .failureResponse else {
                        return
                    }

                    delegate.didAddLog(sender: Sender(origin: self, localized: self), forDogUUID: forDogUUID, forLog: log)
                }
            }
        }

    }
}
//
//  ShowBonusInformationManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/10/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import CallKit
import StoreKit

enum ShowBonusInformationManager {
    
    /// Displays release notes about a new version to the user if they have that setting enabled and the app was updated to that new version
    static func showReleaseNotesBannerIfNeeded() {
        // Check that the app was opened before, as we don't want to show the user release notes on their first launch
        // Then, check that the current version doesn't match the previous version, meaning an upgrade or downgrade. The latter shouldnt be possible
        guard let previousAppVersion = UIApplication.previousAppVersion, previousAppVersion != UIApplication.appVersion else {
            return
        }
        
        // make sure we haven't shown the release notes for this version before. To do this, we check to see if our array of app versions that we showed release notes for contains the app version of the current version. If the array does not contain the current app version, then we haven't shown release notes for this new version and we are ok to proceed.
        guard LocalConfiguration.localAppVersionsWithReleaseNotesShown.contains(UIApplication.appVersion) == false else {
            return
        }
        
        AppDelegate.generalLogger.notice("Showing Release Notes")
        
        let message: String? = "- Skippable Reminders! Want to forgo your reminder's next alarm? Now you can!\n\n- Added Ability to Duplicate Reminders!\n\n-"
        
        PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.houndUpdatedTitle, forSubtitle: message != nil ? VisualConstant.BannerTextConstant.houndUpdatedSubtitle : nil, forStyle: .info) {
            guard let message = message else {
                return
            }
            // If the user taps on the banner, then we show them the release notes
            
            let updateAlertController = UIAlertController(title: "Release Notes For Hound \(UIApplication.appVersion)", message: message, preferredStyle: .alert)
            let understandAlertAction = UIAlertAction(title: "OK", style: .default, handler: nil)
            
            updateAlertController.addAction(understandAlertAction)
            PresentationManager.enqueueAlert(updateAlertController)
        }
        
        // we successfully showed the banner, so store the version we showed it for
        LocalConfiguration.localAppVersionsWithReleaseNotesShown.append(UIApplication.appVersion)
    }
    
    /// This is the number of seconds in a day
    private static let dayDurationInSeconds: Double = 24.0 * 60.0 * 60.0
    
    /// We want to user to review Hound every increasingDaysBetween * numberOfTimesAskedToAppReviewReview days. Additionally, we offset this value by 0.2 day (4.8 hour) to ask during different times of day.
    private static let increasingDaysBetweenAppStoreReview: Double = 5.0 + 0.2
    /// We can only ask a user three time a year to review Hound, therefore, cap the interval to a value slightly over year / 3.
    private static let maximumDaysBetweenAppStoreReview: Double = 122.0 + 0.2
    
    /// We want to user to share Hound every increasingDaysBetween * numberOfTimesAskedToSurveyAppExperience days. Additionally, we offset this value by 0.2 day (4.8 hour) to ask during different times of day.
    private static let increasingDaysBetweenSurveyAppExperience = 3.0 + 0.2
    /// We begin by asking the user to review Hound with at a minimum frequency. This interval progressively grows, but we don't want the interval to grow too large where we ask too infrequently. This variable caps the interval to ensure a certain frequency.
    private static let maximumDaysBetweenSurveyAppExperience: Double = 40.0 + 0.2
    
    /// Checks to see if the user is eligible for a notification to asking them to review Hound and if so presents the notification
    static func requestAppStoreReviewIfNeeded() {
        // We don't want to request an app store star rating if we recently requested a survey app experience
        if let lastDateSurveyAppExperienceRequested = LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.last {
            if lastDateSurveyAppExperienceRequested.distance(to: Date()) <= 1.2 * dayDurationInSeconds {
                return
            }
        }
        
        guard let lastDateUserReviewRequested = LocalConfiguration.localPreviousDatesUserReviewRequested.last else {
            LocalConfiguration.localPreviousDatesUserReviewRequested.append(Date())
            PersistenceManager.persistRateReviewRequestedDates()
            return
        }
        
        // Check if we WANT to show the user a pop-up to review Hound.
        let isDueForReviewRequest: Bool = {
            // count == 1: Been asked zero times before (first Date() is a placeholder). We ask 9.2 days after the initial install.
            // count == 2: asked one time; 18.4 days since last ask
            // count == 3: asked two times; 27.6 days since last ask
            // count == 4: asked three times; 36.8 days since last ask
            
            let numberOfDaysToWaitForNextReview: Double = min(
                Double(LocalConfiguration.localPreviousDatesUserReviewRequested.count) * increasingDaysBetweenAppStoreReview,
                maximumDaysBetweenAppStoreReview
            )
            
            let timeWaitedSinceLastAsk = lastDateUserReviewRequested.distance(to: Date())
            let timeNeededToWaitForNextAsk = numberOfDaysToWaitForNextReview * dayDurationInSeconds
            
            return timeWaitedSinceLastAsk > timeNeededToWaitForNextAsk
        }()
        
        guard isDueForReviewRequest == true else {
            return
        }
        
        // Check if we CAN show the user a pop-up to review Hound.
        let isEligibleForReviewRequest: Bool = {
            // You can request a maximum of three reviews through StoreKit a year. If < 3, then the user is eligible to be asked.
            guard LocalConfiguration.localPreviousDatesUserReviewRequested.count >= 3 else {
                return true
            }
            
            let thirdToLastUserReviewRequestedDate = LocalConfiguration.localPreviousDatesUserReviewRequested.safeIndex(
                LocalConfiguration.localPreviousDatesUserReviewRequested.count - 3)
            let timeWaitedSinceOldestReviewRequest = thirdToLastUserReviewRequestedDate?.distance(to: Date())
            
            guard let timeWaitedSinceOldestReviewRequest = timeWaitedSinceOldestReviewRequest else {
                return false
            }
            let timeNeededToWaitForNextReviewRequest = 367.0 * dayDurationInSeconds
            
            return timeWaitedSinceOldestReviewRequest > timeNeededToWaitForNextReviewRequest
        }()
        
        guard isEligibleForReviewRequest == true else {
            return
        }
        
        /*
         Apple's built in requestReview feature will only work if the user has that setting enabled on their phone. There is no way of checking this though. Therefore, if the setting is set to false, this function turns into a NO-OP with no way for us to tell.
         
         This means we can't use a banner. We run the risk of displaying a banner that asks for a review and won't show anything if tapped. Therefore we use Apple's requestReview directly. If it works, then the user will see the pop-up. Otherwise, the user won't know anything triggered.
         */
        
        guard let window = UIApplication.keyWindow?.windowScene else {
            AppDelegate.generalLogger.error("requestAppStoreReviewIfNeeded unable to fire, window not established")
            return
        }
        
        // Delay this call slightly so that current ui elements have time to complete
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            AppDelegate.generalLogger.notice("Asking user to rate Hound")
            
            SKStoreReviewController.requestReview(in: window)
            LocalConfiguration.localPreviousDatesUserReviewRequested.append(Date())
            PersistenceManager.persistRateReviewRequestedDates()
        }
        
    }
    
    /// Displays a view controller that asks for user's rating of hound
    static func requestSurveyAppExperienceIfNeeded() {
        // We don't want to request a survey for the app experience if we recently requested an app store star rating
        if let lastDateAppStoreViewRequested = LocalConfiguration.localPreviousDatesUserReviewRequested.last {
            if lastDateAppStoreViewRequested.distance(to: Date()) <= 1.2 * dayDurationInSeconds {
                return
            }
        }
        
        // This is the duration, in seconds, that Hound should wait before repeating showing the user the pop up to review the app. Currently, we wait 6 months before asking a user for a survey again
        let durationToWaitBeforeRepeatingSurvey = 180.0 * dayDurationInSeconds
        
        guard let lastDateSurveyAppExperienceRequested = LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.last else {
            LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.append(Date())
            return
        }
        
        if let lastDateUserSurveyFeedbackAppExperienceSubmitted = LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted.last {
            if lastDateUserSurveyFeedbackAppExperienceSubmitted.distance(to: Date()) < durationToWaitBeforeRepeatingSurvey {
                return
            }
        }
        
        // Check if we WANT to show the user a pop-up to share Hound.
        let isDueForSurveyAppExperienceRequest: Bool = {
            // count == 1: Been asked zero times before (first Date() is a placeholder). We ask 5.2 days after the initial install.
            // count == 2: asked one time; 10.4 days since last ask
            // count == 3: asked two times; 15.6 days since last ask
            // count == 4: asked three times; 20.8 days since last ask
            
            let numberOfDaysToWaitForNextSurveyAppExperience: Double = min(
                Double(LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.count) * increasingDaysBetweenSurveyAppExperience,
                maximumDaysBetweenSurveyAppExperience
            )
            
            let timeWaitedSinceLastAsk = lastDateSurveyAppExperienceRequested.distance(to: Date())
            let timeNeededToWaitForNextAsk = numberOfDaysToWaitForNextSurveyAppExperience * dayDurationInSeconds
            
            return timeWaitedSinceLastAsk > timeNeededToWaitForNextAsk
        }()
        
        guard isDueForSurveyAppExperienceRequest == true else {
            return
        }
        
       // Delay this call slightly so that current ui elements have time to complete
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            let vc = SurveyAppExperienceViewController()
            PresentationManager.enqueueViewController(vc)
        }
    }
    
}
//
//  InAppPurchaseManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/13/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import KeychainSwift
import StoreKit

// This main class provides a streamlined way to perform the main two queries
final class InAppPurchaseManager {

    /// Initialized InternalInAppPurchaseManager.shared. This creates the InternalInAppPurchaseManager() object, and this in turn sets that object as a observer for the PaymentQueue and as a observer for the price increase consent
    static func initializeInAppPurchaseManager() {
        _ = InternalInAppPurchaseManager.shared
    }

    /// When you increase the price of a subscription, the system asks your delegate’s function paymentQueueShouldShowPriceConsent() whether to immediately display the price consent sheet, or to delay displaying the sheet until later. For example, you may want to delay showing the sheet if it would interrupt a multistep user interaction, such as setting up a user account. Return false in paymentQueueShouldShowPriceConsent() to prevent the dialog from displaying immediately. To show the price consent sheet after a delay, call showPriceConsentIfNeeded(), which shows the sheet only if the user hasn’t responded to the price increase notifications.
    static func showPriceConsentIfNeeded() {
        InternalInAppPurchaseManager.shared.showPriceConsentIfNeeded()
    }

    /// Attempts to show the App Store manage subscriptions page. If an error occurs with that, then opens the apple.com manage subscritpions page
    static func showManageSubscriptions() {
        // iOS gets picky and throws errors if this isn't on the main thread so ensure that it is
        DispatchQueue.main.async {
            guard let windowScene = UIApplication.keyWindow?.windowScene else {
                guard let url = URL(string: "https://apps.apple.com/account/subscriptions") else {
                    return
                }
                UIApplication.shared.open(url)
                return
            }

            Task {
                do {
                    try await AppStore.showManageSubscriptions(in: windowScene)
                }
                catch {
                    guard let url = URL(string: "https://apps.apple.com/account/subscriptions") else {
                        return
                    }
                    _ = await UIApplication.shared.open(url)
                }
            }
        }
    }

    static var subscriptionProducts: [SKProduct] {
        return InternalInAppPurchaseManager.shared.subscriptionProducts ?? []
    }

    /// Query apple servers to retrieve all available products. If there is an error, ErrorManager is automatically invoked and nil is returned.
    static func fetchProducts(completionHandler: @escaping (HoundError?) -> Void) {
        InternalInAppPurchaseManager.shared.fetchProducts { error in
            completionHandler(error)
        }
    }

    /// Query apple servers to purchase a certain product. If successful, then queries Hound servers to have transaction verified and applied. If there is an error, ErrorManager is automatically invoked and nil is returned.
    static func purchaseProduct(
        forProduct product: SKProduct,
        completionHandler: @escaping (String?) -> Void
    ) {
        InternalInAppPurchaseManager.shared.purchase(forProduct: product) { productIdentifier in
            completionHandler(productIdentifier)
        }
    }

    /// Asks the payment queue to restore previously completed purchases. Once they are restored, the receipt is communicated to the Hound server and any missing record is added.
    static func restorePurchases(completionHandler: @escaping (Bool) -> Void) {
        InternalInAppPurchaseManager.shared.restorePurchases { Bool in
            completionHandler(Bool)
        }
    }

    /// Displays a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.
    static func presentCodeRedemptionSheet() {
        // Make sure the user has the Hound permissions to perform such a request
        guard UserInformation.isUserFamilyHead else {
            ErrorConstant.InAppPurchaseError.purchasePermission().alert()
            return
        }

        SKPaymentQueue.default().presentCodeRedemptionSheet()
    }
}

// Handles the important code of InAppPurchases with Apple server communication. Segmented from main class to reduce clutter
private final class InternalInAppPurchaseManager: NSObject, SKProductsRequestDelegate, SKPaymentTransactionObserver, SKPaymentQueueDelegate {

    // MARK: - Properties

    static let shared = InternalInAppPurchaseManager()

    /// Keeps track of if the system is asyncronously, in the background, updating the transaction records on the hound server. This can occur if there is a subscription renewal which gets added to the paymentQueue.
    var backgroundPurchaseInProgress: Bool = false

    override init() {
        super.init()
        // Observe Price Increase Consent
        SKPaymentQueue.default().delegate = self
        // Observe Pending Transactions
        SKPaymentQueue.default().add(self)
    }

    // MARK: - Consent To Subscription Price Increase

    func paymentQueueShouldShowPriceConsent(_ paymentQueue: SKPaymentQueue) -> Bool {
        // Check to make sure that mainTabBarController exists and is loaded.
        guard MainTabBarController.isInViewHierarchy else {
            // The mainTabBarController doesn't exist yet and/or isn't loaded. Therefore we should defer until its loaded. mainTabBarController will call showPriceConsentIfNeeded once it loads and take care of the deferrment
            return false
        }

        // mainTabBarController exists and is loaded, so lets show the price consent
        return true
    }

    /// When you increase the price of a subscription, the system asks your delegate’s function paymentQueueShouldShowPriceConsent() whether to immediately display the price consent sheet, or to delay displaying the sheet until later. For example, you may want to delay showing the sheet if it would interrupt a multistep user interaction, such as setting up a user account. Return false in paymentQueueShouldShowPriceConsent() to prevent the dialog from displaying immediately. To show the price consent sheet after a delay, call showPriceConsentIfNeeded(), which shows the sheet only if the user hasn’t responded to the price increase notifications.
    func showPriceConsentIfNeeded() {
        SKPaymentQueue.default().showPriceConsentIfNeeded()
    }

    // MARK: - Fetch Products

    /// Keep track of the current request completionHandler
    private var productsRequestCompletionHandler: ((HoundError?) -> Void)?

    /// Products retrieved from SKProductsRequest that are subscription products
    private(set) var subscriptionProducts: [SKProduct]?

    func fetchProducts(completionHandler: @escaping (HoundError?) -> Void) {
        // We have subscription products, so no need to fetch more
        guard subscriptionProducts == nil else {
            completionHandler(nil)
            return
        }
    
        guard productsRequestCompletionHandler == nil else {
            // If another request is initated while there is currently an on going request, we want to reject that request
            completionHandler(ErrorConstant.InAppPurchaseError.productRequestInProgress())
            return
        }

        let request = SKProductsRequest(productIdentifiers: Set(SubscriptionGroup20965379Product.allCases.compactMap({ $0.rawValue })))
        request.delegate = self
        request.start()
        productsRequestCompletionHandler = completionHandler
    }

    /// Get available products from Apple Servers
    func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) {
        let products = response.products.sorted(by: { unknownProduct1, unknownProduct2 in
            // The product with a product identifier that is closer to index 0 of the InAppPurchase enum allCases should come first. If a product identifier is unknown, the known one comes first. If both product identiifers are known, we have the <= productIdentifer come first.

            let product1 = SubscriptionGroup20965379Product(rawValue: unknownProduct1.productIdentifier)
            let product2 = SubscriptionGroup20965379Product(rawValue: unknownProduct2.productIdentifier)

            if product1 == nil && product2 == nil {
                // the product identifiers aren't known to us. Therefore we should sort based upon the product identifier strings themselves
                return unknownProduct1.productIdentifier <= unknownProduct2.productIdentifier
            }

            // at least one of them isn't nil
            guard let product1 = product1 else {
                // since product1 isn't known and therefore product2 is known, product2 should come first
                return false
            }

            guard let product2 = product2 else {
                // since product1 is known and product2 isn't, product1 should come first
                return true
            }

            guard let indexOfProduct1: Int = SubscriptionGroup20965379Product.allCases.firstIndex(of: product1), let indexOfProduct2: Int = SubscriptionGroup20965379Product.allCases.firstIndex(of: product2) else {
                // if we can't find their indexes, compare them based off their productIdentifiers
                return unknownProduct1.productIdentifier <= unknownProduct2.productIdentifier
            }

            // the product with product identifier that has the lower index in .allCases of the InAppPurchase enum comes first
            return indexOfProduct1 <= indexOfProduct2
            })

        // Call everything on async thread. Otherwise, productsRequestCompletionHandler will be set to nil slightly before productsRequestCompletionHandler(result, result) can be called, therefore not calling the completionHandler.
        DispatchQueue.main.async {
            guard products.count >= 1 else {
                self.productsRequestCompletionHandler?(ErrorConstant.InAppPurchaseError.productRequestNotFound())
                self.productsRequestCompletionHandler = nil
                return
            }
            
            self.productsRequestCompletionHandler?(nil)
            self.subscriptionProducts = products.filter({ product in
                product.subscriptionPeriod != nil
            })
        }
    }

    /// Observe if there was an error when retrieving the products
    func request(_ request: SKRequest, didFailWithError error: Error) {
        // return to completion handler then reset for next products request
        DispatchQueue.main.async {
            self.productsRequestCompletionHandler?(ErrorConstant.InAppPurchaseError.productRequestFailed())
            self.productsRequestCompletionHandler = nil
        }
    }

    // MARK: - Purchase a Product

    private var productPurchaseCompletionHandler: ((String?) -> Void)?

    // Prompt a product payment transaction
    func purchase(
        forProduct product: SKProduct,
        completionHandler: @escaping (String?) -> Void
    ) {
        // Make sure the user has the Hound permissions to perform such a request
        guard UserInformation.isUserFamilyHead else {
            ErrorConstant.InAppPurchaseError.purchasePermission().alert()
            completionHandler(nil)
            return
        }

        // Make sure that the user has the correct Apple permissions to perform such a request
        guard SKPaymentQueue.canMakePayments() else {
            ErrorConstant.InAppPurchaseError.purchaseRestricted().alert()
            completionHandler(nil)
            return
        }

        // Make sure there isn't a purchase transaction in process
        guard productPurchaseCompletionHandler == nil else {
            ErrorConstant.InAppPurchaseError.purchaseInProgress().alert()
            completionHandler(nil)
            return
        }

        // Make sure there isn't a restore request in process
        guard InternalInAppPurchaseManager.shared.productRestoreCompletionHandler == nil else {
            ErrorConstant.InAppPurchaseError.restoreInProgress().alert()
            completionHandler(nil)
            return
        }

        // Make sure the system isn't doing anything async in the background
        guard backgroundPurchaseInProgress == false else {
            ErrorConstant.InAppPurchaseError.backgroundPurchaseInProgress().alert()
            completionHandler(nil)
            return
        }

        // Don't test for SKPaymentQueue.default().transactions. This could lock the code from ever executing. E.g. the user goes to buy something (so its in the payment queue) but they stop mid way (maybe leaving the transaction as .purchasing or .deferred). Then the background async processing isn't invoked to start (or it simply can't process whats in the queue) so we are left with transactions in the queue that are stuck and are locking
        productPurchaseCompletionHandler = completionHandler
        let payment = SKMutablePayment(product: product)
        payment.applicationUsername = UserInformation.userAppAccountToken
        SKPaymentQueue.default().add(payment)
    }

    // Observe a transaction state
    func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {
        // Only the family head can perform in-app purchases. This guard statement is here to stop background purchases from attempting to process. They will always fail if the user isn't the family head so no reason to even attempt them.
        guard UserInformation.isUserFamilyHead else {
            return
        }

        // If either of these are nil, there is not an ongoing manual request by a user (as there is no callback to provide information to). Therefore, we are dealing with asyncronously bought transactions (e.g. renewals, phone died while purchasing, etc.) that should be processed in the background.
        guard productPurchaseCompletionHandler != nil || productRestoreCompletionHandler != nil else {
            backgroundPurchaseInProgress = true

            // These are transactions that we know have completely failed. Clear them.
            let failedTransactionsInQueue = transactions.filter { transaction in
                transaction.transactionState == .failed
            }

            failedTransactionsInQueue.forEach { failedTransaction in
                SKPaymentQueue.default().finishTransaction(failedTransaction)
            }

            // These are transactions that we know have completely succeeded. Process and clear them.
            let completedTransactionsInQueue = transactions.filter { transaction in
                transaction.transactionState == .purchased || transaction.transactionState == .restored
            }

            // If we have succeeded transactions, silently contact the server in the background to let it know
            guard completedTransactionsInQueue.count >= 1 else {
                backgroundPurchaseInProgress = false
                return
            }

            TransactionsRequest.create(forErrorAlert: .automaticallyAlertForNone) { responseStatus, _ in
                self.backgroundPurchaseInProgress = false
                guard responseStatus == .successResponse else {
                    return
                }

                // If successful, then we know ALL of the completed transactions in queue have been updated
                completedTransactionsInQueue.forEach { completedTransaction in
                    SKPaymentQueue.default().finishTransaction(completedTransaction)
                }

                // If the subscriptions page is loaded and onscreen, then we refresh it
                SettingsSubscriptionViewController.willRefreshIfNeeded()
            }
            return
        }

        // Check if the user is attempting to purchase a product
        guard let productPurchaseCompletionHandler = productPurchaseCompletionHandler else {
            // User is restoring a transaction
            guard let productRestoreCompletionHandler = productRestoreCompletionHandler else {
                return
            }

            let restoredTransactionsInQueue = transactions.filter { transaction in
                transaction.transactionState == .restored
            }

            // If we have restored transactions, contact the server to let it know
            guard restoredTransactionsInQueue.count >= 1 else {
                productRestoreCompletionHandler(false)
                self.productRestoreCompletionHandler = nil
                return
            }

            TransactionsRequest.create(forErrorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                guard responseStatus == .successResponse else {
                    productRestoreCompletionHandler(false)
                    self.productRestoreCompletionHandler = nil
                    return
                }

                // If successful, then we know ALL of the completed transactions in queue have been updated
                restoredTransactionsInQueue.forEach { restoredTransaction in
                    SKPaymentQueue.default().finishTransaction(restoredTransaction)
                }

                productRestoreCompletionHandler(true)
                self.productRestoreCompletionHandler = nil
            }
            return
        }

        // User is purchasing a product

        for transaction in transactions {
            // We use the main thread so completion handler is on main thread
            DispatchQueue.main.async {
                switch transaction.transactionState {
                case .purchasing:
                    // A transaction that is being processed by the App Store.

                    //  Don't finish transaction, it is still in a processing state
                    break
                case .purchased:
                    // A successfully processed transaction.
                    // Your application should provide the content the user purchased.
                    // Write to the keychain if user has made a purchase
                    let keychain = KeychainSwift()
                    if SubscriptionGroup20965379Product(rawValue: transaction.payment.productIdentifier) != nil {
                        keychain.set(true, forKey: KeyConstant.userPurchasedProductFromSubscriptionGroup20965379.rawValue)
                    }
                    keychain.set(true, forKey: KeyConstant.userPurchasedProduct.rawValue)

                    TransactionsRequest.create(forErrorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                        guard responseStatus == .successResponse else {
                            productPurchaseCompletionHandler(nil)
                            self.productPurchaseCompletionHandler = nil
                            return
                        }

                        productPurchaseCompletionHandler(transaction.payment.productIdentifier)
                        self.productPurchaseCompletionHandler = nil
                        SKPaymentQueue.default().finishTransaction(transaction)
                    }
                case .failed:
                    // A failed transaction.
                    // Check the error property to determine what happened.
                    ErrorConstant.InAppPurchaseError.purchaseFailed().alert()
                    productPurchaseCompletionHandler(nil)
                    self.productPurchaseCompletionHandler = nil
                    SKPaymentQueue.default().finishTransaction(transaction)
                case .restored:
                    // if we have a productPurchaseCompletionHandler, then we lock the transaction queue from other things from interfering
                    // A transaction that restores content previously purchased by the user.
                    // Read the original property to obtain information about the original purchase.

                    TransactionsRequest.create(forErrorAlert: .automaticallyAlertForAll) { responseStatus, _ in
                        guard responseStatus == .successResponse else {
                            productPurchaseCompletionHandler(nil)
                            self.productPurchaseCompletionHandler = nil
                            return
                        }

                        productPurchaseCompletionHandler(transaction.payment.productIdentifier)
                        self.productPurchaseCompletionHandler = nil
                        SKPaymentQueue.default().finishTransaction(transaction)
                    }
                case .deferred:
                    // A transaction that is in the queue, but its final status is pending external action such as Ask to Buy
                    // Update your UI to show the deferred state, and wait for another callback that indicates the final status.

                    ErrorConstant.InAppPurchaseError.purchaseDeferred().alert()
                    productPurchaseCompletionHandler(nil)
                    self.productPurchaseCompletionHandler = nil
                    //  Don't finish transaction, it is still in a processing state
                @unknown default:
                    ErrorConstant.InAppPurchaseError.purchaseUnknown().alert()
                    productPurchaseCompletionHandler(nil)
                    self.productPurchaseCompletionHandler = nil
                    // Don't finish transaction, we can't confirm if it succeeded or failed
                }

            }
        }
    }

    /// This delegate function is called when the user starts an in-app purchase in the App Store, and the transaction continues in your app. Specifically, if your app is already installed, the function is called automatically. If your app is not yet installed when the user starts the in-app purchase in the App Store, the user gets a notification when the app installation is complete. This function is called when the user taps the notification. Otherwise, if the user opens the app manually, this function is called only if the app is opened soon after the purchase was started.
    func paymentQueue(_ queue: SKPaymentQueue, shouldAddStorePayment payment: SKPayment, for product: SKProduct) -> Bool {
        SKPaymentQueue.default().add(payment)
        return true
    }

    // MARK: - Restore Purchases

    private var productRestoreCompletionHandler: ((Bool) -> Void)?

    /// Checks to see if the user is eligible to perform a restore transaction request. If they are, invokes  SKPaymentQueue.default().restoreCompletedTransactions() which then will invoke  paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]).
    func restorePurchases(completionHandler: @escaping (Bool) -> Void) {
        // Make sure the user has the permissions to perform such a request
        guard UserInformation.isUserFamilyHead else {
            ErrorConstant.InAppPurchaseError.restorePermission().alert()
            completionHandler(false)
            return
        }

        // Don't check for SKPaymentQueue.canMakePayments(), as we are only restoring and not making any purchases

        // Make sure there isn't a restore request in process
        guard InternalInAppPurchaseManager.shared.productRestoreCompletionHandler == nil else {
            ErrorConstant.InAppPurchaseError.restoreInProgress().alert()
            completionHandler(false)
            return
        }

        // Make sure there is no purchase request ongoing
        guard productPurchaseCompletionHandler == nil else {
            ErrorConstant.InAppPurchaseError.purchaseInProgress().alert()
            completionHandler(false)
            return
        }

        // Make sure the system isn't doing anything async in the background
        guard backgroundPurchaseInProgress == false else {
            ErrorConstant.InAppPurchaseError.backgroundPurchaseInProgress().alert()
            completionHandler(false)
            return
        }

        let keychain = KeychainSwift()
        let userPurchasedProduct = keychain.getBool(KeyConstant.userPurchasedProduct.rawValue) ?? false

        guard userPurchasedProduct == true else {
            // If the user hasn't purchased a product, as indicated by our keychain which stores the value regardless if the user's device got blown up by a nuke, then don't invoke restoreCompletedTransactions().
            // This is because if "All transactions are unfinished OR The user did not purchase anything that is restorable OR You tried to restore items that are not restorable, such as a non-renewing subscription or a consumable product", this function will simply never return anything, causing the user

            completionHandler(true)
            return
        }

        // Don't test for SKPaymentQueue.default().transactions. This could lock the code from ever executing. E.g. the user goes to buy something (so its in the payment queue) but they stop mid way (maybe leaving the transaction as .purchasing or .deferred). Then the background async processing isn't invoked to start (or it simply can't process whats in the queue) so we are left with transactions in the queue that are stuck and are locking

        InternalInAppPurchaseManager.shared.productRestoreCompletionHandler = completionHandler
        SKPaymentQueue.default().restoreCompletedTransactions()
    }

    func paymentQueue(_ queue: SKPaymentQueue, restoreCompletedTransactionsFailedWithError error: Error) {
        DispatchQueue.main.async {
            if self.productRestoreCompletionHandler != nil {
                ErrorConstant.InAppPurchaseError.restoreFailed().alert()
            }

            self.productRestoreCompletionHandler?(false)
            self.productRestoreCompletionHandler = nil
        }
    }

}
//
//  DogIconManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/12/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum DogIconManager {

    final class LocalDogIcon {
        // MARK: - Main

        init(forDogUUID: UUID, forDogIcon: UIImage) {
            self.dogUUID = forDogUUID
            self.dogIcon = forDogIcon
        }

        // MARK: - Properties

        var dogUUID: UUID
        var dogIcon: UIImage

    }

    // MARK: - Get Dog Icon

    /// Present openCameraOrGalleryForDogIconActionSheet to prompt the user with an action sheet asking if they want to open their camera or choose from their gallery for their dogIcon. Set didSelectDogIconController.delegate to allow you to recieve the dog icon that the user selected.
    static let (didSelectDogIconController, openCameraOrGalleryForDogIconActionSheet) = {
        let imagePickerController = UIImagePickerController()

        let imagePickMethodAlertController = UIAlertController(title: "Choose Image", message: "Your personal dog icons aren't shared with other family members", preferredStyle: .actionSheet)

        imagePickMethodAlertController.addAction(UIAlertAction(title: "Camera", style: .default, handler: { _ in
            if UIImagePickerController .isSourceTypeAvailable(UIImagePickerController.SourceType.camera) {
                imagePickerController.sourceType = UIImagePickerController.SourceType.camera
                imagePickerController.allowsEditing = true
                imagePickerController.cameraCaptureMode = .photo
                imagePickerController.cameraDevice = .rear
                PresentationManager.enqueueViewController(imagePickerController)
            }
            else {
                PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.noCameraTitle, forSubtitle: nil, forStyle: .danger)
            }
        }))

        imagePickMethodAlertController.addAction(UIAlertAction(title: "Gallery", style: .default, handler: { _ in
            imagePickerController.sourceType = UIImagePickerController.SourceType.photoLibrary
            imagePickerController.allowsEditing = true
            PresentationManager.enqueueViewController(imagePickerController)
        }))

        imagePickMethodAlertController.addAction(UIAlertAction.init(title: "Cancel", style: .cancel, handler: nil))

        return (imagePickerController, imagePickMethodAlertController)
    }()

    /// Processes the information returned by the UIImagePickerController, attempts to create an image from it. In the process it scales the image to the point size of the ScaledUiButton of the dogIcon multiplied by the scale factor of the local screen. For Retina displays, the scale factor may be 3.0 or 2.0 and one point can represented by nine or four pixels, respectively. For standard-resolution displays, the scale factor is 1.0 and one point equals one pixel.
    static func processDogIcon(forInfo info: [UIImagePickerController.InfoKey: Any]) -> UIImage? {
        let image = info[.editedImage] as? UIImage ?? info[.originalImage] as? UIImage

        guard let image = image else {
            return nil
        }

        // Arbitrary size multiplied by the scale factor of the user's screen
        let scaledSize = 300.0 * UIScreen.main.scale

        let scaledImageSize = CGSize(width: scaledSize, height: scaledSize)

        let renderer = UIGraphicsImageRenderer(size: scaledImageSize)

        let scaledImage = renderer.image { _ in
            image.draw(in: CGRect(origin: .zero, size: scaledImageSize))
        }

        return scaledImage
    }

    // MARK: - Storage of Icons

    /// If we retrieve a dogIcon from files, store it locally. Only retrieve from files if we don't have stored for this life cycle
    private static var icons: [LocalDogIcon] = []

    /// Attempts to create a file path url for the given dogUUID
    private static func getIconURL(forDogUUID dogUUID: UUID) -> URL? {
        // make sure we have a urls to read/write to
        let documentsURLs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)

        // create URL
        guard let url = documentsURLs.first?.appendingPathComponent("dog\(dogUUID).png") else {
            return nil
        }

        return url
    }

    /// Attempts to retrieve the dogIcon for the provided dogUUID. If no dogIcon is found, then nil is returned
    static func getIcon(forDogUUID dogUUID: UUID) -> UIImage? {
        // Before reading icon from files, see if we have it stored in a reference (meaning we've retrieved it before in this lifecycle). Saves us from needlessly reading from files again
        if let icon = icons.first(where: { localDogIcon in
            localDogIcon.dogUUID.uuidString == dogUUID.uuidString
        }) {
            return icon.dogIcon
        }

        // need a url to perform any read/writes to
        guard let url = getIconURL(forDogUUID: dogUUID) else {
            return nil
        }

        // attempt to find and return image
        let icon = UIImage(contentsOfFile: url.path)

        if let icon = icon {
            // add dog icon to life cycle storage
            icons.append(LocalDogIcon(forDogUUID: dogUUID, forDogIcon: icon))
        }

        return icon
    }

    /// Removes all LocalDogIcons stored in LocalConfiguration.dogIcons that match the provided dogUUID, then adds a LocalDogIcon to LocalConfiguration.dogIcons with the provided dogUUID and dogIcon.
    static func addIcon(forDogUUID dogUUID: UUID, forDogIcon dogIcon: UIImage) {

        removeIcon(forDogUUID: dogUUID)

        // need a url to perform any read/writes to
        guard let url = getIconURL(forDogUUID: dogUUID) else {
            return
        }

        // convert dogIcon to data, then attempt to write to url, saving the image
        do {
            try dogIcon.pngData()?.write(to: url)
            // add dog icon to life cycle storage
            icons.append(LocalDogIcon(forDogUUID: dogUUID, forDogIcon: dogIcon))
        }
        catch {
            // failed to add dog icon
        }
    }

    /// Removes all LocalDogIcons stored in LocalConfiguration.dogIcons that match the provided dogUUID
    static func removeIcon(forDogUUID dogUUID: UUID) {
        // need a url to perform any read/writes to
        guard let url = getIconURL(forDogUUID: dogUUID) else {
            return
        }

        do {
            // attempt to remove any image at specified url
            try FileManager.default.removeItem(at: url)
            // remove lifecycle storage of dog icon
            icons.removeAll { localDogIcon in
                localDogIcon.dogUUID == dogUUID
            }
        }
        catch {
            // failed to remove dog icon
        }
    }
}
//
//  NetworkManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/9/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import Network

final class NetworkManager: NSObject {
    @objc static let shared = NetworkManager()

    private let queue = DispatchQueue.global()
    private let monitor: NWPathMonitor

    @objc private(set) dynamic var isConnected: Bool = false

    override private init() {
        monitor = NWPathMonitor()
        super.init()
        // Start monitoring the internet connection
        monitor.start(queue: queue)
        monitor.pathUpdateHandler = { [self] path in
            self.isConnected = path.status == .satisfied
        }
    }
}
//
//  AudioManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/14/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import AudioToolbox
import AVFoundation
import MediaPlayer
import UIKit

enum AudioManager {

    private static var sharedPlayer: AVAudioPlayer?

    static var isPlaying: Bool {
        // if the shared player is nil, then its impossible to be playing anything
        return sharedPlayer?.isPlaying ?? false
    }

    // MARK: - General Audio

    static func playAudio(forAudioPath audioPath: String) {
        DispatchQueue.global().async {
            guard let path = Bundle.main.path(forResource: audioPath, ofType: "mp3") else {
                return
            }

            let url = URL(fileURLWithPath: path)

            do {
                stopAudio()

                AudioManager.sharedPlayer = try AVAudioPlayer(contentsOf: url)
                AudioManager.sharedPlayer?.numberOfLoops = -1
                AudioManager.sharedPlayer?.volume = 1.0

                // generic .playback audio that mixes with others. most compatible and non intrustive
                try AVAudioSession.sharedInstance().setCategory(.playback, options: [.mixWithOthers])
                try AVAudioSession.sharedInstance().setActive(true)

                AudioManager.sharedPlayer?.play()
            }
            catch {
                AppDelegate.generalLogger.error("playAudio error: \(error.localizedDescription)")
            }
        }
    }

    static func stopAudio() {
        DispatchQueue.global().async {
            shouldVibrate = false
            AudioManager.sharedPlayer?.stop()
        }

    }

    // MARK: - Silent Audio

    static func playSilenceAudio() {
        DispatchQueue.global().async {
            guard let path = Bundle.main.path(forResource: "silence", ofType: "mp3") else {
                return
            }

            let url = URL(fileURLWithPath: path)

            do {
                stopAudio()

                AudioManager.sharedPlayer = try AVAudioPlayer(contentsOf: url)
                AudioManager.sharedPlayer?.numberOfLoops = -1
                AudioManager.sharedPlayer?.volume = 0

                // generic .playback audio that mixes with others. most compatible and non intrustive
                try AVAudioSession.sharedInstance().setCategory(.playback, options: [.mixWithOthers])
                try AVAudioSession.sharedInstance().setActive(true)

                AudioManager.sharedPlayer?.play()

            }
            catch {
                AppDelegate.generalLogger.error("playSilenceAudio error: \(error.localizedDescription)")
            }

        }
    }

    // MARK: - Loud Audio

    ///
    private static var shouldVibrate = false

    /// Checks to see if the user has notifications enabled, loud notifications enabled, and the app is in the background and, if all conditions are met, then begins loud notification and vibration.
    static func playLoudNotification() {
        // make sure the user wants loud notifications
        // don't check for if there are enabled reminders, as client could be out of sync with server which has a reminder
        guard UserConfiguration.isNotificationEnabled && UserConfiguration.isLoudNotificationEnabled && UIApplication.shared.applicationState == .background else {
            return
        }

        shouldVibrate = true
        loopVibrate()
        // make the device repeadedly vibrate
        func loopVibrate() {
            if shouldVibrate == true {
                AudioServicesPlayAlertSoundWithCompletion(SystemSoundID(kSystemSoundID_Vibrate)) {
                    DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) {
                        loopVibrate()
                    }
                }
            }
        }

        // make the device play the loud notification sound
        DispatchQueue.global().async {
            guard let path = Bundle.main.path(forResource: "\(UserConfiguration.notificationSound.rawValue.lowercased())", ofType: "mp3") else {
                return
            }
            let url = URL(fileURLWithPath: path)

            do {
                stopAudio()

                AudioManager.sharedPlayer = try AVAudioPlayer(contentsOf: url)
                AudioManager.sharedPlayer?.numberOfLoops = -1
                AudioManager.sharedPlayer?.volume = 1.0

                MPVolumeView.setVolume(1.0)

                try AVAudioSession.sharedInstance().setCategory(.playback, options: [])
                try AVAudioSession.sharedInstance().setActive(true)

                AudioManager.sharedPlayer?.play()

            }
            catch {
                AppDelegate.generalLogger.error("playLoudNotification error: \(error.localizedDescription)")
            }
        }
    }

}

extension MPVolumeView {
    static func setVolume(_ volume: Float) {
        DispatchQueue.main.async {
            let volumeView = MPVolumeView()
            let slider = volumeView.subviews.first(where: { $0 is UISlider }) as? UISlider

            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.05) {
                slider?.value = volume
            }
        }
    }
}
//
//  PersistenceManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/16/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import KeychainSwift
import StoreKit
import UIKit

enum PersistenceManager {
    /// Called by App or Scene Delegate when setting up in didFinishLaunchingWithOptions, can be either the first time setup or a recurring setup (i.e. not the app isnt being opened for the first time)
    static func applicationDidFinishLaunching() {
        // MARK: Log Launch
        
        AppDelegate.generalLogger.notice("\n-----Device Info-----\n Model: \(UIDevice.current.model) \n Name: \(UIDevice.current.name) \n System Name: \(UIDevice.current.systemName) \n System Version: \(UIDevice.current.systemVersion)")
        
        // MARK: Save App State Values
        
        UIApplication.previousAppVersion = UserDefaults.standard.object(forKey: KeyConstant.localAppVersion.rawValue) as? String
        
        // If the previousAppVersion is less than the oldestCompatibleAppVersion, the user's data is no longer compatible and therefore should be redownloaded.
        if UIApplication.isPreviousAppVersionCompatible == false {
            // Clear out this stored data so the user can redownload from the server
            UserDefaults.standard.set(nil, forKey: KeyConstant.previousDogManagerSynchronization.rawValue)
            UserDefaults.standard.set(nil, forKey: KeyConstant.dogManager.rawValue)
        }
        
        UserDefaults.standard.set(UIApplication.appVersion, forKey: KeyConstant.localAppVersion.rawValue)
        
        UserDefaults.standard.set(true, forKey: "_UIConstraintBasedLayoutLogUnsatisfiable")
        
        // MARK: Load App Information
        
        // GlobalTypes MUST come first, as otherwise other classes (e.g. dog/logs/reminder) that reference it will crash when they get a null reference for GlobalTypes.shared!
        GlobalTypes.load(fromUserDefaults: UserDefaults.standard)
        
        UserInformation.load(fromUserDefaults: UserDefaults.standard)
        
        FamilyInformation.load(fromUserDefaults: UserDefaults.standard)
        
        UserConfiguration.load(fromUserDefaults: UserDefaults.standard)
        
        LocalConfiguration.load(fromUserDefaults: UserDefaults.standard)
        
        OfflineModeManager.load(fromUserDefaults: UserDefaults.standard)
    }
    
    /// Called by App or Scene Delegate when entering the background, used to save information, can be called when terminating for a slightly modifed case.
    static func didEnterBackground(isTerminating: Bool) {
        // MARK: Loud Notifications and Silent Audio
        
        // Check to see if the user is eligible for loud notifications
        // Don't check for enabled reminders, as client could be out of sync with server
        if UserConfiguration.isNotificationEnabled && UserConfiguration.isLoudNotificationEnabled {
            if isTerminating == true {
                // Send notification to user that their loud notifications won't work
                AlertRequest.create(forErrorAlert: .automaticallyAlertForNone, completionHandler: { _, _ in
                })
            }
            else {
                // app isn't terminating so add background silence
                AudioManager.stopAudio()
                AudioManager.playSilenceAudio()
            }
        }
        
        // MARK: Save App Information
        
        GlobalTypes.persist(toUserDefaults: UserDefaults.standard)
    
        UserInformation.persist(toUserDefaults: UserDefaults.standard)
        
        FamilyInformation.persist(toUserDefaults: UserDefaults.standard)
        
        UserConfiguration.persist(toUserDefaults: UserDefaults.standard)
        
        LocalConfiguration.persist(toUserDefaults: UserDefaults.standard)
        
        OfflineModeManager.persist(toUserDefaults: UserDefaults.standard)
    }
    
    static func willEnterForeground() {
        // Invocation of synchronizeNotificationAuthorization from willEnterForeground will only be accurate in conjuction with invocation of synchronizeNotificationAuthorization in viewIsAppearing of MainTabBarController. This makes it so every time Hound is opened, either from the background or from terminated, notifications are properly synced.
        // 1. Hound entering foreground from being terminated. willEnterForeground called upon initial launch of Hound although UserConfiguration (and notification settings) aren't loaded from the server, but viewIsAppearing MainTabBarController will catch as it's invoked once ServerSyncViewController is done loading (and notification settings are loaded
        // 2. Hound entering foreground after entering background. viewIsAppearing MainTabBarController won't catch as MainTabBarController's view isn't appearing anymore but willEnterForeground will catch any imbalance as it's called once app is loaded to foreground
        NotificationPermissionsManager.synchronizeNotificationAuthorization()
        
        // stop any loud notifications that may have occured
        AudioManager.stopAudio()
        
        // If the app hasn't refreshed the dogManager for a given amount of time, then refresh the data.
        if let previousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization, previousDogManagerSynchronization.distance(to: Date()) >= 1 {
            MainTabBarController.shouldRefreshDogManager = true
            MainTabBarController.shouldRefreshFamily = true
        }
        else if LocalConfiguration.previousDogManagerSynchronization == nil {
            MainTabBarController.shouldRefreshDogManager = true
            MainTabBarController.shouldRefreshFamily = true
        }
        
        UNUserNotificationCenter.current().removeAllDeliveredNotifications()
        
    }
    
    /// It is important to persist this value to memory immediately. Apple keeps track of when we ask the user for a rate review and we must keep accurate track. But, if Hound crashes before we can save an updated value of localPreviousDatesUserReviewRequested, then our value and Apple's true value is mismatched.
    static func persistRateReviewRequestedDates() {
        UserDefaults.standard.set(LocalConfiguration.localPreviousDatesUserReviewRequested, forKey: KeyConstant.localPreviousDatesUserReviewRequested.rawValue)
    }
    
    /// Removes values stored in the keychain and UserDefaults for userIdentifier and userId. Additionally, invokes clearStorageToRejoinFamily().
    static func clearStorageToReloginToAccount() {
        /// We write these changes to storage immediately. If not, could cause funky issues if not persisted.
        let keychain = KeychainSwift()
        
        // Clear userIdentifier out of storage so user is forced to login page again
        UserInformation.userIdentifier = nil
        keychain.delete(KeyConstant.userIdentifier.rawValue)
        UserDefaults.standard.removeObject(forKey: KeyConstant.userIdentifier.rawValue)
        
        UserInformation.userId = nil
        keychain.delete(KeyConstant.userId.rawValue)
        UserDefaults.standard.removeObject(forKey: KeyConstant.userId.rawValue)
        
        UserInformation.userAppAccountToken = nil
        UserDefaults.standard.removeObject(forKey: KeyConstant.userAppAccountToken.rawValue)
        
        UserInformation.userNotificationToken = nil
        UserDefaults.standard.removeObject(forKey: KeyConstant.userNotificationToken.rawValue)
        
        clearStorageToRejoinFamily()
    }
    
    /// Removes values stored in the keychain and UserDefaults for localHasCompletedHoundIntroductionViewController, localHasCompletedRemindersIntroductionViewController, localHasCompletedFamilyUpgradeIntroductionViewController, localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController, previousDogManagerSynchronization, and dogManager.
    static func clearStorageToRejoinFamily() {
        // We write these changes to storage immediately. If not, could cause funky issues if not persisted.
        
        // MARK: User Information
        
        UserInformation.familyId = nil
        UserDefaults.standard.removeObject(forKey: KeyConstant.familyId.rawValue)
        
        // MARK: Local Configuration
        LocalConfiguration.localHasCompletedHoundIntroductionViewController = false
        UserDefaults.standard.set(LocalConfiguration.localHasCompletedHoundIntroductionViewController, forKey: KeyConstant.localHasCompletedHoundIntroductionViewController.rawValue)
        
        LocalConfiguration.localHasCompletedRemindersIntroductionViewController = false
        UserDefaults.standard.set(LocalConfiguration.localHasCompletedRemindersIntroductionViewController, forKey: KeyConstant.localHasCompletedRemindersIntroductionViewController.rawValue)
        
        LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController = false
        UserDefaults.standard.set(LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController, forKey: KeyConstant.localHasCompletedFamilyUpgradeIntroductionViewController.rawValue)
        
        LocalConfiguration.localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController = false
        UserDefaults.standard.set(LocalConfiguration.localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController, forKey: KeyConstant.localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController.rawValue)
        
        LocalConfiguration.previousDogManagerSynchronization = nil
        UserDefaults.standard.set(LocalConfiguration.previousDogManagerSynchronization, forKey: KeyConstant.previousDogManagerSynchronization.rawValue)
        
        // MARK: Data
        
        DogManager.globalDogManager = nil
        UserDefaults.standard.removeObject(forKey: KeyConstant.dogManager.rawValue)
    }
    
}
//
//  OfflineModeManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/8/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol OfflineModeManagerDelegate: AnyObject {
    func didUpdateDogManager(sender: Sender, forDogManager: DogManager)
}

final class OfflineModeManager: NSObject, NSCoding, UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    static func persist(toUserDefaults: UserDefaults) {
        if let dataShared = try? NSKeyedArchiver.archivedData(withRootObject: shared, requiringSecureCoding: false) {
            toUserDefaults.set(dataShared, forKey: KeyConstant.offlineModeManagerShared.rawValue)
        }
    }
    
    static func load(fromUserDefaults: UserDefaults) {
        if let dataShared: Data = UserDefaults.standard.data(forKey: KeyConstant.offlineModeManagerShared.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataShared) {
            unarchiver.requiresSecureCoding = false
            if let shared = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? OfflineModeManager {
                OfflineModeManager.shared = shared
            }
        }
    }
    
    // MARK: - NSCoding

    required init?(coder aDecoder: NSCoder) {
        shouldUpdateUser = aDecoder.decodeOptionalBool(forKey: KeyConstant.offlineModeManagerShouldUpdateUser.rawValue) ?? shouldUpdateUser
        shouldGetUser = aDecoder.decodeOptionalBool(forKey: KeyConstant.offlineModeManagerShouldGetUser.rawValue) ?? shouldGetUser
        shouldGetFamily = aDecoder.decodeOptionalBool(forKey: KeyConstant.offlineModeManagerShouldGetFamily.rawValue) ?? shouldGetFamily
        shouldGetDogManager = aDecoder.decodeOptionalBool(forKey: KeyConstant.offlineModeManagerShouldGetDogManager.rawValue) ?? shouldGetDogManager
        offlineModeDeletedObjects = aDecoder.decodeOptionalObject(forKey: KeyConstant.offlineModeManagerOfflineModeDeletedObjects.rawValue) ?? offlineModeDeletedObjects
        // isWaitingForInternetConnection is false when the object is created; changed when startMonitoring is invoked
        // isSyncInProgress is false when the object is created; changed when startMonitoring is invoked
        // hasDisplayedOfflineModeBanner is false when the object is created; changed when we enter offline mode
    }

    func encode(with aCoder: NSCoder) {
        // IMPORTANT ENCODING INFORMATION. DO NOT ENCODE NIL FOR PRIMATIVE TYPES. If encoding a data type which requires a decoding function other than decodeObject (e.g. decodeObject, decodeDouble...), the value that you encode CANNOT be nil. If nil is encoded, then one of these custom decoding functions trys to decode it, a cascade of erros will happen that results in a completely default dog being decoded.
        
        aCoder.encode(shouldUpdateUser, forKey: KeyConstant.offlineModeManagerShouldUpdateUser.rawValue)
        aCoder.encode(shouldGetUser, forKey: KeyConstant.offlineModeManagerShouldGetUser.rawValue)
        aCoder.encode(shouldGetFamily, forKey: KeyConstant.offlineModeManagerShouldGetFamily.rawValue)
        aCoder.encode(shouldGetDogManager, forKey: KeyConstant.offlineModeManagerShouldGetDogManager.rawValue)
        aCoder.encode(offlineModeDeletedObjects, forKey: KeyConstant.offlineModeManagerOfflineModeDeletedObjects.rawValue)
        // isWaitingForInternetConnection is false when the object is created; changed when startMonitoring is invoked
        // isSyncInProgress is false when the object is created; changed when startMonitoring is invoked
    }
    
    // MARK: - Properties
    
    private(set) static var shared: OfflineModeManager = OfflineModeManager()
    
    // MARK: Sync-able Variables
    /// If true, a updateUser request got no response. The user's local data is updated and needs to be synced with the server. This is set to true if a update request for a user request receives no response from the Hound server
    private(set) var shouldUpdateUser: Bool = false
    /// If true, a getUser request got no response. The user's data is outdated and needs to be fetched from the server. This is set to true if a get request for a user request receives no response from the Hound server
    private var shouldGetUser: Bool = false
    /// If true, a getFamily request got no response. The user's family data is outdated and needs to be fetched from the server. This is set to true if a get request for a family request receives no response from the Hound server
    private var shouldGetFamily: Bool = false
    /// If true, the first invocation of sync from startMonitoring requires that the dogManager be synced. This is set to true if a get request for a dog manager, dog, reminder, or log request receives no response from the Hound server
    private var shouldGetDogManager: Bool = false
    /// Dogs, reminders, or logs that were deleted in offline mode and need their deletion synced with the Hound server
    private var offlineModeDeletedObjects: [OfflineModeDeletedObject] = []
    
    // MARK: Pre-Sync Variables
    private var internetConnectionObserver: NSKeyValueObservation?
    /// If true, OfflineModeManager is currently observing and waiting for the user's device to get internet so that it can start resyncing.
    private var isWaitingForInternetConnection: Bool = false {
        didSet {
            if isWaitingForInternetConnection == true && internetConnectionObserver == nil {
                // If we are going to be waiting for an internet connection and have nothing to monitor for that, start monitoring
                internetConnectionObserver = NetworkManager.shared.observe(\.isConnected, options: [.new]) { _, change in
                    // If isConnected did update and its new value is true, we are now connected to internet
                    if let newValue = change.newValue, newValue == true {
                        self.isWaitingForInternetConnection = false
                    }
                }
            }
            
            if isWaitingForInternetConnection == false && internetConnectionObserver != nil {
                // No longer waiting for an internet connection so destroy
                internetConnectionObserver?.invalidate()
                internetConnectionObserver = nil
                // isWaitingForInternetConnection can only be changed by startMonitoring and internetConnectionObserver. If it was set to false and internetConnectionObserver is not nil, then the observer just observed the user getting internet connection again.
                startMonitoring()
            }
        }
    }
    
    // MARK: Syncing Variables
    /// True if the process of either determining if a sync is needed or actual syncing is in progress. False if there is no active syncing.
    private(set) var isSyncInProgress: Bool = false {
        didSet {
            // When isSyncInProgress gets turned off, meaning the syncing has completed, then reset hasDisplayedOfflineModeBanner so that if offline mode is entered again, the banner will display again
            if oldValue == true && isSyncInProgress == false {
                hasDisplayedOfflineModeBanner = false
            }
        }
    }
    /// When Hound first enters offline mode, display a banner that it has done so.
    private(set) var hasDisplayedOfflineModeBanner: Bool = false
    /// The delay that OfflineModeManger waits before attempting to sync again after receiving not response from the Hound server
    private let delayBeforeAttemptingToSyncAgain: Double = 15.0
    /// Sends updates when OfflineModeManager syncs any dog, reminder, or log objects
    weak var delegate: OfflineModeManagerDelegate!
    
    // MARK: - Main
    
    override init() {
        super.init()
    }
    
    // MARK: - Computed Properties
    
    /// Returns true upon finding the first dog, reminder, or log which has needsSyncedWithHoundServer set to true. Returns false if no dog, reminder, or log needs synced.
    private var isDogManagerSyncNeeded: Bool {
        for dog in DogManager.globalDogManager?.dogs ?? [] {
            if dog.offlineModeComponents.needsSyncedWithHoundServer == true {
                return true
            }
            
            for reminder in dog.dogReminders.dogReminders where reminder.offlineModeComponents.needsSyncedWithHoundServer == true {
                return true
            }
            
            for log in dog.dogLogs.dogLogs where log.offlineModeComponents.needsSyncedWithHoundServer == true {
                return true
            }
            
            for trigger in dog.dogTriggers.dogTriggers where trigger.offlineModeComponents.needsSyncedWithHoundServer == true {
                return true
            }
        }
        
        return false
    }
    
    /// Returns true if any of the following need synced: getUser, getFamily, getDogManager, deletedObjects, dogManager. Returns false if nothing needs synced.
    private var isSyncNeeded: Bool {
        if shouldUpdateUser == true {
            return true
        }
        if shouldGetUser == true {
            return true
        }
        if shouldGetFamily == true {
            return true
        }
        if shouldGetDogManager == true {
            return true
        }
        if offlineModeDeletedObjects.isEmpty == false {
            return true
        }
        if isDogManagerSyncNeeded == true {
            return true
        }
        
        return false
    }
    
    // MARK: - Functions
    
    // MARK: Sync Queue Management
    
    enum OfflineModeGetNoResponseTypes {
        case userRequestUpdate
        case userRequestGet
        case familyRequestGet
        case dogManagerGet
    }
    
    /// Invoke this function with the corresponding OfflineModeGetNoResponseTypes if a get user, family, dog manager, dog, reminder, or log request received no response from the server.
    func didGetNoResponse(forType: OfflineModeGetNoResponseTypes) {
        switch forType {
        case .userRequestUpdate:
            shouldUpdateUser = true
        case .userRequestGet:
            shouldGetUser = true
        case .familyRequestGet:
            shouldGetFamily = true
        case .dogManagerGet:
            shouldGetDogManager = true
        }
    }
    
    /// Invoke this function if a dog, reminder, or log was attempted to be deleted, however it failed due to no response from the Hound server
    func addDeletedObjectToQueue(forObject: OfflineModeDeletedObject) {
        // Ensure that the queue doesn't already have the deleted object waiting in it.
        guard offlineModeDeletedObjects.contains(where: { object in
            return object == forObject
        }) == false else {
            return
        }
        
        offlineModeDeletedObjects.append(forObject)
        
        offlineModeDeletedObjects.sort { objectOne, objectTwo in
            // If both objects are the same type, compare by deletedDate
            if type(of: objectOne) == type(of: objectTwo) {
                return objectOne.deletedDate <= objectTwo.deletedDate
            }
            
            // OfflineModeDeletedDog always comes first
            if objectOne is OfflineModeDeletedDog { return true }
            if objectTwo is OfflineModeDeletedDog { return false }
            
            // OfflineModeDeletedReminder comes next (after dogs)
            if objectOne is OfflineModeDeletedReminder { return true }
            if objectTwo is OfflineModeDeletedReminder { return false }
            
            // OfflineModeDeletedLog comes after reminders
            if objectOne is OfflineModeDeletedLog { return true }
            if objectTwo is OfflineModeDeletedLog { return false }
            
            // Remaining case: OfflineModeDeletedTrigger (all others fall here)
            return true
        }
    }
    
    // MARK: Monitoring and Syncing
    
    /// Invoke this function when there is an indication of lost connectivity to either the internet as a whole or the Hound server. OfflineModeManager will attempt to start syncing its data with the Hound server once connection is re-established.
    func startMonitoring() {
        
        // Avoid invoking the code below unless a sync is not in progress
        guard isSyncInProgress == false else {
            // Already syncing
            return
        }
        
        // Perform the isSyncNeeded check second as it is slightly resource intensive. If we can avert it by checking isSyncInProgress first, then that is good.
        guard isSyncNeeded == true else {
            return
        }
        
        if hasDisplayedOfflineModeBanner == false {
            hasDisplayedOfflineModeBanner = true
            PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.infoEnteredOfflineModeTitle, forSubtitle: VisualConstant.BannerTextConstant.infoEnteredOfflineModeSubtitle, forStyle: .info)
        }
        
        guard isWaitingForInternetConnection == false && NetworkManager.shared.isConnected == true else {
            // OfflineModeManager can't do anything until its connected to the internet. We wait until we get a signal that internet connection is restored
            isWaitingForInternetConnection = true
            return
        }
        
        // The sync begins now that a connection is established
        isSyncInProgress = true
        
        syncNextObject()
    }
    
    /// Invoke if an OfflineModeManager request to the Hound server from syncNextObject() received no response. This invoke a delay before the client will restart the syncing process.
    private func noResponseForSync() {
        // Stop all syncing and wait for a delay until we try again to sync. This should begin again from startMonitoring so it goes through the same network checks to see if the user still has connection.
        DispatchQueue.main.asyncAfter(deadline: .now() + delayBeforeAttemptingToSyncAgain) {
            self.isSyncInProgress = false
            self.startMonitoring()
        }
    }
    
    /// Helper function for sync. Attempts to sync getUser. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncGetUser() {
        UserRequest.get(
            forErrorAlert: .automaticallyAlertForNone,
            forSourceFunction: .offlineModeManager
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            // If we got a response for this request, set this flag to false as we no longer need to perform the request. If the request failed, then we ignore it as it will most likely fail again.
            self.shouldGetUser = false
            
            // Continue to sync more upon successful completion
            self.syncNextObject()
        }
    }
    
    /// Helper function for sync. Attempts to sync updateUser. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncUpdateUser() {
        UserRequest.update(
            forErrorAlert: .automaticallyAlertForNone,
            forSourceFunction: .offlineModeManager,
            forBody: UserConfiguration.createBody(addingOntoBody: [:])) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            // If we got a response for this request, set this flag to false as we no longer need to perform the request. If the request failed, then we ignore it as it will most likely fail again.
            self.shouldUpdateUser = false
            
            // Continue to sync more upon successful completion
            self.syncNextObject()
        }
    }
    
    /// Helper function for sync. Attempts to sync getFamily. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncGetFamily() {
        FamilyRequest.get(
            forErrorAlert: .automaticallyAlertForNone,
            forSourceFunction: .offlineModeManager
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            // If we got a response for this request, set this flag to false as we no longer need to perform the request. If the request failed, then we ignore it as it will most likely fail again.
            self.shouldGetFamily = false
            
            // Continue to sync more upon successful completion
            self.syncNextObject()
        }
    }
    
    /// Helper function for sync. Attempts to sync getDogManager. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncGetDogManager() {
        guard let globalDogManager = DogManager.globalDogManager else {
            // Unable to retrieve a dogManager to use to sync from.
            shouldGetDogManager = false
            syncNextObject()
            return
        }
        
        DogsRequest.get(
            forErrorAlert: .automaticallyAlertForNone,
            forSourceFunction: .offlineModeManager,
            forDogManager: globalDogManager
        ) { dogManager, responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            // If we got a response for this request, set this flag to false as we no longer need to perform the request. If the request failed, then we ignore it as it will most likely fail again.
            self.shouldGetDogManager = false
            
            if let dogManager = dogManager {
                self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: dogManager)
            }
            
            // Continue to sync more upon successful completion
            self.syncNextObject()
        }
    }
    
    /// Helper function for sync. Attempts to sync a deleted object. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncDeletedObject() {
        // offlineModeDeletedObjects is already be sorted
        // Primary sort / grouping: dog then reminders then logs
        // Secondary sort within primary group: deletedDate
        
        guard let offlineModeDeletedObject = offlineModeDeletedObjects.first else {
            // No more offlineModeDeletedObjects to sync
            syncNextObject()
            return
        }
        
        // Attempt to cast offlineModeDeletedObject as the three possible different objects. If the cast is successful, then try to sync that object
        if let deletedDog = offlineModeDeletedObject as? OfflineModeDeletedDog {
            DogsRequest.delete(
                forErrorAlert: .automaticallyAlertForNone,
                forSourceFunction: .offlineModeManager,
                forDogUUID: deletedDog.dogUUID
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // Got a response for this request. Whether it was successful or a failure, clear this object from being sync'd
                self.offlineModeDeletedObjects.removeAll { object in
                    return object == deletedDog
                }
                
                // If the dog got added back into the dogManager, remove it again and then push the change to everything else
                if let globalDogManager = DogManager.globalDogManager, globalDogManager.removeDog(forDogUUID: deletedDog.dogUUID) == true {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: globalDogManager)
                }
                
                self.syncNextObject()
            }
        }
        else if let deletedReminder = offlineModeDeletedObject as? OfflineModeDeletedReminder {
            RemindersRequest.delete(
                forErrorAlert: .automaticallyAlertForNone,
                forSourceFunction: .offlineModeManager,
                forDogUUID: deletedReminder.dogUUID,
                forReminderUUIDs: [deletedReminder.reminderUUID]
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // Got a response for this request. Whether it was successful or a failure, clear this object from being sync'd
                self.offlineModeDeletedObjects.removeAll { object in
                    return object == deletedReminder
                }
                
                // If the dog got added back into the dogManager, remove it again and then push the change to everything else
                if let globalDogManager = DogManager.globalDogManager, globalDogManager.findDog(forDogUUID: deletedReminder.dogUUID)?.dogReminders.removeReminder(forReminderUUID: deletedReminder.reminderUUID) == true {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: globalDogManager)
                }
                
                self.syncNextObject()
            }
        }
        else if let deletedLog = offlineModeDeletedObject as? OfflineModeDeletedLog {
            LogsRequest.delete(
                forErrorAlert: .automaticallyAlertForNone,
                forSourceFunction: .offlineModeManager,
                forDogUUID: deletedLog.dogUUID,
                forLogUUID: deletedLog.logUUID
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // Got a response for this request. Whether it was successful or a failure, clear this object from being sync'd
                self.offlineModeDeletedObjects.removeAll { object in
                    return object == deletedLog
                }
                
                // If the dog got added back into the dogManager, remove it again and then push the change to everything else
                if let globalDogManager = DogManager.globalDogManager, globalDogManager.findDog(forDogUUID: deletedLog.dogUUID)?.dogLogs.removeLog(forLogUUID: deletedLog.logUUID) == true {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: globalDogManager)
                }
                
                self.syncNextObject()
            }
        }
        else if let deletedTrigger = offlineModeDeletedObject as? OfflineModeDeletedTrigger {
            TriggersRequest.delete(
                forErrorAlert: .automaticallyAlertForNone,
                forSourceFunction: .offlineModeManager,
                forDogUUID: deletedTrigger.dogUUID,
                forTriggerUUIDs: [deletedTrigger.triggerUUID]
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // Got a response for this request. Whether it was successful or a failure, clear this object from being sync'd
                self.offlineModeDeletedObjects.removeAll { object in
                    return object == deletedTrigger
                }
                
                // If the dog got added back into the dogManager, remove it again and then push the change to everything else
                if let globalDogManager = DogManager.globalDogManager, globalDogManager.findDog(forDogUUID: deletedTrigger.dogUUID)?.dogTriggers.removeTrigger(forTriggerUUID: deletedTrigger.triggerUUID) == true {
                    self.delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: globalDogManager)
                }
                
                self.syncNextObject()
            }
        }
    }
    
    /// Helper function for sync. Attempts to sync all of the unsynced dogs. Recursively invokes itself until all forSyncNeededDogs have been synced. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncDogs(forSyncNeededDogs: [Dog]) {
        // Create a copy so that we can remove elements
        var syncNeededDogs = forSyncNeededDogs
        
        // Get the first dog, which has the more priority, and attempt to sync it
        guard let syncNeededDog = syncNeededDogs.first else {
            // There are no more dogs that need synced
            syncNextObject()
            return
        }
        
        // syncNeededDog exists so its safe to remove the first element from syncNeededDogs
        syncNeededDogs.removeFirst()
        
        guard syncNeededDog.offlineModeComponents.needsSyncedWithHoundServer == true else {
            // Reinvoke helperSyncDogs, except with syncNeededDogs which has this current syncNeededDog removed
            helperSyncDogs(forSyncNeededDogs: syncNeededDogs)
            return
        }
        
        guard syncNeededDog.dogId != nil else {
            // offlineModeDog doesn't have a dogId, so it hasn't been created on the server
            DogsRequest.create(
                forErrorAlert: .automaticallyAlertForNone,
                forSourceFunction: .offlineModeManager,
                forDog: syncNeededDog
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // No need to call the delegate. Object's id is automatically assigned to the value from the server, initialAttemptedSyncDate is automatically set to nil, and we locally have all the information about this object
                
                // Reinvoke helperSyncDogs, except with syncNeededDogs which has this current syncNeededDog removed
                self.helperSyncDogs(forSyncNeededDogs: syncNeededDogs)
            }
            return
        }
        
        // offlineModeDog has a dogId, so its already been created on the server
        DogsRequest.update(
            forErrorAlert: .automaticallyAlertForNone,
            forSourceFunction: .offlineModeManager,
            forDog: syncNeededDog
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            
            // No need to call the delegate. initialAttemptedSyncDate is automatically set to nil and we locally have all the information about this object
            
            // Reinvoke helperSyncDogs, except with syncNeededDogs which has this current syncNeededDog removed
            self.helperSyncDogs(forSyncNeededDogs: syncNeededDogs)
        }
    }
    
    /// Helper function for sync. Attempts to sync all of the unsynced reminders. Recursively invokes itself until all forSyncNeededReminders have been synced. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncReminders(forSyncNeededReminders: [(UUID, Reminder)]) {
        // Create a copy so that we can remove elements
        var syncNeededReminders = forSyncNeededReminders
        
        // Get the first reminder, which has the more priority, and attempt to sync it
        guard let syncNeededReminder = syncNeededReminders.first else {
            // There are no more reminders that need synced
            syncNextObject()
            return
        }
        
        // syncNeededReminder exists so its safe to remove the first element from syncNeededReminders
        syncNeededReminders.removeFirst()
        
        guard syncNeededReminder.1.offlineModeComponents.needsSyncedWithHoundServer == true else {
            // Reinvoke helperSyncReminders, except with syncNeededReminders which has this current syncNeededReminder removed
            helperSyncReminders(forSyncNeededReminders: syncNeededReminders)
            return
        }
        
        guard syncNeededReminder.1.reminderId != nil else {
            // offlineModeReminder doesn't have a dogId, so it hasn't been created on the server
            RemindersRequest.create(
                forErrorAlert: .automaticallyAlertForNone,
                forSourceFunction: .offlineModeManager,
                forDogUUID: syncNeededReminder.0,
                forReminders: [syncNeededReminder.1]
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // No need to call the delegate. Object's id is automatically assigned to the value from the server, initialAttemptedSyncDate is automatically set to nil, and we locally have all the information about this object
                
                // Reinvoke helperSyncReminders, except with syncNeededReminders which has this current syncNeededReminder removed
                self.helperSyncReminders(forSyncNeededReminders: syncNeededReminders)
            }
            return
        }
        
        // offlineModeReminder has a reminderId, so its already been created on the server
        RemindersRequest.update(
            forErrorAlert: .automaticallyAlertForNone,
            forSourceFunction: .offlineModeManager,
            forDogUUID: syncNeededReminder.0,
            forReminders: [syncNeededReminder.1]
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            
            // No need to call the delegate. initialAttemptedSyncDate is automatically set to nil and we locally have all the information about this object
            
            // Reinvoke helperSyncReminders, except with syncNeededReminders which has this current syncNeededReminder removed
            self.helperSyncReminders(forSyncNeededReminders: syncNeededReminders)
        }
    }
    
    /// Helper function for sync. Attempts to sync all of the unsynced logs. Recursively invokes itself until all forSyncNeededLogs have been synced. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncLogs(forSyncNeededLogs: [(UUID, Log)]) {
        // Create a copy so that we can remove elements
        var syncNeededLogs = forSyncNeededLogs
        
        // Get the first log, which has the more priority, and attempt to sync it
        guard let syncNeededLog = syncNeededLogs.first else {
            // There are no more logs that need synced
            syncNextObject()
            return
        }
        
        // syncNeededLog exists so its safe to remove the first element from syncNeededLogs
        syncNeededLogs.removeFirst()
        
        guard syncNeededLog.1.offlineModeComponents.needsSyncedWithHoundServer == true else {
            // Reinvoke helperSyncLogs, except with syncNeededLogs which has this current syncNeededLog removed
            helperSyncLogs(forSyncNeededLogs: syncNeededLogs)
            return
        }
        
        guard syncNeededLog.1.logId != nil else {
            // offlineModeLog doesn't have a dogId, so it hasn't been created on the server
            LogsRequest.create(
                forErrorAlert: .automaticallyAlertForNone,
                forSourceFunction: .offlineModeManager,
                forDogUUID: syncNeededLog.0,
                forLog: syncNeededLog.1
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // No need to call the delegate. Object's id is automatically assigned to the value from the server, initialAttemptedSyncDate is automatically set to nil, and we locally have all the information about this object
                
                // Reinvoke helperSyncLogs, except with syncNeededLogs which has this current syncNeededLog removed
                self.helperSyncLogs(forSyncNeededLogs: syncNeededLogs)
            }
            return
        }
        
        // offlineModeLog has a logId, so its already been created on the server
        LogsRequest.update(
            forErrorAlert: .automaticallyAlertForNone,
            forSourceFunction: .offlineModeManager,
            forDogUUID: syncNeededLog.0,
            forLog: syncNeededLog.1
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            
            // No need to call the delegate. initialAttemptedSyncDate is automatically set to nil and we locally have all the information about this object
            
            // Reinvoke helperSyncLogs, except with syncNeededLogs which has this current syncNeededLog removed
            self.helperSyncLogs(forSyncNeededLogs: syncNeededLogs)
        }
    }
    
    /// Helper function for sync. Attempts to sync all of the unsynced triggers. Recursively invokes itself until all forSyncNeededTriggers have been synced. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncTriggers(forSyncNeededTriggers: [(UUID, Trigger)]) {
        // Create a copy so that we can remove elements
        var syncNeededTriggers = forSyncNeededTriggers
        
        // Get the first trigger, which has the more priority, and attempt to sync it
        guard let syncNeededTrigger = syncNeededTriggers.first else {
            // There are no more triggers that need synced
            syncNextObject()
            return
        }
        
        // syncNeededTrigger exists so its safe to remove the first element from syncNeededTriggers
        syncNeededTriggers.removeFirst()
        
        guard syncNeededTrigger.1.offlineModeComponents.needsSyncedWithHoundServer == true else {
            // Reinvoke helperSyncTriggers, except with syncNeededTriggers which has this current syncNeededTrigger removed
            helperSyncTriggers(forSyncNeededTriggers: syncNeededTriggers)
            return
        }
        
        guard syncNeededTrigger.1.triggerId != nil else {
            // offlineModeTrigger doesn't have a dogId, so it hasn't been created on the server
            TriggersRequest.create(
                forErrorAlert: .automaticallyAlertForNone,
                forSourceFunction: .offlineModeManager,
                forDogUUID: syncNeededTrigger.0,
                forDogTriggers: [syncNeededTrigger.1]
            ) { responseStatus, _ in
                guard responseStatus != .noResponse else {
                    self.noResponseForSync()
                    return
                }
                
                // No need to call the delegate. Object's id is automatically assigned to the value from the server, initialAttemptedSyncDate is automatically set to nil, and we locally have all the information about this object
                
                // Reinvoke helperSyncTriggers, except with syncNeededTriggers which has this current syncNeededTrigger removed
                self.helperSyncTriggers(forSyncNeededTriggers: syncNeededTriggers)
            }
            return
        }
        
        // offlineModeTrigger has a triggerId, so its already been created on the server
        TriggersRequest.update(
            forErrorAlert: .automaticallyAlertForNone,
            forSourceFunction: .offlineModeManager,
            forDogUUID: syncNeededTrigger.0,
            forDogTriggers: [syncNeededTrigger.1]
        ) { responseStatus, _ in
            guard responseStatus != .noResponse else {
                self.noResponseForSync()
                return
            }
            
            // No need to call the delegate. initialAttemptedSyncDate is automatically set to nil and we locally have all the information about this object
            
            // Reinvoke helperSyncTriggers, except with syncNeededTriggers which has this current syncNeededTrigger removed
            self.helperSyncTriggers(forSyncNeededTriggers: syncNeededTriggers)
        }
    }

    /// Helper function for sync. Attempts to sync, in order of priority, unsynced dogs, reminders, and logs. Invokes sync or noResponseForSync depending upon its result when it completes.
    private func helperSyncDogsRemindersLogsTriggers() {
        guard let globalDogManager = DogManager.globalDogManager else {
            syncNextObject()
            return
        }
        
        // Find all dogs that need to be synced and order them by oldest initialAttemptedSyncDate (index 0) to newest (index end)
        let syncNeededDogs = globalDogManager.dogs.filter { dog in
            return dog.offlineModeComponents.needsSyncedWithHoundServer
        }
            .sorted { dog1, dog2 in
            // If a dog is in this array, needsSyncedWithHoundServer is true, which means that initialAttemptedSyncDate should not be nil.
            return (dog1.offlineModeComponents.initialAttemptedSyncDate ?? dog1.offlineModeComponents.initialCreationDate) <= (dog2.offlineModeComponents.initialAttemptedSyncDate ?? dog2.offlineModeComponents.initialCreationDate)
            }
        
        // If we have dogs to sync, sync them first before the reminders and logs
        guard syncNeededDogs.isEmpty == true else {
            helperSyncDogs(forSyncNeededDogs: syncNeededDogs)
            return
        }
        
        // Find all reminders that need to be synced and order them by oldest initialAttemptedSyncDate (index 0) to newest (index end)
        let syncNeededReminders = globalDogManager.dogs.flatMap { dog -> [(UUID, Reminder)] in
            return dog.dogReminders.dogReminders
                .filter { $0.offlineModeComponents.needsSyncedWithHoundServer }
                .map { (dog.dogUUID, $0) } // Create a tuple of dogUUID and reminder
        }
        .sorted { tuple1, tuple2 in
            let reminder1 = tuple1.1
            let reminder2 = tuple2.1
            // If a reminder is in this array, needsSyncedWithHoundServer is true, which means that initialAttemptedSyncDate should not be nil.
            return (reminder1.offlineModeComponents.initialAttemptedSyncDate ?? reminder1.offlineModeComponents.initialCreationDate) <= (reminder2.offlineModeComponents.initialAttemptedSyncDate ?? reminder2.offlineModeComponents.initialCreationDate)
        }
        
        // If we have reminders to sync, sync them first before the logs
        guard syncNeededReminders.isEmpty == true else {
            helperSyncReminders(forSyncNeededReminders: syncNeededReminders)
            return
        }
        
        // Find all logs that need to be synced and order them by oldest initialAttemptedSyncDate (index 0) to newest (index end)
        let syncNeededLogs = globalDogManager.dogs.flatMap { dog -> [(UUID, Log)] in
            return dog.dogLogs.dogLogs
                .filter { $0.offlineModeComponents.needsSyncedWithHoundServer }
                .map { (dog.dogUUID, $0) } // Create a tuple of dogUUID and reminder
        }
        .sorted { tuple1, tuple2 in
            let log1 = tuple1.1
            let log2 = tuple2.1
            // If a log is in this array, needsSyncedWithHoundServer is true, which means that initialAttemptedSyncDate should not be nil.
            return (log1.offlineModeComponents.initialAttemptedSyncDate ?? log1.offlineModeComponents.initialCreationDate) <= (log2.offlineModeComponents.initialAttemptedSyncDate ?? log2.offlineModeComponents.initialCreationDate)
        }
        
        // If we have logs to sync, sync them
        guard syncNeededLogs.isEmpty == true else {
            helperSyncLogs(forSyncNeededLogs: syncNeededLogs)
            return
        }
        
        // Find all triggers that need to be synced and order them by oldest initialAttemptedSyncDate (index 0) to newest (index end)
        let syncNeededTriggers = globalDogManager.dogs.flatMap { dog -> [(UUID, Trigger)] in
            return dog.dogTriggers.dogTriggers
                .filter { $0.offlineModeComponents.needsSyncedWithHoundServer }
                .map { (dog.dogUUID, $0) } // Create a tuple of dogUUID and trigger
        }
        .sorted { tuple1, tuple2 in
            let trigger1 = tuple1.1
            let trigger2 = tuple2.1
            // If a trigger is in this array, needsSyncedWithHoundServer is true, which means that initialAttemptedSyncDate should not be nil.
            return (trigger1.offlineModeComponents.initialAttemptedSyncDate ?? trigger1.offlineModeComponents.initialCreationDate) <= (trigger2.offlineModeComponents.initialAttemptedSyncDate ?? trigger2.offlineModeComponents.initialCreationDate)
        }

        // If we have triggers to sync, sync them first before the logs
        guard syncNeededTriggers.isEmpty == true else {
            helperSyncTriggers(forSyncNeededTriggers: syncNeededTriggers)
            return
        }
        
        // We have synced all the dogs, reminders, and logs
        syncNextObject()
    }
    
    /// In order of a heirarchy of priority, begins to perform requests to the Hound server to progressively re-sync the users data with the server. Waits for a single network call to finish before that request's completionHandler invokes syncNextObject()
    private func syncNextObject() {
        // shouldUpdateUser should come before shouldGetUser otherwise shouldGetUser would overwrite the local changes to UserConfiguration
        guard shouldUpdateUser == false else {
            helperSyncUpdateUser()
            return
        }
        
        guard shouldGetUser == false else {
            helperSyncGetUser()
            return
        }
        
        guard shouldGetFamily == false else {
            helperSyncGetFamily()
            return
        }
        
        guard shouldGetDogManager == false else {
            helperSyncGetDogManager()
            return
        }
        
        // Start sync-ing updates according to priority:
        //      1. deleted dogs
        //      2. deleted reminders/logs
        //      3. dogs
        //      4. reminders/logs
        
        guard offlineModeDeletedObjects.isEmpty == true else {
            helperSyncDeletedObject()
            return
        }
        
        guard isDogManagerSyncNeeded == false else {
            helperSyncDogsRemindersLogsTriggers()
            return
        }
        
        // We have finished syncing everything. Push an update to the MainTabBarVC with the update dogManager
        if let globalDogManager = DogManager.globalDogManager {
            delegate?.didUpdateDogManager(sender: Sender(origin: self, localized: self), forDogManager: globalDogManager)
        }
        
        isSyncInProgress = false
    }
}
//
//  ExportActivityViewManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 9/12/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ExportActivityViewManager {

    /// Verifys that the family has space for a new family member and is unlocked. If conditions are passed, meaning the family can have a new user join, constructs an activityViewController with the information to share (i.e. the familyCode and short description of Hound) then presents it on forViewController
    static func shareFamilyCode(forFamilyCode familyCode: String) {
        guard let globalPresenter = PresentationManager.lastFromGlobalPresenterStack else {
            ErrorConstant.ExportError.shareFamilyCode().alert()
            return
        }

        // Check that the family has space for at least one new member, otherwise block them from sharing the family.
        guard FamilyInformation.familyMembers.count < FamilyInformation.familyActiveSubscription.numberOfFamilyMembers else {
            SettingsSubscriptionViewController.fetchProductsThenGetViewController { vc in
                guard let vc = vc else {
                    // Error message automatically handled
                    return
                }
                
                PresentationManager.enqueueViewController(vc)
            }
            return
        }

        /*
         // Make sure that the family is unlocked so new
        guard FamilyInformation.familyIsLocked == false else {
            PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.invalidLockedFamilyShareTitle, forSubtitle: VisualConstant.BannerTextConstant.invalidLockedFamilyShareSubtitle, forStyle: .danger)
            return
        }
         */

        let shareHoundText = "Connect our family with Hound! It streamlines our pet care routine with shared logs and timely reminders to look after our dog.\n\nJoin my Hound family today by using the following code: \(familyCode)\n\nhttps://apps.apple.com/app/hound-dog-schedule-organizer/id1564604025"

        exportToActivityViewController(forObjectToShare: [shareHoundText], forGlobalPresenter: globalPresenter)
    }

    static func exportLogs(forDogUUIDLogTuples: [(UUID, Log)]) {
        PresentationManager.beginFetchingInformationIndicator()

        guard let globalPresenter = PresentationManager.lastFromGlobalPresenterStack else {
            PresentationManager.endFetchingInformationIndicator {
                ErrorConstant.ExportError.exportLogs().alert()
            }
            return
        }

        // Attempt to get a url to the user's document directory
        guard let documentsDirectoryURL = try? FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true) else {
            PresentationManager.endFetchingInformationIndicator {
                ErrorConstant.ExportError.exportLogs().alert()
            }
            return
        }

        let dateFormatter = DateFormatter()
        // Specifies a short style, typically numeric only, such as “11/23/37” or “3:30 PM”.
        dateFormatter.dateStyle = .short
        // Specifies no style.
        dateFormatter.timeStyle = .none
        
        let dateString = dateFormatter.string(from: Date()).replacingOccurrences(of: "/", with: "-")

        let houndExportedLogsURL: URL = documentsDirectoryURL.appendingPathComponent("Hound-Exported-Logs-\(dateString)").appendingPathExtension("csv")
        // Header for CSV file
        var logsString = "Family Member,Dog Name,Log Action,Log Start Date,Log End Date,Log Unit,Log Note\n\n"
        // to speed up runtime, save a dictionary of dogUUIDs keys and dogNames values here. Skips searching for same dog repeatedly
        var dogUUIDToDogNames: [UUID: String] = [:]
        // to speed up runtime, save a dictionary of userIds keys and full names values here. Skips searching for same family member repeatedly
        var userIdToFamilyMemberFullName: [String: String] = [:]

        // Individual rows for CSV file
        for forDogUUIDLogTuple in forDogUUIDLogTuples {
            let dogUUID = forDogUUIDLogTuple.0
            let log = forDogUUIDLogTuple.1

            var familyMemberFullName = userIdToFamilyMemberFullName[log.userId]
            if familyMemberFullName == nil {
                // if we don't have familyMemberFullName stored in the dictionary for quick reference, store it
                familyMemberFullName = FamilyInformation.findFamilyMember(forUserId: log.userId)?.displayFullName ?? VisualConstant.TextConstant.unknownName
                userIdToFamilyMemberFullName[log.userId] = familyMemberFullName
            }

            var dogName = dogUUIDToDogNames[dogUUID]
            if dogName == nil {
                // if we don't have dogName stored in the dictionary for quick reference, store it
                dogName = DogManager.globalDogManager?.findDog(forDogUUID: dogUUID)?.dogName ?? VisualConstant.TextConstant.unknownName
                dogUUIDToDogNames[dogUUID] = dogName
            }

           // neither should be nil as in the odd case we can't locate either, we just put in VisualConstant.TextConstant.unknownName in its place
            guard let dogName = dogName, let familyMemberFullName = familyMemberFullName else {
                continue
            }

            let logActionType = log.logActionType.convertToReadableName(customActionName: log.logCustomActionName)

            let dateFormatter = DateFormatter()
            // January 25, 2023 at 7:53 AM
            dateFormatter.setLocalizedDateFormatFromTemplate("MMMMdyyyyhma")
            let logStartDate = dateFormatter.string(from: log.logStartDate)
            
            let logEndDate = {
                guard let logEndDate = log.logEndDate else {
                    return ""
                }
                
                return dateFormatter.string(from: logEndDate)
            }()
            
            let logUnit = {
                guard let logUnitType = log.logUnitType, let logNumberOfLogUnits = log.logNumberOfLogUnits else {
                    return ""
                }
                
                return logUnitType.convertedMeasurementString(
                    forLogNumberOfLogUnits: logNumberOfLogUnits,
                    toTargetSystem: UserConfiguration.measurementSystem
                ) ?? ""
            }()
            
            let logNote = log.logNote

            var logString = ""
            logString.append("\(familyMemberFullName.formatIntoCSV()),")
            logString.append("\(dogName.formatIntoCSV()),")
            logString.append("\(logActionType.formatIntoCSV()),")
            logString.append("\(logStartDate.formatIntoCSV()),")
            logString.append("\(logEndDate.formatIntoCSV()),")
            logString.append("\(logUnit.formatIntoCSV()),")
            logString.append("\(logNote.formatIntoCSV())")
            logString.append("\n")

            logsString.append(logString)
        }

        guard (try? logsString.write(to: houndExportedLogsURL, atomically: true, encoding: .utf8)) != nil else {
            PresentationManager.endFetchingInformationIndicator {
                ErrorConstant.ExportError.exportLogs().alert()
            }
            return
        }

        PresentationManager.endFetchingInformationIndicator {
            exportToActivityViewController(forObjectToShare: [houndExportedLogsURL], forGlobalPresenter: globalPresenter)
        }
    }

    /// Creates an activityViewController used to share the objects passed. We purposefully pass through globalPresenter here, so if earlier in the flow one of the invoking functions can't resolve a globalPresenter, we are able to present a custom error message then and there
    private static func exportToActivityViewController(forObjectToShare objectToShare: [Any], forGlobalPresenter globalPresenter: UIViewController) {
        let activityViewController = UIActivityViewController(activityItems: objectToShare, applicationActivities: nil)
        // Configure so that iPads won't crash
        activityViewController.popoverPresentationController?.sourceView = globalPresenter.view

        // exclude some activity types from the list (optional)
        activityViewController.excludedActivityTypes =
        [ UIActivity.ActivityType.addToReadingList ]

        if #available(iOS 15.4, *) {
            activityViewController.excludedActivityTypes?.append(UIActivity.ActivityType.sharePlay)
        }

        PresentationManager.enqueueViewController(activityViewController)
    }
}
//
//  NotificationPermissionsManager.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/31/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum NotificationPermissionsManager {

    /**
     If localIsNotificationAuthorized == true && isNotificationEnabled == true, invokes registerForRemoteNotifications then the completionHandler.
     If shouldAdviseUserBeforeRequestingNotifications == false && localIsNotificationAuthorized == false, invokes registerForRemoteNotifications then the completionHandler.
     If shouldAdviseUserBeforeRequestingNotifications == false && localIsNotificationAuthorized == false, invokes performNotificationAuthorizationRequest()
     If shouldAdviseUserBeforeRequestingNotifications == true, presents alert controller that asks the user if they want to turn on notifications. If they say yes, invokes performNotificationAuthorizationRequest(), otherwise invokes registerForRemoteNotifications then the completionHandler.
     
     performNotificationAuthorizationRequest() uses Apple's requestAuthorization to show the classic "Turn On Notifications" message. If they say yes, then we are able to send the user notifications, if they say no, then we are unable to send the user notifications. Regardless of the result, we update LocalConfiguration and contact the Hound server.
     */
    static func requestNotificationAuthorization(shouldAdviseUserBeforeRequestingNotifications: Bool, completionHandler: (() -> Void)?) {
        guard LocalConfiguration.localIsNotificationAuthorized == false || UserConfiguration.isNotificationEnabled == false else {
            // If localIsNotificationAuthorized == true && isNotificationEnabled == true, there is no purpose in asking the user to request notification authorization. They are already authorized and have notifications enabled. Simply, re-register for remote notifications (repeated re-registering recommended by apple; user could be unregistered for remoteNotifications).
            registerForRemoteNotificationsIfAuthorized()
            completionHandler?()
            return
        }

        // If shouldAdviseUserBeforeRequestingNotifications == true, we present our alert controller that asks the user if they want notifications. We only have one use of Apple's notification prompt, so this prevents wasting that one by seeing if the user wants notifications.
        guard shouldAdviseUserBeforeRequestingNotifications == true else {
            // If adviseUserBeforeRequestingNotifications == false, check the localIsNotificationAuthorized status.
            if LocalConfiguration.localIsNotificationAuthorized == true {
                // If localIsNotificationAuthorized == true, then re-register for remote notifications (repeated re-registering recommended by apple; user could be unregistered for remoteNotifications). Don't change user's notification settings as they could have already configured them since localIsNotificationAuthorized == true.
                registerForRemoteNotificationsIfAuthorized()
                completionHandler?()
            }
            else {
                // If localIsNotificationAuthorized == false, then notification haven't been approved. Therefore, we can request notifications and override any non-user-configured notification settings
                performNotificationAuthorizationRequest()
            }
            return
        }

        let askUserAlertController = UIAlertController(title: "Do you want to turn on notifications?", message: "Don't miss out on important events like your dog needing a helping hand or a family member adding a log", preferredStyle: .alert)

        let turnOnNotificationsAlertAction = UIAlertAction(title: "Turn On Notifications", style: .default) { _ in
            performNotificationAuthorizationRequest()
        }

        let notNowAlertAction = UIAlertAction(title: "Not Now", style: .cancel) { _ in
            registerForRemoteNotificationsIfAuthorized()
            completionHandler?()
        }

        askUserAlertController.addAction(turnOnNotificationsAlertAction)
        askUserAlertController.addAction(notNowAlertAction)

        PresentationManager.enqueueAlert(askUserAlertController)

        func performNotificationAuthorizationRequest() {
            let beforeUpdateIsNotificationEnabled = UserConfiguration.isNotificationEnabled
            let beforeUpdateIsLoudNotificationEnabled = UserConfiguration.isLoudNotificationEnabled
            
            UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge, .carPlay]) { isGranted, _ in
                LocalConfiguration.localIsNotificationAuthorized = isGranted
                registerForRemoteNotificationsIfAuthorized()

                UserConfiguration.isNotificationEnabled = isGranted
                UserConfiguration.isLoudNotificationEnabled = isGranted

                // Contact the server about the updated values and, if there is no response or a bad response, revert the values to their previous values. localIsNotificationAuthorized purposefully excluded as server doesn't need to know that and its value is untrust worthy (user can modify the value without us knowing, unlike our custom variables).
                let body: [String: CompatibleDataTypeForJSON?] = [
                    KeyConstant.userConfigurationIsNotificationEnabled.rawValue: UserConfiguration.isNotificationEnabled, KeyConstant.userConfigurationIsLoudNotificationEnabled.rawValue: UserConfiguration.isLoudNotificationEnabled
                ]

                UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
                    guard responseStatus != .failureResponse else {
                        // Revert local values to previous state due to an error
                        UserConfiguration.isNotificationEnabled = beforeUpdateIsNotificationEnabled
                        UserConfiguration.isLoudNotificationEnabled = beforeUpdateIsLoudNotificationEnabled
                        return
                    }
                    
                    DispatchQueue.main.async {
                        completionHandler?()
                    }
                }
            }
        }

    }

    private static func registerForRemoteNotificationsIfAuthorized() {
        guard LocalConfiguration.localIsNotificationAuthorized == true else {
            return
        }

        DispatchQueue.main.async {
            UIApplication.shared.registerForRemoteNotifications()
        }
    }

    /// Checks to see that the status of localIsNotificationAuthorized matches the status of other notification settings. If there is an imbalance in notification settings or a change has occured, then updates the local settings and server settings to fix the issue
    static func synchronizeNotificationAuthorization() {
        let beforeUpdateIsNotificationEnabled = UserConfiguration.isNotificationEnabled
        let beforeUpdateIsLoudNotificationEnabled = UserConfiguration.isLoudNotificationEnabled

        UNUserNotificationCenter.current().getNotificationSettings { permission in
            switch permission.authorizationStatus {
            case .authorized:
                authorizeNotifications()
            case .denied:
                denyNotifications()
            case .notDetermined:
                denyNotifications()
            case .provisional:
                authorizeNotifications()
            case .ephemeral:
                authorizeNotifications()
            @unknown default:
                denyNotifications()
            }
        }

        /// Enables localIsNotificationAuthorized and checks to make sure that the user is registered for remote notifications
        func authorizeNotifications() {
            // Notifications are authorized
            LocalConfiguration.localIsNotificationAuthorized = true
            // Never cache device tokens in your app; instead, get them from the system when you need them. APNs issues a new device token to your app when certain events happen.
            registerForRemoteNotificationsIfAuthorized()
        }

        /// Disables localIsNotificationAuthorized and checks to make sure that the other notification settings align (making sure there is no imbalance, e.g. isNotificationEnabled == true but localIsNotificationAuthorized == false)
        func denyNotifications() {
            LocalConfiguration.localIsNotificationAuthorized = false

            // The user isn't authorized for notifications, therefore all of those settings should be false. If any of those settings aren't false, representing an imbalance, then we should fix this imbalance and update the Hound server
            guard UserConfiguration.isNotificationEnabled == true || UserConfiguration.isLoudNotificationEnabled == true else {
                return
            }

            UserConfiguration.isNotificationEnabled = false
            UserConfiguration.isLoudNotificationEnabled = false
            DispatchQueue.main.async {
                // The isNotificationAuthorized, isNotificationEnabled, and isLoudNotificationEnabled have been potentially updated. Additionally, SettingsNotifsTableVC could be be the last view opened. Therefore, we need to inform SettingsNotifsTableVC of these changes so that it can update its switches.
                SettingsNotifsTableVC.didSynchronizeNotificationAuthorization()
            }
            var body: [String: CompatibleDataTypeForJSON?] = [:]
            // check for if values were changed, if there were then tell the server
            if UserConfiguration.isNotificationEnabled != beforeUpdateIsNotificationEnabled {
                body[KeyConstant.userConfigurationIsNotificationEnabled.rawValue] = UserConfiguration.isNotificationEnabled
            }
            if UserConfiguration.isLoudNotificationEnabled != beforeUpdateIsLoudNotificationEnabled {
                body[KeyConstant.userConfigurationIsLoudNotificationEnabled.rawValue] = UserConfiguration.isLoudNotificationEnabled
            }

            guard body.keys.isEmpty == false else {
                return
            }
            UserRequest.update(forErrorAlert: .automaticallyAlertOnlyForFailure, forBody: body) { responseStatus, _ in
                guard responseStatus != .failureResponse else {
                    // Revert local values to previous state due to an error
                    UserConfiguration.isNotificationEnabled = beforeUpdateIsNotificationEnabled
                    UserConfiguration.isLoudNotificationEnabled = beforeUpdateIsLoudNotificationEnabled

                    // The isNotificationAuthorized, isNotificationEnabled, and isLoudNotificationEnabled have been potentially updated. Additionally, SettingsNotifsTableVC could be be the last view opened. Therefore, we need to inform SettingsNotifsTableVC of these changes so that it can update its switches.
                    SettingsNotifsTableVC.didSynchronizeNotificationAuthorization()
                    return
                }
            }
        }
    }

}
//
//  Timing.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/20/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

protocol ReminderTimingManagerDelegate: AnyObject {
    func didAddReminder(sender: Sender, forDogUUID: UUID, forReminder: Reminder)
    func didRemoveReminder(sender: Sender, forDogUUID: UUID, forReminderUUID: UUID)
}

final class ReminderTimingManager {
    
    enum ReminderTimerTypes {
        /// Represents a Timer that is used for managing a reminder's alarms (which trigger an alert / alarm for when the reminder is scheduled)
        case alarmTimer
        /// Represents a Timer that is used to change a reminder from isSkipping true to false. This triggers when the current date passes the original reminderExecutionDate that was skipped, indicating the reminder should go back into regular, non-skipping mode.
        case disableIsSkippingTimer
    }
    
    class ReminderTimer {
        var timer: Timer
        var type: ReminderTimerTypes
        var dogName: String
        var dogUUID: UUID
        var reminder: Reminder
        
        init(forTimer: Timer, forType: ReminderTimerTypes, forDogName: String, forDogUUID: UUID, forReminder: Reminder) {
            self.timer = forTimer
            self.type = forType
            self.dogName = forDogName
            self.dogUUID = forDogUUID
            self.reminder = forReminder
        }
    }

    // MARK: - Properties

    static weak var delegate: ReminderTimingManagerDelegate!
    
    private static var reminderTimers: [ReminderTimer] = []

    // MARK: - Main

    /// Initializes all reminder timers
    static func initializeReminderTimers(forDogManager: DogManager) {
        removeTimersForDeletedReminders(forDogManager: forDogManager)
        
        for dog in forDogManager.dogs {
            for reminder in dog.dogReminders.dogReminders {
                // if the reminder has a execution date, then create its timers
                guard reminder.reminderIsEnabled == true, let reminderExecutionDate = reminder.reminderExecutionDate else {
                    // The reminder is disabled and can't have any timers
                    removeTimer(forReminderUUID: reminder.reminderUUID, forType: .alarmTimer)
                    removeTimer(forReminderUUID: reminder.reminderUUID, forType: .disableIsSkippingTimer)
                    continue
                }
                
                // If the reminder doesn't have a reminderAlarmTimer or the reminderAlarmTimer hasn't fired yet, assign the reminder a new reminderAlarmTimer.
                // If reminderAlarmTimer isn't nil and it has already fired, don't overwrite it. It probably is waiting for a user to response to the AlarmUIAlertController.
                let reminderAlarmTimer = findTimer(forReminderUUID: reminder.reminderUUID, forType: .alarmTimer)
                if reminderAlarmTimer == nil || reminderAlarmTimer?.timer.fireDate ?? Date(timeIntervalSince1970: 0.0) > Date() {
                    // Remove the existing timer now that we want to replace it
                    removeTimer(forReminderUUID: reminder.reminderUUID, forType: .alarmTimer)
                    
                    let reminderAlarmTimer = Timer(
                                      fireAt: reminderExecutionDate,
                                      interval: -1,
                                      target: self,
                                      selector: #selector(self.didExecuteReminderAlarmTimer(sender:)),
                                      userInfo: nil,
                                      repeats: false)
                    reminderTimers.append(
                        ReminderTimer(forTimer: reminderAlarmTimer,
                                      forType: .alarmTimer,
                                      forDogName: dog.dogName,
                                      forDogUUID: dog.dogUUID,
                                      forReminder: reminder)
                    )
                    RunLoop.main.add(reminderAlarmTimer, forMode: .common)
                }

                // Sets a timer that executes when the timer should go from isSkipping true -> false.
                // If the reminder doesn't have a reminderDisableIsSkippingTimer or the reminderDisableIsSkippingTimer hasn't fired yet, assign the reminder a new reminderDisableIsSkippingTimer.
                // If reminderDisableIsSkippingTimer isn't nil and it has already fired, don't overwrite it.
                let reminderDisableIsSkippingTimer = findTimer(forReminderUUID: reminder.reminderUUID, forType: .disableIsSkippingTimer)
                if reminderDisableIsSkippingTimer == nil
                    || reminderDisableIsSkippingTimer?.timer.fireDate ?? Date(timeIntervalSince1970: 0.0) > Date(), let disableIsSkippingDate = reminder.disableIsSkippingDate {
                    // Remove the existing timer now that we want to replace it
                    removeTimer(forReminderUUID: reminder.reminderUUID, forType: .disableIsSkippingTimer)
                    
                    let reminderDisableIsSkippingTimer = Timer(fireAt: disableIsSkippingDate,
                                                   interval: -1,
                                                   target: self,
                                                   selector: #selector(didExecuteReminderDisableIsSkippingTimer(sender:)),
                                                   userInfo: nil,
                                                   repeats: false)
                    reminderTimers.append(
                        ReminderTimer(forTimer: reminderDisableIsSkippingTimer,
                                      forType: .disableIsSkippingTimer,
                                      forDogName: dog.dogName,
                                      forDogUUID: dog.dogUUID,
                                      forReminder: reminder)
                    )
                    RunLoop.main.add(reminderDisableIsSkippingTimer, forMode: .common)
                }
            }
        }
    }
    
    // MARK: - Functions
    
    /// For a given forReminderUUID, find the first occurance in reminderAlarmTimers of a ReminderTimer with the same reminderUUID.
    private static func findTimer(forReminderUUID: UUID, forType: ReminderTimerTypes) -> ReminderTimer? {
        return reminderTimers.first { reminderTimer in
            guard reminderTimer.type == forType else {
                return false
            }
            
            return reminderTimer.reminder.reminderUUID == forReminderUUID
        }
    }
    
    /// Removes all reminderTimers with the same forReminderUUID from reminderAlarmTimers, invalidating their timers in the process
    private static func removeTimer(forReminderUUID: UUID, forType: ReminderTimerTypes) {
        reminderTimers.removeAll { reminderTimer in
            guard reminderTimer.type == forType else {
                return false
            }
            
            guard reminderTimer.reminder.reminderUUID == forReminderUUID else {
                return false
            }
            
            reminderTimer.timer.invalidate()
            return true
        }
    }
    
    private static func removeTimersForDeletedReminders(forDogManager: DogManager) {
        reminderTimers.forEach { reminderTimer in
            let dogUUID = reminderTimer.dogUUID
            let reminderUUID = reminderTimer.reminder.reminderUUID
            
            // If the dog or reminder no longer exists, then we have a timer for nothing. Therefore, we should remove it
            if forDogManager.findDog(forDogUUID: dogUUID)?.dogReminders.findReminder(forReminderUUID: reminderUUID) == nil {
                removeTimer(forReminderUUID: reminderUUID, forType: .alarmTimer)
                removeTimer(forReminderUUID: reminderUUID, forType: .disableIsSkippingTimer)
            }
        }
    }
    
    /// When a reminderAlarmTimer executes, it invokes ReminderAlarmManager.willCreateAndShowReminderAlarm. This timer stays in the array of timers until the user responds to the alert, otherwise ReminderTimingManager would create more timers which would create more alerts for the user to click through. Therefore, we only remove the timer once the user has responded to the alert.
    static func didCompleteForReminderTimer(forReminderUUID: UUID, forType: ReminderTimerTypes) {
        removeTimer(forReminderUUID: forReminderUUID, forType: forType)
    }

    // MARK: - Timer Actions

    /// Used as a selector when constructing timer in initializeReminderTimers. Invoke ReminderAlarmManager to show alart controller for reminder alarm
    @objc private static func didExecuteReminderAlarmTimer(sender: Timer) {
        guard let reminderTimer = reminderTimers.first(where: { reminderTimer in
            return reminderTimer.timer == sender
        }) else {
            return
        }
        
        ReminderAlarmManager.willCreateAndShowReminderAlarm(forDogName: reminderTimer.dogName, forDogUUID: reminderTimer.dogUUID, forReminder: reminderTimer.reminder)
    }

    /// Used as a selector when constructing timer in initializeReminderTimers. It triggers when the current date passes the original reminderExecutionDate that was skipped, indicating the reminder should go back into regular, non-skipping mode. If assigning new timer, invalidates the current timer then assigns reminderDisableIsSkippingTimer to new timer.
    @objc private static func didExecuteReminderDisableIsSkippingTimer(sender: Timer) {
        guard let reminderTimer = reminderTimers.first(where: { reminderTimer in
            return reminderTimer.timer == sender
        }) else {
            return
        }
        
        RemindersRequest.get(forErrorAlert: .automaticallyAlertForNone, forDogUUID: reminderTimer.dogUUID, forReminder: reminderTimer.reminder) { reminder, responseStatusReminderGet, _ in
            guard responseStatusReminderGet != .failureResponse else {
                return
            }
            
            guard let reminder = reminder else {
                // If the response was successful but no reminder was returned, that means the reminder was deleted. Therefore, update the dogManager to indicate as such.
                self.delegate.didRemoveReminder(sender: Sender(origin: self, localized: self), forDogUUID: reminderTimer.dogUUID, forReminderUUID: reminderTimer.reminder.reminderUUID)
                return
            }

            reminder.resetForNextAlarm()
            didCompleteForReminderTimer(forReminderUUID: reminder.reminderUUID, forType: .disableIsSkippingTimer)

            RemindersRequest.update(forErrorAlert: .automaticallyAlertForNone, forDogUUID: reminderTimer.dogUUID, forReminders: [reminder]) { responseStatusReminderUpdate, _ in
                guard responseStatusReminderUpdate != .failureResponse else {
                    return
                }

                delegate.didAddReminder(sender: Sender(origin: self, localized: self), forDogUUID: reminderTimer.dogUUID, forReminder: reminder)
            }
        }
    }
}
//
//  PresentationManager.swift
//  viewControllerPresentationQueue-Example
//
//  Created by William Boles on 26/05/2019.
//  Copyright © 2019 William Boles. All rights reserved.
//
//  Modified by Jonathan Xakellis on 2/5/21.
//

import NotificationBannerSwift
import SwiftMessages
import UIKit

enum PresentationManager {
    
    // MARK: - Properties
    
    /// A stack of UIViewControllers that represent the globalPresenter. If a UIViewController becomes eligible to present something, it pushes itself onto the stack. If it becomes ineligible, it removes itself from the stack.
    private static var globalPresenterStack: [UIViewController] = []
    static var lastFromGlobalPresenterStack: UIViewController? {
        return globalPresenterStack.last
    }
    
    /// The UIViewController that is presented by PresentationManager
    private static var currentPresentedViewController: UIViewController? {
        didSet {
            AppDelegate.generalLogger.notice("Current Presented ViewController is now \(self.currentPresentedViewController?.self.description ?? "none") and its presented on \(lastFromGlobalPresenterStack?.description ?? "none")")
            AppDelegate.generalLogger.notice("The globalPresenterStack is \(globalPresenterStack)")
        }
    }
    
    /// UIAlertController that indicates to the user that the app is currently retrieving information.
    private static let fetchingInformationAlertController: UIAlertController = {
        let fetchingInformationAlertController = UIAlertController(title: "Fetching Information...", message: nil, preferredStyle: .alert)
        let height = 95.0
        let centerXAnchorOffset = 0.0
        let bottomAnchorOffset = -20.0
        
        let fetchingActivityIndicator = UIActivityIndicatorView(style: .medium)
        fetchingActivityIndicator.translatesAutoresizingMaskIntoConstraints = false
        fetchingActivityIndicator.isUserInteractionEnabled = false
        fetchingActivityIndicator.startAnimating()
        fetchingInformationAlertController.view.addSubview(fetchingActivityIndicator)
        
        fetchingInformationAlertController.view.heightAnchor.constraint(equalToConstant: height).isActive = true
        fetchingActivityIndicator.centerXAnchor.constraint(equalTo: fetchingInformationAlertController.view.centerXAnchor, constant: centerXAnchorOffset).isActive = true
        fetchingActivityIndicator.bottomAnchor.constraint(equalTo: fetchingInformationAlertController.view.bottomAnchor, constant: bottomAnchorOffset).isActive = true
        return fetchingInformationAlertController
    }()
    
    // MARK: Public Global Presenter Management
    
    /// The presenter used for an alert. Sometimes we need to present an alert but the alert to be shown is called from a non UIAlertController class as that is not in the view heirarchy and physically cannot present a view, so this is used instead.
    static func addGlobalPresenterToStack(_ forViewController: UIViewController) {
        globalPresenterStack.removeAll { viewController in
            // Make sure the same instance isn't in our stack twice
            return viewController === forViewController
        }
        
        globalPresenterStack.append(forViewController)
        
        if let currentPresentedViewController = currentPresentedViewController, globalPresenterStack.contains(currentPresentedViewController) {
            // This fixes a logical anomoily. If a view controller is presented using PresentationManager, it will become the currentPresentedViewController. This is how we normally treated presented views. However, if this currentPresentedViewController is in the globalPresenterStack, it means it is able to present views itself and is eligible. Therefore, we should unlock the presentation stack by removing it as a currentPresentedViewController and continuing to the next item in the stack.
            self.currentPresentedViewController = nil
            presentNextViewController()
        }
    }
    
    static func removeGlobalPresenterFromStack(_ forViewController: UIViewController) {
        globalPresenterStack.removeAll { viewController in
            // Remove all matching instances of our global presenter
            return viewController === forViewController
        }
    }
    
    // MARK: - Static Public Enqueue
    
    /// Invokes enqueueAlert(fetchingInformationAlertController). This indicates to the user that the app is currently retrieving information. fetchingInformationAlertController stays until endFetchingInformationIndicator is called
    static func beginFetchingInformationIndicator() {
        enqueueAlert(fetchingInformationAlertController)
    }
    
    /// Dismisses fetchingInformationAlertController.
    static func endFetchingInformationIndicator(completionHandler: (() -> Void)?) {
        guard fetchingInformationAlertController.isBeingDismissed == false else {
            // We can't dismiss a fetchingInformationAlertController that is already being dismissed. Retry soon, so that completionHandler is invoked when fetchingInformationAlertController is fully dismissed
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                endFetchingInformationIndicator(completionHandler: completionHandler)
            }
            return
        }
        
        guard fetchingInformationAlertController.isBeingPresented == false else {
            // We can't dismiss a fetchingInformationAlertController that is already being presented currently. Retry soon, so that we can dismiss the view onces its presented
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                endFetchingInformationIndicator(completionHandler: completionHandler)
            }
            return
        }
        
        guard fetchingInformationAlertController.presentingViewController != nil else {
            // fetchingInformationAlertController isn't being dismissed and it has no presentingViewController, so it is not presented at all.
            viewControllerPresentationQueue.removeAll { viewController in
                // fetchingInformationAlertController hasn't been presented but it could be in the queue to be presented. Remove it so it can't be presented
                return viewController === fetchingInformationAlertController
            }
            completionHandler?()
            return
        }
        
        fetchingInformationAlertController.dismiss(animated: true) {
            completionHandler?()
        }
    }
    
    static func enqueueViewController(_ forViewController: UIViewController) {
        enqueue(forViewController)
    }
    
    static func enqueueBanner(forTitle title: String, forSubtitle subtitle: String?, forStyle: BannerStyle, onTap: (() -> Void)? = nil) {
        // Reduce the availble styles into a smaller 3 tier group
        // Success
        // Info
        // Danger
        let style: BannerStyle = {
            switch forStyle {
            case .success:
                return .success
            case .info:
                return .info
            case .danger:
                return .danger
            default:
                return .success
            }
        }()
        
        // Create a left view image that corresponds to the style selected
        let leftViewImage: GeneralUIImageView? = {
            var image: UIImage?
            switch style {
            case .success:
                image = UIImage.init(systemName: "checkmark.circle")
            case .info:
                image = UIImage.init(systemName: "info.circle")
            case .danger:
                image = UIImage.init(systemName: "exclamationmark.triangle")
            default:
                image = UIImage.init(systemName: "exclamationmark.triangle")
            }
            
            return image == nil ? nil : GeneralUIImageView(image: image)
        }()
        
        leftViewImage?.tintColor = .white
        
        let banner = FloatingNotificationBanner(title: title, subtitle: subtitle, leftView: leftViewImage, style: style)
        banner.contentMode = .scaleAspectFit
        banner.onTap = onTap
        
        // Select a haptic feedback that corresponds to the style. A more important style requires a heavier haptic
        banner.haptic = {
            switch style {
            case .success:
                return .light
            case .info:
                return .medium
            case .danger:
                return .heavy
            default:
                return .light
            }
        }()
        
        // Select a banner duration that corresponds to the style. A more important style requires a longer duration
        banner.duration = {
            // This is the duration for a title-only banner
            let successDuration = 1.25
            var bannerDuration = successDuration
            switch style {
            case .success:
                bannerDuration = successDuration
            case .info:
                bannerDuration = 4.5
            case .danger:
                bannerDuration = 2.25
            default:
                bannerDuration = successDuration
            }
            
            // If a non-nil and non-blank subtitle was provided, give the user extra reading time
            if let subtitle = subtitle, subtitle.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false {
                // The average person reads at 300 WPM, that is 5 words per second
                // The average word in one of these subtitle messages is 6 characters (excluding white spaces)
                // That the average person can read 30 non-whitespace characters a second, or 1 character per 0.033 seconds
                let subtitleCharacters = subtitle.filter { character in
                    character.isWhitespace == false
                }
                let extraSubtitleReadingTime = Double(subtitleCharacters.count) * 0.032
                
                bannerDuration += extraSubtitleReadingTime
            }
            return bannerDuration
        }()
        
        // Select a banner color that corresponds to the style
        banner.backgroundColor = {
            switch style {
            case .success:
                return .systemGreen
            case .info:
                return .systemBlue
            case .danger:
                return .systemRed
            default:
                return .systemGreen
            }
        }()
        
        banner.haptic = {
            switch style {
            case .success:
                return .medium
            case .info:
                return .light
            case .danger:
                return .heavy
            default:
                return .medium
            }
        }()
        
        banner.show(
            // using default queuePosition: ,
            // using default bannerPosition: ,
            // using default queue: ,
            on: PresentationManager.globalPresenterStack.last,
            // If the globalPresenter's top safeAreaInset is not zero, that mean we have to adjust the banner for the safe area for the notch on the top of the screen. This means we need to artifically adjust the banner further down.
            edgeInsets: (PresentationManager.globalPresenterStack.last?.view.safeAreaInsets.top ?? 0.0) == 0.0
            ? UIEdgeInsets(top: -15.0, left: 10.0, bottom: 10.0, right: 10.0)
            : UIEdgeInsets(top: 15.0, left: 10.0, bottom: 10.0, right: 10.0),
            cornerRadius: VisualConstant.LayerConstant.defaultCornerRadius,
            shadowColor: UIColor.label,
            shadowOpacity: 0.5,
            shadowBlurRadius: 15.0,
            // little/no effect shadowCornerRadius: 10.0,
            // using default shadowOffset: ,
            shadowEdgeInsets: .zero
        )
    }
    
    static func enqueueAlert(_ forAlertController: UIAlertController) {
        // We are unable to change .preferredStyle and if its not .alert (and we queue the alert) then we could crash
        guard forAlertController.preferredStyle == .alert else {
            return
        }
        
        enqueue(forAlertController)
    }
    
    static func enqueueActionSheet(_ forAlertController: UIAlertController, sourceView: UIView) {
        // We are unable to change .preferredStyle and if its not .actionSheet (and we queue the alert) then we could crash
        guard forAlertController.preferredStyle == .actionSheet else {
            return
        }
        
        // This is needed for iPad, otherwise it will crash
        if UIDevice.current.userInterfaceIdiom == .pad {
            forAlertController.popoverPresentationController?.sourceView = sourceView
            forAlertController.popoverPresentationController?.sourceRect = sourceView.bounds
            forAlertController.popoverPresentationController?.permittedArrowDirections = [.up, .down]
        }
        
        enqueue(forAlertController)
    }
    
    // MARK: - Private Internal Queue

    private static var viewControllerPresentationQueue: [UIViewController] = []
    
    private static func enqueue(_ forViewController: UIViewController) {
        // Make sure that the alertController that is being queued isn't already presented or in the queue
        guard currentPresentedViewController !== forViewController && viewControllerPresentationQueue.contains(where: { viewController in
            return viewController === forViewController
        }) == false else {
            // Don't call presentNextViewController() as queue didn't change
            return
        }
        
        guard let forAlarmAlertController = forViewController as? AlarmUIAlertController else {
            // Not dealing with an forAlarmAlertController, can append alertController to queue
            viewControllerPresentationQueue.append(forViewController)
            presentNextViewController()
            return
        }
        
        // User attempted to pass an AlarmUIAlertController that hasn't been setup and is therefore invalid
        guard forAlarmAlertController.dogUUID != nil && forAlarmAlertController.reminders != nil else {
            // Don't call presentNextViewController() as queue didn't change
            return
        }
        
        // If we are dealing with an AlarmUIAlertController, then attempt to absorb it into the currentPresentedViewController.
        if let presentedAlarmAlertController = (currentPresentedViewController as? AlarmUIAlertController), presentedAlarmAlertController.absorb(forAlarmAlertController) {
            // currentPresentedViewController is an AlarmUIAlertController and we were able to absorb forAlarmAlertController into it. Therefore, discard forAlarmAlertController.
            // Don't call presentNextViewController() as queue didn't change
            return
        }
        
        // forAlarmAlertController couldn't be absorbed into currentPresentedViewController, therefore try absorbing it into other items in queue.
        for viewControllerInQueue in viewControllerPresentationQueue {
            guard let alarmAlertControllerInQueue = viewControllerInQueue as? AlarmUIAlertController else {
                // viewControllerInQueue isn't an AlarmUIAlertController and cannot absorb anything. or it is but wasn't able to be combined with forAlarmAlertController
                continue
            }
            
            guard alarmAlertControllerInQueue.absorb(forAlarmAlertController) else {
                // alarmAlertControllerInQueue wasn't able to absorb forAlarmAlertController
                continue
            }
            
            // alarmAlertControllerInQueue was able to successfully absorb forAlarmAlertController. Discard forAlarmAlertController
            // Don't call presentNextViewController() as queue didn't change
            return
        }
        
        // Couldn't absorb forAlarmAlertController with any pre-existing ViewController, therefore append it to queue
        viewControllerPresentationQueue.append(forAlarmAlertController)
        presentNextViewController()
    }
    
    private static func presentNextViewController() {
        // Check that PresentationManager itself is eligible to present another alert. This means the queue has another controller to present and there isn't a ViewController currently presented
        guard let nextPresentedViewController = viewControllerPresentationQueue.first, self.currentPresentedViewController == nil else {
            return
        }
        
        // Check that the globalPresenter can present sometime currently. If not, enter a loop until it can. These temporary conditions normally resolve themselves.
        guard let globalPresenter = PresentationManager.globalPresenterStack.last,
              globalPresenter.isBeingPresented == false,
              globalPresenter.isBeingDismissed == false,
              globalPresenter.presentedViewController == nil,
              globalPresenter.viewIfLoaded?.window != nil else {
            
            AppDelegate.generalLogger.info("\nUnable to presentNextViewController, trying again soon")
            AppDelegate.generalLogger.info("globalPresenter \(PresentationManager.globalPresenterStack.last)")
            AppDelegate.generalLogger.info("globalPresenter.isBeingPresented \(PresentationManager.globalPresenterStack.last?.isBeingPresented == true)")
            AppDelegate.generalLogger.info("globalPresenter.isBeingDismissed \(PresentationManager.globalPresenterStack.last?.isBeingDismissed == true)")
            AppDelegate.generalLogger.info("globalPresenter.presentedViewController \(PresentationManager.globalPresenterStack.last?.presentedViewController)")
            AppDelegate.generalLogger.info("globalPresenter.hasViewIfLoaded.window \(PresentationManager.globalPresenterStack.last?.viewIfLoaded?.window)\n")
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                self.presentNextViewController()
            }
            return
        }
        
        viewControllerPresentationQueue.removeFirst()
        self.currentPresentedViewController = nextPresentedViewController
        
        globalPresenter.present(nextPresentedViewController, animated: true)
        
        self.observeCurrentPresentedViewControllerIsBeingDismissed(previousIsBeingDismissed: nextPresentedViewController.isBeingDismissed)
    }
    
    /// currentPresentedViewController.isBeingDismissed is not KVO compliant. Therefore, we must perform a loop that continuously checks the property. Once the previousIsBeingDismissed is true and the current is false, we know the view has completed
    private static func observeCurrentPresentedViewControllerIsBeingDismissed(previousIsBeingDismissed: Bool) {
        guard let currentPresentedViewController = currentPresentedViewController else {
            return
        }
        
        let currentIsBeingDismissed = currentPresentedViewController.isBeingDismissed
        
        guard currentPresentedViewController.isBeingPresented == false else {
            // If currentPresentedViewController is still in the process of being presented, we cannot analyze it to see if its being dismissed,
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                self.observeCurrentPresentedViewControllerIsBeingDismissed(previousIsBeingDismissed: currentIsBeingDismissed)
            }
            return
        }
        
        guard previousIsBeingDismissed == true && currentIsBeingDismissed == false else {
            // The currentPresentedViewController has not been dismissed. Keep rechecking until it has been.
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                self.observeCurrentPresentedViewControllerIsBeingDismissed(previousIsBeingDismissed: currentIsBeingDismissed)
            }
            return
        }
        
        // If currentPresentedViewController was being dismissed and now its not (indicating it was dismissed), then it is no longer the currentPresentedViewController
        // If currentPresentedViewController has no presentingViewController (indicating it was never presented), then it is no longer the currentPresentedViewController
        
        // If there are any copies of the dismissed VC in the queue, remove them
        viewControllerPresentationQueue.removeAll { viewController in
            return self.currentPresentedViewController === viewController
        }
        
        self.currentPresentedViewController = nil
        presentNextViewController()
    }
}
//
//  MeasurementSystem.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum MeasurementSystem: Int, CaseIterable {
    
    init?(rawValue: Int) {
        for system in MeasurementSystem.allCases where system.rawValue == rawValue {
            self = system
            return
        }
        
        return nil
    }
    
    case imperial = 0
    case metric = 1
    case both = 2
    
    func readableMeasurementSystem() -> String {
        switch self {
        case .imperial:
            return "Imperial"
        case .metric:
            return "Metric"
        case .both:
            return "Both"
        }
    }
    
}
//
//  Reminder Action.swift
//  Hound
//
//  Created by Jonathan Xakellis on 9/27/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum ReminderAction: CaseIterable, Comparable {
    
    // MARK: - Comparable
    
    static func < (lhs: ReminderAction, rhs: ReminderAction) -> Bool {
        let lhsIndex = ReminderAction.allCases.firstIndex(of: lhs) ?? .max
        let rhsIndex = ReminderAction.allCases.firstIndex(of: rhs) ?? .max
        
        return lhsIndex <= rhsIndex
    }
    
    // MARK: - Main

    init?(internalValue: String) {
        // <= 3.1.0 other names used, compare to readableValue as well
        for action in ReminderAction.allCases where action.internalValue == internalValue || action.readableValue == internalValue {
            self = action
            return
        }
        
        return nil
    }
    
    // common
    case feed
    case water
    case potty
    case walk
    // next common
    case brush
    case bathe
    case medicine

    // more common than previous but probably used less by user as weird action
    case sleep
    case trainingSession
    case doctor

    case custom
    
    /// The standardized, internal readable value that corresponds to each case, e.g. "feed" for .feed
    var internalValue: String {
        switch self {
        case .feed:
            return LogAndReminderActionConstant.InternalValue.feed.rawValue
        case .water:
            return LogAndReminderActionConstant.InternalValue.water.rawValue
        case .potty:
            return LogAndReminderActionConstant.InternalValue.potty.rawValue
        case .walk:
            return LogAndReminderActionConstant.InternalValue.walk.rawValue
        case .brush:
            return LogAndReminderActionConstant.InternalValue.brush.rawValue
        case .bathe:
            return LogAndReminderActionConstant.InternalValue.bathe.rawValue
        case .medicine:
            return LogAndReminderActionConstant.InternalValue.medicine.rawValue
        case .sleep:
            return LogAndReminderActionConstant.InternalValue.sleep.rawValue
        case .trainingSession:
            return LogAndReminderActionConstant.InternalValue.trainingSession.rawValue
        case .doctor:
            return LogAndReminderActionConstant.InternalValue.doctor.rawValue
        case .custom:
            return LogAndReminderActionConstant.InternalValue.custom.rawValue
        }
    }
    
    /// The readable value that corresponds to each case, e.g. "Feed" for .feed
    var readableValue: String {
        switch self {
        case .feed:
            return LogAndReminderActionConstant.ReadableValue.feed.rawValue
        case .water:
            return LogAndReminderActionConstant.ReadableValue.water.rawValue
        case .potty:
            return LogAndReminderActionConstant.ReadableValue.potty.rawValue
        case .walk:
            return LogAndReminderActionConstant.ReadableValue.walk.rawValue
        case .brush:
            return LogAndReminderActionConstant.ReadableValue.brush.rawValue
        case .bathe:
            return LogAndReminderActionConstant.ReadableValue.bathe.rawValue
        case .medicine:
            return LogAndReminderActionConstant.ReadableValue.medicine.rawValue
        case .sleep:
            return LogAndReminderActionConstant.ReadableValue.sleep.rawValue
        case .trainingSession:
            return LogAndReminderActionConstant.ReadableValue.trainingSession.rawValue
        case .doctor:
            return LogAndReminderActionConstant.ReadableValue.doctor.rawValue
        case .custom:
            return LogAndReminderActionConstant.ReadableValue.custom.rawValue
        }
    }
    
    /// The readable emoji that corresponds to each case, e.g. 🍗 for .feed
    var readableEmoji: String {
        switch self {
        case .feed:
            return LogAndReminderActionConstant.ReadableEmoji.feed.rawValue
        case .water:
            return LogAndReminderActionConstant.ReadableEmoji.water.rawValue
        case .potty:
            return LogAndReminderActionConstant.ReadableEmoji.potty.rawValue
        case .walk:
            return LogAndReminderActionConstant.ReadableEmoji.walk.rawValue
        case .brush:
            return LogAndReminderActionConstant.ReadableEmoji.brush.rawValue
        case .bathe:
            return LogAndReminderActionConstant.ReadableEmoji.bathe.rawValue
        case .medicine:
            return LogAndReminderActionConstant.ReadableEmoji.medicine.rawValue
        case .sleep:
            return LogAndReminderActionConstant.ReadableEmoji.sleep.rawValue
        case .trainingSession:
            return LogAndReminderActionConstant.ReadableEmoji.trainingSession.rawValue
        case .doctor:
            return LogAndReminderActionConstant.ReadableEmoji.doctor.rawValue
        case .custom:
            return LogAndReminderActionConstant.ReadableEmoji.custom.rawValue
        }
    }

    /// Returns the name of the current reminderAction with an appropiate emoji appended. If non-nil, non-"" reminderCustomActionName is provided, then then that is returned, e.g. fullReadableName(nil, valueDoesNotMatter) -> 'Feed 🍗'; fullReadableName(nil, valueDoesNotMatter) -> 'Custom 📝'; fullReadableName('someCustomName', true) -> 'someCustomName'; fullReadableName('someCustomName', false) -> 'Custom 📝: someCustomName'
    func fullReadableName(reminderCustomActionName: String?, includeMatchingEmoji: Bool = true) -> String {
        let fullReadableNameWithoutEmoji: String = {
            guard self == .medicine || self == .custom else {
                return self.readableValue
            }
            
            if let reminderCustomActionName = reminderCustomActionName, reminderCustomActionName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false {
                return reminderCustomActionName
            }
            
            return self.readableValue
        }()
        
        return includeMatchingEmoji ? fullReadableNameWithoutEmoji.appending(" \(self.readableEmoji)") : fullReadableNameWithoutEmoji
    }

}
//
//  Time Quick Select.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/17/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum TimeQuickSelectOptions: String, CaseIterable {
    case custom = "Custom"
    case now = "Now"
    case fiveMinsAgo = "5 mins ago"
    case fifteenMinsAgo = "15 mins ago"
    case thirtyMinsAgo = "30 mins ago"
    case oneHourAgo = "1 hr ago"
    case twoHoursAgo = "2 hrs ago"
    case fourHoursAgo = "4 hrs ago"
    case eightHoursAgo = "8 hrs ago"
    
    /// Given a forReferenceDate, finds all of the TimeQuickSelectOptions where startingPoint + valueInSeconds is < occurringOnOrBefore
    static func optionsOccurringBeforeDate(startingPoint: Date, occurringOnOrBefore: Date) -> [TimeQuickSelectOptions] {
        return TimeQuickSelectOptions.allCases.filter { timeQuickSelectOption in
            guard let valueInSeconds = timeQuickSelectOption.valueInSeconds() else {
                // If timeQuickSelectOption has no valueInSeconds, then assume it is a valid option (e.g. .custom)
                return true
            }
            
            // Important that this is a <= comparision. If you provide Date() for startingPoint and occurringOnOrBefore, then it isn't deterministic. Sometimes the Dates()s are the exact same, and sometimes they are off by a few microseconds.
            return startingPoint.addingTimeInterval(valueInSeconds) <= occurringOnOrBefore
        }
    }
    
    /// Given a forReferenceDate, finds all of the TimeQuickSelectOptions where startingPoint + valueInSeconds is > occurringOnOrBefore
    static func optionsOccurringAfterDate(startingPoint: Date, occurringOnOrAfter: Date) -> [TimeQuickSelectOptions] {
        return TimeQuickSelectOptions.allCases.filter { timeQuickSelectOption in
            guard let valueInSeconds = timeQuickSelectOption.valueInSeconds() else {
                // If timeQuickSelectOption has no valueInSeconds, then assume it is a valid option (e.g. .custom)
                return true
            }
            
            // Important that this is a >= comparision. If you provide Date() for startingPoint and occurringOnOrAfter, then it isn't deterministic. Sometimes the Dates()s are the exact same, and sometimes they are off by a few microseconds.
            return startingPoint.addingTimeInterval(valueInSeconds) >= occurringOnOrAfter
        }
    }
    
    /// Returns how many seconds ago the TimeQuickSelectOptions represents. .now represents 0.0 seconds ago, .fiveMinsAgo represents -300.0 seconds ago, and .custom represents nil
    func valueInSeconds() -> Double? {
        switch self {
        case .now:
            return -1.0 * 0.0
        case .fiveMinsAgo:
            return -1.0 * 60.0 * 5.0
        case .fifteenMinsAgo:
            return -1.0 * 60.0 * 15.0
        case .thirtyMinsAgo:
            return -1.0 * 60.0 * 30.0
        case .oneHourAgo:
            return -1.0 * 60.0 * 60.0 * 1.0
        case .twoHoursAgo:
            return -1.0 * 60.0 * 60.0 * 2.0
        case .fourHoursAgo:
            return -1.0 * 60.0 * 60.0 * 4.0
        case .eightHoursAgo:
            return -1.0 * 60.0 * 60.0 * 8.0
        case .custom:
            return nil
        }
    }
}
//
//  SubscriptionCancellationReason.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/28/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum SubscriptionCancellationReason: CaseIterable {
    
    case tooExpensive
    case lackingKeyFeatures
    case foundBetterAlternative
    case puppyOutgrewApp
    case notUseful
    case tooManyBugs
    case updateMadeThingsWorse
    case somethingElse
    
    /// The standardized, internal readable value that corresponds to each case, e.g. "tooExpensive" for .tooExpensive
    var internalValue: String {
        switch self {
        case .tooExpensive:
            return "tooExpensive"
        case .lackingKeyFeatures:
            return "lackingKeyFeatures"
        case .foundBetterAlternative:
            return "foundBetterAlternative"
        case .puppyOutgrewApp:
            return "puppyOutgrewApp"
        case .notUseful:
            return "notUseful"
        case .tooManyBugs:
            return "tooManyBugs"
        case .updateMadeThingsWorse:
            return "updateMadeThingsWorse"
        case .somethingElse:
            return "somethingElse"
        }
    }
    
    /// The readable value that corresponds to each case, e.g. "Too Expensive 💸" for .tooExpensive
    var readableValue: String {
        switch self {
        case .tooExpensive:
            return "Too Expensive 💸"
        case .lackingKeyFeatures:
            return "Lacking Key Features 🛠️"
        case .foundBetterAlternative:
            return "Found Better Alternative 📱"
        case .puppyOutgrewApp:
            return "Puppy Outgrew App 🐕"
        case .notUseful:
            return "Not Useful 👎"
        case .tooManyBugs:
            return "Too Many Bugs 🪲"
        case .updateMadeThingsWorse:
            return "Update Made Things Worse 💻"
        case .somethingElse:
            return "Something Else 📝"
        }
    }
    
}
//
//  HoundError.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/22/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ErrorConstant {

    static func serverError(forErrorCode errorCode: String, forRequestId requestId: Int, forResponseId responseId: Int) -> HoundServerError? {
        // TODO FUTURE Make these errors more dynamic. If an error cannot be matched, construct a custom message. This should pull all available info from the error returned by the server.
        // MARK: - GENERAL
        if errorCode == "ER_GENERAL_APP_VERSION_OUTDATED" {
            return GeneralResponseError.appVersionOutdated(forRequestId: requestId, forResponseId: responseId)
        }
        // ER_GENERAL_ENVIRONMENT_INVALID
        // ER_GENERAL_PARSE_FORM_DATA_FAILED
        // ER_GENERAL_PARSE_JSON_FAILED
        // ER_GENERAL_POOL_CONNECTION_FAILED
        // ER_GENERAL_POOL_TRANSACTION_FAILED
        else if errorCode == "ER_GENERAL_APPLE_SERVER_FAILED" {
            return GeneralResponseError.appleServerFailed(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_RATE_LIMIT_EXCEEDED" {
            return GeneralResponseError.rateLimitExceeded(forRequestId: requestId, forResponseId: responseId)
        }
        // MARK: - VALUE
        // ER_VALUE_MISSING
        // ER_VALUE_INVALID
        // MARK: - PERMISSION
        // MARK: NO
        else if errorCode == "ER_PERMISSION_NO_USER" {
            return PermissionResponseError.noUser(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_FAMILY" {
            return PermissionResponseError.noFamily(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_DOG" {
            return PermissionResponseError.noDog(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_LOG" {
            return PermissionResponseError.noLog(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_REMINDER" {
            return PermissionResponseError.noReminder(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_PERMISSION_NO_TRIGGER" {
            return PermissionResponseError.noTrigger(forRequestId: requestId, forResponseId: responseId)
        }
        // MARK: INVALID
        else if errorCode == "ER_PERMISSION_INVALID_FAMILY" {
            return PermissionResponseError.invalidFamily(forRequestId: requestId, forResponseId: responseId)
        }
        // MARK: - FAMILY
        // MARK: LIMIT
        else if errorCode == "ER_FAMILY_LIMIT_FAMILY_MEMBER_TOO_LOW" {
            return FamilyResponseError.limitFamilyMemberTooLow(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_DOG_TOO_LOW" {
            return FamilyResponseError.limitDogTooLow(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_LOG_TOO_LOW" {
            return FamilyResponseError.limitLogTooLow(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_REMINDER_TOO_LOW" {
            return FamilyResponseError.limitReminderTooLow(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_TRIGGER_TOO_LOW" {
            return FamilyResponseError.limitTriggerTooLow(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LIMIT_FAMILY_MEMBER_EXCEEDED" {
            return FamilyResponseError.limitFamilyMemberExceeded(forRequestId: requestId, forResponseId: responseId)
        }
        // MARK: DELETED
        else if errorCode == "ER_FAMILY_DELETED_DOG" {
            return FamilyResponseError.deletedDog(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_DELETED_LOG" {
            return FamilyResponseError.deletedLog(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_DELETED_REMINDER" {
            return FamilyResponseError.deletedReminder(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_DELETED_TRIGGER" {
            return FamilyResponseError.deletedTrigger(forRequestId: requestId, forResponseId: responseId)
        }
        // MARK: JOIN
        else if errorCode == "ER_FAMILY_JOIN_FAMILY_CODE_INVALID" {
            return FamilyResponseError.joinFamilyCodeInvalid(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_JOIN_FAMILY_LOCKED" {
            return FamilyResponseError.joinFamilyLocked(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_JOIN_IN_FAMILY_ALREADY" {
            return FamilyResponseError.joinInFamilyAlready(forRequestId: requestId, forResponseId: responseId)
        }
        // MARK: Leave
        else if errorCode == "ER_FAMILY_LEAVE_SUBSCRIPTION_ACTIVE" {
            return FamilyResponseError.leaveSubscriptionActive(forRequestId: requestId, forResponseId: responseId)
        }
        else if errorCode == "ER_FAMILY_LEAVE_STILL_FAMILY_MEMBERS" {
            return FamilyResponseError.leaveStillFamilyMembers(forRequestId: requestId, forResponseId: responseId)
        }
        // MARK: - NONE
        return nil
    }

    // MARK: - Text Constants

    private static let contactHoundSupport: String = "If the issue persists, please contact Hound support."
    private static let restartHoundAndRetry: String = "If the issue persists, please restart and retry."
    private static let potentialHoundServerOutage: String = "If the issue persists, Hound's server may be experiencing an outage."
    private static let verifyInternetConnection: String = "Please verify that you are connected to the internet and retry."
    private static let tryShorterOne: String = "Please try a shorter one."
    private static let enterValidCode: String = "Please enter in a valid code and retry."

    // MARK: - API Request

    enum GeneralRequestError {
        static func noInternetConnection() -> HoundError {
            HoundError(
                forName: "GeneralRequestError.noInternetConnection",
                forDescription: "Your device doesn't appear to be connected to the internet. \(ErrorConstant.verifyInternetConnection)",
                forOnTap: nil)
        }
    }

    enum FamilyRequestError {
        static func familyCodeBlank() -> HoundError {
            HoundError(
                forName: "FamilyRequestError.familyCodeBlank",
                forDescription: "Your family code is blank! \(ErrorConstant.enterValidCode)",
                forOnTap: nil)
        }
        static func familyCodeInvalid() -> HoundError {
            HoundError(
                forName: "FamilyRequestError.familyCodeInvalid",
                forDescription: "Your family code's format is invalid! \(ErrorConstant.enterValidCode)",
                forOnTap: nil)
        }
    }

    // MARK: - API Response

    enum GeneralResponseError {
        /// The app version that the user is using is out dated
        static func appVersionOutdated(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "GeneralResponseError.appVersionOutdated",
                forDescription: "It looks like you're using an outdated version of Hound. Update now for the latest features and improvements!",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func appleServerFailed(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "GeneralResponseError.appleServerFailed",
                forDescription: "Hound was unable to contact Apple's iTunes server and complete your request. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func rateLimitExceeded(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "GeneralResponseError.rateLimitExceeded",
                forDescription: "You have exceeded Hound's rate limit. Please wait 10 seconds before retrying your request.",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        
        /// GET: != 200...299, e.g. 400, 404, 500
        static func getFailureResponse(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "GeneralResponseError.getFailureResponse",
                forDescription: "We experienced an issue while retrieving your data Hound's server. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }

        /// GET: Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
        static func getNoResponse() -> HoundError {
            HoundError(
                forName: "GeneralResponseError.getNoResponse",
                forDescription: "We were unable to reach Hound's server and retrieve your data. \(ErrorConstant.verifyInternetConnection) \(ErrorConstant.potentialHoundServerOutage)",
                forOnTap: nil)
        }

        /// CREATE/POST:  != 200...299, e.g. 400, 404, 500
        static func postFailureResponse(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "GeneralResponseError.postFailureResponse",
                forDescription: "Hound's server experienced an issue in saving your new data. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        /// CREATE/POST: Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
        static func postNoResponse() -> HoundError {
            HoundError(
                forName: "GeneralResponseError.postNoResponse",
                forDescription: "We were unable to reach Hound's server and save your new data. \(ErrorConstant.verifyInternetConnection) \(ErrorConstant.potentialHoundServerOutage)",
                forOnTap: nil)
        }

        /// UPDATE/PUT:  != 200...299, e.g. 400, 404, 500
        static func putFailureResponse(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "GeneralResponseError.putFailureResponse",
                forDescription: "Hound's server experienced an issue in updating your data. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        /// UPDATE/PUT: Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
        static func putNoResponse() -> HoundError {
            HoundError(
                forName: "GeneralResponseError.putNoResponse",
                forDescription: "We were unable to reach Hound's server and update your data. \(ErrorConstant.verifyInternetConnection) \(ErrorConstant.potentialHoundServerOutage)",
                forOnTap: nil)
        }

        /// DELETE:  != 200...299, e.g. 400, 404, 500
        static func deleteFailureResponse(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "GeneralResponseError.deleteFailureResponse",
                forDescription: "Hound's server experienced an issue in deleting your data. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        /// DELETE: Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
        static func deleteNoResponse() -> HoundError {
            HoundError(
                forName: "GeneralResponseError.deleteNoResponse",
                forDescription: "We were unable to reach Hound's server to delete your data. \(ErrorConstant.verifyInternetConnection) \(ErrorConstant.potentialHoundServerOutage)",
                forOnTap: nil)
        }
    }

    enum PermissionResponseError {
        static func noUser(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "PermissionResponseError.noUser",
                forDescription: "You are attempting to access a user that doesn't exist or you don't have permission to. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func noFamily(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "PermissionResponseError.noFamily",
                forDescription: "You are attempting to access a family that doesn't exist or you don't have permission to. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func noDog(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "PermissionResponseError.noDog",
                forDescription: "You are attempting to access a dog that doesn't exist or you don't have permission to. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func noLog(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "PermissionResponseError.noLog",
                forDescription: "You are attempting to access a log that doesn't exist or you don't have permission to. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func noReminder(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "PermissionResponseError.noReminder",
                forDescription: "You are attempting to access a reminder that doesn't exist or you don't have permission to. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func noTrigger(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "PermissionResponseError.noTrigger",
                forDescription: "You are attempting to access a trigger that doesn't exist or you don't have permission to. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }

        static func invalidFamily(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "PermissionResponseError.invalidFamily",
                forDescription: "You are attempting to perform an action that only the family head can perform. Please contact the family head and have them complete this action. \(ErrorConstant.contactHoundSupport)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
    }

    enum FamilyResponseError {
        // MARK: Limit
        // Too Low
        static func  limitFamilyMemberTooLow(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "FamilyResponseError.limitFamilyMemberTooLow",
                // DON'T MAKE THIS MESSAGE DYNAMIC. User is attempting to join a family but failed, therefore familyActiveSubscription will be inaccurate as user currently has no family.
                forDescription: "This family can only have a limited number of family members! Please have the family head upgrade their subscription before attempting to join this family.",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func  limitDogTooLow(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            // spell out the number of dogs the family can have
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let dogLimitSpelledOut = formatter.string(from: ClassConstant.DogConstant.maximumNumberOfDogs as NSNumber) ?? "negative one"

            return HoundServerError(
                forName: "FamilyResponseError.limitDogTooLow",
                forDescription: "Your family can only have \(dogLimitSpelledOut) dog\(ClassConstant.DogConstant.maximumNumberOfDogs == 1 ? "" : "s")! Please remove an existing dog before trying to add a new one.",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func  limitLogTooLow(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            // spell out the number of logs a dog can have
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let logLimitSpelledOut = formatter.string(from: ClassConstant.DogConstant.maximumNumberOfLogs as NSNumber) ?? "negative one"

            return HoundServerError(
                forName: "FamilyResponseError.limitLogTooLow",
                forDescription: "Your dog can only have \(logLimitSpelledOut) log\(ClassConstant.DogConstant.maximumNumberOfLogs == 1 ? "" : "s")! Please remove an existing log before trying to add a new one.",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func  limitReminderTooLow(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            // spell out the number of logs a dog can have
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let reminderLimitSpelledOut = formatter.string(from: ClassConstant.DogConstant.maximumNumberOfReminders as NSNumber) ?? "negative one"

            return HoundServerError(
                forName: "FamilyResponseError.limitReminderTooLow",
                forDescription: "Your dog can only have \(reminderLimitSpelledOut) reminder\(ClassConstant.DogConstant.maximumNumberOfReminders == 1 ? "" : "s")! Please remove an existing reminder before trying to add a new one.",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func  limitTriggerTooLow(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            // spell out the number of logs a dog can have
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let triggerLimitSpelledOut = formatter.string(from: ClassConstant.DogConstant.maximumNumberOfTriggers as NSNumber) ?? "negative one"

            return HoundServerError(
                forName: "FamilyResponseError.limitTriggerTooLow",
                forDescription: "Your dog can only have \(triggerLimitSpelledOut) trigger\(ClassConstant.DogConstant.maximumNumberOfTriggers == 1 ? "" : "s")! Please remove an existing trigger before trying to add a new one.",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }

        // Exceeded
        static func limitFamilyMemberExceeded(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            // find out how many family members can be in the family
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            let allowedNumberOfFamilyMembers = FamilyInformation.familyActiveSubscription.numberOfFamilyMembers
            let familyMemberLimitSpelledOut = formatter.string(from: allowedNumberOfFamilyMembers as NSNumber) ?? "\(allowedNumberOfFamilyMembers)"

            let numberOfExceededFamilyMembers = FamilyInformation.familyMembers.count - allowedNumberOfFamilyMembers
            let numberOfExceededFamilyMembersSpelledOut = formatter.string(
                from: numberOfExceededFamilyMembers as NSNumber) ?? "\(numberOfExceededFamilyMembers)"

            // user could be family head or they could be a family member
            var description = "Your family is exceeding it's \(familyMemberLimitSpelledOut) family member limit and is unable to have data added or updated. "

            description.append("To restore functionality, please ")

            if UserInformation.isUserFamilyHead == false {
                description.append("have the family head ")
            }

            if numberOfExceededFamilyMembers >= 1 {
                description.append("remove \(numberOfExceededFamilyMembersSpelledOut) family member\(numberOfExceededFamilyMembers == 1 ? "" : "s") or ")
            }
            
            description.append("upgrade your subscription.")
            
            return HoundServerError(
                forName: "FamilyResponseError.limitFamilyMemberExceeded",
                forDescription: description,
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }

        // MARK: Deleted
        /// The dog that the user is trying to access has been marked as deleted
        static func deletedDog(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "FamilyResponseError.deletedDog",
                forDescription: "The dog you are attempting to access has been deleted! Hold on while we refresh your data...",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        /// The log that the user is trying to access has been marked as deleted
        static func deletedLog(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "FamilyResponseError.deletedLog",
                forDescription: "The log you are attempting to access has been deleted! Hold on while we refresh your data...",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        /// The reminder that the user is trying to access has been marked as deleted
        static func deletedReminder(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "FamilyResponseError.deletedReminder",
                forDescription: "The reminder you are attempting to access has been deleted! Hold on while we refresh your data...",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        /// The trigger that the user is trying to access has been marked as deleted
        static func deletedTrigger(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "FamilyResponseError.deletedTrigger",
                forDescription: "The trigger you are attempting to access has been deleted! Hold on while we refresh your data...",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }

        // MARK: Join
        /// Family code was valid but was not linked to any family
        static func joinFamilyCodeInvalid(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "FamilyResponseError.joinFamilyCodeInvalid",
                forDescription: "The family code you input isn't linked to any family. \(ErrorConstant.enterValidCode)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        /// Family code was valid and linked to a family but the family was locked
        static func  joinFamilyLocked(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "FamilyResponseError.joinFamilyLocked",
                forDescription: "The family you are trying to join is locked, preventing any new family members from joining. Please have an existing family member unlock it and retry.",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        /// User is already in a family and therefore can't join a new one
        static func  joinInFamilyAlready(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "FamilyResponseError.joinInFamilyAlready",
                forDescription: "You are already in a family. Please leave your existing family before attempting to join a new one. \(ErrorConstant.contactHoundSupport)",
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }

        // MARK: Leave
        static func  leaveSubscriptionActive(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            HoundServerError(
                forName: "FamilyResponseError.leaveSubscriptionActive",
                forDescription: "You are unable to delete your current family due having an active, auto-renewing subscription. To continue, tap this banner to cancel your subscription. \(ErrorConstant.contactHoundSupport)",
                forOnTap: {
                    // If the user taps the banner, that means they want to cancel their Hound subscription. The only way to cancel a subscription is with Apple's manage subscriptions page.
                    InAppPurchaseManager.showManageSubscriptions()
                },
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
        static func  leaveStillFamilyMembers(forRequestId: Int, forResponseId: Int) -> HoundServerError {
            // if user is family head, then add piece about removing other family members. this error shouldn't happen if the user isn't the family head, and therefore we direct them more toward hound support
            var description = "You are unable to leave your current family. "
            if UserInformation.isUserFamilyHead {
                description.append("Please remove all existing family members before attempting to leave. ")
            }
            description.append("\(ErrorConstant.contactHoundSupport)")

            return HoundServerError(
                forName: "FamilyResponseError.leaveStillFamilyMembers",
                forDescription: description,
                forOnTap: nil,
                forRequestId: forRequestId,
                forResponseId: forResponseId
            )
        }
    }

    // MARK: - Class

    enum InAppPurchaseError {
        // MARK: Product Request Of Available In-App Purchases
        static func productRequestInProgress() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.productRequestInProgress",
                forDescription: "There is a in-app purchase product request currently in progress. You are unable to initiate another in-app purchase product request until the first one has finished processing. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }
        /// The app cannot request App Store about available IAP products for some reason.
        static func productRequestFailed() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.productRequestFailed",
                forDescription: "Your in-app purchase product request has failed. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }
        /// No in-app purchase products were returned by the App Store because none was found.
        static func productRequestNotFound() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.productRequestNotFound",
                forDescription: "Your in-app purchase product request did not return any results. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }

        // MARK: User Attempting To Make An In-App Purchase
        /// User can't make any in-app purchase because SKPaymentQueue.canMakePayment() == false
        static func purchaseRestricted() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.purchaseRestricted",
                forDescription: "Your device is restricted from accessing the Apple App Store and is unable to make in-app purchases. Please remove this restriction before attempting to make another in-app purchase.",
                forOnTap: nil)
        }

        /// User can't make any in-app purchase because they are not the family head
        static func purchasePermission() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.purchasePermission",
                forDescription: "You are attempting to perform an action that only the family head can perform. Please contact the family head and have them complete this action. \(ErrorConstant.contactHoundSupport)",
                forOnTap: nil)
        }

        /// There is a in-app purchases in progress, so a new one cannot be initiated currentProductPurchase != nil || productPurchaseCompletionHandler != nil
        static func purchaseInProgress() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.purchaseInProgress",
                forDescription: "There is an in-app purchase currently in progress. You are unable to initiate another in-app purchase until the first one has finished processing. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }

        /// Deferred. Most likely due to pending parent approval from Ask to Buy
        static func purchaseDeferred() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.purchaseDeferred",
                forDescription: "Your in-app purchase is pending an approval from your parent. To complete your purchase, please have your parent approve the request within 24 hours.",
                forOnTap: nil)
        }

        /// The in app purchase failed and was not completed
        static func purchaseFailed() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.purchaseFailed",
                forDescription: "Your in-app purchase has failed. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }

        /// Unknown error
        static func purchaseUnknown() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.purchaseUnknown",
                forDescription: "Your in-app purchase has experienced an unknown error. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }

        // MARK: User Attempting To Restore An In-App Purchase

        /// User can't make any in-app purchase restoration because they are not the family head
        static func restorePermission() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.restorePermission",
                forDescription: "You are attempting to perform an action that only the family head can perform. Please contact the family head and have them complete this action. \(ErrorConstant.contactHoundSupport)",
                forOnTap: nil)
        }

        /// There is a in-app purchases restoration in progress, so a new one cannot be initiated
        static func restoreInProgress() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.restoreInProgress",
                forDescription: "There is an in-app purchase restoration currently in progress. You are unable to initiate another in-app purchase restoration until the first one has finished processing. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }

        static func restoreFailed() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.restoreFailed",
                forDescription: "Your in-app purchase restoration has failed. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }

        // MARK: System Is Processing Transaction In The Background
        static func backgroundPurchaseInProgress() -> HoundError {
            HoundError(
                forName: "InAppPurchaseError.backgroundPurchaseInProgress",
                forDescription: "There is a transaction currently being processed in the background. This is likely due to a subscription renewal. Please wait a moment for this to finish processing. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }
    }

    enum DogError {
        static func dogNameMissing() -> HoundError {
            HoundError(
                forName: "DogError.dogNameMissing",
                forDescription: "Your dog's name is blank! Try typing something in.",
                forOnTap: nil)
        }
    }

    enum LogError {
        static func parentDogMissing() -> HoundError {
            HoundError(
                forName: "LogError.parentDogMissing",
                forDescription: "Your log needs a corresponding dog! Please try selecting at least one.",
                forOnTap: nil)
        }
        static func logActionMissing() -> HoundError {
            HoundError(
                forName: "LogError.logActionMissing",
                forDescription: "Your log has no action! Please try selecting one.",
                forOnTap: nil)
        }
        static func logStartDateMissing() -> HoundError {
            HoundError(
                forName: "LogError.logStartDateMissing",
                forDescription: "Your log has no start date! Please try selecting one.",
                forOnTap: nil)
        }
    }

    enum ReminderError {
        static func reminderActionMissing() -> HoundError {
            HoundError(
                forName: "ReminderError.reminderActionMissing",
                forDescription: "Your reminder has no action! Please try selecting one.",
                forOnTap: nil)
        }
    }

    enum SignInWithAppleError {
        static func canceled() -> HoundError {
            HoundError(
                forName: "SignInWithAppleError.canceled",
                forDescription: "The 'Sign In With Apple' page was prematurely canceled. \(ErrorConstant.restartHoundAndRetry)",
                forOnTap: nil)
        }
        static func notSignedIn() -> HoundError {
            HoundError(
                forName: "SignInWithAppleError.notSignedIn",
                forDescription: "The 'Sign In With Apple' page failed as you have no Apple ID. Please create an Apple ID with two-factor authentication enabled and retry.",
                forOnTap: nil)
        }
        static func other() -> HoundError {
            HoundError(
                forName: "SignInWithAppleError.other",
                forDescription: "The 'Sign In With Apple' page failed. Please make sure you have an Apple ID with two-factor authentication enabled and retry.",
                forOnTap: nil)
        }
    }

    enum UnknownError {
        static func unknown() -> HoundError {
            HoundError(
                forName: "UnknownError.unknown",
                forDescription: "Hound has experienced an unknown error. \(ErrorConstant.contactHoundSupport)",
                forOnTap: nil)
        }
    }

    enum WeeklyComponentsError {
        static func weekdayArrayInvalid() -> HoundError {
            HoundError(
                forName: "WeeklyComponentsError.weekdayArrayInvalid",
                forDescription: "Please select at least one day of the week for your reminder. You can do this by tapping on the S, M, T, W, T, F, or S. A blue letter means that your reminder's alarm will sound that day and grey means it won't.",
                forOnTap: nil)
        }
    }

    enum ExportError {
        static func shareHound() -> HoundError {
            HoundError(
                forName: "ExportError.shareHound",
                forDescription: "Unable to present menu to share Hound",
                forOnTap: nil)
        }

        static func shareFamilyCode() -> HoundError {
            HoundError(
                forName: "ExportError.shareHound",
                forDescription: "Unable to present menu to share family code",
                forOnTap: nil)
        }

        static func exportLogs() -> HoundError {
            HoundError(
                forName: "ExportError.shareHound",
                forDescription: "Unable to present menu to export logs",
                forOnTap: nil)
        }
    }
}
//
//  View Tag ClassConstant.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/6/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum VisualConstant {
    // MARK: - Visual

    enum ViewTagConstant {
        // reserve lower bound of tag for potential use within app. tags will never reach anywhere near the upper bound of this reserved range but it costs nothing to reserve some tags.

        static let weekdayEnabled = 1000000004
        static let weekdayDisabled = 1000000005
        static let serverSyncViewControllerRetryLogin = 1000000006
        static let serverSyncViewControllerGoToLoginPage = 1000000007
    }

    enum FontConstant {
        // MARK: Header Labels
        static let primaryHeaderLabel = UIFont.systemFont(ofSize: 32.5, weight: .bold)
        
        static let secondaryHeaderLabel = UIFont.systemFont(ofSize: 22.5, weight: .medium)
        static let emphasizedSecondaryHeaderLabel = UIFont.systemFont(ofSize: 22.5, weight: .semibold)
        
        // MARK: Regular Labels
        static let primaryRegularLabel = UIFont.systemFont(ofSize: 17.5, weight: .regular)
        static let emphasizedPrimaryRegularLabel = UIFont.systemFont(ofSize: 17.5, weight: .semibold)
        
        static let weakSecondaryRegularLabel = UIFont.systemFont(ofSize: 15.0, weight: .light)
        static let secondaryRegularLabel = UIFont.systemFont(ofSize: 15.0, weight: .regular)
        static let emphasizedSecondaryRegularLabel = UIFont.systemFont(ofSize: 15.0, weight: .semibold)
        
        static let tertiaryRegularLabel = UIFont.systemFont(ofSize: 13.0, weight: .regular)
        static let emphasizedTertiaryRegularLabel = UIFont.systemFont(ofSize: 13.0, weight: .semibold)

        // MARK: Description Labels
        static let secondaryColorDescLabel = UIFont.systemFont(ofSize: 13.0, weight: .light)
        static let emphasizedSecondaryColorDescLabel = UIFont.systemFont(ofSize: 13.0, weight: .semibold)
        
        static let tertiaryColorDescLabel = UIFont.systemFont(ofSize: 13.0, weight: .regular)
        static let emphasizedTertiaryColorDescLabel = UIFont.systemFont(ofSize: 13.0, weight: .semibold)

        // MARK: Buttons
        static let screenWideButton = UIFont.systemFont(ofSize: 25.0, weight: .semibold)
        static let circleButton = UIFont.systemFont(ofSize: 20.0, weight: .medium)
    }

    enum LayerConstant {
        static let defaultCornerRadius = 10.0
        static let imageCoveringViewCornerRadius = 27.5
    }

    enum BannerTextConstant {
        // MARK: - .success (banner style)
        
        static let successPurchasedSubscriptionTitle = "Welcome to Hound+"
        static let successPurchasedSubscriptionSubtitle = "Dive into the full Hound experience with your family. Enjoy!"

        static let successRestoreTransactionsTitle = "Transactions Back on Track"
        static let successRestoreTransactionsSubtitle = "We've retrieved all your past Hound purchases. Enjoy!"

        static let successRedownloadDataTitle = "Data Re-barked and Ready"
        static let successRedownloadDataSubtitle = "Your dogs, reminders, and logs have been redownloaded from the Hound server and are up-to-date"

        static let successRefreshRemindersTitle = successRedownloadDataTitle
        static let successRefreshRemindersSubtitle = "Your dogs, reminders, and logs are now up-to-date"

        static let successRefreshLogsTitle = successRedownloadDataTitle
        static let successRefreshLogsSubtitle = successRefreshRemindersSubtitle

        static let successRefreshFamilyTitle = "Family Fur-ever Refreshed"
        static let successRefreshFamilySubtitle = "Your family is now up-to-date"

        static let copiedToClipboardTitle = "Copied to Clipboard ✂️"
        static var copiedToClipboardSubtitle: String {
            UIPasteboard.general.string ?? ""
        }
        
        static let surveyFeedbackAppExperienceTitle = "Your Bark, Our Command! 📣"
        static let surveyFeedbackAppExperienceSubtitle = "Thanks for sharing! We're listening and committed to enhancing your Hound experience"

        // MARK: - .info (banner style)

        static let houndUpdatedTitle: String = "Fresh Paws on the Block! 🐾"
        static var houndUpdatedSubtitle: String {
            return "Tap here to check out what version \(UIApplication.appVersion) has in store for you!"
        }
        
        static let infoEnteredOfflineModeTitle = "Switched to Offline Mode"
        static let infoEnteredOfflineModeSubtitle = "Hang tight! We'll sync your data as soon as we reconnect to the Hound servers"
        
        static let infoRedownloadOnHoldTitle = "Your Updates, Coming Up!"
        static let infoRedownloadOnHoldSubtitle = "Hang tight! We'll redownload the latest on your pups as soon as we reconnect to the Hound servers"

        static let infoRefreshOnHoldTitle = "Your Updates, Coming Up!"
        static let infoRefreshOnHoldSubtitle = "Hang tight! We'll fetch the latest on your pups as soon as we reconnect to the Hound servers"

        // MARK: - .danger (banner style)
        
        static let noCameraTitle = "Camera Needed for Snaps 📷"
        static let noCameraSubtitle = "Enable camera access to capture moments with your pup"

        static let errorAlertTitle = "Uh-oh! We sniffed out an issue 🐾"

        static let notificationsDisabledTitle = "Heads Up! Notifications Disabled 🔕"
        static let notificationsDisabledSubtitle = "To enable notifications go to Settings -> Notifications -> Hound and enable \"Allow Notifications\""

        static let invalidLockedFamilyShareTitle = "Family Sharing Gate Locked 🔒"
        static let invalidLockedFamilyShareSubtitle = "Currently, your Hound family is locked, preventing new users from joining. In order to share your family, please unlock it and retry"

        static let notFamilyHeadInvalidPermissionTitle = "Paws Off! Permission Needed 🚫"
        static let notFamilyHeadInvalidPermissionSubtitle = "Only the family head can modify your family's subscription. Please contact them to complete this action"

    }

    enum TextConstant {
        static let unknownText = "Unknown ⚠️"
        static let unknownName = "Missing Name"
        static let unknownEmail = "Missing Email"
        static let unknownUserId = "Missing User ID"
        static let unknownHash = "0123456789012345678901234567890123456789012345678901234567890123"
        static let unknownUUID: UUID = UUID(uuidString: "00000000-0000-4000-8000-000000000000")! // swiftlint:disable:this force_unwrapping
    }

    enum AnimationConstant {
        static let openOrCloseCreateNewDogOrReminder = 0.3
        static let removeFromViewCreateNewDogOrReminderDelay = openOrCloseCreateNewDogOrReminder / 2.0
        /// Duration after selecting a ui element. For example: toggling weekday(s) for a weekly reminder or setCustomSelected for a drop down table view cell
        static let toggleSelectUIElement = 0.125
        static let spinUIElement = 0.4
        static let showOrHideUIElement = 0.15
    }
}
//
//  EnumConstant.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/17/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum DevelopmentConstant {
    /// True if the server we are contacting is our Ubuntu AWS instance, false if we are local hosting off personal computer
    static let isProductionServer: Bool = {
#if DEBUG
        AppDelegate.generalLogger.info("DEBUG configuration for server")
        // Return true to connect to AWS EC2 instance
        // Return false to connect to local
        return true
#else
        AppDelegate.generalLogger.info("RELEASE configuration for server")
        // MARK: ALWAYS RETURN TRUE, WANT PROD SERVER FOR RELEASE
        return true
#endif
    }()
    /// True if we are contacting the production environment side of our server, false if we are contacting the development side
    static let isProductionDatabase: Bool = {
#if DEBUG
        AppDelegate.generalLogger.info("DEBUG configuration for database")
        // MARK: ALWAYS RETURN FALSE, WANT DEV DATABASE FOR DEBUG
        return false
#else
        AppDelegate.generalLogger.info("RELEASE configuration for database")
        // MARK: ALWAYS RETURN TRUE, WANT PROD DATABASE FOR RELEASE
        return true
#endif
    }()

    /// If testing the development of Hound with its development database, then use this user id for a test account.
    static let developmentDatabaseTestUserId: String? = isProductionDatabase ? nil : nil // "3314e13ce7fab539591cfa2d5c8e4a29105befdd9bc3398bbe457ef30448aa0c"

    /// If testing the development of Hound with its development database, then use this user identifier for a test account.
    static let developmentDatabaseTestUserIdentifier: String? = isProductionDatabase ? nil : "000228.36153ca1c4604ee9b7c1614e7ce7b971.2208"

    /// All Hound servers, development or producton, support HTTPS only
    private static let urlScheme: String = isProductionServer ? "https://" : "http://"
    /// The production server is attached to a real domain name, whereas our development server is off the local network
    private static let urlDomainName: String = {
        if isProductionServer && isProductionDatabase {
            return "api.houndorganizer.com"
        }
        else if isProductionServer && !isProductionDatabase {
            return "development.houndorganizer.com"
        }
        else {
            return "0.0.0.0"
        }
    }()
    /// The production server uses https on port 443 for the production database and 8443 for the development database. The development server always uses http on port 80.
    private static let urlPort: String = ":443"
    /// All Hound app requests go under the app path
    private static let urlAppPath: String = "/app"
    /// The base url that api requests go to
    static let url: String = urlScheme + urlDomainName + urlPort + urlAppPath
    /// The interval at which the date picker should display minutes. Use this property to set the interval displayed by the minutes wheel (for example, 15 minutes). The interval value must be evenly divided into 60; if it is not, the default value is used. The default and minimum values are 1; the maximum value is 30.
    static let reminderMinuteInterval = isProductionDatabase ? 5 : 1
}
//
//  Dog Constants.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ClassConstant {

    enum SubscriptionConstant {
        static var defaultSubscription: Subscription {
            Subscription(
                forTransactionId: nil,
                forProductId: defaultProductId,
                forPurchaseDate: nil,
                forExpiresDate: nil,
                forNumberOfFamilyMembers: defaultSubscriptionNumberOfFamilyMembers,
                forIsActive: true,
                forAutoRenewStatus: true,
                forAutoRenewProductId: defaultProductId)
        }
        static let defaultSubscriptionNumberOfFamilyMembers = 1
        static let defaultSubscriptionSpelledOutNumberOfFamilyMembers = "one"
        static let defaultProductId = "com.jonathanxakellis.hound.default"
    }

    enum DogConstant {
        static let defaultDogName: String = "Bella"
        static let defaultDogIcon: UIImage = whitePawWithHands
        static let whitePawWithHands: UIImage = UIImage.init(named: "whitePawWithHands") ?? UIImage()
        static let blackPawWithHands: UIImage = UIImage.init(named: "blackPawWithHands") ?? UIImage()

        static let dogNameCharacterLimit: Int = 32
        // IMPORTANT: If you modify this value, change the value on Hound server's globalConstant LIMIT
        static let maximumNumberOfDogs = 10
        // IMPORTANT: If you modify this value, change the value on Hound server's globalConstant LIMIT
        static let maximumNumberOfLogs = 100000
        // IMPORTANT: If you modify this value, change the value on Hound server's globalConstant LIMIT
        static let maximumNumberOfReminders = 10
        // IMPORTANT: If you modify this value, change the value on Hound server's globalConstant LIMIT
        // TODO RT implement max num of triggers
        static let maximumNumberOfTriggers = 25
    }

    enum LogConstant {
        static var defaultUserId: String {
            UserInformation.userId ?? VisualConstant.TextConstant.unknownHash
        }
        static let defaultLogActionTypeId = 1
        static var defaultLogStartDate: Date { Date() }
        static let logCustomActionNameCharacterLimit: Int = 32
        static let logNoteCharacterLimit: Int = 500
    }

    enum ReminderConstant {
        static let defaultReminderActionTypeId = 1
        static let defaultReminderType = ReminderType.countdown
        static var defaultReminderExecutionBasis: Date { Date() }
        static let defaultReminderIsEnabled = true
        static let reminderCustomActionNameCharacterLimit: Int = 32
        static var defaultReminders: [Reminder] {
            [ defaultReminderOne, defaultReminderTwo, defaultReminderThree, defaultReminderFour ]
        }
        private static var defaultReminderOne: Reminder {
            let reminder = Reminder()
            reminder.reminderActionTypeId = 3
            reminder.changeReminderType(forReminderType: .countdown)
            reminder.countdownComponents.executionInterval = ClassConstant.ReminderComponentConstant.defaultCountdownExecutionInterval
            return reminder
        }
        private static var defaultReminderTwo: Reminder {
            let reminder = Reminder()
            reminder.reminderActionTypeId = 1
            reminder.changeReminderType(forReminderType: .weekly)
            // 7:00 AM local time
            return reminder
        }
        private static var defaultReminderThree: Reminder {
            let reminder = Reminder()
            reminder.reminderActionTypeId = 1
            reminder.changeReminderType(forReminderType: .weekly)
            var date = reminder.reminderExecutionDate ?? DateConstant.default1970Date
            // 12:00 PM local time
            date = Calendar.current.date(byAdding: .hour, value: 5, to: date) ?? DateConstant.default1970Date
            reminder.weeklyComponents.changeUTCHour(forDate: date)
            reminder.weeklyComponents.changeUTCMinute(forDate: date)
            return reminder
        }
        private static var defaultReminderFour: Reminder {
            let reminder = Reminder()
            reminder.reminderActionTypeId = 1
            reminder.changeReminderType(forReminderType: .weekly)
            var date = reminder.reminderExecutionDate ?? DateConstant.default1970Date
            // 5:00 PM local time
            date = Calendar.current.date(byAdding: .hour, value: 10, to: date) ?? DateConstant.default1970Date
            reminder.weeklyComponents.changeUTCHour(forDate: date)
            reminder.weeklyComponents.changeUTCMinute(forDate: date)
            return reminder
        }
    }

    enum ReminderComponentConstant {
        static let defaultCountdownExecutionInterval: Double = 60 * 60 * 2

        static let defaultUTCDay: Int = 1

        /// Hour 7 of the day in the user's local time zone, but adjusted so that hour 7 is in UTC hours (e.g. UTC-5 so localHour is 7 and UTCHour is 12)
        static var defaultUTCHour: Int {
            // We want hour 7 of the day in the users local timezone
            let defaultLocalHour = 7
            let hoursFromUTC = Calendar.current.timeZone.secondsFromGMT() / 3600

            // UTCHour + hoursFromUTC = localHour
            // UTCHour = localHour - hoursFromUTC

            var UTCHour = defaultLocalHour - hoursFromUTC
            // UTCHour could be negative, so roll over into positive
            UTCHour += 24
            // Make sure UTCHour [0, 23]
            UTCHour = UTCHour % 24

            return UTCHour
        }

        /// Minute 0 of the hour in the user's local time zone, but adjusted so that minute 0  is in UTC hours (e.g. UTC-0:30 so localMinute is 0 and UTCMinute is 30)
        static var defaultUTCMinute: Int {
            let defaultLocalMinute = 0
            let minutesFromUTC = (Calendar.current.timeZone.secondsFromGMT() % 3600) / 60

            // UTCMinute + minutesFromUTC = localMinute
            // UTCMinute = localMinute - minutesFromUTC

            var UTCMinute = defaultLocalMinute - minutesFromUTC
            // UTCMinute could be negative, so roll over into positive
            UTCMinute += 60
            // Make sure UTCMinute [0, 59]
            UTCMinute = UTCMinute % 60

            return UTCMinute
        }
    }
    
    enum TriggerConstant {
        static let triggerCustomNameCharacterLimit = 32
        static let defaultTriggerType = TriggerType.timeDelay
        static let defaultTriggerTimeDelay: Double = 60 * 30
        static let defaultTriggerFixedTimeType = TriggerFixedTimeType.day
        static let defaultTriggerFixedTimeTypeAmount = 1
        static let defaultTriggerResultReminderActionTypeId = 3
    }

    enum DateConstant {
        static let default1970Date = Date(timeIntervalSince1970: 0.0)
    }
    
    enum FeedbackConstant {
        static let subscriptionCancellationSuggestionCharacterLimit: Int = 1000
        static let appExperienceSuggestionCharacterLimit: Int = 1000
    }
}
//
//  ConstraintConstant.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/17/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

let maxScaleFactor = 1.3
let screenWidth = 414.0

enum ConstraintConstant {
    enum Global {
        static let contentHoriInset: CGFloat = 20.0
        static let contentVertInset: CGFloat = 10.0
        
        static let intraContentHoriInset: CGFloat = 7.5
    }
    enum PageHeader {
        static let labelHeightMultipler: CGFloat = 40.0 / screenWidth
        static let labelMaxHeight: CGFloat = Self.labelHeightMultipler * screenWidth * maxScaleFactor
        
        static let vertSpacingToPageDescription: CGFloat = 7.5
        
        static let vertSpacingToSection: CGFloat = 20.0
    }
    enum Button {
        static let circleHeightMultiplier: CGFloat = 100.0 / screenWidth
        static let circleMaxHeight: CGFloat = Self.circleHeightMultiplier * screenWidth * maxScaleFactor
        static let circleInset: CGFloat = 10.0
        
        static let miniCircleHeightMultiplier: CGFloat = Self.circleHeightMultiplier / 2.25
        static let miniCircleMaxHeight: CGFloat = Self.circleMaxHeight / 2.25
        static let miniCircleInset: CGFloat = 5.0
        
        static let screenWideHeightMultiplier: CGFloat = 60.0 / screenWidth
        static let screenWideMaxHeight: CGFloat = Self.screenWideHeightMultiplier * screenWidth * maxScaleFactor
        
        static let chevronWidthToHeighRatio: CGFloat = 1.0 / 1.5
    }
    enum Section {
        static let sectionTitleHeightMultipler: CGFloat = 25.0 / screenWidth
        static let sectionTitleMaxHeight: CGFloat = Self.sectionTitleHeightMultipler * screenWidth * maxScaleFactor
        
        static let intraSectionVertSpacing: CGFloat = 7.5
        static let interSectionVertSpacing: CGFloat = 45.0
        
        static let inputHeightMultiplier: CGFloat = 45.0 / screenWidth
        static let inputMaxHeight: CGFloat = Self.inputHeightMultiplier * screenWidth * maxScaleFactor
    }
}
//
//  Key Constants.swift
//  Hound
//
//  Created by Jonathan Xakellis on 9/21/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum KeyConstant: String {

    // MARK: API Response Body

    // client and server
    case result
    case message
    case code
    case name
    case requestId
    case responseId

    // MARK: Family Information

    // client and server
    case familyHeadUserId
    case familyId
    case familyCode
    case familyIsLocked
    case familyKickUserId
    case familyActiveSubscription
    case familyMembers
    case familyHeadIsUser
    case previousFamilyMembers

    // MARK: User Information

    // client
    case userMiddleName
    case userNamePrefix
    case userNameSuffix
    case userNickname

    // client and server
    case userId
    case userIdentifier
    case userAppAccountToken
    case userEmail
    case userFirstName
    case userLastName
    case userNotificationToken

    // MARK: User Configuration
    
    // client
    case previousDogManagerSynchronization

    // client and server
    case userConfigurationInterfaceStyle
    case userConfigurationMeasurementSystem
    
    case userConfigurationSnoozeLength
    
    case userConfigurationIsNotificationEnabled
    case userConfigurationIsLoudNotificationEnabled
    case userConfigurationIsLogNotificationEnabled
    case userConfigurationIsReminderNotificationEnabled
    case userConfigurationNotificationSound
    
    case userConfigurationIsSilentModeEnabled
    case userConfigurationSilentModeStartUTCHour
    case userConfigurationSilentModeEndUTCHour
    case userConfigurationSilentModeStartUTCMinute
    case userConfigurationSilentModeEndUTCMinute

    // MARK: App Store Purchase

    // client
    case userPurchasedProduct
    case userPurchasedProductFromSubscriptionGroup20965379

    // client and server
    case appStoreReceiptURL
    case transactionId
    case productId
    case purchaseDate
    case expiresDate
    case numberOfFamilyMembers
    case isActive
    case autoRenewStatus
    case autoRenewProductId
    
    // MARK: Offline Sync Components
    
    case offlineModeComponents
    case offlineModeComponentsInitialAttemptedSyncDate
    case offlineModeComponentsInitialCreationDate
    
    case offlineModeDeletedObjectDeletedDate
    
    case offlineModeManagerShared
    case offlineModeManagerShouldUpdateUser
    case offlineModeManagerShouldGetUser
    case offlineModeManagerShouldGetFamily
    case offlineModeManagerShouldGetDogManager
    case offlineModeManagerOfflineModeDeletedObjects
    
    // MARK: Dog Manager

    // client
    case dogManager
    case dogs

    // MARK: Dog

    // client
    case dogIcon
    case dogLogs
    case dogReminders
    case dogTriggers

    // client and server
    case dogId
    case dogUUID
    case dogName
    case dogLastModified
    case dogIsDeleted

    // MARK: Log

    // client and server
    case logId
    case logUUID
    case logActionTypeId
    case logCustomActionName
    case logStartDate
    case logEndDate
    case logNote
    case logUnitTypeId
    case logNumberOfLogUnits
    case logLastModified
    case logIsDeleted

    // MARK: Reminder

    // client and server
    case reminderId
    case reminderUUID
    case reminderActionTypeId // also used for ReminderActionType
    case reminderCustomActionName
    case reminderType
    case reminderExecutionBasis
    case reminderExecutionDate
    case reminderIsTriggerResult
    case reminderIsEnabled
    case reminderLastModified
    case reminderIsDeleted
    
    // MARK: GlobalTypes
    
    case globalTypes
    case logActionType
    case reminderActionType
    case mappingLogActionTypeReminderActionType
    case logUnitType
    case mappingLogActionTypeLogUnitType
    
    // MARK: LogUnitType
    
    case unitSymbol
    case isImperial
    case isMetric
    case isUnitMass
    case isUnitVolume
    case isUnitLength
    
    // MARK: ReminderActionType/LogActionType/MappingLogActionTypeReminderActionType
    
    case mappingId
    case internalValue
    case readableValue // also LogUnitType
    case emoji
    case sortOrder
    case isDefault
    case allowsCustom
    
    // MARK: Reminder Trigger
    case triggerId
    case triggerUUID
    case triggerCustomName
    case reactionLogActionTypeIds
    case reactionLogCustomActionNames
    case resultReminderActionTypeId
    case triggerType
    case triggerTimeDelay
    case triggerFixedTimeType
    case triggerFixedTimeTypeAmount
    case triggerFixedTimeUTCHour
    case triggerFixedTimeUTCMinute
    case triggerLastModified
    case triggerIsDeleted
    
    // MARK: Snooze Components

    // client
    case snoozeComponents
    // client and server
    case snoozeExecutionInterval

    // MARK: Countdown Components

    // client
    case countdownComponents
    // client and server
    case countdownExecutionInterval

    // MARK: Weekly Components

    // client
    case weeklyComponents
    case weeklyWeekdays
    // client and server
    case weeklyUTCHour
    case weeklyUTCMinute
    case weeklySunday
    case weeklyMonday
    case weeklyTuesday
    case weeklyWednesday
    case weeklyThursday
    case weeklyFriday
    case weeklySaturday
    case weeklySkippedDate

    // MARK: Monthly Components

    // client
    case monthlyComponents
    // client and server
    case monthlyUTCDay
    case monthlyUTCHour
    case monthlyUTCMinute
    case monthlySkippedDate

    // MARK: One Time Components

    // client
    case oneTimeComponents
    // client and server
    case oneTimeDate
    
    // MARK: Survey Feedback
    
    case surveyFeedback
    case surveyFeedbackType
    case surveyFeedbackDeviceMetricModel
    case surveyFeedbackDeviceMetricSystemVersion
    case surveyFeedbackDeviceMetricAppVersion
    case surveyFeedbackDeviceMetricLocale
    case surveyFeedbackUserCancellationReason
    case surveyFeedbackUserCancellationFeedback
    case surveyFeedbackAppExperienceNumberOfStars
    case surveyFeedbackAppExperienceFeedback

    // MARK: Local

    // client
    case localIsNotificationAuthorized

    case localPreviousLogCustomActionNames
    case localPreviousReminderCustomActionNames

    case localPreviousDatesUserSurveyFeedbackAppExperienceRequested
    case localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted
    case localPreviousDatesUserReviewRequested

    case localAppVersionsWithReleaseNotesShown

    case localHasCompletedFirstTimeSetup
    case localHasCompletedHoundIntroductionViewController
    case localHasCompletedRemindersIntroductionViewController
    case localHasCompletedFamilyUpgradeIntroductionViewController
    case localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController

    case localAppVersion
    case localHasIncompatibleData
}
//
//  Notification Sound.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/6/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum NotificationSound: String, CaseIterable {
    init?(rawValue: String) {
        for sound in NotificationSound.allCases where sound.rawValue == rawValue {
            self = sound
            return
        }

        return nil
    }
    
    case radar = "Radar"
    // case apex = "Apex"
    // case beacon = "Beacon"
    // case bulletin = "Bulletin"
    // case byTheSeaside = "By The Seaside"
    // case chimes  = "Chimes"
    case circuit = "Circuit"
    // case constellation = "Constellation"
    // case cosmic = "Cosmic"
    // case crystals = "Crystals"
    // case hillside = "Hillside"
    case illuminate = "Illuminate"
    // case nightOwl = "Night Owl"
    // case opening = "Opening"
    // case playtime = "Playtime"
    case presto = "Presto"
    // case radiate = "Radiate"
    // case reflection = "Reflection"
    // case ripples = "Ripples"
    case sencha = "Sencha"
    case signal = "Signal"
    case silk = "Silk"
    // case slowRise = "Slow Rise"
    case stargaze = "Stargaze"
    // case summit = "Summit"
    case twinkle = "Twinkle"
    // case uplift = "Uplift"
    case waves = "Waves"
}
//
//  Unit Converter.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum LogUnitTypeConverter {
    
    /// For a given logUnit and its numberOfLogUnits, converts to the targetSystem. If the targetSystem is .both, then nothing is done as all units are acceptable. Otherwise, converts between imperial and metric. For example: 1 oz -> 28.3495 grams
    static func convert(forLogUnit logUnit: LogUnitType, forNumberOfLogUnits numberOfLogUnits: Double, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        guard targetSystem != .both else {
            // A system that supports both measurement types doesn't need to convert any units
            return (logUnit, numberOfLogUnits)
        }
        
        if logUnit.isUnitMass {
            return convertUnitMass(forMeasurement: Measurement(value: numberOfLogUnits, unit: UnitMass(symbol: logUnit.unitSymbol)), toTargetSystem: targetSystem)
        }
        else if logUnit.isUnitVolume {
            return convertUnitVolume(forMeasurement: Measurement(value: numberOfLogUnits, unit: UnitVolume(symbol: logUnit.unitSymbol)), toTargetSystem: targetSystem)
        }
        else if logUnit.isUnitLength {
            return convertUnitLength(forMeasurement: Measurement(value: numberOfLogUnits, unit: UnitLength(symbol: logUnit.unitSymbol)), toTargetSystem: targetSystem)
        }
        
        // Some units can't be converted, e.g. treats
        return (logUnit, numberOfLogUnits)
    }
    
    /// For a given Measurement<UnitMass>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than conversionThreshholdToNextUnit. For example: 4.5 kg is too small, so 450 grams is chosen. 5.5 kg is great enough (> threshhold), so 5.5 kg is chosen.
    private static func convertUnitMass(forMeasurement measurement: Measurement<UnitMass>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        let gt = GlobalTypes.shared else {
            return nil
        }
        let conversionTypes =
        switch targetSystem {
        case .imperial:
            let lbConversion = measurement.converted(to: UnitMass.pounds)
            let ozConversion = measurement.converted(to: UnitMass.ounces)
            if lbConversion.value > 1.0 {
                return (.lb, lbConversion.value)
            }
            else {
                return (.oz, ozConversion.value)
            }
        case .metric, .both:
            // .both should never happen, but if it does, fall through to metric
            let kgConversion = measurement.converted(to: UnitMass.kilograms)
            let gConversion = measurement.converted(to: UnitMass.grams)
            let mgConversion = measurement.converted(to: UnitMass.milligrams)
            
            if kgConversion.value > conversionThreshholdToNextUnit {
                return (.kg, kgConversion.value)
            }
            else if gConversion.value > conversionThreshholdToNextUnit {
                return (.g, gConversion.value)
            }
            else {
                return (.mg, mgConversion.value)
            }
        }
    }
    
    /// For a given Measurement<UnitVolume>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than 1.0. For example: 4.5 kg is too small, so 450 grams is chosen. 5.5 kg is great enough (> threshhold), so 5.5 kg is chosen.
    private static func convertUnitVolume(forMeasurement measurement: Measurement<UnitVolume>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnit, Double) {
        switch targetSystem {
        case .imperial:
            let cupsConversion = measurement.converted(to: UnitVolume.cups)
            let flOzConversion = measurement.converted(to: UnitVolume.fluidOunces)
            let tbspConversion = measurement.converted(to: UnitVolume.tablespoons)
            let tspConversion = measurement.converted(to: UnitVolume.teaspoons)
            
            if cupsConversion.value > 1.0 {
                return (.cup, cupsConversion.value)
            }
            else if flOzConversion.value > 1.0 {
                return (.flOz, flOzConversion.value)
            }
            else if tbspConversion.value > 1.0 {
                return (.tbsp, tbspConversion.value)
            }
            else {
                return (.tsp, tspConversion.value)
            }
        case .metric, .both:
            // .both should never happen, but if it does, fall through to metric
            let lConversion = measurement.converted(to: UnitVolume.liters)
            let mlConversion = measurement.converted(to: UnitVolume.milliliters)
            
            if lConversion.value > 1.0 {
                return (.l, lConversion.value)
            }
            else {
                return (.ml, mlConversion.value)
            }
        }
    }
    
    /// For a given Measurement<UnitLength>, converts it into the units for the targetSystem.Then selects the highest conversion unit where its value is greater than conversionThreshholdToNextUnit. For example: 4.5 kg is too small, so 450 grams is chosen. 5.5 kg is great enough (> threshhold), so 5.5 kg is chosen.
    private static func convertUnitLength(forMeasurement measurement: Measurement<UnitLength>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnit, Double) {
        switch targetSystem {
        case .imperial:
            let milesConversion = measurement.converted(to: UnitLength.miles)
            
            return (.mi, milesConversion.value)
        case .metric, .both:
            // .both should never happen, but if it does, fall through to metric
            let kmConversion = measurement.converted(to: UnitLength.kilometers)
            
            return (.km, kmConversion.value)
        }
    }
    
}
//
//  SurveyFeedbackType.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/31/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum SurveyFeedbackType: String, CaseIterable {
    case cancelSubscription
    case appExperience
}
//
//  Unit Converter.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/4/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum LogUnitTypeConverter {
    
    /// For a given logUnitType and its numberOfLogUnits, converts to the targetSystem. If the targetSystem is .both, then nothing is done as all units are acceptable. Otherwise, converts between imperial and metric. For example: 1 oz -> 28.3495 grams
    static func convert(forLogUnitType logUnitType: LogUnitType, forNumberOfLogUnits numberOfLogUnits: Double, toTargetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        var targetSystem = toTargetSystem
        if targetSystem == .both {
            // .both should never happen, but if it does, fall through to metric
            targetSystem = .metric
        }
        
        if logUnitType.isUnitMass, let unit = UnitMass.from(symbol: logUnitType.unitSymbol) {
            return convertUnitMass(forMeasurement: Measurement(value: numberOfLogUnits, unit: unit), toTargetSystem: targetSystem)
        }
        else if logUnitType.isUnitVolume, let unit = UnitVolume.from(symbol: logUnitType.unitSymbol) {
            return convertUnitVolume(forMeasurement: Measurement(value: numberOfLogUnits, unit: unit), toTargetSystem: targetSystem)
        }
        else if logUnitType.isUnitLength, let unit = UnitLength.from(symbol: logUnitType.unitSymbol) {
            return convertUnitLength(forMeasurement: Measurement(value: numberOfLogUnits, unit: unit), toTargetSystem: targetSystem)
        }
        
        // Some units can't be converted, e.g. treats
        return (logUnitType, numberOfLogUnits)
    }
    
    /// For a given Measurement<UnitVolume>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than 1.0. For example: .5 kg is too small, so 500 grams is chosen. 1.0 kg is great enough (> threshhold), so 1.0 kg is chosen.
    private static func convertUnitMass(forMeasurement measurement: Measurement<UnitMass>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        let conversions = GlobalTypes.shared.logUnitTypes.filter { logUnitType in
            return logUnitType.isUnitMass && UnitMass.from(symbol: logUnitType.unitSymbol) != nil
        }
        .filter { logUnitType in
            switch targetSystem {
            case .imperial: return logUnitType.isImperial
            case .metric: return logUnitType.isMetric
            // .both should never happen, but if it does, fall through to metric
            case .both: return logUnitType.isMetric
            }
        }
        .compactMap { lut in
            let unit = UnitMass.from(symbol: lut.unitSymbol)! // swiftlint:disable:this force_unwrapping
            let converted = measurement.converted(to: unit).value
            return (lut, converted)
        }
        
        // We want to return the conversion with the greatest type and a value above 1.0
        // e.g. if we have 24 oz and 1.5 lbs, we want 1.5 lbs since that is a greater unit, but if 8 oz and 0.5 lbs, then return oz
        
        // Sort ascending by the converted value
        let sortedByValue = conversions.sorted { $0.1 < $1.1 }

        // Find all with value > 1.0
        let aboveOne = sortedByValue.filter { $0.1 > 1.0 }
        
        // 4) If any > 1.0, pick the last (largest); otherwise pick the final entry in sorted list
        if let best = aboveOne.first {
            return (best.0, best.1)
        }
        
        let fallback = sortedByValue.first! // swiftlint:disable:this force_unwrapping
        return (fallback.0, fallback.1)
    }
    
    /// For a given Measurement<UnitVolume>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than 1.0. For example: .5 kg is too small, so 500 grams is chosen. 1.0 kg is great enough (> threshhold), so 1.0 kg is chosen.
    private static func convertUnitVolume(forMeasurement measurement: Measurement<UnitVolume>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        let conversions = GlobalTypes.shared.logUnitTypes.filter { lut in
            return lut.isUnitVolume && UnitVolume.from(symbol: lut.unitSymbol) != nil
        }
        .filter { logUnitType in
            switch targetSystem {
            case .imperial: return logUnitType.isImperial
            case .metric: return logUnitType.isMetric
            // .both should never happen, but if it does, fall through to metric
            case .both: return logUnitType.isMetric
            }
        }
        .compactMap { lut in
            let unit = UnitVolume.from(symbol: lut.unitSymbol)! // swiftlint:disable:this force_unwrapping
            let converted = measurement.converted(to: unit).value
            return (lut, converted)
        }
        
        // We want to return the conversion with the greatest type and a value above 1.0
        // e.g. if we have 24 oz and 1.5 lbs, we want 1.5 lbs since that is a greater unit, but if 8 oz and 0.5 lbs, then return oz
        
        // Sort ascending by the converted value
        let sortedByValue = conversions.sorted { $0.1 < $1.1 }

        // Find all with value > 1.0
        let aboveOne = sortedByValue.filter { $0.1 > 1.0 }
        
        // 4) If any > 1.0, pick the last (largest); otherwise pick the final entry in sorted list
        if let best = aboveOne.first {
            return (best.0, best.1)
        }
        
        let fallback = sortedByValue.first! // swiftlint:disable:this force_unwrapping
        return (fallback.0, fallback.1)
    }
    
    /// For a given Measurement<UnitVolume>, converts it into the units for the targetSystem. Then selects the highest conversion unit where its value is greater than 1.0. For example: .5 kg is too small, so 500 grams is chosen. 1.0 kg is great enough (> threshhold), so 1.0 kg is chosen.
    private static func convertUnitLength(forMeasurement measurement: Measurement<UnitLength>, toTargetSystem targetSystem: MeasurementSystem) -> (LogUnitType, Double) {
        let conversions = GlobalTypes.shared.logUnitTypes.filter { lut in
            return lut.isUnitLength && UnitLength.from(symbol: lut.unitSymbol) != nil
        }
        .filter { logUnitType in
            switch targetSystem {
            case .imperial: return logUnitType.isImperial
            case .metric: return logUnitType.isMetric
            // .both should never happen, but if it does, fall through to metric
            case .both: return logUnitType.isMetric
            }
        }
        .compactMap { lut in
            let unit = UnitLength.from(symbol: lut.unitSymbol)! // swiftlint:disable:this force_unwrapping
            let converted = measurement.converted(to: unit).value
            return (lut, converted)
        }
        
        // We want to return the conversion with the greatest type and a value above 1.0
        // e.g. if we have 24 oz and 1.5 lbs, we want 1.5 lbs since that is a greater unit, but if 8 oz and 0.5 lbs, then return oz
        
        // Sort ascending by the converted value
        let sortedByValue = conversions.sorted { $0.1 < $1.1 }

        // Find all with value > 1.0
        let aboveOne = sortedByValue.filter { $0.1 > 1.0 }
        
        // 4) If any > 1.0, pick the last (largest); otherwise pick the final entry in sorted list
        if let best = aboveOne.first {
            return (best.0, best.1)
        }
        
        let fallback = sortedByValue.first! // swiftlint:disable:this force_unwrapping
        return (fallback.0, fallback.1)
    }
    
}
//
//  NSLayoutConstraintExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/17/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit


extension NSLayoutConstraint {
    @discardableResult
    func constraintWithMultiplier(_ multiplier: CGFloat) -> NSLayoutConstraint {
        // Deactivate the original constraint before creating the new one
        self.isActive = false

        // Create new constraint copying all the parameters but changing the multiplier
        let newConstraint = NSLayoutConstraint(
            item: self.firstItem as Any,
            attribute: self.firstAttribute,
            relatedBy: self.relation,
            toItem: self.secondItem,
            attribute: self.secondAttribute,
            multiplier: multiplier,
            constant: self.constant
        )
        // Copy priority and identifier
        newConstraint.priority = self.priority
        newConstraint.identifier = self.identifier

        // Activate the new constraint
        newConstraint.isActive = true

        return newConstraint
    }
    
    func withPriority(_ priority: UILayoutPriority) -> NSLayoutConstraint {
        self.priority = priority
        return self
    }
}
//
//  CalendarExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/23/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension Calendar {
    /// Calendar object with it's time zone set to GMT+0000
    static var UTCCalendar: Calendar {
        var UTCCalendar = Calendar.current
        UTCCalendar.timeZone = TimeZone(secondsFromGMT: 0) ?? UTCCalendar.timeZone
        return UTCCalendar
    }
}
//
//  NotificationNameExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/27/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension Notification.Name {
    static let didUpdateUserInterfaceStyle = Notification.Name("didUpdateUserInterfaceStyle")
}
//
//  ArrayExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 10/18/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension Array {
    func safeIndex(_ index: Index) -> Element? {
        indices.contains(index) ? self[index] : nil
    }
}
//
//  IntExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/24/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension Int {
    /// Takes the given day of month and appends an appropiate suffix of st, nd, rd, or th, e.g. 31 returns st, 20 returns th, 2 returns nd
    func daySuffix() -> String {
        switch self {
        case 1, 21, 31:
            return "st"
        case 2, 22:
            return "nd"
        case 3, 23:
            return "rd"
        default:
            return "th"
        }
    }
}
//
//  NSCoderExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/22/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension NSCoder {
    func decodeOptionalInteger(forKey key: String) -> Int? {
        return containsValue(forKey: key) ? decodeInteger(forKey: key) : nil
    }
    
    func decodeOptionalBool(forKey key: String) -> Bool? {
        return containsValue(forKey: key) ? decodeBool(forKey: key) : nil
    }
    
    func decodeOptionalDouble(forKey key: String) -> Double? {
        return containsValue(forKey: key) ? decodeDouble(forKey: key) : nil
    }
    
    func decodeOptionalFloat(forKey key: String) -> Float? {
        return containsValue(forKey: key) ? decodeFloat(forKey: key) : nil
    }
    
    func decodeOptionalString(forKey key: String) -> String? {
        return decodeOptionalObject(forKey: key)
    }
    
    func decodeOptionalObject<T>(forKey key: String) -> T? {
        return containsValue(forKey: key) ? decodeObject(forKey: key) as? T : nil
    }
}
//
//  UUIDExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/10/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension UUID {
    static func fromString(forUUIDString: String?) -> UUID? {
        guard let forUUIDString = forUUIDString else {
            return nil
        }
        
        return UUID(uuidString: forUUIDString)
    }
}
//
//  TimeIntervalExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/18/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension TimeInterval {

    /**
     Converts a TimeInterval to a readable string.
        Examples:
        (1800.0, true, true): 30 Mins
        (1800.0, true, false): 30 Minutes
        (1800.0, false, true): 30 mins
        (1800.0, false, false): 30 minutes
        (5400.0, false, true) 1 hr 30 mins
     */
    func readable(capitalizeWords: Bool, abreviateWords: Bool) -> String {
        let totalSeconds = abs(Int(self.rounded()))

        let numberOfWeeks = Int((totalSeconds / (86400)) / 7)
        let numberOfDays = Int((totalSeconds / (86400)) % 7)
        let numberOfHours = Int((totalSeconds % (86400)) / (3600))
        let numberOfMinutes = Int((totalSeconds % 3600) / 60)
        let numberOfSeconds = Int((totalSeconds % 3600) % 60)
        
        var secondString = (abreviateWords ? "Sec" : "Second").appending(numberOfSeconds > 1 ? "s" : "")
        secondString = capitalizeWords ? secondString : secondString.lowercased()
        
        var minuteString = (abreviateWords ? "Min" : "Minute").appending(numberOfMinutes > 1 ? "s" : "")
        minuteString = capitalizeWords ? minuteString : minuteString.lowercased()
        
        var hourString = (abreviateWords ? "Hr" : "Hour").appending(numberOfHours > 1 ? "s" : "")
        hourString = capitalizeWords ? hourString : hourString.lowercased()
        
        var dayString = (abreviateWords ? "D" : "Day").appending(numberOfDays > 1 ? "s" : "")
        dayString = capitalizeWords ? dayString : dayString.lowercased()
        
        var weekString = (abreviateWords ? "Wk" : "Week").appending(numberOfWeeks > 1 ? "s" : "")
        weekString = capitalizeWords ? weekString : weekString.lowercased()
        
        var string = ""

        switch totalSeconds {
        case 0..<60:
            string.append("\(numberOfSeconds) \(secondString) ")
        case 60..<3600:
            string.append("\(numberOfMinutes) \(minuteString) ")
        case 3600..<86400:
            string.append("\(numberOfHours) \(hourString) ")
            if numberOfMinutes > 0 {
                string.append("\(numberOfMinutes) \(minuteString) ")
            }
        case 86400..<604800:
            string.append("\(numberOfDays) \(dayString) ")
            if numberOfHours > 0 {
                string.append("\(numberOfHours) \(hourString) ")
            }
        default:
            string.append("\(numberOfWeeks) \(weekString) ")
            if numberOfDays > 0 {
                string.append("\(numberOfDays) \(dayString) ")
            }
        }

        return string.trimmingCharacters(in: .whitespacesAndNewlines)
    }
}
//
//  UIPasteboardExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/3/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIPasteboard {
    /// Assigns UIPasteboard.general.string to forString then shows a banner to confirm to the user that the specified information was copied.
    func setPasteboard(forString string: String) {
        UIPasteboard.general.string = string

        PresentationManager.enqueueBanner(forTitle: VisualConstant.BannerTextConstant.copiedToClipboardTitle, forSubtitle: VisualConstant.BannerTextConstant.copiedToClipboardSubtitle, forStyle: .success)
    }
}
//
//  StringExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/5/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension String {

    /// Converts dateComponents with .hour and .minute to a readable string, e.g. 8:56AM or 2:23 PM
    static func convertToReadable(fromUTCHour UTCHour: Int, fromUTCMinute UTCMinute: Int) -> String {

        var localHour: Int = {
            let hoursFromUTC = Int(Calendar.current.timeZone.secondsFromGMT() / 3600)
            var localHour = UTCHour + hoursFromUTC
            // Verify localHour >= 0
            if localHour < 0 {
                localHour += 24
            }

            // Verify localHour <= 23
            if localHour > 23 {
                localHour = localHour % 24
            }

            return localHour
        }()

        let localMinute: Int = {
            let minutesFromUTC = Int((Calendar.current.timeZone.secondsFromGMT() % 3600) / 60 )
            var localMinute = UTCMinute + minutesFromUTC
            // Verify localMinute >= 0
            if localMinute < 0 {
                localMinute += 60
            }

            // Verify localMinute <= 59
            if localMinute > 59 {
                localMinute = localMinute % 60
            }

            return localMinute
        }()

        let amOrPM: String = localHour < 12 ? "AM" : "PM"

        // convert localHour to non-military time
        if localHour > 12 {
            localHour -= 12
        }
        else if localHour == 0 {
            localHour = 12
        }

        // 7:00 PM, 7:10 AM
        return "\(localHour):\(localMinute < 10 ? "0" : "")\(localMinute) \(amOrPM)"
    }

    /// Only works if the label it is being used on has a single line of text OR has its paragraphs predefined with \n (s).
    func bounding(font: UIFont, height: CGFloat? = nil, width: CGFloat? = nil) -> CGSize {
        let attributedString = NSAttributedString(string: self, attributes: [.font: font])

        let greatestFiniteMagnitudeBounding = attributedString.boundingRect(with:
                                                                    CGSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude), options: .usesLineFragmentOrigin, context: nil)
        let boundHeight = height ?? greatestFiniteMagnitudeBounding.height
        let boundWidth = width ?? greatestFiniteMagnitudeBounding.width

        return CGSize(width: boundWidth, height: boundHeight)

    }

    /// Takes an ISO8601 string from the Hound server then attempts to create a Date
    func formatISO8601IntoDate() -> Date? {
        // from client
        // 2023-04-06T21:03:15Z
        // from server
        // 2023-04-12T20:40:00.000Z
        let formatterWithMilliseconds = Foundation.ISO8601DateFormatter()
        formatterWithMilliseconds.formatOptions = [.withFractionalSeconds, .withDashSeparatorInDate, .withColonSeparatorInTime, .withFullDate, .withTime]

        let formatterWithoutMilliseconds = Foundation.ISO8601DateFormatter()
        formatterWithoutMilliseconds.formatOptions = [.withDashSeparatorInDate, .withColonSeparatorInTime, .withFullDate, .withTime]

        return formatterWithMilliseconds.date(from: self) ?? formatterWithoutMilliseconds.date(from: self)

    }

    /// If string contains a , or a ",  replaces all occurances of double-quotes with a pair of double quotes then encloses field in double quotes
    func formatIntoCSV() -> String {
        var string = self

        // The string only needs to be modified if it contains double-quotes or commas
        guard string.contains("\"") || string.contains(",") else {
            return string
        }

        // Literal double-quote characters in a CSV are typically represented by a pair of double-quotes.
        string = string.replacingOccurrences(of: "\"", with: "\"\"")

        // To encode a field containing a comma or double-quotes, we must enclose the field in double quotes.
        string = "\"" + string + "\""

        return string
    }
}
//
//  SKProductExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/14/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import StoreKit

extension SKProduct {
    // Attempts to use subscriptionPeriod unit and numberOfUnits to calculate an approximate monthly price, assuming 30 days / month.
    var monthlySubscriptionPrice: Double? {
        // what unit we are using: day, week, month, year
        let periodUnit = self.subscriptionPeriod?.unit
        // how many of the unit: x days, x weeks, x months, x years
        let numberOfUnits = self.subscriptionPeriod?.numberOfUnits

        guard let periodUnit = periodUnit, let numberOfUnits = numberOfUnits else {
            return nil
        }

        let numberOfMonths: Double? = {
            switch periodUnit {
            case .day:
                // days / 30 = months,
                return Double(numberOfUnits) / 30.0
            case .week:
                // weeks * 7 = days, days / 30 = months
                return (Double(numberOfUnits) * 7.0) / 30.0
            case .month:
                return Double(numberOfUnits)
            case .year:
                // years * 12 = months
                return Double(numberOfUnits) * 12.0
            default:
                return nil
            }
        }()

        guard let numberOfMonths = numberOfMonths else {
            return nil
        }

        var monthlySubscriptionPrice: Double = Double(truncating: self.price.dividing(by: NSDecimalNumber(value: numberOfMonths)))
        // truncate to 2 decimal places
        monthlySubscriptionPrice = floor(100 * monthlySubscriptionPrice) / 100
        return monthlySubscriptionPrice

    }

    /// Every SKProduct has a calculable monthlySubscriptionPrice. That means a certain SKProduct in subscriptionProducts will have the highest value of monthlySubscriptionPrice. If we take maximumMonthlySubscriptionPrice and apply it to the time frame of the subscription offered by this product, then we get the "full" price of this product. That is to say, we get the price that this product would cost if we use the highest possible price per time period. For example: 1 month $19.99 and 6 months $59.99. That would make the 1 month's fullPrice $19.99 and 6 month's fullPrice $119.99.
    var fullPrice: Double? {
        let maximumMonthlySubscriptionPrice: Double? = {
            // Find the SKProduct in subscriptionProducts with the highest value of monthlySubscriptionPrice
            var maximumMonthlySubscriptionPrice: Double?

            for product in InAppPurchaseManager.subscriptionProducts {
                guard let monthlySubscriptionPrice = product.monthlySubscriptionPrice else {
                    continue
                }

                maximumMonthlySubscriptionPrice = max(monthlySubscriptionPrice, maximumMonthlySubscriptionPrice ?? 0.0)
            }
            
            return maximumMonthlySubscriptionPrice
        }()
        
        guard let maximumMonthlySubscriptionPrice = maximumMonthlySubscriptionPrice else {
            return nil
        }

        // what unit we are using: day, week, month, year
        let periodUnit = self.subscriptionPeriod?.unit
        // how many of the unit: x days, x weeks, x months, x years
        let numberOfUnits = self.subscriptionPeriod?.numberOfUnits

        guard let periodUnit = periodUnit, let numberOfUnits = numberOfUnits else {
            return nil
        }

        let numberOfMonths: Double? = {
            switch periodUnit {
            case .day:
                // days / 30 = months,
                return Double(numberOfUnits) / 30.0
            case .week:
                // weeks * 7 = days, days / 30 = months
                return (Double(numberOfUnits) * 7.0) / 30.0
            case .month:
                return Double(numberOfUnits)
            case .year:
                // years * 12 = months
                return Double(numberOfUnits) * 12.0
            default:
                return nil
            }
        }()

        guard let numberOfMonths = numberOfMonths else {
            return nil
        }

        var fullPrice = numberOfMonths * maximumMonthlySubscriptionPrice
        
        // truncate to 2 decimal places
        fullPrice = floor(100 * fullPrice) / 100
        
        return fullPrice
    }
}
//
//  DateExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 12/8/20.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension Date {

    func ISO8601FormatWithFractionalSeconds() -> String {
        self.ISO8601Format(Date.ISO8601FormatStyle.init(dateSeparator: .dash, dateTimeSeparator: .standard, timeSeparator: .colon, includingFractionalSeconds: true))
    }

    /// Returns a rounded version of targetDate depending on roundingInterval, e.g. targetDate 18:41:51 -> rounded 18:42:00 for RI of 10 but for a RI of 5 rounded 18:41:50
    static func roundDate(targetDate: Date, roundingInterval: Double, roundingMethod: FloatingPointRoundingRule) -> Date {
        let rounded = Date(timeIntervalSinceReferenceDate: (targetDate.timeIntervalSinceReferenceDate / roundingInterval).rounded(roundingMethod) * roundingInterval)
        return rounded
    }
}
//
//  UnitFoundationExtensions.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/18/25.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

extension UnitMass {
    /// Returns the Foundation UnitMass for a given symbol string (e.g. "mg", "oz"), or nil if not recognized.
    static func from(symbol: String) -> UnitMass? {
        switch symbol {
        case "kg": return .kilograms
        case "g": return .grams
        case "dg": return .decigrams
        case "cg": return .centigrams
        case "mg": return .milligrams
        case "μg": return .micrograms
        case "ng": return .nanograms
        case "pg": return .picograms
        case "oz": return .ounces
        case "lb": return .pounds
        case "st": return .stones
        case "t": return .metricTons
        case "tn": return .shortTons
        case "ct": return .carats
        case "oz t": return .ouncesTroy
        case "slug": return .slugs
        default: return nil
        }
    }
}

// MARK: - UnitLength Symbol Mapping

extension UnitLength {
    /// Returns the Foundation UnitLength for a given symbol string (e.g. "cm", "ft"), or nil if not recognized.
    static func from(symbol: String) -> UnitLength? {
        switch symbol {
        case "Mm": return .megameters
        case "km": return .kilometers
        case "hm": return .hectometers
        case "dam": return .decameters
        case "m": return .meters
        case "dm": return .decimeters
        case "cm": return .centimeters
        case "mm": return .millimeters
        case "μm": return .micrometers
        case "nm": return .nanometers
        case "pm": return .picometers
        case "in": return .inches
        case "ft": return .feet
        case "yd": return .yards
        case "mi": return .miles
        case "smi": return .scandinavianMiles
        case "ly": return .lightyears
        case "nmi": return .nauticalMiles
        case "fathom": return .fathoms
        case "fur": return .furlongs
        case "au": return .astronomicalUnits
        case "pc": return .parsecs
        default: return nil
        }
    }
}

// MARK: - UnitVolume Symbol Mapping

extension UnitVolume {
    /// Returns the Foundation UnitVolume for a given symbol string (e.g. "L", "gal", "mL"), or nil if not recognized.
    static func from(symbol: String) -> UnitVolume? {
        switch symbol {
        case "ML": return .megaliters
        case "kL": return .kiloliters
        case "L": return .liters
        case "dL": return .deciliters
        case "cL": return .centiliters
        case "mL": return .milliliters
        case "km³": return .cubicKilometers
        case "m³": return .cubicMeters
        case "dm³": return .cubicDecimeters
        case "cm³": return .cubicCentimeters
        case "mm³": return .cubicMillimeters
        case "in³": return .cubicInches
        case "ft³": return .cubicFeet
        case "yd³": return .cubicYards
        case "mi³": return .cubicMiles
        case "ac ft": return .acreFeet
        case "bu": return .bushels
        case "tsp": return .teaspoons
        case "tbsp": return .tablespoons
        case "fl oz": return .fluidOunces
        case "cup": return .cups
        case "pt": return .pints
        case "qt": return .quarts
        case "gal": return .gallons
        case "imp tsp": return .imperialTeaspoons
        case "imp tbsp": return .imperialTablespoons
        case "imp fl oz": return .imperialFluidOunces
        case "imp pt": return .imperialPints
        case "imp qt": return .imperialQuarts
        case "imp gal": return .imperialGallons
        case "mcup": return .metricCups
        default: return nil
        }
    }
}
//
//  UIApplicationExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/3/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIApplication {

    /// Special keyWindow
    static var keyWindow: UIWindow? {
        // Get connected scenes
        return UIApplication.shared.connectedScenes
        // Keep only active scenes, onscreen and visible to the user
            .filter { $0.activationState == .foregroundActive }
        // Keep only the first `UIWindowScene`
            .first(where: { $0 is UIWindowScene })
        // Get its associated windows
            .flatMap({ $0 as? UIWindowScene })?.windows
        // Finally, keep only the key window
            .first(where: \.isKeyWindow)
    }

    static var previousAppVersion: String?

    static var appVersion: String {
        Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? oldestCompatibleAppVersion
    }
    
    /// Any appVersion that is older than this version is considered incompatible. App should consider local data as faulty.
    private static var oldestCompatibleAppVersion: String = "3.5.0"
    
    /// Returns true if the previousAppVersion is nil or is greater than or equal to to the oldestCompatibleAppVersion. Returns false if the previousAppVersion is less than oldestCompatibleAppVersion
    static var isPreviousAppVersionCompatible: Bool {
        guard let previousAppVersion = UIApplication.previousAppVersion else {
            return true
        }
        // 3.1.0 -> [3,1,0]
        var previousAppVersionComponents: [Int] = previousAppVersion.split(separator: ".").map { substring in
            return Int(substring) ?? -1
        }
        
        // 3.2.1 -> [3,2,1]
        var oldestCompatibleAppVersionComponents: [Int] = UIApplication.oldestCompatibleAppVersion.split(separator: ".").map { substring in
            return Int(substring) ?? -1
        }
        
        // If one of the arrays is shorter than the other array, pad it with -1 so they are the same length
        if previousAppVersionComponents.count < oldestCompatibleAppVersionComponents.count {
            for _ in 0..<(oldestCompatibleAppVersionComponents.count - previousAppVersionComponents.count) {
                previousAppVersionComponents.append(-1)
            }
        }
        else if oldestCompatibleAppVersionComponents.count < previousAppVersionComponents.count {
            for _ in 0..<(previousAppVersionComponents.count - oldestCompatibleAppVersionComponents.count) {
                oldestCompatibleAppVersionComponents.append(-1)
            }
        }
        
        for (index, oldestCompatibleAppVersionComponent) in oldestCompatibleAppVersionComponents.enumerated() {
            let previousAppVersionComponent = previousAppVersionComponents[index]
            
            guard previousAppVersionComponent != oldestCompatibleAppVersionComponent else {
                // Two components are equal, iterate to the next component
                continue
            }
            
            // The previousAppVersionComponent doesn't equal the oldestCompatibleAppVersionComponent, e.g. [3,1,0] & [3,1,1] -> 0 != 1
            return previousAppVersionComponent >= oldestCompatibleAppVersionComponent
        }
        
        // previousAppVersion == oldestCompatibleAppVersion, so return true
        return true
    }
}
//
//  UIViewControllerExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/30/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIViewController {
    
    @objc func dismissKeyboard() {
        self.view.dismissKeyboard()
    }
    
    /// Performs recursive dismisses without animation until the next presentingViewController is the same class as ofClass, then performs a dismiss with animation to that viewController of equal ofClass and invokes completionHandler once that finishes. If we run out of presentingViewController without finding one of ofClass, then completionHandler is not include
    func dismissToViewController(ofClass: AnyClass, completionHandler: (() -> Void)?) {
        // If we want to dismiss the self, we must make sure its presentedViewController is dismised
        self.presentedViewController?.dismiss(animated: false)
        
        guard self.isKind(of: ofClass) == false else {
            // We already have dismissed to that viewController of ofClass
            completionHandler?()
            return
        }
        
        // With a UITabBarController and UINavigationStack, self.presentingViewController is not a solely reliable way to iterate backwards through the "stack" of presents, segues, modal presentations, etc. Instead, we rely upon the fact that globalPresenter is set by viewIsAppearing, which is invoked after a dismiss is complete
        
        if self.presentingViewController?.isKind(of: ofClass) == true {
            // presentingViewController is ofClass, so perform animations as this is the final dismiss
            self.dismiss(animated: true, completion: completionHandler)
        }
        else if self.isBeingPresented == true || self.presentingViewController != nil {
            // self.presentingViewController before dismiss and PresentationManager.globalPresenter can be the same, or they can be different. viewIsAppearing of views that appear after dismiss can change PresentationManager.globalPresenter.
            // This view controller is being presented, so calling dismiss(animated:completion:) will actually dismiss something.
            self.dismiss(animated: false) {
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ofClass, completionHandler: completionHandler)
            }
        }
        else {
            // This view controller is NOT being presented, so calling dismiss(animated:completion:) won't do anything. Therefore, we ran out of places to dismiss to and didn't reach ofClass.
            completionHandler?()
        }
        
    }
    
    func embedChild(_ child: UIViewController) {
        addChild(child)
        view.addSubview(child.view)
        child.view.translatesAutoresizingMaskIntoConstraints = false
        child.didMove(toParent: self)
    }
    
}
//
//  UIViewExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/20/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIView {

    /// Once called, any future taps to the view will call dismissKeyboard.
    func dismissKeyboardOnTap(delegate: UIGestureRecognizerDelegate) {
        let tap: UITapGestureRecognizer = UITapGestureRecognizer(
            target: self,
            action: #selector(self.dismissKeyboard)
        )

        tap.delegate = delegate
        tap.cancelsTouchesInView = false
        
        self.addGestureRecognizer(tap)
    }

    /// Invokes endEditing(true). This method looks at the current view and its subview hierarchy for the text field that is currently the first responder. If it finds one, it asks that text field to resign as first responder. If the force parameter is set to true, the text field is never even asked; it is forced to resign.
    @objc func dismissKeyboard() {
        self.endEditing(true)
    }

    enum SetRoundedCorners {
        case none
        case top
        case bottom
        case all
    }
    func roundCorners(setCorners: SetRoundedCorners) {
        switch setCorners {
        case .none:
            self.layer.maskedCorners = []
        case .top:
            self.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]
        case .bottom:
            self.layer.maskedCorners = [.layerMinXMaxYCorner, .layerMaxXMaxYCorner]
        case .all:
            self.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner, .layerMinXMaxYCorner, .layerMaxXMaxYCorner]
        }

        self.layer.cornerRadius = VisualConstant.LayerConstant.defaultCornerRadius
        self.layer.cornerCurve = .continuous
    }

    enum AddRoundedCorners {
        case top
        case bottom
        case all
    }
    func roundCorners(addCorners: AddRoundedCorners) {
        switch addCorners {
        case .top:
            self.layer.maskedCorners.insert([.layerMinXMinYCorner, .layerMaxXMinYCorner])
        case .bottom:
            self.layer.maskedCorners.insert([.layerMinXMaxYCorner, .layerMaxXMaxYCorner])
        case .all:
            self.layer.maskedCorners.insert([.layerMinXMinYCorner, .layerMaxXMinYCorner, .layerMinXMaxYCorner, .layerMaxXMaxYCorner])
        }

        self.layer.cornerRadius = VisualConstant.LayerConstant.defaultCornerRadius
        self.layer.cornerCurve = .continuous
    }

    var closestParentViewController: UIViewController? {
        var parentResponder: UIResponder? = self
        while parentResponder != nil {
            parentResponder = parentResponder?.next
            if let viewController = parentResponder as? UIViewController {
                return viewController
            }
        }
        return nil
    }
    
    func createSquareConstraint() -> NSLayoutConstraint {
        return self.widthAnchor.constraint(equalTo: self.heightAnchor)
    }
}
//
//  UIImageExtension.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/30/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

extension UIImage {
    func isEqualToImage(image: UIImage) -> Bool {
        let data1 = self.pngData()
        let data2 = image.pngData()
        return data1 == data2
    }
}
//
//  RemindersRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/1/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum RemindersRequest {
    
    static var baseURL: URL { DogsRequest.baseURL.appendingPathComponent("/reminders") }
    
    /// Returns an array of reminder bodies under the key "reminders". E.g. { reminders : [{reminder1}, {reminder2}] }
    private static func createRemindersBody(forDogUUID: UUID, forReminders: [Reminder]) -> [String: [[String: CompatibleDataTypeForJSON?]]] {
        var reminderBodies: [[String: CompatibleDataTypeForJSON?]] = []
        for forReminder in forReminders {
            reminderBodies.append(forReminder.createBody(forDogUUID: forDogUUID))
        }
        let body: [String: [[String: CompatibleDataTypeForJSON?]]] = [KeyConstant.dogReminders.rawValue: reminderBodies]
        return body
    }
    
}

extension RemindersRequest {
    
    // MARK: - Public Functions
    
    /**
     If query is successful, automatically combines client-side and server-side reminders and returns (reminder, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func get(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forReminder: Reminder,
        completionHandler: @escaping (Reminder?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body: [String: CompatibleDataTypeForJSON?] = forReminder.createBody(forDogUUID: forDogUUID)
        
        return RequestUtils.genericGetRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(nil, responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                let remindersBody: [[String: Any?]]? = {
                    if let remindersBody = responseBody?[KeyConstant.result.rawValue] as? [[String: Any?]] {
                        return remindersBody
                    }
                    else if let reminderBody = responseBody?[KeyConstant.result.rawValue] as? [String: Any?] {
                        return [reminderBody]
                    }
                    else {
                        return nil
                    }
                }()
                
                if responseStatus == .noResponse {
                    // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                    OfflineModeManager.shared.didGetNoResponse(forType: .dogManagerGet)
                }
                else if let reminderBody = remindersBody?.first {
                    // If we got a reminderBody, use it. This can only happen if responseStatus != .noResponse.
                    completionHandler(Reminder(fromBody: reminderBody, reminderToOverride: forReminder.copy() as? Reminder), responseStatus, error)
                    return
                }
                
                // Either no response or no new, updated information from the Hound server
                completionHandler(forReminder, responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically client-side and server-side reminders and returns (reminders, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forReminders: [Reminder],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // There should be reminders to actually create
        guard forReminders.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body = createRemindersBody(forDogUUID: forDogUUID, forReminders: forReminders)
        
        return RequestUtils.genericPostRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { responseBody, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    forReminders.forEach { forReminder in
                        forReminder.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: nil)
                    }
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                let remindersBody: [[String: Any?]]? = {
                    if let remindersBody = responseBody?[KeyConstant.result.rawValue] as? [[String: Any?]] {
                        return remindersBody
                    }
                    else if let reminderBody = responseBody?[KeyConstant.result.rawValue] as? [String: Any?] {
                        return [reminderBody]
                    }
                    else {
                        return nil
                    }
                }()
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the reminders to be updated later
                    forReminders.forEach { forReminder in
                        forReminder.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: Date())
                    }
                }
                else if let remindersBody = remindersBody {
                    remindersBody.forEach { reminderBody in
                        // For each reminderBody, get the reminderUUID and reminderId. We use the reminderUUID to locate the reminder so we can assign it its reminderId
                        guard let reminderId = reminderBody[KeyConstant.reminderId.rawValue] as? Int, let reminderUUID = UUID.fromString(forUUIDString: reminderBody[KeyConstant.reminderUUID.rawValue] as? String) else {
                            return
                        }
                        
                        let forReminder = forReminders.first { forReminder in
                            return forReminder.reminderUUID == reminderUUID
                        }
                        
                        forReminder?.reminderId = reminderId
                    }
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    @discardableResult static func update(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forReminders: [Reminder],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // There should be reminders to actually update
        guard forReminders.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body = createRemindersBody(forDogUUID: forDogUUID, forReminders: forReminders)
        
        return RequestUtils.genericPutRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { _, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    forReminders.forEach { forReminder in
                        forReminder.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: nil)
                    }
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the reminders to be updated later
                    forReminders.forEach { forReminder in
                        forReminder.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: Date())
                    }
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    @discardableResult static func delete(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forReminderUUIDs: [UUID],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // There should be reminders to actually delete
        guard forReminderUUIDs.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body: [String: [[String: CompatibleDataTypeForJSON?]]] = {
            var reminderBodies: [[String: CompatibleDataTypeForJSON?]] = []
            
            for forReminderUUID in forReminderUUIDs {
                var reminderBody: [String: CompatibleDataTypeForJSON?] = [:]
                reminderBody[KeyConstant.dogUUID.rawValue] = forDogUUID.uuidString
                reminderBody[KeyConstant.reminderUUID.rawValue] = forReminderUUID.uuidString
                reminderBodies.append(reminderBody)
            }
        
            return [
                KeyConstant.dogReminders.rawValue: reminderBodies
            ]
        }()
        
        return RequestUtils.genericDeleteRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { _, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the reminder to be deleted later
                    forReminderUUIDs.forEach { forReminderUUID in
                        OfflineModeManager.shared.addDeletedObjectToQueue(forObject: OfflineModeDeletedReminder(dogUUID: forDogUUID, reminderUUID: forReminderUUID, deletedDate: Date()))
                    }
                }
                
                completionHandler(responseStatus, error)
        }
    }
}
//
//  RequestUtils.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/6/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ResponseAutomaticErrorAlertTypes {
    /// If a HoundError is generated by a success, failure, or no response to a request, is it automatically alerted to
    case automaticallyAlertForAll
    /// If a HoundError is generated by a failure response to a request, is it automatically alerted to
    case automaticallyAlertOnlyForFailure
    /// If a HoundError is generated by a success, failure, or no response to a request, is it not automatically alerted to
    case automaticallyAlertForNone
}

enum RequestSourceFunctionTypes {
    /// The request function was invoked through normal means from somewhere in the Hound app
    case normal
    /// The request function was invoked from the OfflineModeManager to re-sync data
    case offlineModeManager
}

enum ResponseStatus {
    /// 200...299
    case successResponse
    /// != 200...299, e.g. 400, 404, 500
    case failureResponse
    /// Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
    case noResponse
}

/// abstractions used by other endpoint classes to make their request to the server, not used anywhere else in hound so therefore internal to endpoints and api requests.
enum RequestUtils {
    static var baseURL: URL { URL(string: DevelopmentConstant.url) ?? URL(fileURLWithPath: "foo") }
    
    private static let session = URLSession(configuration: {
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.timeoutIntervalForRequest = 15.0
        sessionConfig.timeoutIntervalForResource = 30.0
        sessionConfig.waitsForConnectivity = false
        return sessionConfig
    }())
    
    /// Takes an already constructed URLRequest and executes it, returning it in a compeltion handler. This is the basis to all URL requests
    private static func genericRequest(
        forRequest originalRequest: URLRequest,
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
       
        // If there is no internet connection, return noResponse and invoke OfflineModeManager to start attempting to re-sync data once a connection is restored
        // If sourceFunction is normal and OfflineModeManager is actively syncing, return noResponse as we want OfflineModeManager to finish syncing before trying to perform any more requests
        guard (NetworkManager.shared.isConnected) && (forSourceFunction != .normal || OfflineModeManager.shared.isSyncInProgress == false) else {
            // Any completionHandlers or UI element changes must be done on the main thread
            DispatchQueue.main.async {
                let houndError = ErrorConstant.GeneralRequestError.noInternetConnection()
                if forErrorAlert == .automaticallyAlertForAll {
                    houndError.alert()
                }
                
                completionHandler(nil, .noResponse, houndError)
                
                // We can't perform the request because there is no internet connection. Have offline sync manager start monitoring for when connectivity is restored. This has to be after completionHandler, otherwise there will be nothing to sync so OfflineModeManager won't monitor anything
                OfflineModeManager.shared.startMonitoring()
            }
            return nil
        }
        
        var request = originalRequest
        if let userIdentifier = UserInformation.userIdentifier {
            request.setValue(userIdentifier, forHTTPHeaderField: "houndheader-useridentifier")
        }
        request.setValue(UIApplication.appVersion, forHTTPHeaderField: "houndheader-appversion")
        
        AppDelegate.APIRequestLogger.notice("\(request.httpMethod ?? VisualConstant.TextConstant.unknownText) Request for \(request.url?.description ?? VisualConstant.TextConstant.unknownText)")
        
        // Create the task that will send the request
        let task = session.dataTask(with: request) { data, response, error in
            genericRequestResponse(forRequest: request, forErrorAlert: forErrorAlert, completionHandler: completionHandler, forData: data, forURLResponse: response, forError: error)
        }
        
        // Pass off the task to be executed when its time for it. Handles lots of requests coming in at once
        RequestUtilsTaskQueue.enqueueTask(forDataTask: task)
        
        return task.progress
    }
    
    /// Parses the response from session.dataTask(with: request). Depending on if the response was a success, failure, or no response, invokes a futher helper function
    private static func genericRequestResponse(
        forRequest: URLRequest,
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void,
        forData: Data?,
        forURLResponse: URLResponse?,
        forError: Error?
    ) {
        // extract status code from URLResponse
        let responseStatusCode: Int? = (forURLResponse as? HTTPURLResponse)?.statusCode

        // parse response from json
        let responseBody: [String: Any?]? = {
            // if no data or if no status code, then request failed
            guard let forData = forData else {
                return nil
            }
            
            // try to serialize data as "result" form with array of info first, if that fails, revert to regular "message" and "error" format
            return try?
            JSONSerialization.jsonObject(with: forData, options: .fragmentsAllowed) as? [String: [[String: Any?]]]
            ?? JSONSerialization.jsonObject(with: forData, options: .fragmentsAllowed) as? [String: Any?]
        }()
        
        guard forError == nil, let responseBody = responseBody, let responseStatusCode = responseStatusCode else {
            genericRequestNoResponse(
                forRequest: forRequest,
                forErrorAlert: forErrorAlert,
                completionHandler: completionHandler,
                forResponseBody: responseBody,
                forError: forError
            )
            return
        }
        
        guard 200...299 ~= responseStatusCode else {
            genericRequestFailureResponse(
                forRequest: forRequest,
                forErrorAlert: forErrorAlert,
                completionHandler: completionHandler,
                forResponseBody: responseBody
            )
            return
        }
        
        genericRequestSuccessResponse(
            forRequest: forRequest,
            completionHandler: completionHandler,
            forResponseBody: responseBody
        )
    }
    
    /// Handles a case of a no response from a data task query
    private static func genericRequestNoResponse(
        forRequest request: URLRequest,
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void,
        forResponseBody responseBody: [String: Any?]?, forError error: Error?
    ) {
        // assume an error is no response as that implies request/response failure, meaning the end result of no response is the same
        AppDelegate.APIResponseLogger.warning(
            "No \(request.httpMethod ?? VisualConstant.TextConstant.unknownText) Response for \(request.url?.description ?? VisualConstant.TextConstant.unknownText)\nData Task Error: \(error?.localizedDescription ?? VisualConstant.TextConstant.unknownText)")
        
        let responseError: HoundError = {
            switch request.httpMethod {
            case "PATCH":
                return ErrorConstant.GeneralResponseError.getNoResponse()
            case "POST":
                return ErrorConstant.GeneralResponseError.postNoResponse()
            case "PUT":
                return ErrorConstant.GeneralResponseError.putNoResponse()
            case "DELETE":
                return ErrorConstant.GeneralResponseError.deleteNoResponse()
            default:
                return ErrorConstant.GeneralResponseError.getNoResponse()
            }
        }()
        
        // Any completionHandlers or UI element changes must be done on the main thread
        DispatchQueue.main.async {
            if forErrorAlert == .automaticallyAlertForAll {
                responseError.alert()
            }
            
            completionHandler(responseBody, .noResponse, responseError)
            
            // We can't perform the request because there is no internet connection. Have offline sync manager start monitoring for when connectivity is restored. This has to be after completionHandler, otherwise there will be nothing to sync so OfflineModeManager won't monitor anything
            OfflineModeManager.shared.startMonitoring()
        }
    }
    
    /// Handles a case of a failure response from a data task query
    private static func genericRequestFailureResponse(
        forRequest request: URLRequest,
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void,
        forResponseBody responseBody: [String: Any?]
    ) {
        // Our request went through but was invalid
        AppDelegate.APIResponseLogger.warning(
            "Failure \(request.httpMethod ?? VisualConstant.TextConstant.unknownText) Response for \(request.url?.description ?? VisualConstant.TextConstant.unknownText)\n Message: \(responseBody[KeyConstant.message.rawValue] as? String ?? VisualConstant.TextConstant.unknownText)\n Code: \(responseBody[KeyConstant.code.rawValue] as? String ?? VisualConstant.TextConstant.unknownText)\n Type:\(responseBody[KeyConstant.name.rawValue] as? String ?? VisualConstant.TextConstant.unknownText)")
        
        let responseErrorCode: String? = responseBody[KeyConstant.code.rawValue] as? String
        let requestId: Int = responseBody[KeyConstant.requestId.rawValue] as? Int ?? -1
        let responseId: Int = responseBody[KeyConstant.responseId.rawValue] as? Int ?? -1
        
        let responseError: HoundError = {
            // attempt to construct an error from responseErrorCode
            if let responseErrorCode = responseErrorCode, let error = ErrorConstant.serverError(forErrorCode: responseErrorCode, forRequestId: requestId, forResponseId: responseId) {
                return error
            }
            
            // could not construct an error, use a default error message based upon the http method
            switch request.httpMethod {
            case "PATCH":
                return ErrorConstant.GeneralResponseError.getFailureResponse(forRequestId: requestId, forResponseId: responseId)
            case "POST":
                return ErrorConstant.GeneralResponseError.postFailureResponse(forRequestId: requestId, forResponseId: responseId)
            case "PUT":
                return ErrorConstant.GeneralResponseError.putFailureResponse(forRequestId: requestId, forResponseId: responseId)
            case "DELETE":
                return ErrorConstant.GeneralResponseError.deleteFailureResponse(forRequestId: requestId, forResponseId: responseId)
            default:
                return ErrorConstant.GeneralResponseError.getFailureResponse(forRequestId: requestId, forResponseId: responseId)
            }
        }()
        
        // Any completionHandlers or UI element changes must be done on the main thread
        DispatchQueue.main.async {
            
            guard responseError.name != ErrorConstant.GeneralResponseError.appVersionOutdated(forRequestId: -1, forResponseId: -1).name else {
                // If the user's app is outdated, it no longer works for hound. Therefore, prevent them from doing anything until they update.
                // Ignore forErrorAlert
                responseError.alert()
                return
            }
            
            if forErrorAlert == .automaticallyAlertForAll || forErrorAlert == .automaticallyAlertOnlyForFailure {
                responseError.alert()
            }
            
            // if the error happened to be about the user's account or family disappearing or them losing access, then revert them to the login page
            if responseError.name == ErrorConstant.PermissionResponseError.noUser(forRequestId: -1, forResponseId: -1).name {
                PersistenceManager.clearStorageToReloginToAccount()
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncViewController.self, completionHandler: nil)
            }
            else if responseError.name == ErrorConstant.PermissionResponseError.noFamily(forRequestId: -1, forResponseId: -1).name {
                PersistenceManager.clearStorageToRejoinFamily()
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncViewController.self, completionHandler: nil)
            }
            // if the error happens to be because a dog, log, or reminder was deleted, then invoke a low level refresh to update the user's data.
            else if responseError.name == ErrorConstant.FamilyResponseError.deletedDog(forRequestId: -1, forResponseId: -1).name ||
                        responseError.name == ErrorConstant.FamilyResponseError.deletedLog(forRequestId: -1, forResponseId: -1).name ||
                        responseError.name == ErrorConstant.FamilyResponseError.deletedReminder(forRequestId: -1, forResponseId: -1).name ||
                        responseError.name == ErrorConstant.FamilyResponseError.deletedTrigger(forRequestId: -1, forResponseId: -1).name {
                MainTabBarController.shouldRefreshDogManager = true
            }
            else if responseError.name == ErrorConstant.GeneralResponseError.rateLimitExceeded(forRequestId: -1, forResponseId: -1).name {
                RequestUtilsTaskQueue.lastDateRateLimitReceived = Date()
            }
            
            completionHandler(responseBody, .failureResponse, responseError)
        }
    }
    
    /// Handles a case of a success response from a data task query
    private static func genericRequestSuccessResponse(
        forRequest request: URLRequest,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void,
        forResponseBody responseBody: [String: Any?]
    ) {
        // Our request was valid and successful
        AppDelegate.APIResponseLogger.notice("Success \(request.httpMethod ?? VisualConstant.TextConstant.unknownText) Response for \(request.url?.description ?? VisualConstant.TextConstant.unknownText)")
        
        // Any completionHandlers or UI element changes must be done on the main thread
        DispatchQueue.main.async {
            completionHandler(responseBody, .successResponse, nil)
        }
    }
}

extension RequestUtils {
    
    // MARK: - Generic GET, POST, PUT, and DELETE requests
    
    /// Perform a generic get request at the specified url with NO body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericGetRequest(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        forURL: URL,
        forBody: [String: Any?],
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "PATCH"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONSerialization.data(withJSONObject: forBody)
        
        return genericRequest(
            forRequest: request,
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
    }
    
    /// Perform a generic get request at the specified url with provided body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericPostRequest(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        forURL: URL,
        forBody: [String: Any?],
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "POST"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONSerialization.data(withJSONObject: forBody)
        
        return genericRequest(
            forRequest: request,
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
        
    }
    
    /// Perform a generic get request at the specified url with provided body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericPutRequest(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        forURL: URL,
        forBody: [String: Any?],
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "PUT"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONSerialization.data(withJSONObject: forBody)
        
        return genericRequest(
            forRequest: request,
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
        
    }
    
    /// Perform a generic get request at the specified url with NO body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericDeleteRequest(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        forURL: URL,
        forBody: [String: Any?],
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "DELETE"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONSerialization.data(withJSONObject: forBody)
        
        return genericRequest(
            forRequest: request,
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction
        ) { responseBody, responseStatus, error  in
            completionHandler(responseBody, responseStatus, error)
        }
    }
    
}
//
//  LogsRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/1/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum LogsRequest {
    
    static var baseURL: URL { DogsRequest.baseURL.appendingPathComponent("/logs") }
    
    /**
     If query is successful, automatically combines client-side and server-side logs and returns (log, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func get(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forLog: Log,
        completionHandler: @escaping (Log?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body: [String: CompatibleDataTypeForJSON?] = forLog.createBody(forDogUUID: forDogUUID)
        
        return RequestUtils.genericGetRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(nil, responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                    OfflineModeManager.shared.didGetNoResponse(forType: .dogManagerGet)
                }
                else if let logBody = responseBody?[KeyConstant.result.rawValue] as? [String: Any?] {
                    // If we got a logBody, use it. This can only happen if responseStatus != .noResponse.
                    completionHandler(Log(fromBody: logBody, logToOverride: forLog.copy() as? Log), responseStatus, error)
                    return
                }
                
                // Either no response or no new, updated information from the Hound server
                completionHandler(forLog, responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically assigns logId to log and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forLog: Log,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body = forLog.createBody(forDogUUID: forDogUUID)
        
        return RequestUtils.genericPostRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { responseBody, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    forLog.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: nil)
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the log to be updated later
                    forLog.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: Date())
                }
                else if let logId = responseBody?[KeyConstant.result.rawValue] as? Int {
                    // If we got a logId, use it. This can only happen if responseStatus != .noResponse.
                    forLog.logId = logId
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func update(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forLog: Log,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body = forLog.createBody(forDogUUID: forDogUUID)
        
        // make put request, assume body valid as constructed with function
        return RequestUtils.genericPutRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { _, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    forLog.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: nil)
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the log to be updated later
                    forLog.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: Date())
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func delete(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forLogUUID: UUID,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        var body: [String: CompatibleDataTypeForJSON?] = [:]
        body[KeyConstant.dogUUID.rawValue] = forDogUUID.uuidString
        body[KeyConstant.logUUID.rawValue] = forLogUUID.uuidString
        
        return RequestUtils.genericDeleteRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { _, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the log to be deleted later
                    OfflineModeManager.shared.addDeletedObjectToQueue(forObject: OfflineModeDeletedLog(dogUUID: forDogUUID, logUUID: forLogUUID, deletedDate: Date()))
                }
                
                completionHandler(responseStatus, error)
        }
    }
}
//
//  DogsRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/28/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum DogsRequest {
    static var baseURL: URL { FamilyRequest.baseURL.appendingPathComponent("/dogs") }
    
    /**
     If query is successful, automatically combines client-side and server-side dogs and returns (dog, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func get(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDog: Dog,
        completionHandler: @escaping (Dog?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        guard var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: false) else {
            completionHandler(nil, .failureResponse, nil)
            return nil
        }
        
        if let previousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization {
            components.queryItems = components.queryItems ?? []
            // if we have a previousDogManagerSynchronization that isn't equal to 1970 (the default value), then provide it as that means we have a custom value.
            components.queryItems?.append(
                URLQueryItem(
                    name: KeyConstant.previousDogManagerSynchronization.rawValue,
                    value: previousDogManagerSynchronization.ISO8601FormatWithFractionalSeconds()
                ))
        }
        
        guard let url = components.url else {
            completionHandler(nil, .failureResponse, nil)
            return nil
        }
        
        let body: [String: CompatibleDataTypeForJSON?] = [KeyConstant.dogUUID.rawValue: forDog.dogUUID.uuidString]
        
        return RequestUtils.genericGetRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: url,
            forBody: body) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(nil, responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                    OfflineModeManager.shared.didGetNoResponse(forType: .dogManagerGet)
                }
                else if let newDogBody = responseBody?[KeyConstant.result.rawValue] as? [String: Any] {
                    // If we got a dogBody, use it. This can only happen if responseStatus != .noResponse.
                    completionHandler(Dog(fromBody: newDogBody, dogToOverride: forDog.copy() as? Dog), responseStatus, error)
                    return
                }
                
                // Either no response or no new, updated information from the Hound server
                completionHandler(forDog, responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically combines client-side and server-side dogManagers and returns (dogManager, .successResponse)
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse)
     */
    @discardableResult static func get(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogManager: DogManager,
        completionHandler: @escaping (DogManager?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        guard var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: false) else {
            completionHandler(nil, .failureResponse, nil)
            return nil
        }
        
        if let previousDogManagerSynchronization = LocalConfiguration.previousDogManagerSynchronization {
            components.queryItems = components.queryItems ?? []
            // if we have a previousDogManagerSynchronization that isn't equal to 1970 (the default value), then provide it as that means we have a custom value.
            components.queryItems?.append(
                URLQueryItem(
                    name: KeyConstant.previousDogManagerSynchronization.rawValue,
                    value: previousDogManagerSynchronization.ISO8601FormatWithFractionalSeconds()
                ))
        }
        
        guard let url = components.url else {
            completionHandler(nil, .failureResponse, nil)
            return nil
        }
        
        // If the query is successful, we want new previousDogManagerSynchronization to be before the query took place. This ensures that any changes that might have occured DURING our query will be synced at a future date.
        let previousDogManagerSynchronization = Date()
        
        return RequestUtils.genericGetRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: url,
            forBody: [:]) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(nil, responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                
                if responseStatus == .noResponse {
                    // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                    OfflineModeManager.shared.didGetNoResponse(forType: .dogManagerGet)
                }
                else if let dogBodies = responseBody?[KeyConstant.result.rawValue] as? [[String: Any]] {
                    // If we got dogBodies, use them. This can only happen if responseStatus != .noResponse.
                    LocalConfiguration.previousDogManagerSynchronization = previousDogManagerSynchronization
                    
                    completionHandler(DogManager(fromDogBodies: dogBodies, dogManagerToOverride: forDogManager.copy() as? DogManager), responseStatus, error)
                    return
                }
                
                // Either no response or no new, updated information from the Hound server
                completionHandler(forDogManager, responseStatus, error)
        }
        
    }
    
    /**
     If query is successful, automatically assigns dogId to the dog and manages local storage of dogIcon and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDog: Dog,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body = forDog.createBody()
        
        return RequestUtils.genericPostRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { responseBody, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    forDog.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: nil)
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                if let dogIcon = forDog.dogIcon {
                    DogIconManager.addIcon(forDogUUID: forDog.dogUUID, forDogIcon: dogIcon)
                }
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the dog to be updated later
                    forDog.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: Date())
                }
                else if let dogId = responseBody?[KeyConstant.result.rawValue] as? Int {
                    // If we got a dogId, use it. This can only happen if responseStatus != .noResponse.
                    forDog.dogId = dogId
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically manages local storage of dogIcon and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func update(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDog: Dog,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body = forDog.createBody()
        
        return RequestUtils.genericPutRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { _, responseStatus, error in
                // As long as we got a response from the server, it no longers needs synced. Success or failure
                if responseStatus != .noResponse {
                    forDog.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: nil)
                }
                
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                if let dogIcon = forDog.dogIcon {
                    DogIconManager.addIcon(forDogUUID: forDog.dogUUID, forDogIcon: dogIcon)
                }
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the dog to be updated later
                    forDog.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: Date())
                }
                
                completionHandler(responseStatus, error)
        }
    }
    
    /**
     If query is successful, automatically manages local storage of dogIcon and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func delete(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body: [String: CompatibleDataTypeForJSON] = [KeyConstant.dogUUID.rawValue: forDogUUID.uuidString]
        
        return RequestUtils.genericDeleteRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { _, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    // If there was a failureResponse, there was something purposefully wrong with the request
                    completionHandler(responseStatus, error)
                    return
                }
                
                // Either completed successfully or no response from the server, we can proceed as usual
                DogIconManager.removeIcon(forDogUUID: forDogUUID)
                
                if responseStatus == .noResponse {
                    // If we got no response, then mark the dog to be deleted later
                    OfflineModeManager.shared.addDeletedObjectToQueue(forObject: OfflineModeDeletedDog(dogUUID: forDogUUID, deletedDate: Date()))
                }
                
                completionHandler(responseStatus, error)
        }
    }
}
//
//  RequestUtilsTaskQueue.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/18/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum RequestUtilsTaskQueue {
    
    // MARK: - Properties
    /// Tracks the date at which a certain task made a request to the Hound server in order to make sure the rate limit isn't exceeded.
    private static var houndServerRequestDates: [Date] = []
    
    /// For a given rateLimitEvaluationTimePeriod, this is the amount of requests that can be performed without triggering a rate limit. Requests per period: The number of requests over the period of time that will trigger the rate limiting rule.
    private static let numberOfRequestsAllowedInTimePeriod: Int = (20 - 1)

    /// The time period in which a specified number of requests can be made to the hound server without getting a rate limit from cloudflare. The true value is multiplied by 1.2 to provide extra padding. Period: The period of time to consider (in seconds) when evaluating the rate.
    private static let rateLimitEvaluationTimePeriod: Double = (10.0 * 1.2)
    
    /// If a rate limit is triggered, this is the time period for how long we are timed out for. The true value is multiplied by 1.2 to provide extra padding
    private static let rateLimitTimeOutTimePeriod: Double = (10.0 * 1.2)
    
    /// If we receive a rate limit from the Hound server, track this date so we can delay
    static var lastDateRateLimitReceived: Date?
    
    /// The queue of URLSessionDataTask that need to perform their requests to the Hound server. Index 0 is highest priority
    private static var taskQueue: [URLSessionDataTask] = []
    
    /// If startTask triggered a delay that is a recursive call to itself, waiting a specified amount of time to avoid the rate limit, then this is true
    private static var isDelayInProgress: Bool = false
    
    /// If a dataTask hasn't been queued yet
    static func enqueueTask(forDataTask: URLSessionDataTask) {
        // Guard against enqueuing the same dataTask twice
        guard taskQueue.contains(where: { dataTask in
            return dataTask.taskIdentifier == forDataTask.taskIdentifier
        }) == false else {
            return
        }
        
        // When dataTasks are created, they start in the suspended state. Don't try to initiate from other states
        guard forDataTask.state == .suspended else {
            return
        }
        
        taskQueue.append(forDataTask)
        
        startTask()
    }
    
    /// Attempts to send the dataTask at index 0 of the taskQueue. If the app has sent too many requests in a given time frame, then delays the next requests until
    private static func startTask() {
        // startTask already triggered a delay to avoid the rate limit. Wait for that to return
        guard isDelayInProgress == false else {
            return
        }
        
        let delayNeededToAvoidRateLimit: Double = {
            if let lastDateRateLimitReceived = lastDateRateLimitReceived, lastDateRateLimitReceived.distance(to: Date()) <= rateLimitTimeOutTimePeriod {
                // E.g. rateLimitTimeOutTimePeriod 10 seconds
                // lastDateRateLimitReceived 30.0 seconds ago -> 30.0 <= 10.0 -> false -> this code not invoked
                // lastDateRateLimitReceived 5.0 seconds ago -> 10.0 - 5.0 -> 5.0
                return rateLimitTimeOutTimePeriod - lastDateRateLimitReceived.distance(to: Date())
            }
            
            // Check if enough requests have been performed where we could have exceeded the rate limit
            guard let oldestRequestAtStartOfTimePeriod = houndServerRequestDates.safeIndex(houndServerRequestDates.count - 1 - numberOfRequestsAllowedInTimePeriod) else {
                return 0.0
            }
            
            // Find the delay in which we wait long enough to perform the next request, so the tail end of the rate limit requests is older than the rate limit period. This ensures that, for examples, we have a 10 second rate limit period where CloudFlare won't allow more than 20 requests, we wait long enough so that 20th request is older than 10 seconds. Ensuring CloudFlare is ready to accept a new request.
            // E.g. rateLimitEvaluationTimePeriod 10 seconds
            // oldestRequestAtStartOfTimePeriod 30.0 seconds ago -> (10.0 - 30.0) -> -20.0 -> 0.0
            // oldestRequestAtStartOfTimePeriod 5.0 seconds ago -> (10.0 - 5.0) -> 5.0 -> 5.0
            return max(0.0, rateLimitEvaluationTimePeriod - oldestRequestAtStartOfTimePeriod.distance(to: Date()))
        }()
        
        guard delayNeededToAvoidRateLimit <= 0.1 else {
            isDelayInProgress = true
            DispatchQueue.global().asyncAfter(deadline: .now() + delayNeededToAvoidRateLimit) {
                self.isDelayInProgress = false
                self.startTask()
            }
            return
        }
        
        guard let dataTask = taskQueue.first else {
            // We have no data tasks to send
            return
        }
        
        // If we successfully for the first element from taskQueue, we can explictely remove that element without fear of crashing
        taskQueue.removeFirst()
        
        houndServerRequestDates.append(Date())
        
        dataTask.resume()
        
        startTask()
    }
    
}
//
//  SurveyFeedbackRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 1/31/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation
import UIKit

enum SurveyFeedbackRequest {
    static var baseURL: URL { FamilyRequest.baseURL.appendingPathComponent("/surveyFeedback")}
    
    /**
     Invoke function when user fills out the feedback survey for why they are cancelling their Hound+ subscription.
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
   */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        userCancellationReason: SubscriptionCancellationReason?,
        userCancellationFeedback: String,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body: [String: CompatibleDataTypeForJSON?] = [
            KeyConstant.surveyFeedbackType.rawValue: SurveyFeedbackType.cancelSubscription.rawValue,
            KeyConstant.surveyFeedbackUserCancellationReason.rawValue: userCancellationReason?.internalValue,
            KeyConstant.surveyFeedbackUserCancellationFeedback.rawValue: userCancellationFeedback
        ]
        
        return create(forErrorAlert: forErrorAlert, forSourceFunction: forSourceFunction, forBody: body, completionHandler: completionHandler)
    }
    
    /**
     Invoke function when user fills out the feedback survey for their experience with Hound
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
   */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        numberOfStars: Int,
        appExperienceFeedback: String,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let body: [String: CompatibleDataTypeForJSON?] = [
            KeyConstant.surveyFeedbackType.rawValue: SurveyFeedbackType.appExperience.rawValue,
            KeyConstant.surveyFeedbackAppExperienceNumberOfStars.rawValue: numberOfStars,
            KeyConstant.surveyFeedbackAppExperienceFeedback.rawValue: appExperienceFeedback
        ]
        
        return create(forErrorAlert: forErrorAlert, forSourceFunction: forSourceFunction, forBody: body) { responseStatus, houndError in
            guard responseStatus != .failureResponse else {
                completionHandler(responseStatus, houndError)
                return
            }
            
            // We successfully submitted the survey for app experience, so track that
            if responseStatus == .successResponse {
                LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted.append(Date())
            }
            
            completionHandler(responseStatus, houndError)
        }
    }

    /**
     Sends a generic surveyFeedback request to the Hound server, appending a variety of device metrics to the passed body
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
   */
    @discardableResult private static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forBody: [String: CompatibleDataTypeForJSON?],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
       
        var forBodyWithDeviceMetrics = forBody
        forBodyWithDeviceMetrics[KeyConstant.surveyFeedbackDeviceMetricModel.rawValue] = UIDevice.current.model
        forBodyWithDeviceMetrics[KeyConstant.surveyFeedbackDeviceMetricSystemVersion.rawValue] = UIDevice.current.systemVersion
        forBodyWithDeviceMetrics[KeyConstant.surveyFeedbackDeviceMetricAppVersion.rawValue] = UIApplication.appVersion
        forBodyWithDeviceMetrics[KeyConstant.surveyFeedbackDeviceMetricLocale.rawValue] = Locale.current.identifier
        
        // All of the previous body should be encapsulated inside a surveyFeedback body
        let body: [String: [String: CompatibleDataTypeForJSON?]] = [ KeyConstant.surveyFeedback.rawValue: forBodyWithDeviceMetrics]
        
        return RequestUtils.genericPostRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body) { _, responseStatus, error in
                completionHandler(responseStatus, error)
        }
    }
}
//
//  TransactionsRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/23/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum TransactionsRequest {

    static var baseURLWithoutParams: URL { FamilyRequest.baseURL.appendingPathComponent("/transactions") }

    /**
     If query is successful, automatically manages FamilyInformation.familySubscriptions and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
    */
    @discardableResult static func get(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {

        RequestUtils.genericGetRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURLWithoutParams,
            forBody: [:]) { responseBody, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                if let result = responseBody?[KeyConstant.result.rawValue] as? [[String: Any?]] {

                    FamilyInformation.clearAllFamilySubscriptions()
                    for subscription in result {
                        FamilyInformation.addFamilySubscription(forSubscription: Subscription(fromBody: subscription))
                    }

                    completionHandler(.successResponse, error)
                }
                else {
                    completionHandler(.failureResponse, error)
                }
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }

    /**
     Sends a request with the user's base64 encoded appStoreRecieptURL for the user to create a subscription.
     If query is successful, automatically manages FamilyInformation.familySubscriptions and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
    */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // Get the receipt if it's available. If the receipt isn't available, we sent through an invalid base64EncodedString, then the server will return us an error
        let base64EncodedReceiptString: String? = {
            guard let appStoreReceiptURL = Bundle.main.appStoreReceiptURL, FileManager.default.fileExists(atPath: appStoreReceiptURL.path), let receiptData = try? Data(contentsOf: appStoreReceiptURL, options: .alwaysMapped) else {
                // Experienced an error, so no base64 encoded string
                return nil
            }

            return receiptData.base64EncodedString(options: [])
        }()

        guard let base64EncodedReceiptString = base64EncodedReceiptString else {
            completionHandler(.failureResponse, nil)
            return nil
        }

        let body: [String: CompatibleDataTypeForJSON?] = [KeyConstant.appStoreReceiptURL.rawValue: base64EncodedReceiptString]

        return RequestUtils.genericPostRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURLWithoutParams,
            forBody: body) { responseBody, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                if let result = responseBody?[KeyConstant.result.rawValue] as? [String: Any?] {
                    let familyActiveSubscription = Subscription(fromBody: result)
                    FamilyInformation.addFamilySubscription(forSubscription: familyActiveSubscription)

                    completionHandler(.successResponse, error)
                }
                else {
                    completionHandler(.failureResponse, error)
                }
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }
}
//
//  ResponseStatus.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/16/22.
//  Copyright © 2022 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum ResponseStatus {
    /// 200...299
    case successResponse
    /// != 200...299, e.g. 400, 404, 500
    case failureResponse
    /// Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
    case noResponse
}
//
//  UserRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/28/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum UserRequest {

    static var baseURL: URL { RequestUtils.baseURL.appendingPathComponent("/user")}
    /**
     If query is successful, automatically sets up UserInformation and UserConfiguration and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func get(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericGetRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: [:]) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    OfflineModeManager.shared.didGetNoResponse(forType: .userRequestGet)
                }
                else if let result = responseBody?[KeyConstant.result.rawValue] as? [String: Any?] {
                    UserInformation.setup(fromBody: result)
                    UserConfiguration.setup(fromBody: result)
                }
                
                completionHandler(responseStatus, error)
        }
    }

    /**
     Creates a user's account on the server
     If query is successful, automatically sets up UserInformation.userId and returns (true, .successResponse, requestId, responseId)
     If query isn't successful, returns (false, .failureResponse, requestId, responseId) or (false, .noResponse, requestId, responseId)
     */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericPostRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: UserConfiguration.createBody(addingOntoBody: UserInformation.createBody(addingOntoBody: nil))) { responseBody, responseStatus, error in

            switch responseStatus {
            case .successResponse:
                if let userId = responseBody?[KeyConstant.result.rawValue] as? String {
                    UserInformation.userId = userId
                    completionHandler(.successResponse, error)
                }
                else {
                    completionHandler(.failureResponse, error)
                }
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }

    /**
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func update(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forBody: [String: CompatibleDataTypeForJSON?],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericPutRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: forBody) { _, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    OfflineModeManager.shared.didGetNoResponse(forType: .userRequestUpdate)
                }
                
                completionHandler(responseStatus, error)
        }
    }

    /**
     If query is successful, automatically invokes PersistenceManager.clearStorageToReloginToAccount() and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func delete(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forBody: [String: CompatibleDataTypeForJSON?] = [:],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericDeleteRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: forBody) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                PersistenceManager.clearStorageToReloginToAccount()
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }
}
//
//  FamilyRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/3/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum FamilyRequest {
    
    static var baseURL: URL { UserRequest.baseURL.appendingPathComponent("/family") }

    /**
     If query is successful, automatically sets up FamilyInformation and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func get(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        return RequestUtils.genericGetRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: [:]) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    completionHandler(responseStatus, error)
                    return
                }
                
                if responseStatus == .noResponse {
                    OfflineModeManager.shared.didGetNoResponse(forType: .familyRequestGet)
                }
                else if let result = responseBody?[KeyConstant.result.rawValue] as? [String: Any?] {
                    FamilyInformation.setup(fromBody: result)
                }
                
                completionHandler(responseStatus, error)
        }
    }

    /**
     Sends a request for the user to create their own family.
     If query is successful, automatically invokes PersistenceManager.clearStorageToRejoinFamily() and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericPostRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: [:]) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                PersistenceManager.clearStorageToRejoinFamily()
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }

    /**
     Update specific piece(s) of the family
     If query is successful, automatically invokes PersistenceManager.clearStorageToRejoinFamily() and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func update(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forBody: [String: CompatibleDataTypeForJSON?],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        let attemptingToJoinFamily = forBody[KeyConstant.familyCode.rawValue] != nil
        
        return RequestUtils.genericPutRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: forBody) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                if attemptingToJoinFamily {
                    // User successfully joined a new family
                    PersistenceManager.clearStorageToRejoinFamily()
                }
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }

    /**
     If the user is a familyMember, lets the user leave the family.
     If the user is a familyHead and are the only member, deletes the family.
     If query is successful, automatically invokes PersistenceManager.clearStorageToRejoinFamily() and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func delete(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forBody: [String: CompatibleDataTypeForJSON?] = [:],
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericDeleteRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: forBody) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                PersistenceManager.clearStorageToRejoinFamily()
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }
}
//
//  AlertRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/18/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum AlertRequest {
    static var baseURL: URL { UserRequest.baseURL.appendingPathComponent("/alert")}

    /**
     Invoke function when user is terminating Hound. Sends query to Hound server that sends APN to user, warning against terminating the app
     If query is successful, automatically DEFAULT-DOES-NOTHING and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
   */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        return RequestUtils.genericPostRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: [:]) { _, responseStatus, error in
            switch responseStatus {
            case .successResponse:
                completionHandler(responseStatus, error)
            case .failureResponse:
                completionHandler(responseStatus, error)
            case .noResponse:
                completionHandler(responseStatus, error)
            }
        }
    }
}
//
//  TypesRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/1/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Static word needed to conform to protocol. Enum preferred to a class as you can't instance an enum that is all static
enum GlobalTypesRequest {

    static var baseURL: URL { RequestUtils.baseURL.appendingPathComponent("/globalTypes")}
    /**
     If query is successful, automatically sets up UserInformation and UserConfiguration and returns (true, .successResponse)
     If query isn't successful, returns (false, .failureResponse) or (false, .noResponse)
     */
    @discardableResult static func get(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        completionHandler: @escaping (ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        RequestUtils.genericGetRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: [:]) { responseBody, responseStatus, error in
                guard responseStatus != .failureResponse else {
                    completionHandler(responseStatus, error)
                    return
                }
                
                if let result = responseBody?[KeyConstant.result.rawValue] as? [String: Any?] {
                    GlobalTypes.shared = GlobalTypes(fromBody: result)
                }
                
                guard GlobalTypes.shared != nil else {
                    completionHandler(.failureResponse, error)
                    return
                }
                
                completionHandler(responseStatus, error)
        }
    }
}
//
//  TriggersRequest.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/14/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import Foundation

enum TriggersRequest {
    
    static var baseURL: URL { DogsRequest.baseURL.appendingPathComponent("/dogTriggers") }
    
    /// Returns an array of reminder trigger bodies under the key "dogTriggers".
    private static func createTriggersBody(
        forDogUUID: UUID,
        forDogTriggers: [Trigger]
    ) -> [String: [[String: CompatibleDataTypeForJSON?]]] {
        var triggerBodies: [[String: CompatibleDataTypeForJSON?]] = []
        for forTrigger in forDogTriggers {
            triggerBodies.append(
                forTrigger.createBody(forDogUUID: forDogUUID)
            )
        }
        let body: [String: [[String: CompatibleDataTypeForJSON?]]] = [
            KeyConstant.dogTriggers.rawValue: triggerBodies
        ]
        return body
    }
    
}

extension TriggersRequest {
    
    // MARK: - Public Functions
    
    /**
     If query is successful, combines client-side and server-side dogTriggers and returns (trigger, .successResponse).
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse).
     */
    @discardableResult static func get(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forTrigger: Trigger,
        completionHandler: @escaping (
            Trigger?,
            ResponseStatus,
            HoundError?
        ) -> Void
    ) -> Progress? {
        let body: [String: CompatibleDataTypeForJSON?] =
        forTrigger.createBody(forDogUUID: forDogUUID)
        
        return RequestUtils.genericGetRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body
        ) { responseBody, responseStatus, error in
            guard responseStatus != .failureResponse else {
                // If there was a failureResponse, there was something purposefully wrong with the request
                completionHandler(nil, responseStatus, error)
                return
            }
            
            // Either completed successfully or no response from the server, we can proceed as usual
            let triggersBody: [[String: Any?]]? = {
                if let array = responseBody?[KeyConstant.result.rawValue] as? [[String: Any?]] {
                    return array
                }
                else if let single = responseBody?[KeyConstant.result.rawValue] as? [String: Any?] {
                    return [single]
                }
                else {
                    return nil
                }
            }()
            
            if responseStatus == .noResponse {
                // If we got no response from a get request, then communicate to OfflineModeManager so it will sync the dogManager from the server when it begins to sync
                OfflineModeManager.shared.didGetNoResponse(
                    forType: .dogManagerGet
                )
            }
            else if let triggerBody = triggersBody?.first {
                // If we got a triggerBody, use it. This can only happen if responseStatus != .noResponse.
                let override = forTrigger.copy() as? Trigger
                completionHandler(
                    Trigger(
                        fromBody: triggerBody,
                        triggerToOverride: override
                    ),
                    responseStatus,
                    error
                )
                return
            }
            
            // Either no response or no new, updated information from the Hound server
            completionHandler(
                forTrigger,
                responseStatus,
                error
            )
        }
    }
    
    /**
     If query is successful, creates triggers and returns (.successResponse).
     If query isn't successful, returns (nil, .failureResponse) or (nil, .noResponse).
     */
    @discardableResult static func create(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forDogTriggers: [Trigger],
        completionHandler: @escaping (
            ResponseStatus,
            HoundError?
        ) -> Void
    ) -> Progress? {
        // There should be triggers to actually create
        guard forDogTriggers.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body = createTriggersBody(
            forDogUUID: forDogUUID,
            forDogTriggers: forDogTriggers
        )
        
        return RequestUtils.genericPostRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body
        ) { responseBody, responseStatus, error in
            // As long as we got a response from the server, it no longers needs synced. Success or failure
            if responseStatus != .noResponse {
                forDogTriggers.forEach { trigger in
                    trigger.offlineModeComponents
                        .updateInitialAttemptedSyncDate(
                            forInitialAttemptedSyncDate: nil
                        )
                }
            }
            
            guard responseStatus != .failureResponse else {
                // If there was a failureResponse, there was something purposefully wrong with the request
                completionHandler(responseStatus, error)
                return
            }
            
            // Either completed successfully or no response from the server, we can proceed as usual
            let triggersBody: [[String: Any?]]? = {
                if let array = responseBody?[KeyConstant.result.rawValue] as? [[String: Any?]] {
                    return array
                }
                else if let single = responseBody?[KeyConstant.result.rawValue] as? [String: Any?] {
                    return [single]
                }
                else {
                    return nil
                }
            }()
            
            if responseStatus == .noResponse {
                // If we got no response, then mark the triggers to be updated later
                forDogTriggers.forEach { trigger in
                    trigger.offlineModeComponents
                        .updateInitialAttemptedSyncDate(
                            forInitialAttemptedSyncDate: Date()
                        )
                }
            }
            else if let bodies = triggersBody {
                // For each body, get the UUID and id. We use the uuid to locate the reminder so we can assign it its id
                bodies.forEach { body in
                    guard let id = body[KeyConstant.triggerId.rawValue] as? Int,
                          let uuidString = body[KeyConstant.triggerUUID.rawValue] as? String,
                          let uuid = UUID.fromString(forUUIDString: uuidString)
                    else {
                        return
                    }
                    
                    forDogTriggers.first(where: { $0.triggerUUID == uuid })?.triggerId = id
                }
            }
            
            completionHandler(responseStatus, error)
        }
    }
    
    @discardableResult static func update(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forDogTriggers: [Trigger],
        completionHandler: @escaping (
            ResponseStatus,
            HoundError?
        ) -> Void
    ) -> Progress? {
        // There should be reminders to actually update
        guard forDogTriggers.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body = createTriggersBody(forDogUUID: forDogUUID, forDogTriggers: forDogTriggers)
        
        return RequestUtils.genericPutRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body
        ) { _, responseStatus, error in
            // As long as we got a response from the server, it no longers needs synced. Success or failure
            if responseStatus != .noResponse {
                forDogTriggers.forEach { trigger in
                    trigger.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: nil)
                }
            }
            
            guard responseStatus != .failureResponse else {
                // If there was a failureResponse, there was something purposefully wrong with the request
                completionHandler(responseStatus, error)
                return
            }
            
            if responseStatus == .noResponse {
                // If we got no response, then mark the reminders to be updated later
                forDogTriggers.forEach { trigger in
                    trigger.offlineModeComponents.updateInitialAttemptedSyncDate(forInitialAttemptedSyncDate: Date())
                }
            }
            
            completionHandler(responseStatus, error)
        }
    }
    
    @discardableResult static func delete(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes = .normal,
        forDogUUID: UUID,
        forTriggerUUIDs: [UUID],
        completionHandler: @escaping (
            ResponseStatus,
            HoundError?
        ) -> Void
    ) -> Progress? {
        // There should be reminders to actually delete
        guard forTriggerUUIDs.count >= 1 else {
            completionHandler(.successResponse, nil)
            return nil
        }
        
        let body: [String: [[String: CompatibleDataTypeForJSON?]]] = {
            var triggerBodies: [[String: CompatibleDataTypeForJSON?]] = []
            for forUUID in forTriggerUUIDs {
                var entry: [String: CompatibleDataTypeForJSON?] = [:]
                entry[KeyConstant.dogUUID.rawValue] = forDogUUID.uuidString
                entry[KeyConstant.triggerUUID.rawValue] = forUUID.uuidString
                triggerBodies.append(entry)
            }
            return [KeyConstant.dogTriggers.rawValue: triggerBodies]
        }()
        
        return RequestUtils.genericDeleteRequest(
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction,
            forURL: baseURL,
            forBody: body
        ) { _, responseStatus, error in
            guard responseStatus != .failureResponse else {
                // If there was a failureResponse, there was something purposefully wrong with the request
                completionHandler(responseStatus, error)
                return
            }
            
            // Either completed successfully or no response from the server, we can proceed as usual
            
            if responseStatus == .noResponse {
                forTriggerUUIDs.forEach { uuid in
                    OfflineModeManager.shared
                        .addDeletedObjectToQueue(forObject:
                                                    OfflineModeDeletedTrigger(
                                                        dogUUID: forDogUUID,
                                                        triggerUUID: uuid,
                                                        deletedDate: Date()))
                }
            }
            
            completionHandler(responseStatus, error)
        }
    }
}
//
//  UserConfiguration.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/7/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

/// Configuration that is local to the app only. If the app is reinstalled then this data should be pulled down from the cloud
final class UserConfiguration: UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    static func persist(toUserDefaults: UserDefaults) {
        toUserDefaults.set(UserConfiguration.interfaceStyle.rawValue, forKey: KeyConstant.userConfigurationInterfaceStyle.rawValue)
        toUserDefaults.set(UserConfiguration.measurementSystem.rawValue, forKey: KeyConstant.userConfigurationMeasurementSystem.rawValue)
        
        toUserDefaults.set(UserConfiguration.notificationSound.rawValue, forKey: KeyConstant.userConfigurationNotificationSound.rawValue)
        
        toUserDefaults.set(UserConfiguration.isNotificationEnabled, forKey: KeyConstant.userConfigurationIsNotificationEnabled.rawValue)
        toUserDefaults.set(UserConfiguration.isLoudNotificationEnabled, forKey: KeyConstant.userConfigurationIsLoudNotificationEnabled.rawValue)
        toUserDefaults.set(UserConfiguration.isLogNotificationEnabled, forKey: KeyConstant.userConfigurationIsLogNotificationEnabled.rawValue)
        toUserDefaults.set(UserConfiguration.isReminderNotificationEnabled, forKey: KeyConstant.userConfigurationIsReminderNotificationEnabled.rawValue)
        
        toUserDefaults.set(UserConfiguration.isSilentModeEnabled, forKey: KeyConstant.userConfigurationIsSilentModeEnabled.rawValue)
        toUserDefaults.set(UserConfiguration.silentModeStartUTCHour, forKey: KeyConstant.userConfigurationSilentModeStartUTCHour.rawValue)
        toUserDefaults.set(UserConfiguration.silentModeEndUTCHour, forKey: KeyConstant.userConfigurationSilentModeEndUTCHour.rawValue)
        toUserDefaults.set(UserConfiguration.silentModeStartUTCMinute, forKey: KeyConstant.userConfigurationSilentModeStartUTCMinute.rawValue)
        toUserDefaults.set(UserConfiguration.silentModeEndUTCMinute, forKey: KeyConstant.userConfigurationSilentModeEndUTCMinute.rawValue)
    }
    
    static func load(fromUserDefaults: UserDefaults) {
        // NOTE: User Configuration is stored on the Hound server and retrieved synced. However, if the user is in offline mode, they will need these values. Therefore, use local storage as a second backup for these values
        
        if let interfaceStyleInt = fromUserDefaults.value(forKey: KeyConstant.userConfigurationInterfaceStyle.rawValue) as? Int {
            UserConfiguration.interfaceStyle = UIUserInterfaceStyle(rawValue: interfaceStyleInt) ?? UserConfiguration.interfaceStyle
        }
        if let measurementSystemInt = fromUserDefaults.value(forKey: KeyConstant.userConfigurationMeasurementSystem.rawValue) as? Int {
            UserConfiguration.measurementSystem = MeasurementSystem(rawValue: measurementSystemInt) ?? UserConfiguration.measurementSystem
        }
        
        UserConfiguration.snoozeLength = fromUserDefaults.value(forKey: KeyConstant.userConfigurationSnoozeLength.rawValue) as? Double ?? UserConfiguration.snoozeLength
        
        UserConfiguration.isNotificationEnabled = fromUserDefaults.value(forKey: KeyConstant.userConfigurationIsNotificationEnabled.rawValue) as? Bool ?? UserConfiguration.isNotificationEnabled
        UserConfiguration.isLoudNotificationEnabled = fromUserDefaults.value(forKey: KeyConstant.userConfigurationIsLoudNotificationEnabled.rawValue) as? Bool ?? UserConfiguration.isLoudNotificationEnabled
        UserConfiguration.isLogNotificationEnabled = fromUserDefaults.value(forKey: KeyConstant.userConfigurationIsLogNotificationEnabled.rawValue) as? Bool ?? UserConfiguration.isLogNotificationEnabled
        UserConfiguration.isReminderNotificationEnabled = fromUserDefaults.value(forKey: KeyConstant.userConfigurationIsReminderNotificationEnabled.rawValue) as? Bool ?? UserConfiguration.isReminderNotificationEnabled
        if let notificationSoundString = fromUserDefaults.value(forKey: KeyConstant.userConfigurationNotificationSound.rawValue) as? String {
            UserConfiguration.notificationSound = NotificationSound(rawValue: notificationSoundString) ?? UserConfiguration.notificationSound
        }
        
        UserConfiguration.isSilentModeEnabled = fromUserDefaults.value(forKey: KeyConstant.userConfigurationIsSilentModeEnabled.rawValue) as? Bool ?? UserConfiguration.isSilentModeEnabled
        UserConfiguration.silentModeStartUTCHour = fromUserDefaults.value(forKey: KeyConstant.userConfigurationSilentModeStartUTCHour.rawValue) as? Int ?? UserConfiguration.silentModeStartUTCHour
        UserConfiguration.silentModeEndUTCHour = fromUserDefaults.value(forKey: KeyConstant.userConfigurationSilentModeEndUTCHour.rawValue) as? Int ?? UserConfiguration.silentModeEndUTCHour
        UserConfiguration.silentModeStartUTCMinute = fromUserDefaults.value(forKey: KeyConstant.userConfigurationSilentModeStartUTCMinute.rawValue) as? Int ?? UserConfiguration.silentModeStartUTCMinute
        UserConfiguration.silentModeEndUTCMinute = fromUserDefaults.value(forKey: KeyConstant.userConfigurationSilentModeEndUTCMinute.rawValue) as? Int ?? UserConfiguration.silentModeEndUTCMinute
    }
    
    // MARK: - Main
    
    /// If OfflineModeManager.shared.shouldUpdateUser is false, sets the UserConfiguration values equal to all the values found in the body.
    static func setup(fromBody body: [String: Any?]) {
        // This is a unique edge case. If the user updated their UserConfiguration (while offline), then terminates Hound, then re-opens Hound, the first thing the app will do is a get request to the Hound server. This would overwrite the user's local changes. Therefore, don't overwrite these changes.
        guard OfflineModeManager.shared.shouldUpdateUser == false else {
            return
        }
        
        if let interfaceStyleInt = body[KeyConstant.userConfigurationInterfaceStyle.rawValue] as? Int, let interfaceStyle = UIUserInterfaceStyle(rawValue: interfaceStyleInt) {
            self.interfaceStyle = interfaceStyle
        }
        if let measurementSystemInt = body[KeyConstant.userConfigurationMeasurementSystem.rawValue] as? Int, let measurementSystem = MeasurementSystem(rawValue: measurementSystemInt) {
            self.measurementSystem = measurementSystem
        }
        
        if let snoozeLength = body[KeyConstant.userConfigurationSnoozeLength.rawValue] as? Double {
            self.snoozeLength = snoozeLength
        }
        
        if let isNotificationEnabled = body[KeyConstant.userConfigurationIsNotificationEnabled.rawValue] as? Bool {
            self.isNotificationEnabled = isNotificationEnabled
        }
        if let isLoudNotificationEnabled = body[KeyConstant.userConfigurationIsLoudNotificationEnabled.rawValue] as? Bool {
            self.isLoudNotificationEnabled = isLoudNotificationEnabled
        }
        if let isLogNotificationEnabled = body[KeyConstant.userConfigurationIsLogNotificationEnabled.rawValue] as? Bool {
            self.isLogNotificationEnabled = isLogNotificationEnabled
        }
        if let isReminderNotificationEnabled = body[KeyConstant.userConfigurationIsReminderNotificationEnabled.rawValue] as? Bool {
            self.isReminderNotificationEnabled = isReminderNotificationEnabled
        }
        if let notificationSoundString = body[KeyConstant.userConfigurationNotificationSound.rawValue] as? String, let notificationSound = NotificationSound(rawValue: notificationSoundString) {
            self.notificationSound = notificationSound
        }
        
        if let isSilentModeEnabled = body[KeyConstant.userConfigurationIsSilentModeEnabled.rawValue] as? Bool {
            self.isSilentModeEnabled = isSilentModeEnabled
        }
        if let silentModeStartUTCHour = body[KeyConstant.userConfigurationSilentModeStartUTCHour.rawValue] as? Int {
            self.silentModeStartUTCHour = silentModeStartUTCHour
        }
        if let silentModeEndUTCHour = body[KeyConstant.userConfigurationSilentModeEndUTCHour.rawValue] as? Int {
            self.silentModeEndUTCHour = silentModeEndUTCHour
        }
        if let silentModeStartUTCMinute = body[KeyConstant.userConfigurationSilentModeStartUTCMinute.rawValue] as? Int {
            self.silentModeStartUTCMinute = silentModeStartUTCMinute
        }
        if let silentModeEndUTCMinute = body[KeyConstant.userConfigurationSilentModeEndUTCMinute.rawValue] as? Int {
            self.silentModeEndUTCMinute = silentModeEndUTCMinute
        }
    }

    // MARK: - In-App Appearance Related
    
    private static var storedInterfaceStyle: UIUserInterfaceStyle = .unspecified
    static var interfaceStyle: UIUserInterfaceStyle {
        get {
            storedInterfaceStyle
        }
        set {
            storedInterfaceStyle = newValue
            NotificationCenter.default.post(name: .didUpdateUserInterfaceStyle, object: nil)
        }
    }
    
    static var measurementSystem: MeasurementSystem = {
        if #available(iOS 16, *) {
            switch Locale.current.measurementSystem {
            case .metric:
                return .metric
            case .us:
                return .imperial
            case .uk:
                return .metric
            default:
                return .metric
            }
        }
        else {
            return Locale.current.usesMetricSystem ? .metric : .imperial
        }
    }()

    // MARK: - Alarm Timing Related

    static var snoozeLength: Double = Double(60 * 5)

    // MARK: - iOS Notification Related

    /// This should be stored on the server as it is important to only send notifications to devices that can use them. This will always be overriden by the user upon reinstall if its state is different in that new install.
    static var isNotificationEnabled: Bool = false

    /// Determines if the app should send the user loud notifications. Loud notification bypass most iPhone settings to play at max volume (Do Not Disturb, ringer off, volume off...)
    static var isLoudNotificationEnabled: Bool = false

    /// Determines if the server should send the user notifications when a log is created (or other similar actions)
    static var isLogNotificationEnabled: Bool = true

    /// Determines if the server should send the user notifications when a reminder's alarm triggers (or other similar actions)
    static var isReminderNotificationEnabled: Bool = true

    /// Sound a notification will play
    static var notificationSound: NotificationSound = NotificationSound.radar

    static var isSilentModeEnabled: Bool = false

    /// Hour of the day, in UTC, that silent mode will start. During silent mode, no notifications will be sent to the user
    static var silentModeStartUTCHour: Int = {
        // We want hour 22 of the day in the users local timezone (10:__ PM)
        let defaultUTCHour = 22
        let hoursFromUTC = Calendar.current.timeZone.secondsFromGMT() / 3600

        // UTCHour + hoursFromUTC = localHour
        // UTCHour = localHour - hoursFromUTC

        var localHour = defaultUTCHour - hoursFromUTC
        // localHour could be negative, so roll over into positive
        localHour += 24
        // Make sure localHour [0, 23]
        localHour = localHour % 24

        return localHour
    }()

    /// Hour of the day, in UTC, that silent mode will end. During silent mode, no notifications will be sent to the user
    static var silentModeEndUTCHour: Int = {
        // We want hour 5 of the day in the users local timezone (5:__ AM)
        let defaultUTCHour = 5
        let hoursFromUTC = Calendar.current.timeZone.secondsFromGMT() / 3600

        // UTCHour + hoursFromUTC = localHour
        // UTCHour = localHour - hoursFromUTC

        var localHour = defaultUTCHour - hoursFromUTC
        // localHour could be negative, so roll over into positive
        localHour += 24
        // Make sure localHour [0, 23]
        localHour = localHour % 24

        return localHour
    }()

    static var silentModeStartUTCMinute: Int = {
        // We want minute 0 of the day in the users local timezone (_:?? AM)
        let defaultUTCMinute = 0
        let minutesFromUTC = (Calendar.current.timeZone.secondsFromGMT() % 3600) / 60

        // UTCMinute + minuteFromUTC = localMinute
        // UTCMinute = localMinute - minuteFromUTC

        var localMinute = defaultUTCMinute - minutesFromUTC
        // localMinute could be negative, so roll over into positive
        localMinute += 60
        // Make sure localMinute [0, 59]
        localMinute = localMinute % 60

        return localMinute
    }()

    static var silentModeEndUTCMinute: Int = {
        // We want minute 0 of the day in the users local timezone (_:?? AM)
        let defaultUTCMinute = 0
        let minutesFromUTC = (Calendar.current.timeZone.secondsFromGMT() % 3600) / 60

        // UTCMinute + minuteFromUTC = localMinute
        // UTCMinute = localMinute - minuteFromUTC

        var localMinute = defaultUTCMinute - minutesFromUTC
        // localMinute could be negative, so roll over into positive
        localMinute += 60
        // Make sure localMinute [0, 59]
        localMinute = localMinute % 60

        return localMinute
    }()
}

extension UserConfiguration {
    // MARK: - Request

    /// Returns an array literal of the user configurations's properties. This is suitable to be used as the JSON body for a HTTP request
    static func createBody(addingOntoBody: [String: CompatibleDataTypeForJSON?]?) -> [String: CompatibleDataTypeForJSON?] {
        var body: [String: CompatibleDataTypeForJSON?] = addingOntoBody ?? [:]

        body[KeyConstant.userConfigurationInterfaceStyle.rawValue] = UserConfiguration.interfaceStyle.rawValue
        body[KeyConstant.userConfigurationMeasurementSystem.rawValue] = UserConfiguration.measurementSystem.rawValue

        body[KeyConstant.userConfigurationSnoozeLength.rawValue] = UserConfiguration.snoozeLength

        body[KeyConstant.userConfigurationIsNotificationEnabled.rawValue] = UserConfiguration.isNotificationEnabled
        body[KeyConstant.userConfigurationIsLoudNotificationEnabled.rawValue] = UserConfiguration.isLoudNotificationEnabled
        body[KeyConstant.userConfigurationIsLogNotificationEnabled.rawValue] = UserConfiguration.isLogNotificationEnabled
        body[KeyConstant.userConfigurationIsReminderNotificationEnabled.rawValue] = UserConfiguration.isReminderNotificationEnabled
        body[KeyConstant.userConfigurationNotificationSound.rawValue] = UserConfiguration.notificationSound.rawValue

        body[KeyConstant.userConfigurationIsSilentModeEnabled.rawValue] = UserConfiguration.isSilentModeEnabled
        body[KeyConstant.userConfigurationSilentModeStartUTCHour.rawValue] = UserConfiguration.silentModeStartUTCHour
        body[KeyConstant.userConfigurationSilentModeEndUTCHour.rawValue] = UserConfiguration.silentModeEndUTCHour
        body[KeyConstant.userConfigurationSilentModeStartUTCMinute.rawValue] = UserConfiguration.silentModeStartUTCMinute
        body[KeyConstant.userConfigurationSilentModeEndUTCMinute.rawValue] = UserConfiguration.silentModeEndUTCMinute
        
        // userNotificationToken is synced through UserRequest.update. Therefore, include it in the UserConfiguration body with the rest of the information that is updated. This is especially important for offline mode, which, if it detects a noResponse in UserRequest.update, re-syncs all of the UserConfiguration.
        body[KeyConstant.userNotificationToken.rawValue] = UserInformation.userNotificationToken
        return body
    }
}
//
//  FamilyInformation.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/5/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// Configuration that is local to the app only. If the app is reinstalled then this data should be pulled down from the cloud
final class FamilyInformation: UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    static func persist(toUserDefaults: UserDefaults) {
        toUserDefaults.set(familyHeadUserId, forKey: KeyConstant.familyHeadUserId.rawValue)
        toUserDefaults.set(familyCode, forKey: KeyConstant.familyCode.rawValue)
        toUserDefaults.set(familyIsLocked, forKey: KeyConstant.familyIsLocked.rawValue)
        
        if let dataPreviousFamilyMembers = try? NSKeyedArchiver.archivedData(withRootObject: previousFamilyMembers, requiringSecureCoding: false) {
            toUserDefaults.set(dataPreviousFamilyMembers, forKey: KeyConstant.previousFamilyMembers.rawValue)
        }
        if let dataFamilyMembers = try? NSKeyedArchiver.archivedData(withRootObject: familyMembers, requiringSecureCoding: false) {
            toUserDefaults.set(dataFamilyMembers, forKey: KeyConstant.familyMembers.rawValue)
        }
        if let dataActiveFamilySubscription = try? NSKeyedArchiver.archivedData(withRootObject: familyActiveSubscription, requiringSecureCoding: false) {
            toUserDefaults.set(dataActiveFamilySubscription, forKey: KeyConstant.familyActiveSubscription.rawValue)
        }
    }
    
    static func load(fromUserDefaults: UserDefaults) {
        FamilyInformation.familyHeadUserId = fromUserDefaults.value(forKey: KeyConstant.familyHeadUserId.rawValue) as? String
        FamilyInformation.familyCode = fromUserDefaults.value(forKey: KeyConstant.familyCode.rawValue) as? String
        FamilyInformation.familyIsLocked = fromUserDefaults.value(forKey: KeyConstant.familyIsLocked.rawValue) as? Bool ?? FamilyInformation.familyIsLocked
       
        if let dataPreviousFamilyMembers: Data = UserDefaults.standard.data(forKey: KeyConstant.previousFamilyMembers.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataPreviousFamilyMembers) {
            unarchiver.requiresSecureCoding = false
            
            if let previousFamilyMembers = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? [FamilyMember] {
                FamilyInformation.previousFamilyMembers = previousFamilyMembers
            }
            else {
                AppDelegate.generalLogger.error("step 2/2 Failed to decode previousFamilyMembers with unarchiver")
            }
        }
        else {
            AppDelegate.generalLogger.error("step 1/2 Failed to decode previousFamilyMembers with unarchiver")
        }
        
        if let dataFamilyMembers: Data = UserDefaults.standard.data(forKey: KeyConstant.familyMembers.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataFamilyMembers) {
            unarchiver.requiresSecureCoding = false
            
            if let familyMembers = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? [FamilyMember] {
                FamilyInformation.familyMembers = familyMembers
            }
            else {
                AppDelegate.generalLogger.error("step 2/2 Failed to decode familyMembers with unarchiver")
            }
        }
        else {
            AppDelegate.generalLogger.error("step 1/2 Failed to decode familyMembers with unarchiver")
        }
        
        if let dataFamilyActiveSubscription: Data = UserDefaults.standard.data(forKey: KeyConstant.familyActiveSubscription.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataFamilyActiveSubscription) {
            unarchiver.requiresSecureCoding = false
            
            if let familyActiveSubscription = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? Subscription {
                // The familyActiveSubscription should always have isActive true. However, decodeBool might decode it as false if no key exists for that value.
                familyActiveSubscription.isActive = true
                FamilyInformation.addFamilySubscription(forSubscription: familyActiveSubscription)
            }
            else {
                AppDelegate.generalLogger.error("step 2/2 Failed to decode familyActiveSubscription with unarchiver")
            }
        }
        else {
            AppDelegate.generalLogger.error("step 1/2 Failed to decode familyActiveSubscription with unarchiver")
        }
    }
    
    // MARK: - Properties
    
    private(set) static var familyHeadUserId: String?

    /// The code used by new users to join the family
    private(set) static var familyCode: String?

    /// If a family is locked, then no new members can join. Only the family head can lock and unlock the family.
    static var familyIsLocked: Bool = false

    /// Users that used to be in the family
    private(set) static var previousFamilyMembers: [FamilyMember] = []

    /// Users that are currently in the family
    private(set) static var familyMembers: [FamilyMember] = []

    private(set) static var familySubscriptions: [Subscription] = []

    // MARK: - Main
    
    /// Sets the FamilyInformation values equal to all the values found in the fromBody. The key for the each fromBody value must match the name of the FamilyInformation property exactly in order to be used. The value must also be able to be converted into the proper data type.
    static func setup(fromBody: [String: Any?]) {
        if let familyHeadUserId = fromBody[KeyConstant.familyHeadUserId.rawValue] as? String {
            self.familyHeadUserId = familyHeadUserId
        }
        if let familyIsLocked = fromBody[KeyConstant.familyIsLocked.rawValue] as? Bool {
            self.familyIsLocked = familyIsLocked
        }
        if let familyCode = fromBody[KeyConstant.familyCode.rawValue] as? String {
            self.familyCode = familyCode
        }
        if let familyMembersBody = fromBody[KeyConstant.familyMembers.rawValue] as? [[String: Any?]] {
            familyMembers.removeAll()
            // get individual bodies for members
            for familyMemberBody in familyMembersBody {
                // convert fromBody into family member
                familyMembers.append(FamilyMember(fromBody: familyMemberBody))
            }

            familyMembers.sort(by: { $0 <= $1 })
        }
        if let previousFamilyMembersBody = fromBody[KeyConstant.previousFamilyMembers.rawValue] as? [[String: Any?]] {
            previousFamilyMembers.removeAll()

            // get individual bodies for previous family members
            for previousFamilyMemberBody in previousFamilyMembersBody {
                // convert fromBody into family member; a previousFamilyMember can't be a family head so pass nil
                previousFamilyMembers.append(FamilyMember(fromBody: previousFamilyMemberBody))
            }

            previousFamilyMembers.sort(by: { $0 <= $1 })

        }
        if let familyActiveSubscriptionBody = fromBody[KeyConstant.familyActiveSubscription.rawValue] as? [String: Any?] {
            let familyActiveSubscription = Subscription(fromBody: familyActiveSubscriptionBody)
            addFamilySubscription(forSubscription: familyActiveSubscription)
        }
    }
    
    // MARK: - Computed Properties
    
    static var familyActiveSubscription: Subscription {
        let potentialSubscription = familySubscriptions.first { subscription in
            subscription.isActive
        }

        return potentialSubscription ?? ClassConstant.SubscriptionConstant.defaultSubscription
    }
    
    // MARK: - Functions
    
    static func findFamilyMember(forUserId userId: String?) -> FamilyMember? {
        guard let userId = userId else {
            return nil
        }

        let matchingFamilyMember: FamilyMember? = FamilyInformation.familyMembers.first { familyMember in
            familyMember.userId == userId
        } ?? FamilyInformation.previousFamilyMembers.first(where: { previousFamilyMember in
            previousFamilyMember.userId == userId
        })

        return matchingFamilyMember
    }

    static func addFamilySubscription(forSubscription subscription: Subscription) {
        // Remove any transactions that match the transactionId
        familySubscriptions.removeAll { existingSubscription in
            existingSubscription.transactionId == subscription.transactionId
        }

        if subscription.isActive {
            // There can only be one active subscription, so remove tag from others
            familySubscriptions.forEach { existingSubscription in
                existingSubscription.isActive = false
            }
            // Active subscription goes at the beginning
            familySubscriptions.insert(subscription, at: 0)
        }
        else {
            // Other subscriptions go at the end
            familySubscriptions.append(subscription)
        }
    }

    static func clearAllFamilySubscriptions() {
        familySubscriptions.removeAll()
    }

}
//
//  UserInformation.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/7/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import KeychainSwift

/// Information specific to the user.
final class UserInformation: UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    /// Persists all of the UserInformation variables to the specified UserDefaults and, selectively, some to KeychainSwift
    static func persist(toUserDefaults: UserDefaults) {
        let keychain = KeychainSwift()
        
        if let userIdentifier = UserInformation.userIdentifier {
            keychain.set(userIdentifier, forKey: KeyConstant.userIdentifier.rawValue)
            UserDefaults.standard.set(userIdentifier, forKey: KeyConstant.userIdentifier.rawValue)
        }

        if let email = UserInformation.userEmail {
            keychain.set(email, forKey: KeyConstant.userEmail.rawValue)
            UserDefaults.standard.set(email, forKey: KeyConstant.userEmail.rawValue)
        }

        if let firstName = UserInformation.userFirstName {
            keychain.set(firstName, forKey: KeyConstant.userFirstName.rawValue)
            UserDefaults.standard.set(firstName, forKey: KeyConstant.userFirstName.rawValue)
        }

        if let lastName = UserInformation.userLastName {
            keychain.set(lastName, forKey: KeyConstant.userLastName.rawValue)
            UserDefaults.standard.set(lastName, forKey: KeyConstant.userLastName.rawValue)
        }
        
        // The important
        toUserDefaults.set(UserInformation.userId, forKey: KeyConstant.userId.rawValue)
        toUserDefaults.set(UserInformation.familyId, forKey: KeyConstant.familyId.rawValue)
        toUserDefaults.set(UserInformation.userAppAccountToken, forKey: KeyConstant.userAppAccountToken.rawValue)
        toUserDefaults.set(UserInformation.userNotificationToken, forKey: KeyConstant.userNotificationToken.rawValue)
    }
    
    /// Loads all of the UserInformation variables from the specified UserDefaults and, selectively, some from KeychainSwift
    static func load(fromUserDefaults: UserDefaults) {
        // These values are retrieved from Sign In With Apple so therefore need to be persisted specially. All other values can be retrieved using these values.
        let keychain = KeychainSwift()
        
        UserInformation.userIdentifier =
        keychain.get(KeyConstant.userIdentifier.rawValue)
        ?? fromUserDefaults.value(forKey: KeyConstant.userIdentifier.rawValue) as? String
        ?? DevelopmentConstant.developmentDatabaseTestUserIdentifier
        ?? UserInformation.userIdentifier
        
        UserInformation.userEmail =
        keychain.get(KeyConstant.userEmail.rawValue)
        ?? fromUserDefaults.value(forKey: KeyConstant.userEmail.rawValue) as? String
        ?? UserInformation.userEmail
        
        UserInformation.userFirstName =
        keychain.get(KeyConstant.userFirstName.rawValue)
        ?? fromUserDefaults.value(forKey: KeyConstant.userFirstName.rawValue) as? String
        ?? UserInformation.userFirstName
        
        UserInformation.userLastName =
        keychain.get(KeyConstant.userLastName.rawValue)
        ?? fromUserDefaults.value(forKey: KeyConstant.userLastName.rawValue) as? String
        ?? UserInformation.userLastName
        
        // MARK: Load Rest of User Information (excluding that which was loaded from the keychain)
        
        UserInformation.userId = fromUserDefaults.value(forKey: KeyConstant.userId.rawValue) as? String ?? UserInformation.userId ?? DevelopmentConstant.developmentDatabaseTestUserId
        
        UserInformation.familyId = fromUserDefaults.value(forKey: KeyConstant.familyId.rawValue) as? String ?? UserInformation.familyId
        
        UserInformation.userAppAccountToken = fromUserDefaults.value(forKey: KeyConstant.userAppAccountToken.rawValue) as? String ?? UserInformation.userAppAccountToken
        
        UserInformation.userNotificationToken = fromUserDefaults.value(forKey: KeyConstant.userNotificationToken.rawValue) as? String ?? UserInformation.userNotificationToken
    }
    
    // MARK: - Properties
    
    static var userId: String?

    static var userIdentifier: String?
    
    static var familyId: String?

    static var userAppAccountToken: String?

    static var userNotificationToken: String?

    static var userEmail: String?

    static var userFirstName: String?

    static var userLastName: String?
    
    // MARK: - Main
    /// Sets the UserInformation values equal to all the values found in the body. The key for the each body value must match the name of the UserConfiguration property exactly in order to be used. The value must also be able to be converted into the proper data type.
    static func setup(fromBody body: [String: Any?]) {
        if let userId = body[KeyConstant.userId.rawValue] as? String {
            self.userId = userId
        }
        if let familyId = body[KeyConstant.familyId.rawValue] as? String {
            self.familyId = familyId
        }
        if let userAppAccountToken = body[KeyConstant.userAppAccountToken.rawValue] as? String {
            self.userAppAccountToken = userAppAccountToken
        }
        if let userNotificationToken = body[KeyConstant.userNotificationToken.rawValue] as? String {
            self.userNotificationToken = userNotificationToken
        }
        if let userEmail = body[KeyConstant.userEmail.rawValue] as? String {
            self.userEmail = userEmail
        }
        if let userFirstName = body[KeyConstant.userFirstName.rawValue] as? String {
            self.userFirstName = userFirstName
        }
        if let userLastName = body[KeyConstant.userLastName.rawValue] as? String {
            self.userLastName = userLastName
        }
    }
    
    // MARK: - Computed Properties
    
    /// The users member's full name. Handles cases where the first name and/or last name may be ""
    static var displayFullName: String {
        let trimmedFirstName = userFirstName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        let trimmedLastName = userLastName?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""

        // check to see if anything is blank
        if trimmedFirstName.isEmpty && trimmedLastName.isEmpty {
            return VisualConstant.TextConstant.unknownName
        }
        // we know one of OR both of the trimmedFirstName and trimmedLast name are != nil &&.isEmpty == false
        else if trimmedFirstName.isEmpty {
            // no first name but has last name
            return trimmedLastName
        }
        else if trimmedLastName.isEmpty {
            // no last name but has first name
            return trimmedFirstName
        }
        else {
            return "\(trimmedFirstName) \(trimmedLastName)"
        }
    }
    
    static var isUserFamilyHead: Bool {
        return FamilyInformation.findFamilyMember(forUserId: UserInformation.userId)?.isUserFamilyHead ?? false
    }
    
    // MARK: - Function
    
    /// Returns an array literal of the user information's properties. This is suitable to be used as the JSON body for a HTTP request
    static func createBody(addingOntoBody: [String: CompatibleDataTypeForJSON?]?) -> [String: CompatibleDataTypeForJSON?] {
        var body: [String: CompatibleDataTypeForJSON?] = addingOntoBody ?? [:]
        
        body[KeyConstant.userEmail.rawValue] = UserInformation.userEmail
        body[KeyConstant.userFirstName.rawValue] = UserInformation.userFirstName
        body[KeyConstant.userLastName.rawValue] = UserInformation.userLastName
        
        return body
    }
}
//
//  LocalConfiguration.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/7/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import StoreKit
import UIKit

/// Configuration that is local to the app only. If the app is reinstalled then this data should be fresh
final class LocalConfiguration: UserDefaultPersistable {
    
    // MARK: - UserDefaultPersistable
    
    /// Persists all of the LocalConfiguration variables and the globalDogManager to the specified UserDefaults
    static func persist(toUserDefaults: UserDefaults) {
        toUserDefaults.set(LocalConfiguration.previousDogManagerSynchronization, forKey: KeyConstant.previousDogManagerSynchronization.rawValue)
        
        if let dogManager = DogManager.globalDogManager, let dataDogManager = try? NSKeyedArchiver.archivedData(withRootObject: dogManager, requiringSecureCoding: false) {
            toUserDefaults.set(dataDogManager, forKey: KeyConstant.dogManager.rawValue)
        }
        
        if let dataLocalPreviousLogCustomActionNames = try? NSKeyedArchiver.archivedData(withRootObject: LocalConfiguration.localPreviousLogCustomActionNames, requiringSecureCoding: false) {
            toUserDefaults.set(dataLocalPreviousLogCustomActionNames, forKey: KeyConstant.localPreviousLogCustomActionNames.rawValue)
        }
        if let dataLocalPreviousReminderCustomActionNames = try? NSKeyedArchiver.archivedData(withRootObject: LocalConfiguration.localPreviousReminderCustomActionNames, requiringSecureCoding: false) {
            toUserDefaults.set(dataLocalPreviousReminderCustomActionNames, forKey: KeyConstant.localPreviousReminderCustomActionNames.rawValue)
        }
        
        toUserDefaults.set(LocalConfiguration.localIsNotificationAuthorized, forKey: KeyConstant.localIsNotificationAuthorized.rawValue)
        
        toUserDefaults.set(LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested, forKey: KeyConstant.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.rawValue)
        
        toUserDefaults.set(LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted, forKey: KeyConstant.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted.rawValue)
        
        toUserDefaults.set(LocalConfiguration.localAppVersionsWithReleaseNotesShown, forKey: KeyConstant.localAppVersionsWithReleaseNotesShown.rawValue)
        
        toUserDefaults.set(LocalConfiguration.localHasCompletedHoundIntroductionViewController, forKey: KeyConstant.localHasCompletedHoundIntroductionViewController.rawValue)
        toUserDefaults.set(LocalConfiguration.localHasCompletedRemindersIntroductionViewController, forKey: KeyConstant.localHasCompletedRemindersIntroductionViewController.rawValue)
        toUserDefaults.set(LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController, forKey: KeyConstant.localHasCompletedFamilyUpgradeIntroductionViewController.rawValue)
        toUserDefaults.set(LocalConfiguration.localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController, forKey: KeyConstant.localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController.rawValue)
        
        // Don't persist value. This is purposefully reset everytime the app reopens
        LocalConfiguration.localDateWhenAppLastEnteredBackground = Date()
    }
    
    /// Load all of the LocalConfiguration variables and the globalDogManager from the specified UserDefaults
    static func load(fromUserDefaults: UserDefaults) {
        LocalConfiguration.previousDogManagerSynchronization = fromUserDefaults.value(forKey: KeyConstant.previousDogManagerSynchronization.rawValue) as? Date ?? LocalConfiguration.previousDogManagerSynchronization
        
        if let dataDogManager: Data = UserDefaults.standard.data(forKey: KeyConstant.dogManager.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataDogManager) {
            unarchiver.requiresSecureCoding = false
            
            if let dogManager = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? DogManager {
                DogManager.globalDogManager = dogManager
            }
            else {
                // if nil, then decode failed or there was an issue. therefore, set the interval back to past so we can refresh from the server
                AppDelegate.generalLogger.error("Failed to decode dogManager with unarchiver")
                DogManager.globalDogManager = nil
                LocalConfiguration.previousDogManagerSynchronization = nil
            }
        }
        else {
            // if nil, then decode failed or there was an issue. therefore, set the interval back to past so we can refresh from the server
            AppDelegate.generalLogger.error("Failed to construct dataDogManager or construct unarchiver for dogManager")
            DogManager.globalDogManager = nil
            LocalConfiguration.previousDogManagerSynchronization = nil
        }
        
        if let dataLocalPreviousLogCustomActionNames: Data = fromUserDefaults.data(forKey: KeyConstant.localPreviousLogCustomActionNames.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataLocalPreviousLogCustomActionNames) {
            unarchiver.requiresSecureCoding = false
            
            LocalConfiguration.localPreviousLogCustomActionNames = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? [PreviousLogCustomActionName] ?? LocalConfiguration.localPreviousLogCustomActionNames
        }
        
        if let dataLocalPreviousReminderCustomActionNames: Data = fromUserDefaults.data(forKey: KeyConstant.localPreviousReminderCustomActionNames.rawValue), let unarchiver = try? NSKeyedUnarchiver.init(forReadingFrom: dataLocalPreviousReminderCustomActionNames) {
            unarchiver.requiresSecureCoding = false
            
            LocalConfiguration.localPreviousReminderCustomActionNames = unarchiver.decodeObject(forKey: NSKeyedArchiveRootObjectKey) as? [PreviousReminderCustomActionName] ?? LocalConfiguration.localPreviousReminderCustomActionNames
        }
        
        LocalConfiguration.localIsNotificationAuthorized =
        fromUserDefaults.value(forKey: KeyConstant.localIsNotificationAuthorized.rawValue) as? Bool
        ?? LocalConfiguration.localIsNotificationAuthorized
        
        LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested =
        fromUserDefaults.value(forKey: KeyConstant.localPreviousDatesUserSurveyFeedbackAppExperienceRequested.rawValue) as? [Date]
        ?? LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceRequested
        
        LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted =
        fromUserDefaults.value(forKey: KeyConstant.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted.rawValue) as? [Date]
        ?? LocalConfiguration.localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted
        
        LocalConfiguration.localPreviousDatesUserReviewRequested =
        fromUserDefaults.value(forKey: KeyConstant.localPreviousDatesUserReviewRequested.rawValue) as? [Date] ?? LocalConfiguration.localPreviousDatesUserReviewRequested
        
        LocalConfiguration.localAppVersionsWithReleaseNotesShown =
        fromUserDefaults.value(forKey: KeyConstant.localAppVersionsWithReleaseNotesShown.rawValue) as? [String]
        ?? LocalConfiguration.localAppVersionsWithReleaseNotesShown
        
        LocalConfiguration.localHasCompletedHoundIntroductionViewController =
        fromUserDefaults.value(forKey: KeyConstant.localHasCompletedHoundIntroductionViewController.rawValue) as? Bool
        ?? LocalConfiguration.localHasCompletedHoundIntroductionViewController
        
        LocalConfiguration.localHasCompletedRemindersIntroductionViewController =
        fromUserDefaults.value(forKey: KeyConstant.localHasCompletedRemindersIntroductionViewController.rawValue) as? Bool
        ?? LocalConfiguration.localHasCompletedRemindersIntroductionViewController
        
        LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController =
        fromUserDefaults.value(forKey: KeyConstant.localHasCompletedFamilyUpgradeIntroductionViewController.rawValue) as? Bool
        ?? LocalConfiguration.localHasCompletedFamilyUpgradeIntroductionViewController
        
        LocalConfiguration.localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController = fromUserDefaults.value(forKey: KeyConstant.localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController.rawValue) as? Bool ?? LocalConfiguration.localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController
    }
    
    // MARK: Sync Related

    /// For our first every dogManager sync, we want to retrieve ever dog, reminder, and log (which can be a LOT of data as accounts accumlate logs over the years). To get everything the family has ever added, we set our last sync as far back in time as it will go. This will retrieve everything
    static var previousDogManagerSynchronization: Date?

    // MARK: Log Related

    /// An array storing the logCustomActionName input by the user. If the user selects a log as 'Custom' then puts in a custom name, it will be tracked here.
    static var localPreviousLogCustomActionNames: [PreviousLogCustomActionName] = []

    /// Add the custom log action name to the stored array of localPreviousLogCustomActionNames. If it is already present, then nothing changes, otherwise override the oldest one
    static func addLogCustomAction(forLogActionType: LogActionType, forLogCustomActionName: String) {
        // make sure its a valid custom type
        guard forLogActionType.allowsCustom else {
            return
        }
        
        // make sure the name actually contains something
        guard forLogCustomActionName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false else {
            return
        }

        // Remove any identical records to this, as we want these to all be unique
        localPreviousLogCustomActionNames.removeAll { previousLogCustomActionName in
            return previousLogCustomActionName.logActionTypeId == forLogActionType.logActionTypeId && previousLogCustomActionName.logCustomActionName == forLogCustomActionName
        }
        
        // Re-add at beginning of array
        localPreviousLogCustomActionNames.insert(PreviousLogCustomActionName(logActionTypeId: forLogActionType.logActionTypeId, logCustomActionName: forLogCustomActionName), at: 0)
        
        // check to see if we are over capacity, if we are then remove the last item
        if localPreviousLogCustomActionNames.count > 5 {
            localPreviousLogCustomActionNames.removeLast()
        }
    }

    // MARK: Reminder Related

    /// An array storing the localPreviousReminderCustomActionNames input by the user. If the user selects a reminder as 'Custom' then puts in a custom name, it will be tracked here.
    static var localPreviousReminderCustomActionNames: [PreviousReminderCustomActionName] = []

    /// Add the custom reminder action name to the stored array of localPreviousReminderCustomActionNames. If it is already present, then nothing changes, otherwise override the oldest one
    static func addReminderCustomAction(forReminderActionType: ReminderActionType, forReminderCustomActionName: String) {
        // make sure its a valid custom type
        guard forReminderActionType.allowsCustom else {
            return
        }
        
        // make sure the name actually contains something
        guard forReminderCustomActionName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false else {
            return
        }

        // Remove any identical records to this, as we want these to all be unique
        localPreviousReminderCustomActionNames.removeAll { previousReminderCustomActionName in
            return previousReminderCustomActionName.reminderActionTypeId == forReminderActionType.reminderActionTypeId && previousReminderCustomActionName.reminderCustomActionName == forReminderCustomActionName
        }
        
        // Re-add at beginning of array
        localPreviousReminderCustomActionNames.insert(PreviousReminderCustomActionName(reminderActionTypeId: forReminderActionType.reminderActionTypeId, reminderCustomActionName: forReminderCustomActionName), at: 0)
        
        // check to see if we are over capacity, if we are then remove the last item
        if localPreviousReminderCustomActionNames.count > 5 {
            localPreviousReminderCustomActionNames.removeLast()
        }
    }

    // MARK: iOS Notification Related

    static var localIsNotificationAuthorized: Bool = false

    // MARK: Alert Related

    /// Used to track when the user was last asked to give survey feedback on their experience with Hound. We add a Date() to the array by default to signify when the app was installed (or the update for this feature was installed)
    static var localPreviousDatesUserSurveyFeedbackAppExperienceRequested: [Date] = []
    
    /// Used to track when the user last provided the survey feedback on their experience with Hound
    static var localPreviousDatesUserSurveyFeedbackAppExperienceSubmitted: [Date] = []

    /// Used to track when the user was shown Apple's request review pop-up that allows the user to one to five star Hound
    static var localPreviousDatesUserReviewRequested: [Date] = []

    /// Keeps track of what Hound versions the release notes have been shown for. For example, if we show the release notes for Hound 2.0.0, then we will store 2.0.0 in the array. This makes sure the release notes are only shown once for a given update
    static var localAppVersionsWithReleaseNotesShown: [String] = []

    /// Keeps track of if the user has viewed AND completed the family introduction view controller (which helps the user setup their first dog)
    static var localHasCompletedHoundIntroductionViewController: Bool = false

    /// Keeps track of if the user has viewed AND completed the reminders introduction view controller (which helps the user setup their first reminders)
    static var localHasCompletedRemindersIntroductionViewController: Bool = false

    /// Keeps track of if the user has viewed AND completed the settings family introduction view controller (which helps notify the user of their family limits)
    static var localHasCompletedFamilyUpgradeIntroductionViewController: Bool = false

    /// Keeps track of if the user has view AND completed the legacy subscription warning view controller (which warns users that the subscription they have is soon to be discontinued).
    static var localHasCompletedDepreciatedVersion1SubscriptionWarningAlertController: Bool = false

    /// Everytime Hound is restarted and entering from a terminated state, this value is set to Date(). Then when the app closes, it is set to Date() again. If Hound is closed for more than a certain time frame, using this variable to track how long it was closed, then we do certain actions, e.g. refresh the dog manager for new updates.
    static var localDateWhenAppLastEnteredBackground: Date = Date()
}
//
//  CompatibleDataTypeForJSON.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/10/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

/// A data type that can be transmitted to / understood by the Hound server through JSON. This means it has to be a standard, primative type which can be undestood (strings, booleans, numbers, nulls, etc.)
protocol CompatibleDataTypeForJSON {}

extension String: CompatibleDataTypeForJSON {}
extension Int: CompatibleDataTypeForJSON {}
/*
extension Int8: CompatibleDataTypeForJSON {}
extension Int16: CompatibleDataTypeForJSON {}
extension Int32: CompatibleDataTypeForJSON {}
extension Int64: CompatibleDataTypeForJSON {}
extension UInt: CompatibleDataTypeForJSON {}
extension UInt8: CompatibleDataTypeForJSON {}
extension UInt16: CompatibleDataTypeForJSON {}
extension UInt32: CompatibleDataTypeForJSON {}
extension UInt64: CompatibleDataTypeForJSON {}
 */
extension Float: CompatibleDataTypeForJSON {}
extension Double: CompatibleDataTypeForJSON {}
extension Bool: CompatibleDataTypeForJSON {}
// now arrays of JSON-compatible elements themselves become JSON-compatible
extension Array: CompatibleDataTypeForJSON where Element: CompatibleDataTypeForJSON {}
extension Dictionary: CompatibleDataTypeForJSON where Key == String, Value: CompatibleDataTypeForJSON {}
//
//  GeneralUIProtocol.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/10/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

protocol GeneralUIProtocol {
    /// Open ended field to be used for extra information if needed in certain use cases
    var properties: [String: CompatibleDataTypeForJSON?] { get set }
}

protocol GeneralUIKitProtocol {
    func setupGeneratedViews()
    func addSubViews()
    func setupConstraints()
}
//
//  UserDefaultPersistable.swift
//  Hound
//
//  Created by Jonathan Xakellis on 2/14/24.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import Foundation

protocol UserDefaultPersistable {
    static func persist(toUserDefaults: UserDefaults)
    static func load(fromUserDefaults: UserDefaults)
}
//
//  IntroductionView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/24/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

/// Modular introduction view with header, description, and content slot.
/// Designed for reuse across pages.
final class IntroductionView: GeneralUIView {
    
    // MARK: - Elements
    
    let backgroundImageView: GeneralUIImageView = {
        let imageView = GeneralUIImageView(huggingPriority: 300, compressionResistancePriority: 300)
        imageView.image = UIImage(named: "darkGreenForestWithMountainsFamilyWalkingDog")
        return imageView
    }()
    
    let whiteBackgroundView: GeneralUIView = {
        let view = GeneralUIView(huggingPriority: 290, compressionResistancePriority: 290)
        view.backgroundColor = .systemBackground
        view.layer.cornerRadius = VisualConstant.LayerConstant.imageCoveringViewCornerRadius
        view.layer.cornerCurve = .continuous
        return view
    }()
    
    let pageHeaderLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 280, compressionResistancePriority: 280)
        label.textAlignment = .center
        label.font = VisualConstant.FontConstant.primaryHeaderLabel
        return label
    }()
    
    let pageDescriptionLabel: GeneralUILabel = {
        let label = GeneralUILabel(huggingPriority: 270, compressionResistancePriority: 270)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        label.textColor = .secondaryLabel
        return label
    }()
    
    let contentView: GeneralUIView = {
        let view = GeneralUIView(huggingPriority: 260, compressionResistancePriority: 260)
        return view
    }()
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        self.backgroundColor = .systemBackground
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        self.addSubview(backgroundImageView)
        self.addSubview(whiteBackgroundView)
        self.addSubview(pageHeaderLabel)
        self.addSubview(pageDescriptionLabel)
        self.addSubview(contentView)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        let overlap: CGFloat = 25.0
        
        // backgroundImageView
        NSLayoutConstraint.activate([
            backgroundImageView.topAnchor.constraint(lessThanOrEqualTo: self.topAnchor),
            backgroundImageView.bottomAnchor.constraint(lessThanOrEqualTo: self.centerYAnchor).withPriority(.defaultHigh),
            backgroundImageView.leadingAnchor.constraint(equalTo: self.leadingAnchor),
            backgroundImageView.trailingAnchor.constraint(equalTo: self.trailingAnchor),
            backgroundImageView.createSquareConstraint()
        ])
        
        // whiteBackgroundView
        NSLayoutConstraint.activate([
            whiteBackgroundView.topAnchor.constraint(equalTo: backgroundImageView.bottomAnchor, constant: -overlap),
            whiteBackgroundView.bottomAnchor.constraint(equalTo: self.bottomAnchor),
            whiteBackgroundView.leadingAnchor.constraint(equalTo: self.leadingAnchor),
            whiteBackgroundView.trailingAnchor.constraint(equalTo: self.trailingAnchor)
        ])
        
        // pageHeaderLabel
        NSLayoutConstraint.activate([
            pageHeaderLabel.topAnchor.constraint(equalTo: whiteBackgroundView.topAnchor, constant: overlap),
            pageHeaderLabel.leadingAnchor.constraint(equalTo: whiteBackgroundView.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            pageHeaderLabel.trailingAnchor.constraint(equalTo: whiteBackgroundView.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            pageHeaderLabel.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.PageHeader.labelMaxHeight),
            pageHeaderLabel.heightAnchor.constraint(equalTo: self.widthAnchor, multiplier: ConstraintConstant.PageHeader.labelHeightMultipler).withPriority(.defaultHigh)
        ])
        
        // pageDescriptionLabel
        NSLayoutConstraint.activate([
            pageDescriptionLabel.topAnchor.constraint(equalTo: pageHeaderLabel.bottomAnchor, constant: ConstraintConstant.PageHeader.vertSpacingToPageDescription),
            pageDescriptionLabel.leadingAnchor.constraint(equalTo: self.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            pageDescriptionLabel.trailingAnchor.constraint(equalTo: self.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset)
        ])
        
        // contentView
        NSLayoutConstraint.activate([
            contentView.topAnchor.constraint(equalTo: pageDescriptionLabel.bottomAnchor, constant: ConstraintConstant.PageHeader.vertSpacingToSection),
            contentView.leadingAnchor.constraint(equalTo: self.safeAreaLayoutGuide.leadingAnchor, constant: ConstraintConstant.Global.contentHoriInset),
            contentView.trailingAnchor.constraint(equalTo: self.safeAreaLayoutGuide.trailingAnchor, constant: -ConstraintConstant.Global.contentHoriInset),
            contentView.bottomAnchor.constraint(equalTo: self.safeAreaLayoutGuide.bottomAnchor, constant: -ConstraintConstant.Global.contentVertInset)
        ])
    }
}
//
//  DropDownUIView.swift
//  DropDownUIView
//
//  Created by ems on 02/05/19.
//  Copyright © 2019 Majesco. All rights reserved.
//

import UIKit

protocol DropDownUIViewDataSource {
    func setupCellForDropDown(cell: UITableViewCell, indexPath: IndexPath, dropDownUIViewIdentifier: String)
    /// Returns number of rows in a given section of the dropDownMenu
    func numberOfRows(forSection: Int, dropDownUIViewIdentifier: String) -> Int
    /// Returns number section in the dropDownMenu
    func numberOfSections(dropDownUIViewIdentifier: String) -> Int

    /// Called when an item is selected in the dropdown menu
    func selectItemInDropDown(indexPath: IndexPath, dropDownUIViewIdentifier: String)
}

final class DropDownUIView: GeneralUIView {

    // MARK: - Static

    /// Leading and trailing inset for labels inside drop down. 8.0 aligns properly with the inset from a  GeneralUILabel
    static let insetForGeneralUILabel: CGFloat = 8.0

    /// Height of each row in the dropdownuiview, should be same height as the GeneralUIlabel that it presents on
    static let rowHeightForGeneralUILabel: CGFloat = 45.0

    // MARK: - Variables

    /// The DropDownIdentifier is to differentiate if you are using multiple Xibs
    private var dropDownUIViewIdentifier: String = "DROP_DOWN"
    // Table View
    private(set) var dropDownTableView: GeneralUITableView?
    private var dropDownViewWidth: CGFloat = 0
    private var dropDownViewOffset: CGFloat = 0
    private var dropDownDataSource: DropDownUIViewDataSource?

    // Other Variables
    private var viewPositionReference: CGRect?
    private(set) var isDown: Bool = false

    // MARK: - DropDown Methods

    /// Make Table View Programatically
    func setupDropDown(forDropDownUIViewIdentifier: String, forDataSource: DropDownUIViewDataSource, forViewPositionReference: CGRect, forOffset: CGFloat, forRowHeight: CGFloat) {
        self.dropDownUIViewIdentifier = forDropDownUIViewIdentifier
        self.dropDownDataSource = forDataSource
        self.viewPositionReference = forViewPositionReference
        self.dropDownViewWidth = forViewPositionReference.width
        self.dropDownViewOffset = forOffset

        // The shadow on self so it can expand as much as it wants, border on dropDownTableView so it and the subviews can be masked / clipped.
        self.shadowColor = UIColor.label
        self.shadowOffset = CGSize(width: 0, height: 2.5)
        self.shadowRadius = 5.0
        self.shadowOpacity = 0.5

        self.frame = CGRect(x: forViewPositionReference.minX, y: forViewPositionReference.maxY + forOffset, width: 0, height: 0)

        let dropDownTableView = GeneralUITableView(frame: CGRect(x: self.frame.minX, y: self.frame.minY, width: 0, height: 0))
        self.dropDownTableView = dropDownTableView

        // Sets Row Height of your Custom XIB
        dropDownTableView.rowHeight = forRowHeight
        dropDownTableView.estimatedRowHeight = forRowHeight
        dropDownTableView.register(DropDownTVC.self, forCellReuseIdentifier: DropDownTVC.reuseIdentifier)

        // The shadow on self so it can expand as much as it wants, border on dropDownTableView so it and the subviews can be masked / clipped.
        dropDownTableView.shouldRoundCorners = true
        dropDownTableView.borderColor = .systemGray2
        dropDownTableView.borderWidth = 0.5

        dropDownTableView.separatorStyle = .none
        dropDownTableView.delegate = self
        dropDownTableView.dataSource = self
        dropDownTableView.allowsSelection = true
        dropDownTableView.isUserInteractionEnabled = true

        self.addSubview(dropDownTableView)
    }

    /// Shows Drop Down Menu, hides it if already present. The height of the dropdown shown will be equal to the rowHeight of the individual dropdown cells multiplied by the numberOfRowsToShow
    func showDropDown(numberOfRowsToShow numberOfRows: CGFloat, animated: Bool) {
        guard isDown == false else {
            self.hideDropDown(animated: animated)
            return
        }

        guard let dropDownTableView = dropDownTableView, let viewPositionReference = viewPositionReference else {
            return
        }

        let heightSpecifiedForNumberOfRows = numberOfRows * dropDownTableView.rowHeight
        let heightNeededToDisplayAllRows: CGFloat = {
            var heightNeeded: CGFloat = 0.0
            let numberOfSections = dropDownDataSource?.numberOfSections(dropDownUIViewIdentifier: self.dropDownUIViewIdentifier) ?? 0
            
            for i in 0..<numberOfSections {
                let numberOfRows = dropDownDataSource?.numberOfRows(forSection: i, dropDownUIViewIdentifier: self.dropDownUIViewIdentifier) ?? 0
                heightNeeded += CGFloat(numberOfRows) * dropDownTableView.rowHeight
            }
            
            return heightNeeded
        }()
        
        self.dropDownTableView?.isScrollEnabled = heightNeededToDisplayAllRows > heightSpecifiedForNumberOfRows
        
        self.dropDownTableView?.reloadData()
        
        isDown = true
        self.frame = CGRect(x: viewPositionReference.minX, y: viewPositionReference.maxY + dropDownViewOffset, width: dropDownViewWidth, height: 0)
        dropDownTableView.frame = CGRect(x: 0, y: 0, width: dropDownViewWidth, height: 0)
        
        // The shadow takes up a certain amount of space, in addition to the size of the dropdown view, so distance to bottom should account for that.
        let distanceToBottomExtraPadForShadow = max((self.shadowRadius ?? 0.0) + (self.shadowOffset?.height ?? 0.0), 0.0)
        // Distance to the bottom of the the superview from the top of our view.
        // This, in essence, is the amount if displayable space we have to work with. Any more than this, and we are trying to display outside the superview.
        let distanceToBottom = max((self.superview?.frame.height ?? 0.0) - self.frame.minY - distanceToBottomExtraPadForShadow, 0.0)
        // First, we don't want to make the drop down larger than the space needed to display all of its content. So we limit its size to the theoretical maximum space it would need to display all of its content
        // Second, we don't want the drop down larger than the available space in the superview. So we cap its size at the distance from the top of the dropDownView to the bottom of the superview.
        let height = min(min(heightSpecifiedForNumberOfRows, heightNeededToDisplayAllRows), distanceToBottom)

        UIView.animate(withDuration: animated ? 0.7 : 0.0, delay: 0, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.05, options: .curveLinear, animations: {
            self.frame.size = CGSize(width: self.dropDownViewWidth, height: height)
            dropDownTableView.frame.size = CGSize(width: self.dropDownViewWidth, height: height)
        })

    }

    /// Hides DropDownMenu
    func hideDropDown(animated: Bool) {
        guard isDown else {
            return
        }

        isDown = false

        UIView.animate(withDuration: animated ? 0.5 : 0, delay: 0, usingSpringWithDamping: 0.8, initialSpringVelocity: 0.3, options: .curveLinear, animations: {
            self.frame.size = CGSize(width: self.dropDownViewWidth, height: 0)
            self.dropDownTableView?.frame.size = CGSize(width: self.dropDownViewWidth, height: 0)
        })
    }
}

// MARK: - Table View Methods

extension DropDownUIView: UITableViewDelegate, UITableViewDataSource {

    func numberOfSections(in tableView: UITableView) -> Int {
        (dropDownDataSource?.numberOfSections(dropDownUIViewIdentifier: self.dropDownUIViewIdentifier) ?? 0)
    }

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        (dropDownDataSource?.numberOfRows(forSection: section, dropDownUIViewIdentifier: self.dropDownUIViewIdentifier) ?? 0)
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell: UITableViewCell = (dropDownTableView?.dequeueReusableCell(withIdentifier: DropDownTVC.reuseIdentifier) ?? GeneralUITableViewCell())

        dropDownDataSource?.setupCellForDropDown(cell: cell, indexPath: indexPath, dropDownUIViewIdentifier: self.dropDownUIViewIdentifier)

        return cell
    }

    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        dropDownDataSource?.selectItemInDropDown(indexPath: indexPath, dropDownUIViewIdentifier: self.dropDownUIViewIdentifier)
    }

}
//
//  DropDownParentDogTableViewCell.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/2/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class DropDownTVC: GeneralUITableViewCell {

    // MARK: - Elements

    let label: GeneralUILabel = {
        let label = GeneralUILabel()
        label.font = VisualConstant.FontConstant.primaryRegularLabel
        return label
    }()

    private var leading: NSLayoutConstraint!
    private var trailing: NSLayoutConstraint!

    // MARK: - Properties
    
    static let reuseIdentifier = "DropDownTVC"

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    private(set) var isCustomSelected: Bool = false

    // MARK: - Functions

    func adjustLeadingTrailing(newConstant: CGFloat) {
        leading.constant = newConstant
        trailing.constant = newConstant
    }

    /// isSelected and setSelected are used and modified by the system when a user physically taps on a cell. If we use either of these, this will mess up our own tracking and processes for the selection process
    func setCustomSelectedTableViewCell(forSelected selected: Bool) {
        // DO NOT INVOKE DEFAULT IMPLEMENTATION OF super.setSelected(selected, animated: animated)
        guard selected != isCustomSelected else {
            return
        }

        isCustomSelected = selected
        UIView.animate(withDuration: VisualConstant.AnimationConstant.toggleSelectUIElement) {
            self.contentView.backgroundColor = selected ? .systemBlue : .systemBackground
            self.label.textColor = selected ? .white : .label
        }

    }

    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }

    override func addSubViews() {
        super.addSubViews()
        contentView.addSubview(label)
    }

    override func setupConstraints() {
        super.setupConstraints()
        leading = label.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 8)
        trailing = label.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -8)
        
        NSLayoutConstraint.activate([
            label.topAnchor.constraint(equalTo: contentView.topAnchor),
            label.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            leading,
            trailing
        ])
    }
}
import UIKit

private extension UIApplication {
    /// Finds the currently visible (topmost) view controller.
    func topMostViewController() -> UIViewController? {
        let keyWindow = windows.first { $0.isKeyWindow }
        guard var top = keyWindow?.rootViewController else { return nil }
        while true {
            if let presented = top.presentedViewController {
                top = presented
            } else if let nav = top as? UINavigationController, let v = nav.visibleViewController {
                top = v
            } else if let tab = top as? UITabBarController, let v = tab.selectedViewController {
                top = v
            } else {
                break
            }
        }
        return top
    }
}

class SizeDebugView: UIView {
    private weak var targetView: UIView?
    private weak var targetVC: UIViewController?
    private let label = UILabel()
    private var cleanupTimer: Timer?
    
    // MARK: – Shared state
    private static let overlays = NSHashTable<SizeDebugView>.weakObjects()
    private static var highlightsVisible = false
    private static var highlightBoxes: [UIView] = []
    
    // MARK: – Init & teardown
    
    init(measuring view: UIView) {
        super.init(frame: .zero)
        targetView = view
        targetVC = view.closestParentViewController
        setupLabel()
        SizeDebugView.overlays.add(self)
        startCleanupLoop()
    }
    
    required init?(coder: NSCoder) { fatalError("not supported") }
    
    deinit { cleanupTimer?.invalidate() }
    
    private func setupLabel() {
        backgroundColor = UIColor.black.withAlphaComponent(0.6)
        label.font = .systemFont(ofSize: 8, weight: .medium)
        label.textColor = .white
        label.isUserInteractionEnabled = true
        addSubview(label)
        
        let tap = UITapGestureRecognizer(target: self, action: #selector(toggleHighlights))
        label.addGestureRecognizer(tap)
        
        layer.zPosition = .greatestFiniteMagnitude
    }
    
    // MARK: – Layout
    
    override func layoutSubviews() {
        super.layoutSubviews()
        guard let target = targetView, let host = superview else { return }
        // update label text
        let w = Int(target.bounds.width), h = Int(target.bounds.height)
        label.text = "\(w)×\(h)"
        label.sizeToFit()
        
        // position over target
        let origin = target.convert(CGPoint.zero, to: host)
        let newSize = CGSize(width: label.frame.width + 4,
                             height: label.frame.height + 4)
        frame = CGRect(origin: origin, size: newSize)
        label.frame.origin = CGPoint(x: 2, y: 2)
    }
    
    // MARK: – Highlight toggle
    
    @objc private func toggleHighlights() {
        // clear existing
        SizeDebugView.highlightBoxes.forEach { $0.removeFromSuperview() }
        SizeDebugView.highlightBoxes.removeAll()
        
        SizeDebugView.highlightsVisible.toggle()
        guard SizeDebugView.highlightsVisible else { return }
        
        // draw new highlight boxes
        for overlay in SizeDebugView.overlays.allObjects {
            guard
                let tgt = overlay.targetView,
                let container = overlay.superview
            else { continue }
            
            let boxFrame = tgt.convert(tgt.bounds, to: container)
            let box = UIView(frame: boxFrame)
            box.backgroundColor = .clear
            box.layer.borderWidth = 2
            box.layer.borderColor = UIColor.red.cgColor
            box.layer.zPosition = .greatestFiniteMagnitude
            box.isUserInteractionEnabled = false
            container.addSubview(box)
            SizeDebugView.highlightBoxes.append(box)
        }
    }
    
    // MARK: – Cleanup loop
    
    private func startCleanupLoop() {
        cleanupTimer = Timer.scheduledTimer(withTimeInterval: 0.05, repeats: true) { [weak self] _ in
            guard
                let self = self,
                let tv = self.targetView,
                let vc = self.targetVC
            else {
                self?.removeOverlay()
                return
            }
            
            // 1) removed from hierarchy?
            if tv.superview == nil {
                removeOverlay(); return
            }
            // 2) VC still topmost?
            if UIApplication.shared.topMostViewController() !== vc {
                removeOverlay(); return
            }
            // 3) still around → update
            self.setNeedsLayout()
        }
    }
    
    private func removeOverlay() {
        cleanupTimer?.invalidate()
        removeFromSuperview()
    }
    
    // MARK: – Installer
    
    static func install(on view: UIView) {
        DispatchQueue.main.async {
            let host = findNonClippingAncestor(of: view) ?? view.superview
            guard let container = host else { return }
            
            // avoid dupes
            if container.subviews.contains(where: {
                ($0 as? SizeDebugView)?.targetView === view
            }) { return }
            
            let overlay = SizeDebugView(measuring: view)
            container.addSubview(overlay)
            overlay.setNeedsLayout()
            overlay.layoutIfNeeded()
        }
    }
    
    private static func findNonClippingAncestor(of view: UIView) -> UIView? {
        var c = view.superview
        while let cand = c {
            if !cand.clipsToBounds { return cand }
            c = cand.superview
        }
        return nil
    }
}
//
//  GeneralUITableViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class GeneralUITableViewController: UITableViewController, GeneralUIProtocol, GeneralUIKitProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - GeneralUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Properties
    
    /// If true, upon viewIsAppearing and viewDidDisappear, the viewController will add or remove itself from the presentation manager's global presenter stack
    var eligibleForGlobalPresenter: Bool = false {
        didSet {
            if eligibleForGlobalPresenter == false {
                PresentationManager.removeGlobalPresenterFromStack(self)
            }
        }
    }
    
    // MARK: - Main
    
    convenience init() {
        self.init(style: .plain)
    }
    
    override func loadView() {
        super.loadView()
        setupGeneratedViews()
    }
    
    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.addGlobalPresenterToStack(self)
        }
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.removeGlobalPresenterFromStack(self)
        }
    }
    
}
//
//  GeneralUIDatePicker.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/13/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class GeneralUIDatePicker: UIDatePicker, GeneralUIProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.contentHorizontalAlignment = .center
        self.contentVerticalAlignment = .center
        self.translatesAutoresizingMaskIntoConstraints = false
        
        SizeDebugView.install(on: self)
    }
    
}
//
//  GeneralUIImageView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/28/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class GeneralUIImageView: UIImageView, GeneralUIProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - Properties
    
    private var hasAdjustedShouldRoundCorners: Bool = false
    /// If true, self.layer.cornerRadius = self.bounds.height / 2 is applied upon bounds change. Otherwise, self.layer.cornerRadius = 0 is applied upon bounds change.
    var shouldRoundCorners: Bool = false {
        didSet {
            self.hasAdjustedShouldRoundCorners = true
            self.updateCornerRoundingIfNeeded()
        }
    }
    
    // MARK: - Override Properties
    
    /// Resize corner radius when the bounds change
    override var bounds: CGRect {
        didSet {
            // Make sure to incur didSet of superclass
            super.bounds = bounds
            self.updateCornerRoundingIfNeeded()
            self.updateScaleImagePointSize()
            self.checkForOversizedFrame()
        }
    }
    
    override var image: UIImage? {
        didSet {
            // Make sure to incur didSet of superclass
            super.image = image
            self.updateScaleImagePointSize()
        }
    }
    
    var shouldAutoAdjustAlpha = false {
        didSet {
            guard let preAdjustmentAlpha = preAdjustmentAlpha else {
                return
            }
            
            // adjust super.alpha to avoid triggering our self.alpha override
            super.alpha = preAdjustmentAlpha
            self.preAdjustmentAlpha = nil
        }
    }
    private var preAdjustmentAlpha: CGFloat?
    override var isUserInteractionEnabled: Bool {
        didSet {
            // Make sure to incur didSet of superclass
            super.isUserInteractionEnabled = isUserInteractionEnabled
            if shouldAutoAdjustAlpha {
                if preAdjustmentAlpha == nil {
                    preAdjustmentAlpha = alpha
                }
                // adjust super.alpha to avoid triggering our self.alpha override
                super.alpha = isUserInteractionEnabled ? 1 : 0.5
            }
        }
    }
    
    override var alpha: CGFloat {
        didSet {
            super.alpha = alpha
            self.preAdjustmentAlpha = alpha
        }
    }
    
    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }
    
    override init(image: UIImage?) {
        super.init(image: image)
        self.applyDefaultSetup()
    }
    
    override init(image: UIImage?, highlightedImage: UIImage?) {
        super.init(image: image, highlightedImage: highlightedImage)
        self.applyDefaultSetup()
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        checkForOversizedFrame()
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.clipsToBounds = true
        self.contentMode = .scaleAspectFit
        self.translatesAutoresizingMaskIntoConstraints = false
        
        SizeDebugView.install(on: self)
        
        updateCornerRoundingIfNeeded()
        updateScaleImagePointSize()
    }
    
    private func updateCornerRoundingIfNeeded() {
        if self.hasAdjustedShouldRoundCorners == true {
            if shouldRoundCorners {
                self.layer.masksToBounds = true
            }
            self.layer.cornerRadius = shouldRoundCorners ? self.bounds.height / 2.0 : 0.0
            self.layer.cornerCurve = .continuous
        }
    }
    
    /// If there is a current, symbol image, scales its point size to the smallest dimension of bounds
    private func updateScaleImagePointSize() {
        guard let image = image, image.isSymbolImage == true else {
            return
        }
        
        let smallestDimension = bounds.height <= bounds.width ? bounds.height : bounds.width
        
        super.image = image.applyingSymbolConfiguration(UIImage.SymbolConfiguration.init(pointSize: smallestDimension))
    }
    
    private func checkForOversizedFrame() {
        let maxReasonableSize: CGFloat = 5000
        if bounds.width > maxReasonableSize || bounds.height > maxReasonableSize {
            AppDelegate.generalLogger.error(
                """
                [GeneralUIImageView] WARNING: Oversized frame detected.
                ImageView Frame: \(self.bounds.width) x \(self.bounds.height)
                Superview: \(String(describing: self.superview))
                Stack: \(Thread.callStackSymbols.joined(separator: "\n"))
                """
            )
        }
    }
    
}
//
//  GeneralUISwitch.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/13/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class GeneralUISwitch: UISwitch, GeneralUIProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.contentHorizontalAlignment = .center
        self.contentVerticalAlignment = .center
        self.translatesAutoresizingMaskIntoConstraints = false
        self.onTintColor = .systemBlue
        
        SizeDebugView.install(on: self)
    }

}
//
//  GeneralUITextView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/30/22.
//  Copyright © 2024 Jonathan Xakellis. All rights reserved.
//

import UIKit

/// Custom UITextView supporting a properly inset placeholder label, rounding, and border styling.
final class GeneralUITextView: UITextView, GeneralUIProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - Properties
    
    private var hasAdjustedShouldRoundCorners: Bool = false
    /// If true, self.layer.cornerRadius = VisualConstant.LayerConstant.defaultCornerRadius. Otherwise, self.layer.cornerRadius = 0.
    var shouldRoundCorners: Bool = false {
        didSet {
            hasAdjustedShouldRoundCorners = true
            updateCornerRoundingIfNeeded()
        }
    }
    
    var borderWidth: Double {
        get { Double(self.layer.borderWidth) }
        set { self.layer.borderWidth = CGFloat(newValue) }
    }
    
    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }
    
    /// Placeholder label shown when text is empty.
    private let placeholderLabel: GeneralUILabel = {
        let label = GeneralUILabel()
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.textColor = .placeholderText
        label.isUserInteractionEnabled = false
        label.translatesAutoresizingMaskIntoConstraints = false
        return label
    }()
    
    private var placeholderTopConstraint: NSLayoutConstraint!
    private var placeholderLeadingConstraint: NSLayoutConstraint!
    private var placeholderTrailingConstraint: NSLayoutConstraint!
    
    /// Space from edge to text/placeholder (matches system if not set elsewhere)
    private var lastKnownTextContainerInset: UIEdgeInsets = .zero
    private var lastKnownLineFragmentPadding: CGFloat = 0
    
    // MARK: - Override Properties
    
    override var isUserInteractionEnabled: Bool {
        didSet {
            super.isUserInteractionEnabled = isUserInteractionEnabled
            self.alpha = isUserInteractionEnabled ? 1 : 0.5
        }
    }
    
    /// Placeholder text (will show if text is empty).
    var placeholder: String? {
        didSet {
            placeholderLabel.text = placeholder
            updatePlaceholderVisibility()
        }
    }
    
    override var text: String! {
        didSet { updatePlaceholderVisibility() }
    }
    
    override var attributedText: NSAttributedString! {
        didSet { updatePlaceholderVisibility() }
    }
    
    override var font: UIFont? {
        didSet {
            placeholderLabel.font = font
        }
    }
    
    override var textAlignment: NSTextAlignment {
        didSet {
            placeholderLabel.textAlignment = textAlignment
        }
    }
    
    override var textContainerInset: UIEdgeInsets {
        didSet {
            super.textContainerInset = textContainerInset
            updatePlaceholderConstraints()
        }
    }
    
    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero, textContainer: nil)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        applyDefaultSetup()
    }
    
    override init(frame: CGRect, textContainer: NSTextContainer?) {
        super.init(frame: frame, textContainer: textContainer)
        applyDefaultSetup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Setup
    
    private func applyDefaultSetup() {
        self.clipsToBounds = true
        self.isMultipleTouchEnabled = true
        self.contentMode = .scaleToFill
        self.textAlignment = .natural
        self.translatesAutoresizingMaskIntoConstraints = false
        self.textContainerInset = UIEdgeInsets(top: 7.5, left: 7.5, bottom: 7.5, right: 7.5)
        self.font = self.font ?? VisualConstant.FontConstant.primaryRegularLabel
        
        placeholderLabel.font = self.font
        placeholderLabel.textAlignment = self.textAlignment
        
        addSubview(placeholderLabel)
        setupPlaceholderConstraints()
        updatePlaceholderConstraints()
        
        NotificationCenter.default.addObserver(self, selector: #selector(textViewDidChangeNotification), name: UITextView.textDidChangeNotification, object: self)
        
        SizeDebugView.install(on: self)
        updateCornerRoundingIfNeeded()
        updatePlaceholderVisibility()
    }
    
    /// Adds constraints for the placeholder label, relative to textContainerInset and lineFragmentPadding.
    private func setupPlaceholderConstraints() {
        // Remove old constraints if they exist (in case font/insets change)
        if placeholderTopConstraint != nil { removeConstraint(placeholderTopConstraint) }
        if placeholderLeadingConstraint != nil { removeConstraint(placeholderLeadingConstraint) }
        if placeholderTrailingConstraint != nil { removeConstraint(placeholderTrailingConstraint) }
        
        let insets = textContainerInset
        let padding = textContainer.lineFragmentPadding
        
        placeholderTopConstraint = placeholderLabel.topAnchor.constraint(equalTo: self.topAnchor, constant: insets.top)
        placeholderLeadingConstraint = placeholderLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: insets.left + padding)
        placeholderTrailingConstraint = placeholderLabel.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: -(insets.right + padding))
        placeholderTopConstraint.isActive = true
        placeholderLeadingConstraint.isActive = true
        placeholderTrailingConstraint.isActive = true
    }
    
    /// Updates the placeholder label's constraints if textContainerInset or lineFragmentPadding changes.
    private func updatePlaceholderConstraints() {
        if placeholderTopConstraint == nil || placeholderLeadingConstraint == nil || placeholderTrailingConstraint == nil { return }
        
        let insets = textContainerInset
        let padding = textContainer.lineFragmentPadding
        
        placeholderTopConstraint.constant = insets.top
        placeholderLeadingConstraint.constant = insets.left + padding
        placeholderTrailingConstraint.constant = -(insets.right + padding)
        layoutIfNeeded()
    }
    
    private func updatePlaceholderVisibility() {
        placeholderLabel.isHidden = !(text?.isEmpty ?? true)
    }
    
    @objc private func textViewDidChangeNotification(_ notification: Notification) {
        updatePlaceholderVisibility()
    }
    
    // MARK: - Trait/Appearance Overrides
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        
        if #available(iOS 13.0, *), traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }
    
    private func updateCornerRoundingIfNeeded() {
        if hasAdjustedShouldRoundCorners {
            if shouldRoundCorners {
                self.layer.masksToBounds = true
            }
            self.layer.cornerRadius = shouldRoundCorners ? VisualConstant.LayerConstant.defaultCornerRadius : 0.0
            self.layer.cornerCurve = .continuous
        }
    }
}
//
//  GeneralHeaderView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/20/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class GeneralHeaderView: GeneralUIView {
    
    // MARK: - Views
    
    private let headerLabel: GeneralUILabel = {
        let label = GeneralUILabel(constraintBasedLayout: false)
        label.numberOfLines = 0
        label.font = VisualConstant.FontConstant.emphasizedSecondaryHeaderLabel
        return label
    }()
    
    // MARK: - Properties
    
    private static let topConstraint = ConstraintConstant.Global.contentVertInset
    private static let heightConstraint = 25.0
    private static let bottomConstraint = ConstraintConstant.Global.contentVertInset
    
    static var cellHeight: Double {
        return topConstraint + heightConstraint + bottomConstraint
    }
    
    // MARK: - Setup
    
    func setTitle(_ title: String) {
        headerLabel.text = title
    }
    
    // MARK: - Setup Elements
    
    override func setupGeneratedViews() {
        super.setupGeneratedViews()
    }
    
    override func addSubViews() {
        super.addSubViews()
        addSubview(headerLabel)
    }
    
    override func setupConstraints() {
        super.setupConstraints()
        
        // Header views inside table views can't use auto layout, so we have to use frames
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        
        let leftInset = CGFloat(ConstraintConstant.Global.contentHoriInset)
        let rightInset = CGFloat(ConstraintConstant.Global.contentHoriInset)
        let width = bounds.width - leftInset - rightInset
        
        // Position the label inside the header, respecting top/bottom insets
        headerLabel.frame = CGRect(
            x: leftInset,
            y: Self.topConstraint,
            width: width,
            height: Self.heightConstraint
        )
    }
}

//
//  GeneralUITabBarController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class GeneralUITabBarController: UITabBarController, GeneralUIProtocol, GeneralUIKitProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - GeneralUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Properties

    /// If true, upon viewIsAppearing and viewDidDisappear, the viewController will add or remove itself from the presentation manager's global presenter stack
    var eligibleForGlobalPresenter: Bool = false {
        didSet {
            if eligibleForGlobalPresenter == false {
                PresentationManager.removeGlobalPresenterFromStack(self)
            }
        }
    }
    
    // MARK: - Main
    
    override func loadView() {
        super.loadView()
        setupGeneratedViews()
    }

    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.addGlobalPresenterToStack(self)
        }
    }

    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.removeGlobalPresenterFromStack(self)
        }
    }

}
//
//  GeneralUITableView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/29/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class GeneralUITableView: UITableView, GeneralUIProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - Properties

    var shouldAutomaticallyAdjustHeight: Bool = false {
        didSet {
            if shouldAutomaticallyAdjustHeight {
                self.invalidateIntrinsicContentSize()
                self.layoutIfNeeded()
            }
        }
    }

    private var hasAdjustedShouldRoundCorners: Bool = false
    /// If true, VisualConstant.LayerConstant.defaultCornerRadius is applied upon bounds change. Otherwise, self.layer.cornerRadius = 0 is applied upon bounds change.
    var shouldRoundCorners: Bool = false {
        didSet {
            self.hasAdjustedShouldRoundCorners = true
            self.updateCornerRoundingIfNeeded()
        }
    }

    var borderWidth: Double {
        get {
            Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }

    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }

    var shadowColor: UIColor? {
        didSet {
            if let shadowColor = shadowColor {
                self.layer.shadowColor = shadowColor.cgColor
            }
        }
    }

    var shadowOffset: CGSize? {
        didSet {
            if let shadowOffset = shadowOffset {
                self.layer.shadowOffset = shadowOffset
            }
        }
    }

    var shadowRadius: CGFloat? {
        didSet {
            if let shadowRadius = shadowRadius {
                self.layer.shadowRadius = shadowRadius
            }
        }
    }

    var shadowOpacity: Float? {
        didSet {
            if let shadowOpacity = shadowOpacity {
                self.layer.shadowOpacity = shadowOpacity
            }
        }
    }

    // MARK: - Override Properties

    override var intrinsicContentSize: CGSize {
        if shouldAutomaticallyAdjustHeight {
            self.layoutIfNeeded()
            return self.contentSize
        }
        else {
            return super.intrinsicContentSize
        }
    }

    override var contentSize: CGSize {
        didSet {
            // Make sure to incur didSet of superclass
            super.contentSize = contentSize
            if shouldAutomaticallyAdjustHeight {
                self.invalidateIntrinsicContentSize()
            }
        }
    }

    override var bounds: CGRect {
        didSet {
            // Make sure to incur didSet of superclass
            super.bounds = bounds
            updateCornerRoundingIfNeeded()
        }
    }

    override var isUserInteractionEnabled: Bool {
        didSet {
            // Make sure to incur didSet of superclass
            super.isUserInteractionEnabled = isUserInteractionEnabled
            self.alpha = isUserInteractionEnabled ? 1 : 0.5
        }
    }

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero, style: .plain)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect, style: UITableView.Style) {
        super.init(frame: frame, style: style)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    // MARK: - Override Functions
    
    private func applyDefaultSetup() {
        self.clipsToBounds = true
        self.contentMode = .scaleToFill
        self.showsHorizontalScrollIndicator = false
        self.showsVerticalScrollIndicator = false
        self.separatorStyle = .none
        self.translatesAutoresizingMaskIntoConstraints = false
        
        SizeDebugView.install(on: self)
        
        updateCornerRoundingIfNeeded()
    }

    override func reloadData() {
        super.reloadData()
        if shouldAutomaticallyAdjustHeight {
            self.invalidateIntrinsicContentSize()
        }
    }

    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)

        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
            if let shadowColor = shadowColor {
                self.layer.shadowColor = shadowColor.cgColor
            }
        }
    }

    // MARK: - Functions

    private func updateCornerRoundingIfNeeded() {
        if self.hasAdjustedShouldRoundCorners == true {
            if shouldRoundCorners {
                self.layer.masksToBounds = true
            }
            self.layer.cornerRadius = shouldRoundCorners ? VisualConstant.LayerConstant.defaultCornerRadius : 0.0
            self.layer.cornerCurve = .continuous
        }
    }

}
//
//  GeneralUITextField.swift
//  Hound
//
//  Created by Jonathan Xakellis on 3/30/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class GeneralUITextField: UITextField, GeneralUIProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]

    // MARK: - Properties

    private var hasAdjustedShouldRoundCorners: Bool = false
    /// If true, self.layer.cornerRadius = VisualConstant.LayerConstant.defaultCornerRadius. Otherwise, self.layer.cornerRadius = 0.
    var shouldRoundCorners: Bool = false {
        didSet {
            self.hasAdjustedShouldRoundCorners = true
            self.updateCornerRoundingIfNeeded()
        }
    }

    var borderWidth: Double {
        get {
            Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }

    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }

    // MARK: - Override Properties

    override var isEnabled: Bool {
        didSet {
            // Make sure to incur didSet of superclass
            super.isEnabled = isEnabled
            self.alpha = isEnabled ? 1 : 0.5
        }
    }

    // MARK: - Main
    
    init(
        huggingPriority: Float = UILayoutPriority.defaultLow.rawValue,
        compressionResistencePriority: Float = UILayoutPriority.defaultLow.rawValue
    ) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistencePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistencePriority), for: .vertical)
        applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Override Functions

    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)

        // UI has changed its appearance to dark/light mode
        if #available(iOS 13.0, *), traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }

    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.contentHorizontalAlignment = .left
        self.contentVerticalAlignment = .center
        self.translatesAutoresizingMaskIntoConstraints = false
        self.textAlignment = .natural
        self.clearsOnBeginEditing = true
        
        self.minimumFontSize = 15
        self.font = VisualConstant.FontConstant.primaryRegularLabel
        
        SizeDebugView.install(on: self)
        
        updateCornerRoundingIfNeeded()
    }

    private func updateCornerRoundingIfNeeded() {
        if self.hasAdjustedShouldRoundCorners == true {
            if shouldRoundCorners {
                self.layer.masksToBounds = true
                self.borderStyle = .roundedRect
            }
            
            self.layer.cornerRadius = shouldRoundCorners ? VisualConstant.LayerConstant.defaultCornerRadius : 0.0
            self.layer.cornerCurve = .continuous
        }
    }

}
//
//  GeneralUIButton.swift
//  Hound
//
//  Created by Jonathan Xakellis on 7/19/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class GeneralUIButton: UIButton, GeneralUIProtocol {

    // MARK: - GeneralUIProtocol

    var properties: [String: CompatibleDataTypeForJSON?] = [:]

    // MARK: - Properties

    private var hasAdjustedShouldRoundCorners: Bool = false
    /// If true, self.layer.cornerRadius = self.bounds.height / 2 is applied upon bounds change. Otherwise, self.layer.cornerRadius = 0 is applied upon bounds change.
    var shouldRoundCorners: Bool = false {
        didSet {
            self.hasAdjustedShouldRoundCorners = true
            self.updateCornerRoundingIfNeeded()
        }
    }

    /// If true, upon .touchUpInside the button will dismiss the closest parent UIViewController.
    var shouldDismissParentViewController: Bool = false {
        didSet {
            if shouldDismissParentViewController {
                self.addTarget(self, action: #selector(dismissParentViewController), for: .touchUpInside)
            }
            else {
                self.removeTarget(self, action: #selector(dismissParentViewController), for: .touchUpInside)
            }
        }
    }
    @objc private func dismissParentViewController() {
        self.closestParentViewController?.dismiss(animated: true)
    }

    var borderWidth: Double {
        get { Double(self.layer.borderWidth) }
        set { self.layer.borderWidth = CGFloat(newValue) }
    }

    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }

    /// When set, this closure will create the NSAttributedString for attributedText and set attributedTitle equal to that. This is necessary because attributedText doesn't support dynamic colors and therefore doesn't change its colors when the UITraitCollection updates. Additionally, this closure is invoked when the UITraitCollection updates to manually make the attributedText support dynamic colors.
    var attributedTextClosure: (() -> NSAttributedString)? {
        didSet {
            if let attributedText = attributedTextClosure?() {
                self.setAttributedTitle(attributedText, for: .normal)
            }
        }
    }

    /// Used in beginSpinning and endSpinning to track state before spin began
    private var beforeSpinTintColor: UIColor?
    /// Used in beginSpinning and endSpinning to track state before spin began
    private var beforeSpinUserInteractionEnabled: Bool?
    /// Used in beginSpinning and endSpinning to track state before spin began
    private var isSpinning: Bool {
        beforeSpinTintColor != nil || beforeSpinUserInteractionEnabled != nil
    }

    var backgroundCircleTintColor: UIColor? {
        didSet {
            updateBackgroundCircle()
        }
    }

    /// Using UIImageView to avoid button recursion/layout issues.
    private var backgroundCircleView: UIImageView?

    // MARK: - Override Properties

    /// Resize corner radius when the bounds change
    override var bounds: CGRect {
        didSet {
            super.bounds = bounds
            self.updateCornerRoundingIfNeeded()
            self.updateScaleImagePointSize()
            self.updateBackgroundCircle()
        }
    }

    override var isEnabled: Bool {
        didSet {
            super.isEnabled = isEnabled
            self.alpha = isEnabled ? 1 : 0.5
        }
    }

    override var isHidden: Bool {
        didSet {
            super.isHidden = isHidden
            backgroundCircleView?.isHidden = isHidden
        }
    }

    // MARK: - Main

    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        self.applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    // MARK: - Override Functions

    override func setImage(_ image: UIImage?, for state: UIControl.State) {
        super.setImage(image, for: state)
        updateScaleImagePointSize()
    }

    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
            if let attributedText = attributedTextClosure?() {
                self.setAttributedTitle(attributedText, for: .normal)
            }
        }
    }

    override func layoutSubviews() {
        super.layoutSubviews()
        // Check for accidentally huge frames
        checkForOversizedFrame()
    }

    // MARK: - Functions

    private func applyDefaultSetup() {
        self.contentHorizontalAlignment = .center
        self.contentVerticalAlignment = .center
        self.contentMode = .scaleToFill
        self.translatesAutoresizingMaskIntoConstraints = false
        
        SizeDebugView.install(on: self)

        updateCornerRoundingIfNeeded()
        updateScaleImagePointSize()
    }

    private func updateCornerRoundingIfNeeded() {
        if self.hasAdjustedShouldRoundCorners == true {
            if shouldRoundCorners {
                self.layer.masksToBounds = true
            }
            self.layer.cornerRadius = shouldRoundCorners ? self.bounds.height / 2.0 : 0.0
            self.layer.cornerCurve = .continuous
        }
    }

    /// If there is a current, symbol image, scales its point size to the smallest dimension of bounds
    private func updateScaleImagePointSize() {
        guard let currentImage = currentImage, currentImage.isSymbolImage == true else {
            return
        }
        let smallestDimension = bounds.height <= bounds.width ? bounds.height : bounds.width
        super.setImage(currentImage.applyingSymbolConfiguration(UIImage.SymbolConfiguration.init(pointSize: smallestDimension)), for: .normal)
    }

    private func updateBackgroundCircle() {
        guard let backgroundCircleTintColor = backgroundCircleTintColor else {
            // Remove background circle if tint is cleared
            backgroundCircleView?.removeFromSuperview()
            backgroundCircleView = nil
            return
        }

        // If it doesn't exist, create it and insert below imageView
        if backgroundCircleView == nil {
            let image = UIImageView(image: UIImage(systemName: "circle.fill"))
            image.isUserInteractionEnabled = false
            if let imageView = imageView {
                                insertSubview(image, belowSubview: imageView)
                            }
                            else {
                                addSubview(image)
                            }
            
            backgroundCircleView = image
        }

        // Update color and frame each time
        backgroundCircleView?.tintColor = backgroundCircleTintColor

        let multiplier = 1.05
        let width = bounds.width / multiplier
        let height = bounds.height / multiplier
        let adjustedBounds = CGRect(
            x: (bounds.width / 2.0) - (width / 2),
            y: (bounds.height / 2.0) - (height / 2),
            width: width,
            height: height)

        backgroundCircleView?.frame = adjustedBounds
    }

    func beginSpinning() {
        guard isSpinning == false else { return }
        beforeSpinUserInteractionEnabled = isUserInteractionEnabled
        isUserInteractionEnabled = false
        beforeSpinTintColor = tintColor
        tintColor = UIColor.systemGray2

        spin()

        func spin() {
            guard isSpinning == true else { return }
            // begin spin
            UIView.animate(withDuration: VisualConstant.AnimationConstant.spinUIElement, delay: 0, options: .curveLinear) {
                self.transform = CGAffineTransform(rotationAngle: CGFloat.pi)
            } completion: { _ in
                guard self.isSpinning == true else { return }
                // end spin
                UIView.animate(withDuration: VisualConstant.AnimationConstant.spinUIElement, delay: 0, options: .curveLinear) {
                    self.transform = CGAffineTransform(rotationAngle: CGFloat.pi * 2.0)
                } completion: { _ in
                    guard self.isSpinning == true else { return }
                    spin()
                }
            }
        }
    }

    func endSpinning() {
        guard isSpinning == true else { return }
        transform = .identity
        if let beforeSpinTintColor = beforeSpinTintColor {
            tintColor = beforeSpinTintColor
            self.beforeSpinTintColor = nil
        }
        if let beforeSpinUserInteractionEnabled = beforeSpinUserInteractionEnabled {
            isUserInteractionEnabled = beforeSpinUserInteractionEnabled
            self.beforeSpinUserInteractionEnabled = nil
        }
    }

    // MARK: - Debugging

    /// Logs a warning if the frame size is unreasonably large, indicating a likely constraint or layout issue
    private func checkForOversizedFrame() {
        let maxReasonableSize: CGFloat = 5000
        if bounds.width > maxReasonableSize || bounds.height > maxReasonableSize {
            AppDelegate.generalLogger.error(
                """
                [GeneralUIButton] WARNING: Oversized frame detected.
                Button Frame: \(self.bounds.width) x \(self.bounds.height)
                Superview: \(String(describing: self.superview))
                Stack: \(Thread.callStackSymbols.joined(separator: "\n"))
                """
            )
        }
    }

}

extension GeneralUIButton {
    func createScreenWideHeightMultiplier () -> NSLayoutConstraint {
        return self.heightAnchor.constraint(equalTo: self.widthAnchor, multiplier: ConstraintConstant.Button.screenWideHeightMultiplier).withPriority(.defaultHigh)
    }
    func createScrenWideMaxHeight() -> NSLayoutConstraint {
        return self.heightAnchor.constraint(lessThanOrEqualToConstant: ConstraintConstant.Button.screenWideMaxHeight)
    }
}
//
//  GeneralUILabel.swift
//  Hound
//
//  Created by Jonathan Xakellis on 5/3/21.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class GeneralUILabel: UILabel, GeneralUIProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]

    // MARK: - Properties
    
    /// If shouldRoundCorners == true, then this variable dictates the cornerRadius.If true, then cornerRadius = self.bounds.height / 2.0. If false, cornerRadius = VisualConstant.LayerConstant.defaultCornerRadius.
    var isRoundingToCircle: Bool = false {
        didSet {
            self.updateCornerRoundingIfNeeded()
        }
    }

    private var hasAdjustedShouldRoundCorners: Bool = false
    /// If true, the corners of the view are rounded, depending upon the value of isRoundingToCircle. If false, cornerRadius = 0.
    var shouldRoundCorners: Bool = false {
        didSet {
            self.hasAdjustedShouldRoundCorners = true
            self.updateCornerRoundingIfNeeded()
        }
    }

    var borderWidth: Double {
        get {
            Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }

    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }

    private let placeholderLabelSpacing: String = "  "
    private var placeholderLabel: UILabel?
    /// placeholder is a second GeneralUILabel that is added as a subview to this GeneralUILabel. It acts as temporary inlaid text until an actual value is input
    var placeholder: String? {
        get {
            var placeholderText: String?

            if let placeholderLabel = placeholderLabel {
                var withRemovedPadding = placeholderLabel.text
                withRemovedPadding?.removeFirst(2)
                placeholderText = withRemovedPadding
            }

            return placeholderText
        }
        set {
            guard let placeholderLabel = placeholderLabel else {
                // We do not have a placeholderLabel yet
                if let newValue = newValue {
                    // Because this is our first time making a placeholderLabel, text doesn't have the two space padding on the front of it. We do this step first because if we set self.placeholderLabel to something that isn't nil, the special logic for text starts (which removes the first two characters).
                    if let text = self.text {
                        self.text = placeholderLabelSpacing.appending(text)
                    }

                    // We have placeholder text, so make a placeholderLabel
                    let placeholderLabel = UILabel()

                    placeholderLabel.text = placeholderLabelSpacing.appending(newValue)
                    placeholderLabel.sizeToFit()

                    placeholderLabel.font = self.font
                    placeholderLabel.textColor = UIColor.placeholderText
                    self.placeholderLabel = placeholderLabel

                    self.updatePlaceholderLabelIsHidden()

                    self.addSubview(placeholderLabel)
                    self.updatePlaceholderLabelFrame()
                }

                return
            }

            // We have a placeholderLabel, update it's text
            if let newValue = newValue {
                // add two space offset to placeholder label.
                placeholderLabel.text = placeholderLabelSpacing.appending(newValue)
            }
            else {
                placeholderLabel.text = nil
            }

            placeholderLabel.sizeToFit()
        }
    }

    /// When set, this closure will create the NSAttributedString for attributedText and set attributedTet equal to that. This is necessary because attributedText doesn't support dynamic colors and therefore doesn't change its colors when the UITraitCollection updates. Additionally, this closure is invoke when the UITraitCollection updates to manually make the attributedText support dynamic colors
    var attributedTextClosure: (() -> NSAttributedString)? {
        didSet {
            if let attributedText = attributedTextClosure?() {
                self.attributedText = attributedText
            }
        }
    }

    // MARK: - Override Properties

    override var bounds: CGRect {
        didSet {
            super.bounds = bounds
            self.updatePlaceholderLabelFrame()
        }
    }

    override var text: String? {
        get {
            var text = super.text
            if placeholder != nil {
                text?.removeFirst(2)
            }
            return text
        }
        set {
            if let newValue = newValue {
                super.text = placeholder != nil ? placeholderLabelSpacing.appending(newValue) : newValue
            }
            else {
                super.text = nil
            }

            guard let placeholderLabel = placeholderLabel else {
                return
            }

            guard let placeholderLabelText = placeholderLabel.text, placeholderLabelText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false else {
                placeholderLabel.isHidden = true
                return
            }

            updatePlaceholderLabelIsHidden()
        }
    }

    override var isEnabled: Bool {
        didSet {
            // Make sure to incur didSet of superclass
            super.isEnabled = isEnabled
            self.alpha = isEnabled ? 1 : 0.5
        }
    }

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue, constraintBasedLayout: Bool = true) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup(constraintBasedLayout: constraintBasedLayout)
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup(constraintBasedLayout: nil)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Override Functions

    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)

        // UI has changed its appearance to dark/light mode
        if #available(iOS 13.0, *), traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
            if let attributedText = attributedTextClosure?() {
                self.attributedText = attributedText
            }
        }
    }

    // MARK: - Functions
    
    private func applyDefaultSetup(constraintBasedLayout: Bool?) {
        self.contentMode = .left
        self.textAlignment = .natural
        self.lineBreakMode = .byTruncatingTail
        self.baselineAdjustment = .alignBaselines
        self.adjustsFontSizeToFitWidth = true
        self.translatesAutoresizingMaskIntoConstraints = constraintBasedLayout == false ? true : false
        self.minimumScaleFactor = 0.875
        
        SizeDebugView.install(on: self)
        
        updateCornerRoundingIfNeeded()
    }

    private func updateCornerRoundingIfNeeded() {
        if self.hasAdjustedShouldRoundCorners == true {
            if shouldRoundCorners {
                self.layer.masksToBounds = true
            }
            
            let cornerRadiusIfRounding = isRoundingToCircle ? self.bounds.height / 2.0 : VisualConstant.LayerConstant.defaultCornerRadius
            self.layer.cornerRadius = shouldRoundCorners ? cornerRadiusIfRounding : 0.0
            self.layer.cornerCurve = .continuous
        }
    }

    private func updatePlaceholderLabelFrame() {
        placeholderLabel?.frame = self.bounds
    }

    private func updatePlaceholderLabelIsHidden() {
        // If text isn't nil and has a non-empty string, we want to hide the placeholder (since the place it was holding for now has text in it)
        placeholderLabel?.isHidden = self.text != nil && self.text?.trimmingCharacters(in: .whitespaces).isEmpty == false
    }
}
//
//  GeneralUIViewController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 11/21/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class GeneralUIViewController: UIViewController, GeneralUIProtocol, GeneralUIKitProtocol {
    
    // TODO FUTURE add property to allow view controller to be swiped back on to dismiss
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - GeneralUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Properties
    
    /// If true, upon viewIsAppearing and viewDidDisappear, the viewController will add or remove itself from the presentation manager's global presenter stack
    var eligibleForGlobalPresenter: Bool = false {
        didSet {
            if eligibleForGlobalPresenter == false {
                PresentationManager.removeGlobalPresenterFromStack(self)
            }
        }
    }
    
    // MARK: - Main
    
    override func loadView() {
        super.loadView()
        setupGeneratedViews()
    }

    override func viewIsAppearing(_ animated: Bool) {
        super.viewIsAppearing(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.addGlobalPresenterToStack(self)
        }
    }

    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        if eligibleForGlobalPresenter {
            PresentationManager.removeGlobalPresenterFromStack(self)
        }
    }

}
//
//  GeneralUIView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/2/23.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

class GeneralUIView: UIView, GeneralUIProtocol, GeneralUIKitProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - GeneralUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Properties

    private var hasAdjustedShouldRoundCorners: Bool = false
    /// If true, self.layer.cornerRadius = VisualConstant.LayerConstant.defaultCornerRadius. Otherwise, self.layer.cornerRadius = 0.
    var shouldRoundCorners: Bool = false {
        didSet {
            self.hasAdjustedShouldRoundCorners = true
            self.updateCornerRoundingIfNeeded()
        }
    }

   var borderWidth: Double {
        get {
            Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }

    var borderColor: UIColor? {
        didSet {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
        }
    }

    var shadowColor: UIColor? {
        didSet {
            if let shadowColor = shadowColor {
                self.layer.shadowColor = shadowColor.cgColor
            }
        }
    }

    var shadowOffset: CGSize? {
        didSet {
            if let shadowOffset = shadowOffset {
                self.layer.shadowOffset = shadowOffset
            }
        }
    }

    var shadowRadius: CGFloat? {
        didSet {
            if let shadowRadius = shadowRadius {
                self.layer.shadowRadius = shadowRadius
            }
        }
    }

    var shadowOpacity: Float? {
        didSet {
            if let shadowOpacity = shadowOpacity {
                self.layer.shadowOpacity = shadowOpacity
            }
        }
    }

    // MARK: - Override Properties

    override var bounds: CGRect {
        didSet {
            // Make sure to incur didSet of superclass
            super.bounds = bounds
            updateCornerRoundingIfNeeded()
        }
    }

    override var isUserInteractionEnabled: Bool {
        didSet {
            // Make sure to incur didSet of superclass
            super.isUserInteractionEnabled = isUserInteractionEnabled
            self.alpha = isUserInteractionEnabled ? 1 : 0.5
        }
    }

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Override Functions
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)

        // UI has changed its appearance to dark/light mode
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            if let borderColor = borderColor {
                self.layer.borderColor = borderColor.cgColor
            }
            if let shadowColor = shadowColor {
                self.layer.shadowColor = shadowColor.cgColor
            }
        }
    }

    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.translatesAutoresizingMaskIntoConstraints = false
        
        setupGeneratedViews()
        
        SizeDebugView.install(on: self)
        
        updateCornerRoundingIfNeeded()
    }

    private func updateCornerRoundingIfNeeded() {
        if self.hasAdjustedShouldRoundCorners == true {
            if shouldRoundCorners {
                self.layer.masksToBounds = true
            }
            self.layer.cornerRadius = shouldRoundCorners ? VisualConstant.LayerConstant.defaultCornerRadius : 0.0
            self.layer.cornerCurve = .continuous
        }
    }
}
//
//  GeneralUITableViewCell.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class GeneralUITableViewCell: UITableViewCell, GeneralUIProtocol, GeneralUIKitProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - GeneralUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        
        applyDefaultSetup()
        
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }
    
    // MARK: - Main
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        setupGeneratedViews()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    override func awakeFromNib() {
        super.awakeFromNib()
        fatalError("XIB is not supported")
    }
    
    // MARK: - Functions
    
    private func applyDefaultSetup() {
        selectionStyle = .none
        backgroundColor = .clear
        contentView.backgroundColor = .clear
        selectedBackgroundView?.backgroundColor = .clear
    }

}
//
//  GeneralUIProgressView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/13/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

final class GeneralUIProgressView: UIProgressView, GeneralUIProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }
    
    // MARK: - Override Functions
    
    private func applyDefaultSetup() {
        self.contentMode = .scaleToFill
        self.translatesAutoresizingMaskIntoConstraints = false
        
        SizeDebugView.install(on: self)
    }

}
//
//  GeneralUIScrollView.swift
//  Hound
//
//  Created by Jonathan Xakellis on 6/6/25.
//  Copyright © 2025 Jonathan Xakellis. All rights reserved.
//

import UIKit

class GeneralUIScrollView: UIScrollView, GeneralUIProtocol, GeneralUIKitProtocol {
    
    // MARK: - GeneralUIProtocol
    
    var properties: [String: CompatibleDataTypeForJSON?] = [:]
    
    // MARK: - GeneralUIProtocol
    
    private var didSetupGeneratedViews = false
    internal func setupGeneratedViews() {
        guard !didSetupGeneratedViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupGeneratedViews = true
        addSubViews()
        setupConstraints()
    }
    
    private var didAddSubViews = false
    internal func addSubViews() {
        guard !didAddSubViews else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didAddSubViews = true
        return
    }
    
    private var didSetupConstraints = false
    internal func setupConstraints() {
        guard !didSetupConstraints else {
            AppDelegate.generalLogger.warning("Attempting to re-invoke setupGeneratedViews for \(String(describing: type(of: self)))")
            return
        }
        didSetupConstraints = true
        return
    }

    // MARK: - Override Properties

    // MARK: - Main
    
    init(huggingPriority: Float = UILayoutPriority.defaultLow.rawValue, compressionResistancePriority: Float = UILayoutPriority.defaultLow.rawValue) {
        super.init(frame: .zero)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .horizontal)
        self.setContentHuggingPriority(UILayoutPriority(huggingPriority), for: .vertical)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .horizontal)
        self.setContentCompressionResistancePriority(UILayoutPriority(compressionResistancePriority), for: .vertical)
        self.applyDefaultSetup()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        applyDefaultSetup()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        fatalError("NIB/Storyboard is not supported")
    }

    // MARK: - Functions
    
    private func applyDefaultSetup() {
        self.clipsToBounds = true
        self.isMultipleTouchEnabled = true
        self.contentMode = .scaleToFill
        self.showsHorizontalScrollIndicator = false
        self.showsVerticalScrollIndicator = false
        self.translatesAutoresizingMaskIntoConstraints = false
        
        SizeDebugView.install(on: self)
        
        setupGeneratedViews()
    }
}
//
//  AlarmUIAlertController.swift
//  Hound
//
//  Created by Jonathan Xakellis on 8/23/22.
//  Copyright © 2023 Jonathan Xakellis. All rights reserved.
//

import Foundation
import UIKit

final class AlarmUIAlertController: UIAlertController {
    
    // MARK: - Properties

    /// If nil, this AlarmUIAlertController has not been combined. If non-nil, this AlarmUIAlertController has been combined into another AlarmUIAlertController.
    private(set) var absorbedIntoAlarmAlertController: AlarmUIAlertController?

    /// The dogUUID that the AlarmUIAlertController is alerting about
    private(set) var dogUUID: UUID?

    /// The reminder(s) that the AlarmUIAlertController is alerting about
    private(set) var reminders: [Reminder]?

    // MARK: - Main

    /// UIAlertController can't be subclassed. Therefore, we can't override the init functions.
    func setup(forDogUUID: UUID, forReminder: Reminder) {
        self.dogUUID = forDogUUID
        self.reminders = [forReminder]
    }

    // MARK: - Functions

    /// If the provided AlarmUIAlertController contains matching data, incorporates that data into self and removes the data from the provided AlarmUIAlertController. Returns true if successfully absorbed other view controller.
    func absorb(_ absorbFromAlarmAlertController: AlarmUIAlertController) -> Bool {
        // We don't want to absorb a AlarmUIAlertController that has already been AlarmUIAlertController
        guard absorbFromAlarmAlertController.absorbedIntoAlarmAlertController == nil else {
            return false
        }

        // Check that both AlarmUIAlertController both are setup with reminders
        guard let selfReminder = reminders?.first, let absorbedReminder = absorbFromAlarmAlertController.reminders?.first else {
            return false
        }
        
        // Check that both AlarmUIAlertController both reference the same dog
        guard let selfDogUUID = dogUUID, let absorbedDogUUID = absorbFromAlarmAlertController.dogUUID, selfDogUUID == absorbedDogUUID else {
            return false
        }

        // Check that both AlarmUIAlertController both reference reminders with the same reminderActionType
        guard selfReminder.reminderActionType == absorbedReminder.reminderActionType  else {
            return false
        }

        // If reminderActionType is .custom, check that both AlarmUIAlertController both reference reminders with the same reminderCustomActionName
        guard selfReminder.reminderActionType.allowsCustom == false || (selfReminder.reminderCustomActionName == absorbedReminder.reminderCustomActionName) else {
            return false
        }

        // Both AlarmUIAlertController are the same. Add their components together
        self.reminders = (self.reminders ?? []) + (absorbFromAlarmAlertController.reminders ?? [])

        // absorbFromAlarmAlertController should now be dismantled
        absorbFromAlarmAlertController.absorbedIntoAlarmAlertController = self
        absorbFromAlarmAlertController.dogUUID = nil
        absorbFromAlarmAlertController.reminders = nil

        return true
    }
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2018 Denis Kozhukhov
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit
import SnapKit

open class FloatingNotificationBanner: GrowingNotificationBanner {
    
    public init(
        title: String? = nil,
        subtitle: String? = nil,
        titleFont: UIFont? = nil,
        titleColor: UIColor? = nil,
        titleTextAlign: NSTextAlignment? = nil,
        subtitleFont: UIFont? = nil,
        subtitleColor: UIColor? = nil,
        subtitleTextAlign: NSTextAlignment? = nil,
        leftView: UIView? = nil,
        rightView: UIView? = nil,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil,
        iconPosition: IconPosition = .center
    ) {

        super.init(
            title: title,
            subtitle: subtitle,
            leftView: leftView,
            rightView: rightView,
            style: style,
            colors: colors,
            iconPosition: iconPosition
        )
        
        if let titleFont = titleFont {
            self.titleFont = titleFont
            titleLabel!.font = titleFont
        }
        
        if let titleColor = titleColor {
            titleLabel!.textColor = titleColor
        }
        
        if let titleTextAlign = titleTextAlign {
            titleLabel!.textAlignment = titleTextAlign
        }
        
        if let subtitleFont = subtitleFont {
            self.subtitleFont = subtitleFont
            subtitleLabel!.font = subtitleFont
        }
        
        if let subtitleColor = subtitleColor {
            subtitleLabel!.textColor = subtitleColor
        }
        
        if let subtitleTextAlign = subtitleTextAlign {
            subtitleLabel!.textAlignment = subtitleTextAlign
        }
    }
    
    public init(customView: UIView) {
        super.init(style: .customView)
        self.customView = customView
        
        contentView.addSubview(customView)
        customView.snp.makeConstraints { (make) in
            make.edges.equalTo(contentView)
        }
        
        spacerView.backgroundColor = customView.backgroundColor
    }
    
    /**
     Convenience function to display banner with non .zero default edge insets
     */
    public func show(
        queuePosition: QueuePosition = .back,
        bannerPosition: BannerPosition = .top,
        queue: NotificationBannerQueue = NotificationBannerQueue.default,
        on viewController: UIViewController? = nil,
        edgeInsets: UIEdgeInsets = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8),
        cornerRadius: CGFloat? = nil,
        shadowColor: UIColor = .black,
        shadowOpacity: CGFloat = 1,
        shadowBlurRadius: CGFloat = 0,
        shadowCornerRadius: CGFloat = 0,
        shadowOffset: UIOffset = .zero,
        shadowEdgeInsets: UIEdgeInsets? = nil
    ) {

        self.bannerEdgeInsets = edgeInsets
        
        if let cornerRadius = cornerRadius {
            contentView.layer.cornerRadius = cornerRadius
            contentView.subviews.last?.layer.cornerRadius = cornerRadius
        }
        
        if style == .customView, let customView = contentView.subviews.last {
           customView.backgroundColor = customView.backgroundColor?.withAlphaComponent(transparency)
        }

        show(
            queuePosition: queuePosition,
            bannerPosition: bannerPosition,
            queue: queue,
            on: viewController
        )
        
        applyShadow(
            withColor: shadowColor,
            opacity: shadowOpacity,
            blurRadius: shadowBlurRadius,
            cornerRadius: shadowCornerRadius,
            offset: shadowOffset,
            edgeInsets: shadowEdgeInsets
        )
        
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
}

private extension FloatingNotificationBanner {
    
    /**
     Add shadow for notification with specified parameters.
     */
    private func applyShadow(
        withColor color: UIColor = .black,
        opacity: CGFloat = 1,
        blurRadius: CGFloat = 0,
        cornerRadius: CGFloat = 0,
        offset: UIOffset = .zero,
        edgeInsets: UIEdgeInsets? = nil
    ) {

        guard blurRadius >= 0 else { return }

        contentView.layer.shadowColor = color.cgColor
        contentView.layer.shadowOpacity = Float(opacity)
        contentView.layer.shadowRadius = blurRadius
        contentView.layer.shadowOffset = CGSize(width: offset.horizontal, height: offset.vertical)
        
        if let edgeInsets = edgeInsets {
            var shadowRect = CGRect(origin: .zero, size: bannerPositionFrame.startFrame.size)
            shadowRect.size.height -= (spacerViewHeight() - spacerViewDefaultOffset) // to proper handle spacer height affects
            shadowRect.origin.x += edgeInsets.left
            shadowRect.origin.y += edgeInsets.top
            shadowRect.size.width -= (edgeInsets.left + edgeInsets.right)
            shadowRect.size.height -= (edgeInsets.top + edgeInsets.bottom)
            contentView.layer.shadowPath = UIBezierPath(roundedRect: shadowRect, cornerRadius: cornerRadius).cgPath
        }
        
        contentView.layer.rasterizationScale = UIScreen.main.scale
        contentView.layer.shouldRasterize = true
    }
    
}
//
//  UIWindow+orientation.swift
//  NotificationBannerSwift
//
//  Created by gabmarfer on 15/10/2019.
//

import UIKit

extension UIWindow {

    public var width: CGFloat {
        let orientation = UIDevice.current.orientation
        switch orientation {
        case .landscapeLeft, .landscapeRight:
            return max(frame.width, frame.height)
        case .portrait, .portraitUpsideDown:
            return min(frame.width, frame.height)
        default:
            return frame.width
        }
    }

    public var height: CGFloat {
        let orientation = UIDevice.current.orientation
        switch orientation {
        case .landscapeLeft, .landscapeRight:
            return min(frame.width, frame.height)
        case .portrait, .portraitUpsideDown:
            return max(frame.width, frame.height)
        default:
            return frame.height
        }
    }

}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit

@objc
public enum BannerPosition: Int {
    case bottom
    case top
}

class BannerPositionFrame {
    
    private(set) var startFrame: CGRect = .zero
    private(set) var endFrame: CGRect = .zero

    init(
        bannerPosition: BannerPosition,
        bannerWidth: CGFloat,
        bannerHeight: CGFloat,
        maxY: CGFloat,
        finishYOffset: CGFloat = 0,
        edgeInsets: UIEdgeInsets?
    ) {

        self.startFrame = startFrame(
            for: bannerPosition,
            bannerWidth: bannerWidth,
            bannerHeight: bannerHeight,
            maxY: maxY,
            edgeInsets: edgeInsets
        )
        
        self.endFrame = endFrame(
            for: bannerPosition,
            bannerWidth: bannerWidth,
            bannerHeight: bannerHeight,
            maxY: maxY,
            finishYOffset: finishYOffset,
            edgeInsets: edgeInsets
        )
    }
    
    /**
        Returns the start frame for the notification banner based on the given banner position
        - parameter bannerPosition: The position the notification banners should slide in from
        - parameter bannerWidth: The width of the notification banner
        - parameter bannerHeight: The height of the notification banner
        - parameter maxY: The maximum `y` position the banner can slide in from. This value is only used 
        if the bannerPosition is .bottom
        - parameter edgeInsets: The sides edges insets from superview
     */
    private func startFrame(
        for bannerPosition: BannerPosition,
        bannerWidth: CGFloat,
        bannerHeight: CGFloat,
        maxY: CGFloat,
        edgeInsets: UIEdgeInsets?
    ) -> CGRect {
        
        let edgeInsets = edgeInsets ?? .zero
        
        switch bannerPosition {
        case .bottom:
            return CGRect(
                x: edgeInsets.left,
                y: maxY,
                width: bannerWidth - edgeInsets.left - edgeInsets.right,
                height: bannerHeight
            )
        case .top:
            return CGRect(
                x: edgeInsets.left,
                y: -bannerHeight,
                width: bannerWidth - edgeInsets.left - edgeInsets.right,
                height: bannerHeight
            )

        }
    }
    
    /**
     Returns the end frame for the notification banner based on the given banner position
     - parameter bannerPosition: The position the notification banners should slide in from
     - parameter bannerWidth: The width of the notification banner
     - parameter bannerHeight: The height of the notification banner
     - parameter maxY: The maximum `y` position the banner can slide in from. This value is only used if the bannerPosition is .bottom
     - parameter finishYOffset: The `y` position offset the banner can slide in. Used for displaying several banenrs simaltaneously
     - parameter edgeInsets: The sides edges insets from superview
     */
    private func endFrame(
        for bannerPosition: BannerPosition,
        bannerWidth: CGFloat,
        bannerHeight: CGFloat,
        maxY: CGFloat,
        finishYOffset: CGFloat = 0,
        edgeInsets: UIEdgeInsets?
    ) -> CGRect {
        
        let edgeInsets = edgeInsets ?? .zero

        switch bannerPosition {
        case .bottom:
            return CGRect(
                x: edgeInsets.left,
                y: maxY - bannerHeight - edgeInsets.bottom - finishYOffset,
                width: startFrame.width,
                height: startFrame.height)
        case .top:
            return CGRect(
                x: edgeInsets.left,
                y: edgeInsets.top + finishYOffset,
                width: startFrame.width,
                height: startFrame.height
            )
        }
    }

}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import Foundation

@objc
public enum BannerStyle: Int {
    case danger
    case info
    case customView
    case success
    case warning
}

/*

 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

import UIKit

import MarqueeLabel

@objcMembers
open class StatusBarNotificationBanner: BaseNotificationBanner {

    public override var bannerHeight: CGFloat {
        get {
            if let customBannerHeight = customBannerHeight {
                return customBannerHeight
            } else if shouldAdjustForDynamicIsland() {
                return 70.0
            } else if shouldAdjustForNotchFeaturedIphone() {
                return 50.0
            } else {
                return 20.0 + heightAdjustment
            }
        } set {
            customBannerHeight = newValue
        }
    }

    override init(style: BannerStyle, colors: BannerColorsProtocol? = nil) {
        super.init(style: style, colors: colors)

        titleLabel = MarqueeLabel()
        (titleLabel as! MarqueeLabel).animationDelay = 2
        (titleLabel as! MarqueeLabel).type = .leftRight
        titleLabel!.font = UIFont.systemFont(ofSize: 12.5, weight: UIFont.Weight.bold)
        titleLabel!.textAlignment = .center
        titleLabel!.textColor = .white
        contentView.addSubview(titleLabel!)

        titleLabel!.snp.makeConstraints { (make) in
            make.top.equalToSuperview().offset(heightAdjustment)
            make.left.equalToSuperview().offset(5)
            make.right.equalToSuperview().offset(-5)
            make.bottom.equalToSuperview()
        }

        updateMarqueeLabelsDurations()
    }

    public convenience init(
        title: String,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil
    ) {
        self.init(style: style, colors: colors)
        titleLabel!.text = title
    }

    public convenience init(
        attributedTitle: NSAttributedString,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil
    ) {
        self.init(style: style, colors: colors)
        titleLabel!.attributedText = attributedTitle
    }

    public init(customView: UIView) {
        super.init(style: .customView)
        self.customView = customView
        
        contentView.addSubview(customView)
        customView.snp.makeConstraints { make in
            make.edges.equalTo(contentView)
        }

        spacerView.backgroundColor = customView.backgroundColor
    }

    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }

}

public extension StatusBarNotificationBanner {
    
    func applyStyling(
        titleColor: UIColor? = nil,
        titleTextAlign: NSTextAlignment? = nil
    ) {
        
        if let titleColor = titleColor {
            titleLabel!.textColor = titleColor
        }
        
        if let titleTextAlign = titleTextAlign {
            titleLabel!.textAlignment = titleTextAlign
        }
    }
    
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit

class NotificationBannerUtilities: NSObject {

    class func isNotchFeaturedIPhone() -> Bool {
        if #available(iOS 11, *) {
            if UIApplication.shared.keyWindow?.safeAreaInsets.bottom ?? 0.0 > 0.0 {
                return true
            } else {
                return false
            }
        } else {
            return false
        }
    }
    
    class func hasDynamicIsland() -> Bool {
        if #available(iOS 11, *) {
            if UIApplication.shared.keyWindow?.safeAreaInsets.top ?? 0.0 > 50.0 {
                return true
            } else {
                return false
            }
        } else {
            return false
        }
    }
    
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit

@objc
public protocol BannerColorsProtocol {
    func color(for style: BannerStyle) -> UIColor
}

public class BannerColors: BannerColorsProtocol {

    public func color(for style: BannerStyle) -> UIColor {
        switch style {
            case .danger:
                return UIColor(red:0.90, green:0.31, blue:0.26, alpha:1.00)
            case .info:
                return UIColor(red:0.23, green:0.60, blue:0.85, alpha:1.00)
            case .customView:
                return .clear
            case .success:
                return UIColor(red:0.22, green:0.80, blue:0.46, alpha:1.00)
            case .warning:
                return UIColor(red:1.00, green:0.66, blue:0.16, alpha:1.00)
        }
    }
}
//
//  String+heightForConstrainedWidth.swift
//  NotificationBanner
//
//  Created by Sascha Gordner on 03.10.18.
//  Copyright © 2018 Dalton Hinterscher. All rights reserved.
//
// https://stackoverflow.com/questions/30450434/figure-out-size-of-uilabel-based-on-string-in-swift

import UIKit

public extension String {
    
    /// Calculates the height a label will need in order to display the String for the given width and font.
    ///
    /// - Parameters:
    ///   - width: Max width of the bounding rect
    ///   - font: Font used to render the string
    /// - Returns: Height a string will need to be completely visible
    func height(forConstrainedWidth width: CGFloat, font: UIFont) -> CGFloat {
        let constraintRect = CGSize(width: width, height: .greatestFiniteMagnitude)
        let boundingBox = self.boundingRect(
            with: constraintRect,
            options: [.usesLineFragmentOrigin, .usesFontLeading],
            attributes: [.font: font],
            context: nil
        )
        return boundingBox.height
    }
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit
import SnapKit

open class GrowingNotificationBanner: BaseNotificationBanner {
    
    public enum IconPosition {
        case top
        case center
    }
    
    /// The height of the banner when it is presented
    override public var bannerHeight: CGFloat {
        get {
            if let customBannerHeight = customBannerHeight {
                return customBannerHeight
            } else {
                // Calculate the height based on contents of labels
                
                // Determine available width for displaying the label
                var boundingWidth = UIScreen.main.bounds.width - padding * 2
                
                // Substract safeAreaInsets from width, if available
                // We have to use keyWindow to ask for safeAreaInsets as `self` only knows its' safeAreaInsets in layoutSubviews
                if #available(iOS 11.0, *), let keyWindow = UIApplication.shared.keyWindow {
                    let safeAreaOffset = keyWindow.safeAreaInsets.left + keyWindow.safeAreaInsets.right
                    
                    boundingWidth -= safeAreaOffset
                }
                
                if leftView != nil {
                    boundingWidth -= sideViewSize + padding
                }
                
                if rightView != nil {
                    boundingWidth -= sideViewSize + padding
                }
                
                let titleHeight = ceil(titleLabel?.sizeThatFits(
                    CGSize(width: boundingWidth,
                           height: .greatestFiniteMagnitude)).height ?? 0.0)
                
                let subtitleHeight = ceil(subtitleLabel?.sizeThatFits(
                    CGSize(width: boundingWidth,
                           height: .greatestFiniteMagnitude)).height ?? 0.0)
             
                let topOffset: CGFloat
                let minHeight: CGFloat

                if shouldAdjustForNotchFeaturedIphone() {
                    topOffset = 44.0
                    minHeight = 88.0
                } else if shouldAdjustForDynamicIsland() {
                    topOffset = 44.0
                    minHeight = 104.0
                } else {
                    topOffset = verticalSpacing
                    minHeight = 64.0
                }
                
                var actualBannerHeight = topOffset + titleHeight + subtitleHeight + verticalSpacing
                
                if !subtitleHeight.isZero && !titleHeight.isZero {
                    actualBannerHeight += innerSpacing
                }
                
                return heightAdjustment + max(actualBannerHeight, minHeight)
            }
        } set {
            customBannerHeight = newValue
        }
    }
    
    /// Spacing between the last label and the bottom edge of the banner
    private let verticalSpacing: CGFloat = 14.0
    
    /// Spacing between title and subtitle
    private let innerSpacing: CGFloat = 2.5
    
    /// The bottom most label of the notification if a subtitle is provided
    public internal(set) var subtitleLabel: UILabel?
    
    /// The view that is presented on the left side of the notification
    private var leftView: UIView?
    
    /// The view that is presented on the right side of the notification
    private var rightView: UIView?
    
    /// Square size for left/right view if set
    private let sideViewSize: CGFloat
    
    /// Font used for the title label
    internal var titleFont: UIFont = UIFont.systemFont(ofSize: 17.5, weight: UIFont.Weight.bold)
    
    /// Font used for the subtitle label
    internal var subtitleFont: UIFont = UIFont.systemFont(ofSize: 15.0)
    
    public init(
        title: String? = nil,
        subtitle: String? = nil,
        leftView: UIView? = nil,
        rightView: UIView? = nil,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil,
        iconPosition: IconPosition = .center,
        sideViewSize: CGFloat = 24.0
    ) {
        
        self.leftView = leftView
        self.rightView = rightView
        self.sideViewSize = sideViewSize
        
        super.init(style: style, colors: colors)
        
        let labelsView = UIStackView()
        labelsView.axis = .vertical
        labelsView.spacing = innerSpacing
        
        let outerStackView = UIStackView()
        outerStackView.spacing = padding
        
        switch iconPosition {
        case .top:
            outerStackView.alignment = .top
        case .center:
            outerStackView.alignment = .center
        }
        
        if let leftView = leftView {
            outerStackView.addArrangedSubview(leftView)
            leftView.snp.makeConstraints { $0.size.equalTo(sideViewSize) }
        }
        
        outerStackView.addArrangedSubview(labelsView)
        
        if let title = title {
            titleLabel = UILabel()
            titleLabel!.font = titleFont
            titleLabel!.numberOfLines = 0
            titleLabel!.textColor = .white
            titleLabel!.text = title
            titleLabel!.setContentHuggingPriority(.required, for: .vertical)
            labelsView.addArrangedSubview(titleLabel!)
        }
        
        if let subtitle = subtitle {
            subtitleLabel = UILabel()
            subtitleLabel!.font = subtitleFont
            subtitleLabel!.numberOfLines = 0
            subtitleLabel!.textColor = .white
            subtitleLabel!.text = subtitle
            if title == nil {
                subtitleLabel!.setContentHuggingPriority(.required, for: .vertical)
            }
            labelsView.addArrangedSubview(subtitleLabel!)
        }
        
        if let rightView = rightView {
            outerStackView.addArrangedSubview(rightView)
            rightView.snp.makeConstraints { $0.size.equalTo(sideViewSize) }
        }
        
        contentView.addSubview(outerStackView)
        outerStackView.snp.makeConstraints { (make) in
            if #available(iOS 11.0, *) {
                make.left.equalTo(safeAreaLayoutGuide).offset(padding)
                make.right.equalTo(safeAreaLayoutGuide).offset(-padding)
            } else {
                make.left.equalToSuperview().offset(padding)
                make.right.equalToSuperview().offset(-padding)
            }
            
            make.centerY.equalToSuperview()
        }
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func spacerViewHeight() -> CGFloat {
        return super.spacerViewHeight() + heightAdjustment
    }
}

public extension GrowingNotificationBanner {
    
    func applyStyling(
        cornerRadius: CGFloat? = nil,
        titleFont: UIFont? = nil,
        titleColor: UIColor? = nil,
        titleTextAlign: NSTextAlignment? = nil,
        subtitleFont: UIFont? = nil,
        subtitleColor: UIColor? = nil,
        subtitleTextAlign: NSTextAlignment? = nil
    ) {
        
        if let cornerRadius = cornerRadius {
            contentView.layer.cornerRadius = cornerRadius
        }
        
        if let titleFont = titleFont {
            self.titleFont = titleFont
            titleLabel!.font = titleFont
        }
        
        if let titleColor = titleColor {
            titleLabel!.textColor = titleColor
        }
        
        if let titleTextAlign = titleTextAlign {
            titleLabel!.textAlignment = titleTextAlign
        }
        
        if let subtitleFont = subtitleFont {
            self.subtitleFont = subtitleFont
            subtitleLabel!.font = subtitleFont
        }
        
        if let subtitleColor = subtitleColor {
            subtitleLabel!.textColor = subtitleColor
        }
        
        if let subtitleTextAlign = subtitleTextAlign {
            subtitleLabel!.textAlignment = subtitleTextAlign
        }
        
        if titleFont != nil || subtitleFont != nil {
            updateBannerHeight()
        }
    }
    
}
/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit

public enum BannerHaptic {
    case light
    case medium
    case heavy
    case none

    @available(iOS 10.0, *)
    var impactStyle: UIImpactFeedbackGenerator.FeedbackStyle? {
        switch self {
        case .light:
            return .light
        case .medium:
            return .medium
        case .heavy:
            return .heavy
        case .none:
            return nil
        }
    }
}

open class BannerHapticGenerator: NSObject {

    /**
        Generates a haptic based on the given haptic
        -parameter haptic: The haptic strength to generate when a banner is shown
     */
    open class func generate(_ haptic: BannerHaptic) {
        guard let style = haptic.impactStyle else { return }
        let feedbackGenerator = UIImpactFeedbackGenerator(style: style)
        feedbackGenerator.prepare()
        feedbackGenerator.impactOccurred()
    }
}
/*

 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

import UIKit
import SnapKit

import MarqueeLabel

public protocol NotificationBannerDelegate: AnyObject {
    func notificationBannerWillAppear(_ banner: BaseNotificationBanner)
    func notificationBannerDidAppear(_ banner: BaseNotificationBanner)
    func notificationBannerWillDisappear(_ banner: BaseNotificationBanner)
    func notificationBannerDidDisappear(_ banner: BaseNotificationBanner)
}

@objcMembers
open class BaseNotificationBanner: UIView {

    /// Notification that will be posted when a notification banner will appear
    public static let BannerWillAppear: Notification.Name = Notification.Name(rawValue: "NotificationBannerWillAppear")

    /// Notification that will be posted when a notification banner did appear
    public static let BannerDidAppear: Notification.Name = Notification.Name(rawValue: "NotificationBannerDidAppear")

    /// Notification that will be posted when a notification banner will appear
    public static let BannerWillDisappear: Notification.Name = Notification.Name(rawValue: "NotificationBannerWillDisappear")

    /// Notification that will be posted when a notification banner did appear
    public static let BannerDidDisappear: Notification.Name = Notification.Name(rawValue: "NotificationBannerDidDisappear")

    /// Notification banner object key that is included with each Notification
    public static let BannerObjectKey: String = "NotificationBannerObjectKey"

    /// The delegate of the notification banner
    public weak var delegate: NotificationBannerDelegate?

    /// The style of the notification banner
    public let style: BannerStyle

    /// The height of the banner when it is presented
    public var bannerHeight: CGFloat {
        get {
            if let customBannerHeight = customBannerHeight {
                return customBannerHeight
            } else if shouldAdjustForDynamicIsland() {
                return 104.0
            } else if shouldAdjustForNotchFeaturedIphone() {
                return 88.0
            } else {
                return 64.0 + heightAdjustment
            }
        } set {
            customBannerHeight = newValue
        }
    }

    /// The topmost label of the notification if a custom view is not desired
    public internal(set) var titleLabel: UILabel?

    /// The time before the notificaiton is automatically dismissed
    public var duration: TimeInterval = 5.0 {
        didSet {
            updateMarqueeLabelsDurations()
        }
    }

    /// If false, the banner will not be dismissed until the developer programatically dismisses it
    public var autoDismiss: Bool = true {
        didSet {
            if !autoDismiss {
                dismissOnTap = false
                dismissOnSwipeUp = false
            }
        }
    }

    /// The transparency of the background of the notification banner
    public var transparency: CGFloat = 1.0 {
        didSet {
            if let customView = customView {
                customView.backgroundColor = customView.backgroundColor?.withAlphaComponent(transparency)
            } else {
                let color = backgroundColor
                self.backgroundColor = color
            }
        }
    }

    /// The type of haptic to generate when a banner is displayed
    public var haptic: BannerHaptic = .heavy

    /// If true, notification will dismissed when tapped
    public var dismissOnTap: Bool = true

    /// If true, notification will dismissed when swiped up
    public var dismissOnSwipeUp: Bool = true

    /// Closure that will be executed if the notification banner is tapped
    public var onTap: (() -> Void)?

    /// Closure that will be executed if the notification banner is swiped up
    public var onSwipeUp: (() -> Void)?

    /// Responsible for positioning and auto managing notification banners
    public var bannerQueue: NotificationBannerQueue = NotificationBannerQueue.default

    /// Banner show and dimiss animation duration
    public var animationDuration: TimeInterval = 0.5

    /// Whether or not the notification banner is currently being displayed
    public var isDisplaying: Bool = false
    
    /// Whether or not to post the default accessibility notification.
    public var shouldPostAccessibilityNotification: Bool = true

    /// The view that the notification layout is presented on. The constraints/frame of this should not be changed
    internal var contentView: UIView!

    /// A view that helps the spring animation look nice when the banner appears
    internal var spacerView: UIView!

    // The custom view inside the notification banner
    internal var customView: UIView?

    /// The default offset for spacerView top or bottom
    internal var spacerViewDefaultOffset: CGFloat = 10.0

    /// The maximum number of banners simultaneously visible on screen
    internal var maximumVisibleBanners: Int = 1

    /// The default padding between edges and views
    internal var padding: CGFloat = 15.0

    /// The view controller to display the banner on. This is useful if you are wanting to display a banner underneath a navigation bar
    internal weak var parentViewController: UIViewController?

    /// If this is not nil, then this height will be used instead of the auto calculated height
    internal var customBannerHeight: CGFloat?

    /// Used by the banner queue to determine wether a notification banner was placed in front of it in the queue
    var isSuspended: Bool = false

    /// The main window of the application which banner views are placed on
    private let appWindow: UIWindow? = {
        if #available(iOS 13.0, *) {
            return UIApplication.shared.connectedScenes
                .first { $0.activationState == .foregroundActive || $0.activationState == .foregroundInactive }
                .map { $0 as? UIWindowScene }
                .flatMap { $0?.windows.first } ?? UIApplication.shared.delegate?.window ?? UIApplication.shared.keyWindow
        }

        return UIApplication.shared.delegate?.window ?? nil
    }()

    /// The position the notification banner should slide in from
    private(set) var bannerPosition: BannerPosition = .top

    /// The notification banner sides edges insets from superview. If presented - spacerView color will be transparent
    internal var bannerEdgeInsets: UIEdgeInsets? = nil {
        didSet {
            if bannerEdgeInsets != nil {
                spacerView.backgroundColor = .clear
            }
        }
    }

    /// Object that stores the start and end frames for the notification banner based on the provided banner position
    internal var bannerPositionFrame: BannerPositionFrame!

    /// The user info that gets passed to each notification
    private var notificationUserInfo: [String: BaseNotificationBanner] {
        return [BaseNotificationBanner.BannerObjectKey: self]
    }

    open override var backgroundColor: UIColor? {
        get {
            return contentView.backgroundColor
        } set {
            guard style != .customView else { return }
            let color = newValue?.withAlphaComponent(transparency)
            contentView.backgroundColor = color
            spacerView.backgroundColor = color
        }
    }

    init(style: BannerStyle, colors: BannerColorsProtocol? = nil) {
        self.style = style
        super.init(frame: .zero)

        spacerView = UIView()
        addSubview(spacerView)

        contentView = UIView()
        addSubview(contentView)

        if let colors = colors {
            backgroundColor = colors.color(for: style)
        } else {
            backgroundColor = BannerColors().color(for: style)
        }

        let swipeUpGesture = UISwipeGestureRecognizer(target: self, action: #selector(onSwipeUpGestureRecognizer))
        swipeUpGesture.direction = .up
        addGestureRecognizer(swipeUpGesture)
    }

    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    deinit {
        NotificationCenter.default.removeObserver(
            self,
            name: UIDevice.orientationDidChangeNotification,
            object: nil
        )
    }

    /**
        Creates the proper banner constraints based on the desired banner position
     */
    private func createBannerConstraints(for bannerPosition: BannerPosition) {

        spacerView.snp.remakeConstraints { (make) in
            if bannerPosition == .top {
                make.top.equalToSuperview().offset(-spacerViewDefaultOffset)
            } else {
                make.bottom.equalToSuperview().offset(spacerViewDefaultOffset)
            }
            make.left.equalToSuperview()
            make.right.equalToSuperview()
            updateSpacerViewHeight(make: make)
        }

        contentView.snp.remakeConstraints { (make) in
            if bannerPosition == .top {
                make.top.equalTo(spacerView.snp.bottom)
                make.bottom.equalToSuperview()
            } else {
                make.top.equalToSuperview()
                make.bottom.equalTo(spacerView.snp.top)
            }

            make.left.equalToSuperview()
            make.right.equalToSuperview()
        }

    }

    /**
         Updates the spacer view height. Specifically used for orientation changes.
     */
    private func updateSpacerViewHeight(make: ConstraintMaker? = nil) {
        let finalHeight = spacerViewHeight()
        if let make = make {
            make.height.equalTo(finalHeight)
        } else {
            spacerView.snp.updateConstraints({ (make) in
                make.height.equalTo(finalHeight)
            })
        }
    }

    internal func spacerViewHeight() -> CGFloat {
        if shouldAdjustForDynamicIsland() {
            return 44.0
        } else if shouldAdjustForNotchFeaturedIphone() {
            return 40.0
        } else {
            return 10.0
        }
    }

    private func finishBannerYOffset() -> CGFloat {
        let bannerIndex = (bannerQueue.banners.firstIndex(of: self) ?? bannerQueue.banners.filter { $0.isDisplaying }.count)
        
        return bannerQueue.banners.prefix(bannerIndex).reduce(0) { $0
            + $1.bannerHeight
            - (bannerPosition == .top ? spacerViewHeight() : 0) // notch spacer height for top position only
            + (bannerPosition == .top ? spacerViewDefaultOffset : -spacerViewDefaultOffset) // to reduct additions in createBannerConstraints (it's needed for proper shadow framing)
            + (bannerPosition == .top ? spacerViewDefaultOffset : -spacerViewDefaultOffset) // default space between banners
            // this calculations are made only for banners except first one, for first banner it'll be 0
        }
    }
    
    internal func updateBannerPositionFrames() {
        guard let window = appWindow else { return }
        bannerPositionFrame = BannerPositionFrame(
            bannerPosition: bannerPosition,
            bannerWidth: window.width,
            bannerHeight: bannerHeight,
            maxY: maximumYPosition(),
            finishYOffset: finishBannerYOffset(),
            edgeInsets: bannerEdgeInsets
        )
    }

    internal func animateUpdatedBannerPositionFrames() {
        UIView.animate(
            withDuration: animationDuration,
            delay: 0.0,
            usingSpringWithDamping: 0.7,
            initialSpringVelocity: 1,
            options: [.curveLinear, .allowUserInteraction],
            animations: {
                self.frame = self.bannerPositionFrame.endFrame
        })
    }

    /**
        Places a NotificationBanner on the queue and shows it if its the first one in the queue
        - parameter queuePosition: The position to show the notification banner. If the position is .front, the
        banner will be displayed immediately
        - parameter bannerPosition: The position the notification banner should slide in from
        - parameter queue: The queue to display the notification banner on. It is up to the developer
        to manage multiple banner queues and prevent any conflicts that may occur.
        - parameter viewController: The view controller to display the notifification banner on. If nil, it will
        be placed on the main app window
    */
    public func show(
        queuePosition: QueuePosition = .back,
        bannerPosition: BannerPosition = .top,
        queue: NotificationBannerQueue = NotificationBannerQueue.default,
        on viewController: UIViewController? = nil
    ) {
        parentViewController = viewController
        bannerQueue = queue
        show(
            placeOnQueue: true,
            queuePosition: queuePosition,
            bannerPosition: bannerPosition
        )
    }

    /**
        Places a NotificationBanner on the queue and shows it if its the first one in the queue
        - parameter placeOnQueue: If false, banner will not be placed on the queue and will be showed/resumed immediately
        - parameter queuePosition: The position to show the notification banner. If the position is .front, the
        banner will be displayed immediately
        - parameter bannerPosition: The position the notification banner should slide in from
    */
    func show(
        placeOnQueue: Bool,
        queuePosition: QueuePosition = .back,
        bannerPosition: BannerPosition = .top
    ) {

        guard !isDisplaying else {
            return
        }

        self.bannerPosition = bannerPosition
        createBannerConstraints(for: bannerPosition)
        updateBannerPositionFrames()

        NotificationCenter.default.removeObserver(
            self,
            name: UIDevice.orientationDidChangeNotification,
            object: nil
        )
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(onOrientationChanged),
            name: UIDevice.orientationDidChangeNotification,
            object: nil
        )

        if placeOnQueue {
            bannerQueue.addBanner(
                self,
                bannerPosition: bannerPosition,
                queuePosition: queuePosition
            )
        } else {
            guard bannerPositionFrame != nil else {
                remove();
                return
            }

            self.frame = bannerPositionFrame.startFrame

            if let parentViewController = parentViewController, parentViewController.view != nil {
                parentViewController.view.addSubview(self)
                if statusBarShouldBeShown() {
                    appWindow?.windowLevel = UIWindow.Level.normal
                }
            } else {
                appWindow?.addSubview(self)
                if statusBarShouldBeShown() && !(parentViewController == nil && bannerPosition == .top) {
                    appWindow?.windowLevel = UIWindow.Level.normal
                } else {
                    appWindow?.windowLevel = UIWindow.Level.statusBar + 1
                }
            }

            NotificationCenter.default.post(
                name: BaseNotificationBanner.BannerWillAppear,
                object: self,
                userInfo: notificationUserInfo
            )
            
            delegate?.notificationBannerWillAppear(self)
            
            if self.shouldPostAccessibilityNotification {
                postAccessibilityNotification()
            }

            let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(self.onTapGestureRecognizer))
            self.addGestureRecognizer(tapGestureRecognizer)

            self.isDisplaying = true

            let bannerIndex = Double(bannerQueue.banners.firstIndex(of: self) ?? 0) + 1
            UIView.animate(
                withDuration: animationDuration * bannerIndex,
                delay: 0.0,
                usingSpringWithDamping: 0.7,
                initialSpringVelocity: 1,
                options: [.curveLinear, .allowUserInteraction],
                animations: {
                    BannerHapticGenerator.generate(self.haptic)
                    self.frame = self.bannerPositionFrame.endFrame
            }) { (completed) in

                NotificationCenter.default.post(
                    name: BaseNotificationBanner.BannerDidAppear,
                    object: self,
                    userInfo: self.notificationUserInfo
                )
                
                self.delegate?.notificationBannerDidAppear(self)

                /* We don't want to add the selector if another banner was queued in front of it
                   before it finished animating or if it is meant to be shown infinitely
                */
                if !self.isSuspended && self.autoDismiss {
                    self.perform(
                        #selector(self.dismiss),
                        with: nil,
                        afterDelay: self.duration
                    )
                }
            }
        }
    }

    /**
        Suspends a notification banner so it will not be dismissed. This happens because a new notification banner was placed in front of it on the queue.
    */
    func suspend() {
        if autoDismiss {
            NSObject.cancelPreviousPerformRequests(
                withTarget: self,
                selector: #selector(dismiss),
                object: nil
            )
            isSuspended = true
            isDisplaying = false
        }
    }

    /**
        Resumes a notification banner immediately.
    */
    func resume() {
        if autoDismiss {
            self.perform(
                #selector(dismiss),
                with: nil,
                afterDelay: self.duration
            )
            isSuspended = false
            isDisplaying = true
        }
    }

    /**
        Resets a notification banner's elapsed duration to zero.
    */
    public func resetDuration() {
        if autoDismiss {
             NSObject.cancelPreviousPerformRequests(
                withTarget: self,
                selector: #selector(dismiss),
                object: nil
             )
            
             self.perform(#selector(dismiss), with: nil, afterDelay: self.duration)
        }
    }
    
    /**
        The height adjustment needed in order for the banner to look properly displayed.
     */
    internal var heightAdjustment: CGFloat {
        if NotificationBannerUtilities.hasDynamicIsland() {
            return 16.0
        }
        
        // iOS 13 does not allow covering the status bar on non-notch iPhones
        // The banner needs to be moved further down under the status bar in this case
        guard #available(iOS 13.0, *), !NotificationBannerUtilities.isNotchFeaturedIPhone() else {
            return 0
        }

        return UIApplication.shared.statusBarFrame.height
    }

    /**
        Update banner height, it's necessary after banner labels font update
     */
    internal func updateBannerHeight() {
        onOrientationChanged()
    }

    /**
        Changes the frame of the notification banner when the orientation of the device changes
    */
    @objc private dynamic func onOrientationChanged() {
        guard let window = appWindow,
              currentDeviceOrientationIsSupportedByApp() else { return }
        
        updateSpacerViewHeight()

        let edgeInsets = bannerEdgeInsets ?? .zero

        let newY = (bannerPosition == .top) ? (frame.origin.y) : (window.height - bannerHeight + edgeInsets.top - edgeInsets.bottom)
        
        frame = CGRect(
            x: frame.origin.x,
            y: newY,
            width: window.width - edgeInsets.left - edgeInsets.right,
            height: bannerHeight
        )

        bannerPositionFrame = BannerPositionFrame(
            bannerPosition: bannerPosition,
            bannerWidth: window.width,
            bannerHeight: bannerHeight,
            maxY: maximumYPosition(),
            finishYOffset: finishBannerYOffset(),
            edgeInsets: bannerEdgeInsets
        )
    }

    /**
     Dismisses the NotificationBanner and shows the next one if there is one to show on the queue
     */
    @objc public func dismiss(forced: Bool = false) {

        guard isDisplaying else {
            return
        }

        NSObject.cancelPreviousPerformRequests(
            withTarget: self,
            selector: #selector(dismiss),
            object: nil
        )

        NotificationCenter.default.post(
            name: BaseNotificationBanner.BannerWillDisappear,
            object: self,
            userInfo: notificationUserInfo
        )
        
        delegate?.notificationBannerWillDisappear(self)

        isDisplaying = false
        remove()

        // Prevent any user action from showing an additional animation
        self.bannerQueue.activeAnimation = true

        UIView.animate(
            withDuration: forced ? animationDuration / 2 : animationDuration,
            animations: {
                self.frame = self.bannerPositionFrame.startFrame
        }) { (completed) in
            self.bannerQueue.activeAnimation = false

            self.removeFromSuperview()

            NotificationCenter.default.post(
                name: BaseNotificationBanner.BannerDidDisappear,
                object: self,
                userInfo: self.notificationUserInfo
            )
            
            self.delegate?.notificationBannerDidDisappear(self)

            self.bannerQueue.showNext(callback: { (isEmpty) in
                if isEmpty || self.statusBarShouldBeShown() {
                    self.appWindow?.windowLevel = UIWindow.Level.normal
                }
            })
        }
    }

    /**
     Removes the NotificationBanner from the queue if not displaying
     */
    public func remove() {

        guard !isDisplaying else {
            return
        }

        bannerQueue.removeBanner(self)
    }

    /**
        Called when a notification banner is tapped
    */
    @objc private dynamic func onTapGestureRecognizer() {
        if dismissOnTap {
            dismiss()
        }

        onTap?()
    }

    /**
        Called when a notification banner is swiped up
    */
    @objc private dynamic func onSwipeUpGestureRecognizer() {
        if dismissOnSwipeUp {
            dismiss()
        }

        onSwipeUp?()
    }


    /**
        Determines wether or not the status bar should be shown when displaying
        a banner underneath the navigation bar
     */
    private func statusBarShouldBeShown() -> Bool {

        for banner in bannerQueue.banners {
            if (banner.parentViewController == nil && banner.bannerPosition == .top) {
                return false
            }
        }

        return true
    }
    
    /**
        Determines wether or not the current orientation that the device is in
        is supported by the current application.
     */
    private func currentDeviceOrientationIsSupportedByApp() -> Bool {
        let supportedOrientations = UIApplication.shared.supportedInterfaceOrientations(for: appWindow)
        
        switch UIDevice.current.orientation {
        case .portrait:
            return supportedOrientations.contains(.portrait)
        case .portraitUpsideDown:
            return supportedOrientations.contains(.portraitUpsideDown)
        case .landscapeLeft:
            return supportedOrientations.contains(.landscapeLeft)
        case .landscapeRight:
            return supportedOrientations.contains(.landscapeRight)
        default:
            return false
        }
    }

    /**
        Calculates the maximum `y` position that a notification banner can slide in from
    */

    private func maximumYPosition() -> CGFloat {
        if let parentViewController = parentViewController {
            return parentViewController.view.frame.height
        } else {
            return appWindow?.height ?? 0
        }
    }

    /**
         Determines wether or not we should adjust the banner for notch featured iPhone
     */

    internal func shouldAdjustForDynamicIsland() -> Bool {
        return NotificationBannerUtilities.hasDynamicIsland()
            && UIApplication.shared.statusBarOrientation.isPortrait
            && (self.parentViewController?.navigationController?.isNavigationBarHidden ?? true)
    }
    
    internal func shouldAdjustForNotchFeaturedIphone() -> Bool {
        return NotificationBannerUtilities.isNotchFeaturedIPhone()
            && UIApplication.shared.statusBarOrientation.isPortrait
            && (self.parentViewController?.navigationController?.isNavigationBarHidden ?? true)
    }
    /**
        Updates the scrolling marquee label duration
    */
    internal func updateMarqueeLabelsDurations() {
        (titleLabel as? MarqueeLabel)?.speed = .duration(CGFloat(duration <= 3 ? 0.5 : duration - 3))
    }


    /**
     Posts a `UIAccessibility` notification when a notification appears.
     */
    private func postAccessibilityNotification() {
        var bannerAccessibilityLabel: String? = nil
        switch self {
        case let banner as NotificationBanner:
            if let title = banner.titleLabel?.text, let subtitle = banner.subtitleLabel?.text {
                bannerAccessibilityLabel = "\(title) \(subtitle)"
            }
        case let banner as FloatingNotificationBanner:
            if let title = banner.titleLabel?.text, let subtitle = banner.subtitleLabel?.text {
                bannerAccessibilityLabel = "\(title) \(subtitle)"
            }
        case let banner as GrowingNotificationBanner:
            if let title = banner.titleLabel?.text, let subtitle = banner.subtitleLabel?.text {
                bannerAccessibilityLabel = "\(title) \(subtitle)"
            }
        default:
            break
        }
        accessibilityLabel = bannerAccessibilityLabel
        isAccessibilityElement = true
        UIAccessibility.post(notification: .screenChanged, argument: self)
    }
}

/*

 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

import UIKit

@objc
public enum QueuePosition: Int {
    case back
    case front
}

@objcMembers
open class NotificationBannerQueue: NSObject {

    /// The default instance of the NotificationBannerQueue
    public static let `default` = NotificationBannerQueue()

    /// The notification banners currently placed on the queue
    private(set) var banners: [BaseNotificationBanner] = []

    /// The notification banners currently placed on the queue
    private(set) var maxBannersOnScreenSimultaneously: Int = 1

    /// This is a mutex to prevent too many notification banners from appearing on screen at once
    /// while our BaseNotificationBanner is animating itself off screen
    public var activeAnimation = false

    /// The current number of notification banners on the queue
    public var numberOfBanners: Int {
        return banners.count
    }

    public init(maxBannersOnScreenSimultaneously: Int = 1) {
        self.maxBannersOnScreenSimultaneously = maxBannersOnScreenSimultaneously
    }

    /**
        Adds a banner to the queue
        -parameter banner: The notification banner to add to the queue
        -parameter queuePosition: The position to show the notification banner. If the position is .front, the
        banner will be displayed immediately
    */
    func addBanner(
        _ banner: BaseNotificationBanner,
        bannerPosition: BannerPosition,
        queuePosition: QueuePosition
    ) {

        if queuePosition == .back {
            banners.append(banner)

            let bannersCount =  banners.filter { $0.isDisplaying }.count
            if bannersCount < maxBannersOnScreenSimultaneously && self.activeAnimation == false {
                banner.show(placeOnQueue: false, bannerPosition: banner.bannerPosition)
            }

        } else {
            banner.show(placeOnQueue: false, bannerPosition: bannerPosition)

            if let firstBanner = firstNotDisplayedBanner() {
                firstBanner.suspend()
            }

            banners.insert(banner, at: 0)
        }

    }

    /**
        Removes a banner from the queue
        -parameter banner: A notification banner to remove from the queue.
     */
    func removeBanner(_ banner: BaseNotificationBanner) {

        if let index = banners.firstIndex(of: banner) {
            banners.remove(at: index)
        }

        banners.forEach {
            $0.updateBannerPositionFrames()
            if $0.isDisplaying {
                $0.animateUpdatedBannerPositionFrames()
            }
        }
    }

    /**
        Shows the next notificaiton banner on the queue if one exists
        -parameter callback: The closure to execute after a banner is shown or when the queue is empty
    */
    func showNext(callback: ((_ isEmpty: Bool) -> Void)) {

        if let banner = firstNotDisplayedBanner() {

            if banner.isSuspended {
                banner.resume()
            } else {
                banner.show(placeOnQueue: false, bannerPosition: banner.bannerPosition)
            }

            callback(false)
        }
        else {
            callback(true)
            return
        }
    }

    func firstNotDisplayedBanner() -> BaseNotificationBanner? {
        return banners.filter { !$0.isDisplaying }.first
    }

    /**
        Removes all notification banners from the queue
    */
    public func removeAll() {
        banners.removeAll()
    }

    /**
     Forced dissmiss all notification banners from the queue
     */
    public func dismissAllForced() {
        banners.forEach { $0.dismiss(forced: true) }
        banners.removeAll()
    }

}

/*
 
 The MIT License (MIT)
 Copyright (c) 2017-2018 Dalton Hinterscher
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 */

import UIKit
import SnapKit

import MarqueeLabel

@objcMembers
open class NotificationBanner: BaseNotificationBanner {
    
    /// The bottom most label of the notification if a subtitle is provided
    public internal(set) var subtitleLabel: MarqueeLabel?
    
    /// The view that is presented on the left side of the notification
    private var leftView: UIView?
    
    /// The view that is presented on the right side of the notification
    private var rightView: UIView?
    
    /// Font used for the title label
    private var titleFont: UIFont = UIFont.systemFont(ofSize: 17.5, weight: UIFont.Weight.bold)
    
    /// Font used for the subtitle label
    private var subtitleFont: UIFont = UIFont.systemFont(ofSize: 15.0)

    public init(
        title: String? = nil,
        subtitle: String? = nil,
        leftView: UIView? = nil,
        rightView: UIView? = nil,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil
    ) {
        
        super.init(style: style, colors: colors)
        
        if let leftView = leftView {
            contentView.addSubview(leftView)
            
            let size = (leftView.frame.height > 0) ? min(44, leftView.frame.height) : 44
            
            leftView.snp.makeConstraints({ (make) in
                make.centerY.equalToSuperview().offset(heightAdjustment / 4)
                make.left.equalToSuperview().offset(10)
                make.size.equalTo(size)
            })
        }
        
        if let rightView = rightView {
            contentView.addSubview(rightView)
            
            let size = (rightView.frame.height > 0) ? min(44, rightView.frame.height) : 44
            rightView.snp.makeConstraints({ (make) in
                make.centerY.equalToSuperview().offset(heightAdjustment / 4)
                make.right.equalToSuperview().offset(-10)
                make.size.equalTo(size)
            })
        }
        
        let labelsView = UIView()
        contentView.addSubview(labelsView)
        
        if let title = title {
            titleLabel = MarqueeLabel()
            (titleLabel as! MarqueeLabel).type = .left
            titleLabel!.font = titleFont
            titleLabel!.textColor = .white
            titleLabel!.text = title
            labelsView.addSubview(titleLabel!)
            
            titleLabel!.snp.makeConstraints { (make) in
                make.top.equalToSuperview()
                make.left.equalToSuperview()
                make.right.equalToSuperview()
                if let _ = subtitle {
                    titleLabel!.numberOfLines = 1
                } else {
                    titleLabel!.numberOfLines = 2
                }
            }
        }
        
        if let subtitle = subtitle {
            subtitleLabel = MarqueeLabel()
            subtitleLabel!.type = .left
            subtitleLabel!.font = subtitleFont
            subtitleLabel!.numberOfLines = 1
            subtitleLabel!.textColor = .white
            subtitleLabel!.text = subtitle
            labelsView.addSubview(subtitleLabel!)
            
            subtitleLabel!.snp.makeConstraints { (make) in
                if title != nil {
                    make.top.equalTo(titleLabel!.snp.bottom).offset(2.5)
                    make.left.equalTo(titleLabel!)
                    make.right.equalTo(titleLabel!)
                }
                else {
                    make.top.equalToSuperview()
                    make.left.equalToSuperview()
                    make.right.equalToSuperview()
                }
            }
        }
        
        labelsView.snp.makeConstraints { (make) in
            make.centerY.equalToSuperview().offset(heightAdjustment / 4)
            
            if let leftView = leftView {
                make.left.equalTo(leftView.snp.right).offset(padding)
            } else {
                make.left.equalToSuperview().offset(padding)
            }
            
            if let rightView = rightView {
                make.right.equalTo(rightView.snp.left).offset(-padding)
            } else {
                make.right.equalToSuperview().offset(-padding)
            }
            
            if let subtitleLabel = subtitleLabel {
                make.bottom.equalTo(subtitleLabel)
            } else {
                make.bottom.equalTo(titleLabel!)
            }
        }
        
        updateMarqueeLabelsDurations()
        
    }
    
    public convenience init(
        attributedTitle: NSAttributedString,
        attributedSubtitle: NSAttributedString? = nil,
        leftView: UIView? = nil,
        rightView: UIView? = nil,
        style: BannerStyle = .info,
        colors: BannerColorsProtocol? = nil
    ) {
        
        let subtitle: String? = (attributedSubtitle != nil) ? "" : nil
        self.init(title: "", subtitle: subtitle, leftView: leftView, rightView: rightView, style: style, colors: colors)
        titleLabel!.attributedText = attributedTitle
        subtitleLabel?.attributedText = attributedSubtitle
    }
    
    public init(customView: UIView) {
        super.init(style: .customView)
        self.customView = customView
        
        contentView.addSubview(customView)
        customView.snp.makeConstraints { (make) in
            make.edges.equalTo(contentView)
        }
        
        spacerView.backgroundColor = customView.backgroundColor
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    internal override func updateMarqueeLabelsDurations() {
        super.updateMarqueeLabelsDurations()
        subtitleLabel?.speed = .duration(CGFloat(duration <= 1 ? 1 : duration - 1))
    }
    
}

public extension NotificationBanner {
    
    func applyStyling(
        cornerRadius: CGFloat? = nil,
        titleFont: UIFont? = nil,
        titleColor: UIColor? = nil,
        titleTextAlign: NSTextAlignment? = nil,
        subtitleFont: UIFont? = nil,
        subtitleColor: UIColor? = nil,
        subtitleTextAlign: NSTextAlignment? = nil
    ) {
        
        if let cornerRadius = cornerRadius {
            contentView.layer.cornerRadius = cornerRadius
        }
        
        if let titleFont = titleFont {
            titleLabel!.font = titleFont
        }
        
        if let titleColor = titleColor {
            titleLabel!.textColor = titleColor
        }
        
        if let titleTextAlign = titleTextAlign {
            titleLabel!.textAlignment = titleTextAlign
        }
        
        if let subtitleFont = subtitleFont {
            subtitleLabel!.font = subtitleFont
        }
        
        if let subtitleColor = subtitleColor {
            subtitleLabel!.textColor = subtitleColor
        }
        
        if let subtitleTextAlign = subtitleTextAlign {
            subtitleLabel!.textAlignment = subtitleTextAlign
        }
        
        if titleFont != nil || subtitleFont != nil {
            updateBannerHeight()
        }
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintMultiplierTarget {
    
    var constraintMultiplierTargetValue: CGFloat { get }
    
}

extension Int: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}

extension UInt: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}

extension Float: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}

extension Double: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}

extension CGFloat: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return self
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol LayoutConstraintItem: AnyObject {
}

@available(iOS 9.0, OSX 10.11, *)
extension ConstraintLayoutGuide : LayoutConstraintItem {
}

extension ConstraintView : LayoutConstraintItem {
}


extension LayoutConstraintItem {
    
    internal func prepare() {
        if let view = self as? ConstraintView {
            view.translatesAutoresizingMaskIntoConstraints = false
        }
    }
    
    internal var superview: ConstraintView? {
        if let view = self as? ConstraintView {
            return view.superview
        }
        
        if #available(iOS 9.0, OSX 10.11, *), let guide = self as? ConstraintLayoutGuide {
            return guide.owningView
        }
        
        return nil
    }
    internal var constraints: [Constraint] {
        return self.constraintsSet.allObjects as! [Constraint]
    }
    
    internal func add(constraints: [Constraint]) {
        let constraintsSet = self.constraintsSet
        for constraint in constraints {
            constraintsSet.add(constraint)
        }
    }
    
    internal func remove(constraints: [Constraint]) {
        let constraintsSet = self.constraintsSet
        for constraint in constraints {
            constraintsSet.remove(constraint)
        }
    }
    
    private var constraintsSet: NSMutableSet {
        let constraintsSet: NSMutableSet
        
        if let existing = objc_getAssociatedObject(self, &constraintsKey) as? NSMutableSet {
            constraintsSet = existing
        } else {
            constraintsSet = NSMutableSet()
            objc_setAssociatedObject(self, &constraintsKey, constraintsSet, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
        return constraintsSet
        
    }
    
}
private var constraintsKey: UInt8 = 0
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

@available(*, deprecated, message:"Use ConstraintMakerPrioritizable instead.")
public typealias ConstraintMakerPriortizable = ConstraintMakerPrioritizable

public class ConstraintMakerPrioritizable: ConstraintMakerFinalizable {
    
    @discardableResult
    public func priority(_ amount: ConstraintPriority) -> ConstraintMakerFinalizable {
        self.description.priority = amount.value
        return self
    }
    
    @discardableResult
    public func priority(_ amount: ConstraintPriorityTarget) -> ConstraintMakerFinalizable {
        self.description.priority = amount
        return self
    }
    
    @available(*, deprecated, message:"Use priority(.required) instead.")
    @discardableResult
    public func priorityRequired() -> ConstraintMakerFinalizable {
        return self.priority(.required)
    }
    
    @available(*, deprecated, message:"Use priority(.high) instead.")
    @discardableResult
    public func priorityHigh() -> ConstraintMakerFinalizable {
        return self.priority(.high)
    }
    
    @available(*, deprecated, message:"Use priority(.medium) instead.")
    @discardableResult
    public func priorityMedium() -> ConstraintMakerFinalizable {
        return self.priority(.medium)
    }
    
    @available(*, deprecated, message:"Use priority(.low) instead.")
    @discardableResult
    public func priorityLow() -> ConstraintMakerFinalizable {
        return self.priority(.low)
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintDescription {
    
    internal let item: LayoutConstraintItem
    internal var attributes: ConstraintAttributes
    internal var relation: ConstraintRelation? = nil
    internal var sourceLocation: (String, UInt)? = nil
    internal var label: String? = nil
    internal var related: ConstraintItem? = nil
    internal var multiplier: ConstraintMultiplierTarget = 1.0
    internal var constant: ConstraintConstantTarget = 0.0
    internal var priority: ConstraintPriorityTarget = 1000.0
    internal lazy var constraint: Constraint? = {
        guard let relation = self.relation,
              let related = self.related,
              let sourceLocation = self.sourceLocation else {
            return nil
        }
        let from = ConstraintItem(target: self.item, attributes: self.attributes)
        
        return Constraint(
            from: from,
            to: related,
            relation: relation,
            sourceLocation: sourceLocation,
            label: self.label,
            multiplier: self.multiplier,
            constant: self.constant,
            priority: self.priority
        )
    }()
    
    // MARK: Initialization
    
    internal init(item: LayoutConstraintItem, attributes: ConstraintAttributes) {
        self.item = item
        self.attributes = attributes
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


internal struct ConstraintAttributes : OptionSet, ExpressibleByIntegerLiteral {
    
    typealias IntegerLiteralType = UInt
    
    internal init(rawValue: UInt) {
        self.rawValue = rawValue
    }
    internal init(_ rawValue: UInt) {
        self.init(rawValue: rawValue)
    }
    internal init(nilLiteral: ()) {
        self.rawValue = 0
    }
    internal init(integerLiteral rawValue: IntegerLiteralType) {
        self.init(rawValue: rawValue)
    }
    
    internal private(set) var rawValue: UInt
    internal static var allZeros: ConstraintAttributes { return 0 }
    internal static func convertFromNilLiteral() -> ConstraintAttributes { return 0 }
    internal var boolValue: Bool { return self.rawValue != 0 }
    
    internal func toRaw() -> UInt { return self.rawValue }
    internal static func fromRaw(_ raw: UInt) -> ConstraintAttributes? { return self.init(raw) }
    internal static func fromMask(_ raw: UInt) -> ConstraintAttributes { return self.init(raw) }
    
    // normal
    
    internal static let none: ConstraintAttributes = 0
    internal static let left: ConstraintAttributes = ConstraintAttributes(UInt(1) << 0)
    internal static let top: ConstraintAttributes = ConstraintAttributes(UInt(1) << 1)
    internal static let right: ConstraintAttributes = ConstraintAttributes(UInt(1) << 2)
    internal static let bottom: ConstraintAttributes = ConstraintAttributes(UInt(1) << 3)
    internal static let leading: ConstraintAttributes = ConstraintAttributes(UInt(1) << 4)
    internal static let trailing: ConstraintAttributes = ConstraintAttributes(UInt(1) << 5)
    internal static let width: ConstraintAttributes = ConstraintAttributes(UInt(1) << 6)
    internal static let height: ConstraintAttributes = ConstraintAttributes(UInt(1) << 7)
    internal static let centerX: ConstraintAttributes = ConstraintAttributes(UInt(1) << 8)
    internal static let centerY: ConstraintAttributes = ConstraintAttributes(UInt(1) << 9)
    internal static let lastBaseline: ConstraintAttributes = ConstraintAttributes(UInt(1) << 10)
    
    @available(iOS 8.0, OSX 10.11, *)
    internal static let firstBaseline: ConstraintAttributes = ConstraintAttributes(UInt(1) << 11)

    @available(iOS 8.0, *)
    internal static let leftMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 12)

    @available(iOS 8.0, *)
    internal static let rightMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 13)

    @available(iOS 8.0, *)
    internal static let topMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 14)

    @available(iOS 8.0, *)
    internal static let bottomMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 15)

    @available(iOS 8.0, *)
    internal static let leadingMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 16)

    @available(iOS 8.0, *)
    internal static let trailingMargin: ConstraintAttributes = ConstraintAttributes(UInt(1) << 17)

    @available(iOS 8.0, *)
    internal static let centerXWithinMargins: ConstraintAttributes = ConstraintAttributes(UInt(1) << 18)

    @available(iOS 8.0, *)
    internal static let centerYWithinMargins: ConstraintAttributes = ConstraintAttributes(UInt(1) << 19)
    
    // aggregates
    
    internal static let edges: ConstraintAttributes = [.horizontalEdges, .verticalEdges]
    internal static let horizontalEdges: ConstraintAttributes = [.left, .right]
    internal static let verticalEdges: ConstraintAttributes = [.top, .bottom]
    internal static let directionalEdges: ConstraintAttributes = [.directionalHorizontalEdges, .directionalVerticalEdges]
    internal static let directionalHorizontalEdges: ConstraintAttributes = [.leading, .trailing]
    internal static let directionalVerticalEdges: ConstraintAttributes = [.top, .bottom]
    internal static let size: ConstraintAttributes = [.width, .height]
    internal static let center: ConstraintAttributes = [.centerX, .centerY]

    @available(iOS 8.0, *)
    internal static let margins: ConstraintAttributes = [.leftMargin, .topMargin, .rightMargin, .bottomMargin]

    @available(iOS 8.0, *)
    internal static let directionalMargins: ConstraintAttributes = [.leadingMargin, .topMargin, .trailingMargin, .bottomMargin]

    @available(iOS 8.0, *)
    internal static let centerWithinMargins: ConstraintAttributes = [.centerXWithinMargins, .centerYWithinMargins]
    
    internal var layoutAttributes:[LayoutAttribute] {
        var attrs = [LayoutAttribute]()
        if (self.contains(ConstraintAttributes.left)) {
            attrs.append(.left)
        }
        if (self.contains(ConstraintAttributes.top)) {
            attrs.append(.top)
        }
        if (self.contains(ConstraintAttributes.right)) {
            attrs.append(.right)
        }
        if (self.contains(ConstraintAttributes.bottom)) {
            attrs.append(.bottom)
        }
        if (self.contains(ConstraintAttributes.leading)) {
            attrs.append(.leading)
        }
        if (self.contains(ConstraintAttributes.trailing)) {
            attrs.append(.trailing)
        }
        if (self.contains(ConstraintAttributes.width)) {
            attrs.append(.width)
        }
        if (self.contains(ConstraintAttributes.height)) {
            attrs.append(.height)
        }
        if (self.contains(ConstraintAttributes.centerX)) {
            attrs.append(.centerX)
        }
        if (self.contains(ConstraintAttributes.centerY)) {
            attrs.append(.centerY)
        }
        if (self.contains(ConstraintAttributes.lastBaseline)) {
            attrs.append(.lastBaseline)
        }
        
        #if os(iOS) || os(tvOS)
            if (self.contains(ConstraintAttributes.firstBaseline)) {
                attrs.append(.firstBaseline)
            }
            if (self.contains(ConstraintAttributes.leftMargin)) {
                attrs.append(.leftMargin)
            }
            if (self.contains(ConstraintAttributes.rightMargin)) {
                attrs.append(.rightMargin)
            }
            if (self.contains(ConstraintAttributes.topMargin)) {
                attrs.append(.topMargin)
            }
            if (self.contains(ConstraintAttributes.bottomMargin)) {
                attrs.append(.bottomMargin)
            }
            if (self.contains(ConstraintAttributes.leadingMargin)) {
                attrs.append(.leadingMargin)
            }
            if (self.contains(ConstraintAttributes.trailingMargin)) {
                attrs.append(.trailingMargin)
            }
            if (self.contains(ConstraintAttributes.centerXWithinMargins)) {
                attrs.append(.centerXWithinMargins)
            }
            if (self.contains(ConstraintAttributes.centerYWithinMargins)) {
                attrs.append(.centerYWithinMargins)
            }
        #endif
        
        return attrs
    }
}

internal func + (left: ConstraintAttributes, right: ConstraintAttributes) -> ConstraintAttributes {
    return left.union(right)
}

internal func +=(left: inout ConstraintAttributes, right: ConstraintAttributes) {
    left.formUnion(right)
}

internal func -=(left: inout ConstraintAttributes, right: ConstraintAttributes) {
    left.subtract(right)
}

internal func ==(left: ConstraintAttributes, right: ConstraintAttributes) -> Bool {
    return left.rawValue == right.rawValue
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public struct ConstraintViewDSL: ConstraintAttributesDSL {
    
    @discardableResult
    public func prepareConstraints(_ closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        return ConstraintMaker.prepareConstraints(item: self.view, closure: closure)
    }
    
    public func makeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.makeConstraints(item: self.view, closure: closure)
    }
    
    public func remakeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.remakeConstraints(item: self.view, closure: closure)
    }
    
    public func updateConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.updateConstraints(item: self.view, closure: closure)
    }
    
    public func removeConstraints() {
        ConstraintMaker.removeConstraints(item: self.view)
    }
    
    public var contentHuggingHorizontalPriority: Float {
        get {
            return self.view.contentHuggingPriority(for: .horizontal).rawValue
        }
        nonmutating set {
            self.view.setContentHuggingPriority(LayoutPriority(rawValue: newValue), for: .horizontal)
        }
    }
    
    public var contentHuggingVerticalPriority: Float {
        get {
            return self.view.contentHuggingPriority(for: .vertical).rawValue
        }
        nonmutating set {
            self.view.setContentHuggingPriority(LayoutPriority(rawValue: newValue), for: .vertical)
        }
    }
    
    public var contentCompressionResistanceHorizontalPriority: Float {
        get {
            return self.view.contentCompressionResistancePriority(for: .horizontal).rawValue
        }
        nonmutating set {
            self.view.setContentCompressionResistancePriority(LayoutPriority(rawValue: newValue), for: .horizontal)
        }
    }
    
    public var contentCompressionResistanceVerticalPriority: Float {
        get {
            return self.view.contentCompressionResistancePriority(for: .vertical).rawValue
        }
        nonmutating set {
            self.view.setContentCompressionResistancePriority(LayoutPriority(rawValue: newValue), for: .vertical)
        }
    }
    
    public var target: AnyObject? {
        return self.view
    }
    
    internal let view: ConstraintView
    
    internal init(view: ConstraintView) {
        self.view = view
        
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintPriorityTarget {
    
    var constraintPriorityTargetValue: Float { get }
    
}

extension Int: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}

extension UInt: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}

extension Float: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return self
    }
    
}

extension Double: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}

extension CGFloat: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}

#if os(iOS) || os(tvOS)
extension UILayoutPriority: ConstraintPriorityTarget {

    public var constraintPriorityTargetValue: Float {
        return self.rawValue
    }

}
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    public typealias ConstraintInsets = UIEdgeInsets
#else
    public typealias ConstraintInsets = NSEdgeInsets
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintMakerFinalizable {
    
    internal let description: ConstraintDescription
    
    internal init(_ description: ConstraintDescription) {
        self.description = description
    }
    
    @discardableResult
    public func labeled(_ label: String) -> ConstraintMakerFinalizable {
        self.description.label = label
        return self
    }
    
    public var constraint: Constraint {
        return self.description.constraint!
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintDSL {
    
    var target: AnyObject? { get }
    
    func setLabel(_ value: String?)
    func label() -> String?
    
}
extension ConstraintDSL {
    
    public func setLabel(_ value: String?) {
        objc_setAssociatedObject(self.target as Any, &labelKey, value, .OBJC_ASSOCIATION_COPY_NONATOMIC)
    }
    public func label() -> String? {
        return objc_getAssociatedObject(self.target as Any, &labelKey) as? String
    }
    
}
private var labelKey: UInt8 = 0


public protocol ConstraintBasicAttributesDSL : ConstraintDSL {
}
extension ConstraintBasicAttributesDSL {
    
    // MARK: Basics
    
    public var left: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.left)
    }
    
    public var top: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.top)
    }
    
    public var right: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.right)
    }
    
    public var bottom: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.bottom)
    }
    
    public var leading: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.leading)
    }
    
    public var trailing: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.trailing)
    }
    
    public var width: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.width)
    }
    
    public var height: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.height)
    }
    
    public var centerX: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerX)
    }
    
    public var centerY: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerY)
    }
    
    public var edges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.edges)
    }
    
    public var directionalEdges: ConstraintItem {
      return ConstraintItem(target: self.target, attributes: ConstraintAttributes.directionalEdges)
    }

    public var horizontalEdges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.horizontalEdges)
    }

    public var verticalEdges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.verticalEdges)
    }

    public var directionalHorizontalEdges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.directionalHorizontalEdges)
    }

    public var directionalVerticalEdges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.directionalVerticalEdges)
    }

    public var size: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.size)
    }
    
    public var center: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.center)
    }
    
}

public protocol ConstraintAttributesDSL : ConstraintBasicAttributesDSL {
}
extension ConstraintAttributesDSL {
    
    // MARK: Baselines
    @available(*, deprecated, renamed:"lastBaseline")
    public var baseline: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.lastBaseline)
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var lastBaseline: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.lastBaseline)
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var firstBaseline: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.firstBaseline)
    }
    
    // MARK: Margins
    
    @available(iOS 8.0, *)
    public var leftMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.leftMargin)
    }
    
    @available(iOS 8.0, *)
    public var topMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.topMargin)
    }
    
    @available(iOS 8.0, *)
    public var rightMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.rightMargin)
    }
    
    @available(iOS 8.0, *)
    public var bottomMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.bottomMargin)
    }
    
    @available(iOS 8.0, *)
    public var leadingMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.leadingMargin)
    }
    
    @available(iOS 8.0, *)
    public var trailingMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.trailingMargin)
    }
    
    @available(iOS 8.0, *)
    public var centerXWithinMargins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerXWithinMargins)
    }
    
    @available(iOS 8.0, *)
    public var centerYWithinMargins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerYWithinMargins)
    }
    
    @available(iOS 8.0, *)
    public var margins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.margins)
    }
    
    @available(iOS 8.0, *)
    public var directionalMargins: ConstraintItem {
      return ConstraintItem(target: self.target, attributes: ConstraintAttributes.directionalMargins)
    }

    @available(iOS 8.0, *)
    public var centerWithinMargins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerWithinMargins)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintMakerExtendable: ConstraintMakerRelatable {
    
    public var left: ConstraintMakerExtendable {
        self.description.attributes += .left
        return self
    }
    
    public var top: ConstraintMakerExtendable {
        self.description.attributes += .top
        return self
    }
    
    public var bottom: ConstraintMakerExtendable {
        self.description.attributes += .bottom
        return self
    }
    
    public var right: ConstraintMakerExtendable {
        self.description.attributes += .right
        return self
    }
    
    public var leading: ConstraintMakerExtendable {
        self.description.attributes += .leading
        return self
    }
    
    public var trailing: ConstraintMakerExtendable {
        self.description.attributes += .trailing
        return self
    }
    
    public var width: ConstraintMakerExtendable {
        self.description.attributes += .width
        return self
    }
    
    public var height: ConstraintMakerExtendable {
        self.description.attributes += .height
        return self
    }
    
    public var centerX: ConstraintMakerExtendable {
        self.description.attributes += .centerX
        return self
    }
    
    public var centerY: ConstraintMakerExtendable {
        self.description.attributes += .centerY
        return self
    }
    
    @available(*, deprecated, renamed:"lastBaseline")
    public var baseline: ConstraintMakerExtendable {
        self.description.attributes += .lastBaseline
        return self
    }
    
    public var lastBaseline: ConstraintMakerExtendable {
        self.description.attributes += .lastBaseline
        return self
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var firstBaseline: ConstraintMakerExtendable {
        self.description.attributes += .firstBaseline
        return self
    }
    
    @available(iOS 8.0, *)
    public var leftMargin: ConstraintMakerExtendable {
        self.description.attributes += .leftMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var rightMargin: ConstraintMakerExtendable {
        self.description.attributes += .rightMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var topMargin: ConstraintMakerExtendable {
        self.description.attributes += .topMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var bottomMargin: ConstraintMakerExtendable {
        self.description.attributes += .bottomMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var leadingMargin: ConstraintMakerExtendable {
        self.description.attributes += .leadingMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var trailingMargin: ConstraintMakerExtendable {
        self.description.attributes += .trailingMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var centerXWithinMargins: ConstraintMakerExtendable {
        self.description.attributes += .centerXWithinMargins
        return self
    }
    
    @available(iOS 8.0, *)
    public var centerYWithinMargins: ConstraintMakerExtendable {
        self.description.attributes += .centerYWithinMargins
        return self
    }
    
    public var edges: ConstraintMakerExtendable {
        self.description.attributes += .edges
        return self
    }
    public var horizontalEdges: ConstraintMakerExtendable {
        self.description.attributes += .horizontalEdges
        return self
    }
    public var verticalEdges: ConstraintMakerExtendable {
        self.description.attributes += .verticalEdges
        return self
    }
    public var directionalEdges: ConstraintMakerExtendable {
        self.description.attributes += .directionalEdges
        return self
    }
    public var directionalHorizontalEdges: ConstraintMakerExtendable {
        self.description.attributes += .directionalHorizontalEdges
        return self
    }
    public var directionalVerticalEdges: ConstraintMakerExtendable {
        self.description.attributes += .directionalVerticalEdges
        return self
    }
    public var size: ConstraintMakerExtendable {
        self.description.attributes += .size
        return self
    }
    
    @available(iOS 8.0, *)
    public var margins: ConstraintMakerExtendable {
        self.description.attributes += .margins
        return self
    }
    
    @available(iOS 8.0, *)
    public var directionalMargins: ConstraintMakerExtendable {
      self.description.attributes += .directionalMargins
      return self
    }

    @available(iOS 8.0, *)
    public var centerWithinMargins: ConstraintMakerExtendable {
        self.description.attributes += .centerWithinMargins
        return self
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

public struct ConstraintPriority : ExpressibleByFloatLiteral, Equatable, Strideable {
    public typealias FloatLiteralType = Float
    
    public let value: Float
    
    public init(floatLiteral value: Float) {
        self.value = value
    }
    
    public init(_ value: Float) {
        self.value = value
    }
    
    public static var required: ConstraintPriority {
        return 1000.0
    }
    
    public static var high: ConstraintPriority {
        return 750.0
    }
    
    public static var medium: ConstraintPriority {
        #if os(OSX)
            return 501.0
        #else
            return 500.0
        #endif
        
    }
    
    public static var low: ConstraintPriority {
        return 250.0
    }
    
    public static func ==(lhs: ConstraintPriority, rhs: ConstraintPriority) -> Bool {
        return lhs.value == rhs.value
    }

    // MARK: Strideable

    public func advanced(by n: FloatLiteralType) -> ConstraintPriority {
        return ConstraintPriority(floatLiteral: value + n)
    }

    public func distance(to other: ConstraintPriority) -> FloatLiteralType {
        return other.value - value
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintInsetTarget: ConstraintConstantTarget {
}

extension Int: ConstraintInsetTarget {
}

extension UInt: ConstraintInsetTarget {
}

extension Float: ConstraintInsetTarget {
}

extension Double: ConstraintInsetTarget {
}

extension CGFloat: ConstraintInsetTarget {
}

extension ConstraintInsets: ConstraintInsetTarget {
}

extension ConstraintInsetTarget {

    internal var constraintInsetTargetValue: ConstraintInsets {
        if let amount = self as? ConstraintInsets {
            return amount
        } else if let amount = self as? Float {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else if let amount = self as? Double {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else if let amount = self as? CGFloat {
            return ConstraintInsets(top: amount, left: amount, bottom: amount, right: amount)
        } else if let amount = self as? Int {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else if let amount = self as? UInt {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else {
            return ConstraintInsets(top: 0, left: 0, bottom: 0, right: 0)
        }
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
import UIKit
#else
import AppKit
#endif

#if os(iOS) || os(tvOS)
public protocol ConstraintDirectionalInsetTarget: ConstraintConstantTarget {
}

@available(iOS 11.0, tvOS 11.0, *)
extension ConstraintDirectionalInsets: ConstraintDirectionalInsetTarget {
}

extension ConstraintDirectionalInsetTarget {

  @available(iOS 11.0, tvOS 11.0, *)
  internal var constraintDirectionalInsetTargetValue: ConstraintDirectionalInsets {
    if let amount = self as? ConstraintDirectionalInsets {
      return amount
    } else {
      return ConstraintDirectionalInsets(top: 0, leading: 0, bottom: 0, trailing: 0)
    }
  }
}
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


extension ConstraintMakerRelatable {
  
    @discardableResult
    public func equalToSuperview<T: ConstraintRelatableTarget>(_ closure: (ConstraintView) -> T, _ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `equalToSuperview`.")
        }
        return self.relatedTo(closure(other), relation: .equal, file: file, line: line)
    }
  
    @discardableResult
    public func lessThanOrEqualToSuperview<T: ConstraintRelatableTarget>(_ closure: (ConstraintView) -> T, _ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `lessThanOrEqualToSuperview`.")
        }
        return self.relatedTo(closure(other), relation: .lessThanOrEqual, file: file, line: line)
    }
  
    @discardableResult
    public func greaterThanOrEqualTo<T: ConstraintRelatableTarget>(_ closure: (ConstraintView) -> T, _ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `greaterThanOrEqualToSuperview`.")
        }
        return self.relatedTo(closure(other), relation: .greaterThanOrEqual, file: file, line: line)
    }
  
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
    public typealias ConstraintInterfaceLayoutDirection = UIUserInterfaceLayoutDirection
#else
    import AppKit
    public typealias ConstraintInterfaceLayoutDirection = NSUserInterfaceLayoutDirection
#endif


public struct ConstraintConfig {
    
    public static var interfaceLayoutDirection: ConstraintInterfaceLayoutDirection = .leftToRight
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#endif

    
@available(iOS 8.0, *)
public extension ConstraintLayoutSupport {
    
    var snp: ConstraintLayoutSupportDSL {
        return ConstraintLayoutSupportDSL(support: self)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    public typealias ConstraintView = UIView
#else
    public typealias ConstraintView = NSView
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    @available(iOS 9.0, *)
    public typealias ConstraintLayoutGuide = UILayoutGuide
#else
    @available(OSX 10.11, *)
    public typealias ConstraintLayoutGuide = NSLayoutGuide
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    @available(iOS 8.0, *)
    public typealias ConstraintLayoutSupport = UILayoutSupport
#else
    public class ConstraintLayoutSupport {}
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

import Foundation

#if os(iOS) || os(tvOS)
    import UIKit
#if swift(>=4.2)
    typealias LayoutRelation = NSLayoutConstraint.Relation
    typealias LayoutAttribute = NSLayoutConstraint.Attribute
#else
    typealias LayoutRelation = NSLayoutRelation
    typealias LayoutAttribute = NSLayoutAttribute
#endif
    typealias LayoutPriority = UILayoutPriority
#else
    import AppKit
    typealias LayoutRelation = NSLayoutConstraint.Relation
    typealias LayoutAttribute = NSLayoutConstraint.Attribute
    typealias LayoutPriority = NSLayoutConstraint.Priority
#endif

//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintConstantTarget {
}

extension CGPoint: ConstraintConstantTarget {
}

extension CGSize: ConstraintConstantTarget {    
}

extension ConstraintInsets: ConstraintConstantTarget {
}

#if os(iOS) || os(tvOS)
@available(iOS 11.0, tvOS 11.0, *)
extension ConstraintDirectionalInsets: ConstraintConstantTarget {
}
#endif

extension ConstraintConstantTarget {
    
    internal func constraintConstantTargetValueFor(layoutAttribute: LayoutAttribute) -> CGFloat {
        if let value = self as? CGFloat {
            return value
        }
        
        if let value = self as? Float {
            return CGFloat(value)
        }
        
        if let value = self as? Double {
            return CGFloat(value)
        }
        
        if let value = self as? Int {
            return CGFloat(value)
        }
        
        if let value = self as? UInt {
            return CGFloat(value)
        }
        
        if let value = self as? CGSize {
            if layoutAttribute == .width {
                return value.width
            } else if layoutAttribute == .height {
                return value.height
            } else {
                return 0.0
            }
        }
        
        if let value = self as? CGPoint {
            #if os(iOS) || os(tvOS)
                switch layoutAttribute {
                case .left, .right, .leading, .trailing, .centerX, .leftMargin, .rightMargin, .leadingMargin, .trailingMargin, .centerXWithinMargins:
                    return value.x
                case .top, .bottom, .centerY, .topMargin, .bottomMargin, .centerYWithinMargins, .lastBaseline, .firstBaseline:
                    return value.y
                case .width, .height, .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #endif
            }
            #else
                switch layoutAttribute {
                case .left, .right, .leading, .trailing, .centerX:
                    return value.x
                case .top, .bottom, .centerY, .lastBaseline, .firstBaseline:
                    return value.y
                case .width, .height, .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #endif
            }
            #endif
        }
        
        if let value = self as? ConstraintInsets {
            #if os(iOS) || os(tvOS)
                switch layoutAttribute {
                case .left, .leftMargin:
                    return value.left
                case .top, .topMargin, .firstBaseline:
                    return value.top
                case .right, .rightMargin:
                    return -value.right
                case .bottom, .bottomMargin, .lastBaseline:
                    return -value.bottom
                case .leading, .leadingMargin:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? value.left : value.right
                case .trailing, .trailingMargin:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? -value.right : -value.left
                case .centerX, .centerXWithinMargins:
                    return (value.left - value.right) / 2
                case .centerY, .centerYWithinMargins:
                    return (value.top - value.bottom) / 2
                case .width:
                    return -(value.left + value.right)
                case .height:
                    return -(value.top + value.bottom)
                case .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #endif
            }
            #else
                switch layoutAttribute {
                case .left:
                    return value.left
                case .top, .firstBaseline:
                    return value.top
                case .right:
                    return -value.right
                case .bottom, .lastBaseline:
                    return -value.bottom
                case .leading:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? value.left : value.right
                case .trailing:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? -value.right : -value.left
                case .centerX:
                    return (value.left - value.right) / 2
                case .centerY:
                    return (value.top - value.bottom) / 2
                case .width:
                    return -(value.left + value.right)
                case .height:
                    return -(value.top + value.bottom)
                case .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #endif
            }
            #endif
        }
        
        #if os(iOS) || os(tvOS)
            if #available(iOS 11.0, tvOS 11.0, *), let value = self as? ConstraintDirectionalInsets {
                switch layoutAttribute {
                case .left, .leftMargin:
                  return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? value.leading : value.trailing
                case .top, .topMargin, .firstBaseline:
                    return value.top
                case .right, .rightMargin:
                  return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? -value.trailing : -value.leading
                case .bottom, .bottomMargin, .lastBaseline:
                    return -value.bottom
                case .leading, .leadingMargin:
                    return value.leading
                case .trailing, .trailingMargin:
                    return -value.trailing
                case .centerX, .centerXWithinMargins:
                    return (value.leading - value.trailing) / 2
                case .centerY, .centerYWithinMargins:
                    return (value.top - value.bottom) / 2
                case .width:
                    return -(value.leading + value.trailing)
                case .height:
                    return -(value.top + value.bottom)
                case .notAnAttribute:
                    return 0.0
                #if swift(>=5.0)
                @unknown default:
                    return 0.0
                #else
                default:
                    return 0.0
                #endif
                }
            }
        #endif

        return 0.0
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintOffsetTarget: ConstraintConstantTarget {
}

extension Int: ConstraintOffsetTarget {
}

extension UInt: ConstraintOffsetTarget {
}

extension Float: ConstraintOffsetTarget {
}

extension Double: ConstraintOffsetTarget {
}

extension CGFloat: ConstraintOffsetTarget {
}

extension ConstraintOffsetTarget {
    
    internal var constraintOffsetTargetValue: CGFloat {
        let offset: CGFloat
        if let amount = self as? Float {
            offset = CGFloat(amount)
        } else if let amount = self as? Double {
            offset = CGFloat(amount)
        } else if let amount = self as? CGFloat {
            offset = CGFloat(amount)
        } else if let amount = self as? Int {
            offset = CGFloat(amount)
        } else if let amount = self as? UInt {
            offset = CGFloat(amount)
        } else {
            offset = 0.0
        }
        return offset
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintMakerEditable: ConstraintMakerPrioritizable {

    @discardableResult
    public func multipliedBy(_ amount: ConstraintMultiplierTarget) -> ConstraintMakerEditable {
        self.description.multiplier = amount
        return self
    }
    
    @discardableResult
    public func dividedBy(_ amount: ConstraintMultiplierTarget) -> ConstraintMakerEditable {
        return self.multipliedBy(1.0 / amount.constraintMultiplierTargetValue)
    }
    
    @discardableResult
    public func offset(_ amount: ConstraintOffsetTarget) -> ConstraintMakerEditable {
        self.description.constant = amount.constraintOffsetTargetValue
        return self
    }
    
    @discardableResult
    public func inset(_ amount: ConstraintInsetTarget) -> ConstraintMakerEditable {
        self.description.constant = amount.constraintInsetTargetValue
        return self
    }
    
    #if os(iOS) || os(tvOS)
    @discardableResult
    @available(iOS 11.0, tvOS 11.0, *)
    public func inset(_ amount: ConstraintDirectionalInsetTarget) -> ConstraintMakerEditable {
        self.description.constant = amount.constraintDirectionalInsetTargetValue
        return self
    }
    #endif
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

public class ConstraintMaker {
    
    public var left: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.left)
    }
    
    public var top: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.top)
    }
    
    public var bottom: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.bottom)
    }
    
    public var right: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.right)
    }
    
    public var leading: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.leading)
    }
    
    public var trailing: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.trailing)
    }
    
    public var width: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.width)
    }
    
    public var height: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.height)
    }
    
    public var centerX: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerX)
    }
    
    public var centerY: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerY)
    }
    
    @available(*, deprecated, renamed:"lastBaseline")
    public var baseline: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.lastBaseline)
    }
    
    public var lastBaseline: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.lastBaseline)
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var firstBaseline: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.firstBaseline)
    }
    
    @available(iOS 8.0, *)
    public var leftMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.leftMargin)
    }
    
    @available(iOS 8.0, *)
    public var rightMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.rightMargin)
    }
    
    @available(iOS 8.0, *)
    public var topMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.topMargin)
    }
    
    @available(iOS 8.0, *)
    public var bottomMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.bottomMargin)
    }
    
    @available(iOS 8.0, *)
    public var leadingMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.leadingMargin)
    }
    
    @available(iOS 8.0, *)
    public var trailingMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.trailingMargin)
    }
    
    @available(iOS 8.0, *)
    public var centerXWithinMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerXWithinMargins)
    }
    
    @available(iOS 8.0, *)
    public var centerYWithinMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerYWithinMargins)
    }
    
    public var edges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.edges)
    }
    public var horizontalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.horizontalEdges)
    }
    public var verticalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.verticalEdges)
    }
    public var directionalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.directionalEdges)
    }
    public var directionalHorizontalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.directionalHorizontalEdges)
    }
    public var directionalVerticalEdges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.directionalVerticalEdges)
    }
    public var size: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.size)
    }
    public var center: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.center)
    }
    
    @available(iOS 8.0, *)
    public var margins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.margins)
    }
    
    @available(iOS 8.0, *)
    public var directionalMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.directionalMargins)
    }

    @available(iOS 8.0, *)
    public var centerWithinMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerWithinMargins)
    }
    
    public let item: LayoutConstraintItem
    private var descriptions = [ConstraintDescription]()
    
    internal init(item: LayoutConstraintItem) {
        self.item = item
        self.item.prepare()
    }
    
    internal func makeExtendableWithAttributes(_ attributes: ConstraintAttributes) -> ConstraintMakerExtendable {
        let description = ConstraintDescription(item: self.item, attributes: attributes)
        self.descriptions.append(description)
        return ConstraintMakerExtendable(description)
    }
    
    internal static func prepareConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        let maker = ConstraintMaker(item: item)
        closure(maker)
        var constraints: [Constraint] = []
        for description in maker.descriptions {
            guard let constraint = description.constraint else {
                continue
            }
            constraints.append(constraint)
        }
        return constraints
    }
    
    internal static func makeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) {
        let constraints = prepareConstraints(item: item, closure: closure)
        for constraint in constraints {
            constraint.activateIfNeeded(updatingExisting: false)
        }
    }
    
    internal static func remakeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) {
        self.removeConstraints(item: item)
        self.makeConstraints(item: item, closure: closure)
    }
    
    internal static func updateConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) {
        guard item.constraints.count > 0 else {
            self.makeConstraints(item: item, closure: closure)
            return
        }
        
        let constraints = prepareConstraints(item: item, closure: closure)
        for constraint in constraints {
            constraint.activateIfNeeded(updatingExisting: true)
        }
    }
    
    internal static func removeConstraints(item: LayoutConstraintItem) {
        let constraints = item.constraints
        for constraint in constraints {
            constraint.deactivateIfNeeded()
        }
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


internal enum ConstraintRelation : Int {
    case equal = 1
    case lessThanOrEqual
    case greaterThanOrEqual
    
    internal var layoutRelation: LayoutRelation {
        get {
            switch(self) {
            case .equal:
                return .equal
            case .lessThanOrEqual:
                return .lessThanOrEqual
            case .greaterThanOrEqual:
                return .greaterThanOrEqual
            }
        }
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


@available(iOS 9.0, OSX 10.11, *)
public struct ConstraintLayoutGuideDSL: ConstraintAttributesDSL {
    
    @discardableResult
    public func prepareConstraints(_ closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        return ConstraintMaker.prepareConstraints(item: self.guide, closure: closure)
    }
    
    public func makeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.makeConstraints(item: self.guide, closure: closure)
    }
    
    public func remakeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.remakeConstraints(item: self.guide, closure: closure)
    }
    
    public func updateConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.updateConstraints(item: self.guide, closure: closure)
    }
    
    public func removeConstraints() {
        ConstraintMaker.removeConstraints(item: self.guide)
    }
    
    public var target: AnyObject? {
        return self.guide
    }
    
    internal let guide: ConstraintLayoutGuide
    
    internal init(guide: ConstraintLayoutGuide) {
        self.guide = guide
        
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public extension ConstraintView {
    
    @available(*, deprecated, renamed:"snp.left")
    var snp_left: ConstraintItem { return self.snp.left }
    
    @available(*, deprecated, renamed:"snp.top")
    var snp_top: ConstraintItem { return self.snp.top }
    
    @available(*, deprecated, renamed:"snp.right")
    var snp_right: ConstraintItem { return self.snp.right }
    
    @available(*, deprecated, renamed:"snp.bottom")
    var snp_bottom: ConstraintItem { return self.snp.bottom }
    
    @available(*, deprecated, renamed:"snp.leading")
    var snp_leading: ConstraintItem { return self.snp.leading }
    
    @available(*, deprecated, renamed:"snp.trailing")
    var snp_trailing: ConstraintItem { return self.snp.trailing }
    
    @available(*, deprecated, renamed:"snp.width")
    var snp_width: ConstraintItem { return self.snp.width }
    
    @available(*, deprecated, renamed:"snp.height")
    var snp_height: ConstraintItem { return self.snp.height }
    
    @available(*, deprecated, renamed:"snp.centerX")
    var snp_centerX: ConstraintItem { return self.snp.centerX }
    
    @available(*, deprecated, renamed:"snp.centerY")
    var snp_centerY: ConstraintItem { return self.snp.centerY }
    
    @available(*, deprecated, renamed:"snp.baseline")
    var snp_baseline: ConstraintItem { return self.snp.baseline }
    
    @available(*, deprecated, renamed:"snp.lastBaseline")
    @available(iOS 8.0, OSX 10.11, *)
    var snp_lastBaseline: ConstraintItem { return self.snp.lastBaseline }
    
    @available(iOS, deprecated, renamed:"snp.firstBaseline")
    @available(iOS 8.0, OSX 10.11, *)
    var snp_firstBaseline: ConstraintItem { return self.snp.firstBaseline }
    
    @available(iOS, deprecated, renamed:"snp.leftMargin")
    @available(iOS 8.0, *)
    var snp_leftMargin: ConstraintItem { return self.snp.leftMargin }
    
    @available(iOS, deprecated, renamed:"snp.topMargin")
    @available(iOS 8.0, *)
    var snp_topMargin: ConstraintItem { return self.snp.topMargin }
    
    @available(iOS, deprecated, renamed:"snp.rightMargin")
    @available(iOS 8.0, *)
    var snp_rightMargin: ConstraintItem { return self.snp.rightMargin }
    
    @available(iOS, deprecated, renamed:"snp.bottomMargin")
    @available(iOS 8.0, *)
    var snp_bottomMargin: ConstraintItem { return self.snp.bottomMargin }
    
    @available(iOS, deprecated, renamed:"snp.leadingMargin")
    @available(iOS 8.0, *)
    var snp_leadingMargin: ConstraintItem { return self.snp.leadingMargin }
    
    @available(iOS, deprecated, renamed:"snp.trailingMargin")
    @available(iOS 8.0, *)
    var snp_trailingMargin: ConstraintItem { return self.snp.trailingMargin }
    
    @available(iOS, deprecated, renamed:"snp.centerXWithinMargins")
    @available(iOS 8.0, *)
    var snp_centerXWithinMargins: ConstraintItem { return self.snp.centerXWithinMargins }
    
    @available(iOS, deprecated, renamed:"snp.centerYWithinMargins")
    @available(iOS 8.0, *)
    var snp_centerYWithinMargins: ConstraintItem { return self.snp.centerYWithinMargins }
    
    @available(*, deprecated, renamed:"snp.edges")
    var snp_edges: ConstraintItem { return self.snp.edges }
    
    @available(*, deprecated, renamed:"snp.size")
    var snp_size: ConstraintItem { return self.snp.size }
    
    @available(*, deprecated, renamed:"snp.center")
    var snp_center: ConstraintItem { return self.snp.center }
    
    @available(iOS, deprecated, renamed:"snp.margins")
    @available(iOS 8.0, *)
    var snp_margins: ConstraintItem { return self.snp.margins }
    
    @available(iOS, deprecated, renamed:"snp.centerWithinMargins")
    @available(iOS 8.0, *)
    var snp_centerWithinMargins: ConstraintItem { return self.snp.centerWithinMargins }
    
    @available(*, deprecated, renamed:"snp.prepareConstraints(_:)")
    func snp_prepareConstraints(_ closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        return self.snp.prepareConstraints(closure)
    }
    
    @available(*, deprecated, renamed:"snp.makeConstraints(_:)")
    func snp_makeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        self.snp.makeConstraints(closure)
    }
    
    @available(*, deprecated, renamed:"snp.remakeConstraints(_:)")
    func snp_remakeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        self.snp.remakeConstraints(closure)
    }
    
    @available(*, deprecated, renamed:"snp.updateConstraints(_:)")
    func snp_updateConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        self.snp.updateConstraints(closure)
    }
    
    @available(*, deprecated, renamed:"snp.removeConstraints()")
    func snp_removeConstraints() {
        self.snp.removeConstraints()
    }
    
    var snp: ConstraintViewDSL {
        return ConstraintViewDSL(view: self)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public final class ConstraintItem {
    
    internal weak var target: AnyObject?
    internal let attributes: ConstraintAttributes
    
    internal init(target: AnyObject?, attributes: ConstraintAttributes) {
        self.target = target
        self.attributes = attributes
    }
    
    internal var layoutConstraintItem: LayoutConstraintItem? {
        return self.target as? LayoutConstraintItem
    }
    
}

public func ==(lhs: ConstraintItem, rhs: ConstraintItem) -> Bool {
    // pointer equality
    guard lhs !== rhs else {
        return true
    }
    
    // must both have valid targets and identical attributes
    guard let target1 = lhs.target,
          let target2 = rhs.target,
          target1 === target2 && lhs.attributes == rhs.attributes else {
            return false
    }
    
    return true
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

public final class Constraint {

    internal let sourceLocation: (String, UInt)
    internal let label: String?

    private let from: ConstraintItem
    private let to: ConstraintItem
    private let relation: ConstraintRelation
    private let multiplier: ConstraintMultiplierTarget
    private var constant: ConstraintConstantTarget {
        didSet {
            self.updateConstantAndPriorityIfNeeded()
        }
    }
    private var priority: ConstraintPriorityTarget {
        didSet {
          self.updateConstantAndPriorityIfNeeded()
        }
    }
    public var layoutConstraints: [LayoutConstraint]
    
    public var isActive: Bool {
        set {
            if newValue {
                activate()
            }
            else {
                deactivate()
            }
        }
        
        get {
            for layoutConstraint in self.layoutConstraints {
                if layoutConstraint.isActive {
                    return true
                }
            }
            return false
        }
    }
    
    // MARK: Initialization

    internal init(from: ConstraintItem,
                  to: ConstraintItem,
                  relation: ConstraintRelation,
                  sourceLocation: (String, UInt),
                  label: String?,
                  multiplier: ConstraintMultiplierTarget,
                  constant: ConstraintConstantTarget,
                  priority: ConstraintPriorityTarget) {
        self.from = from
        self.to = to
        self.relation = relation
        self.sourceLocation = sourceLocation
        self.label = label
        self.multiplier = multiplier
        self.constant = constant
        self.priority = priority
        self.layoutConstraints = []

        // get attributes
        let layoutFromAttributes = self.from.attributes.layoutAttributes
        let layoutToAttributes = self.to.attributes.layoutAttributes

        // get layout from
        let layoutFrom = self.from.layoutConstraintItem!

        // get relation
        let layoutRelation = self.relation.layoutRelation

        for layoutFromAttribute in layoutFromAttributes {
            // get layout to attribute
            let layoutToAttribute: LayoutAttribute
            #if os(iOS) || os(tvOS)
                if layoutToAttributes.count > 0 {
                    if self.from.attributes == .edges && self.to.attributes == .margins {
                        switch layoutFromAttribute {
                        case .left:
                            layoutToAttribute = .leftMargin
                        case .right:
                            layoutToAttribute = .rightMargin
                        case .top:
                            layoutToAttribute = .topMargin
                        case .bottom:
                            layoutToAttribute = .bottomMargin
                        default:
                            fatalError()
                        }
                    } else if self.from.attributes == .margins && self.to.attributes == .edges {
                        switch layoutFromAttribute {
                        case .leftMargin:
                            layoutToAttribute = .left
                        case .rightMargin:
                            layoutToAttribute = .right
                        case .topMargin:
                            layoutToAttribute = .top
                        case .bottomMargin:
                            layoutToAttribute = .bottom
                        default:
                            fatalError()
                        }
                    } else if self.from.attributes == .directionalEdges && self.to.attributes == .directionalMargins {
                      switch layoutFromAttribute {
                      case .leading:
                        layoutToAttribute = .leadingMargin
                      case .trailing:
                        layoutToAttribute = .trailingMargin
                      case .top:
                        layoutToAttribute = .topMargin
                      case .bottom:
                        layoutToAttribute = .bottomMargin
                      default:
                        fatalError()
                      }
                    } else if self.from.attributes == .directionalMargins && self.to.attributes == .directionalEdges {
                      switch layoutFromAttribute {
                      case .leadingMargin:
                        layoutToAttribute = .leading
                      case .trailingMargin:
                        layoutToAttribute = .trailing
                      case .topMargin:
                        layoutToAttribute = .top
                      case .bottomMargin:
                        layoutToAttribute = .bottom
                      default:
                        fatalError()
                      }
                    } else if self.from.attributes == self.to.attributes {
                        layoutToAttribute = layoutFromAttribute
                    } else {
                        layoutToAttribute = layoutToAttributes[0]
                    }
                } else {
                    if self.to.target == nil && (layoutFromAttribute == .centerX || layoutFromAttribute == .centerY) {
                        layoutToAttribute = layoutFromAttribute == .centerX ? .left : .top
                    } else {
                        layoutToAttribute = layoutFromAttribute
                    }
                }
            #else
                if self.from.attributes == self.to.attributes {
                    layoutToAttribute = layoutFromAttribute
                } else if layoutToAttributes.count > 0 {
                    layoutToAttribute = layoutToAttributes[0]
                } else {
                    layoutToAttribute = layoutFromAttribute
                }
            #endif

            // get layout constant
            let layoutConstant: CGFloat = self.constant.constraintConstantTargetValueFor(layoutAttribute: layoutToAttribute)

            // get layout to
            var layoutTo: AnyObject? = self.to.target

            // use superview if possible
            if layoutTo == nil && layoutToAttribute != .width && layoutToAttribute != .height {
                layoutTo = layoutFrom.superview
            }

            // create layout constraint
            let layoutConstraint = LayoutConstraint(
                item: layoutFrom,
                attribute: layoutFromAttribute,
                relatedBy: layoutRelation,
                toItem: layoutTo,
                attribute: layoutToAttribute,
                multiplier: self.multiplier.constraintMultiplierTargetValue,
                constant: layoutConstant
            )

            // set label
            layoutConstraint.label = self.label

            // set priority
            layoutConstraint.priority = LayoutPriority(rawValue: self.priority.constraintPriorityTargetValue)

            // set constraint
            layoutConstraint.constraint = self

            // append
            self.layoutConstraints.append(layoutConstraint)
        }
    }

    // MARK: Public

    @available(*, deprecated, renamed:"activate()")
    public func install() {
        self.activate()
    }

    @available(*, deprecated, renamed:"deactivate()")
    public func uninstall() {
        self.deactivate()
    }

    public func activate() {
        self.activateIfNeeded()
    }

    public func deactivate() {
        self.deactivateIfNeeded()
    }

    @discardableResult
    public func update(offset: ConstraintOffsetTarget) -> Constraint {
        self.constant = offset.constraintOffsetTargetValue
        return self
    }

    @discardableResult
    public func update(inset: ConstraintInsetTarget) -> Constraint {
        self.constant = inset.constraintInsetTargetValue
        return self
    }

    #if os(iOS) || os(tvOS)
    @discardableResult
    @available(iOS 11.0, tvOS 11.0, *)
    public func update(inset: ConstraintDirectionalInsetTarget) -> Constraint {
      self.constant = inset.constraintDirectionalInsetTargetValue
      return self
    }
    #endif

    @discardableResult
    public func update(priority: ConstraintPriorityTarget) -> Constraint {
        self.priority = priority.constraintPriorityTargetValue
        return self
    }

    @discardableResult
    public func update(priority: ConstraintPriority) -> Constraint {
        self.priority = priority.value
        return self
    }

    @available(*, deprecated, renamed:"update(offset:)")
    public func updateOffset(amount: ConstraintOffsetTarget) -> Void { self.update(offset: amount) }

    @available(*, deprecated, renamed:"update(inset:)")
    public func updateInsets(amount: ConstraintInsetTarget) -> Void { self.update(inset: amount) }

    @available(*, deprecated, renamed:"update(priority:)")
    public func updatePriority(amount: ConstraintPriorityTarget) -> Void { self.update(priority: amount) }

    @available(*, deprecated, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityRequired() -> Void {}

    @available(*, deprecated, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityHigh() -> Void { fatalError("Must be implemented by Concrete subclass.") }

    @available(*, deprecated, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityMedium() -> Void { fatalError("Must be implemented by Concrete subclass.") }

    @available(*, deprecated, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityLow() -> Void { fatalError("Must be implemented by Concrete subclass.") }

    // MARK: Internal

    internal func updateConstantAndPriorityIfNeeded() {
        for layoutConstraint in self.layoutConstraints {
            let attribute = (layoutConstraint.secondAttribute == .notAnAttribute) ? layoutConstraint.firstAttribute : layoutConstraint.secondAttribute
            layoutConstraint.constant = self.constant.constraintConstantTargetValueFor(layoutAttribute: attribute)

            let requiredPriority = ConstraintPriority.required.value
            if (layoutConstraint.priority.rawValue < requiredPriority), (self.priority.constraintPriorityTargetValue != requiredPriority) {
                layoutConstraint.priority = LayoutPriority(rawValue: self.priority.constraintPriorityTargetValue)
            }
        }
    }

    internal func activateIfNeeded(updatingExisting: Bool = false) {
        guard let item = self.from.layoutConstraintItem else {
            print("WARNING: SnapKit failed to get from item from constraint. Activate will be a no-op.")
            return
        }
        let layoutConstraints = self.layoutConstraints

        if updatingExisting {
            var existingLayoutConstraints: [LayoutConstraint] = []
            for constraint in item.constraints {
                existingLayoutConstraints += constraint.layoutConstraints
            }

            for layoutConstraint in layoutConstraints {
                let existingLayoutConstraint = existingLayoutConstraints.first { $0 == layoutConstraint }
                guard let updateLayoutConstraint = existingLayoutConstraint else {
                    fatalError("Updated constraint could not find existing matching constraint to update: \(layoutConstraint)")
                }

                let updateLayoutAttribute = (updateLayoutConstraint.secondAttribute == .notAnAttribute) ? updateLayoutConstraint.firstAttribute : updateLayoutConstraint.secondAttribute
                updateLayoutConstraint.constant = self.constant.constraintConstantTargetValueFor(layoutAttribute: updateLayoutAttribute)
            }
        } else {
            NSLayoutConstraint.activate(layoutConstraints)
            item.add(constraints: [self])
        }
    }

    internal func deactivateIfNeeded() {
        guard let item = self.from.layoutConstraintItem else {
            print("WARNING: SnapKit failed to get from item from constraint. Deactivate will be a no-op.")
            return
        }
        let layoutConstraints = self.layoutConstraints
        NSLayoutConstraint.deactivate(layoutConstraints)
        item.remove(constraints: [self])
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif

public extension LayoutConstraint {
    
    override var description: String {
        var description = "<"
        
        description += descriptionForObject(self)
        
        if let firstItem = conditionalOptional(from: self.firstItem) {
            description += " \(descriptionForObject(firstItem))"
        }
        
        if self.firstAttribute != .notAnAttribute {
            description += ".\(descriptionForAttribute(self.firstAttribute))"
        }
        
        description += " \(descriptionForRelation(self.relation))"
        
        if let secondItem = self.secondItem {
            description += " \(descriptionForObject(secondItem))"
        }
        
        if self.secondAttribute != .notAnAttribute {
            description += ".\(descriptionForAttribute(self.secondAttribute))"
        }
        
        if self.multiplier != 1.0 {
            description += " * \(self.multiplier)"
        }
        
        if self.secondAttribute == .notAnAttribute {
            description += " \(self.constant)"
        } else {
            if self.constant > 0.0 {
                description += " + \(self.constant)"
            } else if self.constant < 0.0 {
                description += " - \(abs(self.constant))"
            }
        }
        
        if self.priority.rawValue != 1000.0 {
            description += " ^\(self.priority)"
        }
        
        description += ">"
        
        return description
    }
    
}

private func descriptionForRelation(_ relation: LayoutRelation) -> String {
    switch relation {
    case .equal:                return "=="
    case .greaterThanOrEqual:   return ">="
    case .lessThanOrEqual:      return "<="
    #if swift(>=5.0)
    @unknown default:           return "unknown"
    #endif
    }
}

private func descriptionForAttribute(_ attribute: LayoutAttribute) -> String {
    #if os(iOS) || os(tvOS)
        switch attribute {
        case .notAnAttribute:       return "notAnAttribute"
        case .top:                  return "top"
        case .left:                 return "left"
        case .bottom:               return "bottom"
        case .right:                return "right"
        case .leading:              return "leading"
        case .trailing:             return "trailing"
        case .width:                return "width"
        case .height:               return "height"
        case .centerX:              return "centerX"
        case .centerY:              return "centerY"
        case .lastBaseline:         return "lastBaseline"
        case .firstBaseline:        return "firstBaseline"
        case .topMargin:            return "topMargin"
        case .leftMargin:           return "leftMargin"
        case .bottomMargin:         return "bottomMargin"
        case .rightMargin:          return "rightMargin"
        case .leadingMargin:        return "leadingMargin"
        case .trailingMargin:       return "trailingMargin"
        case .centerXWithinMargins: return "centerXWithinMargins"
        case .centerYWithinMargins: return "centerYWithinMargins"
        #if swift(>=5.0)
        @unknown default:           return "unknown"
        #endif
    }
    #else
        switch attribute {
        case .notAnAttribute:       return "notAnAttribute"
        case .top:                  return "top"
        case .left:                 return "left"
        case .bottom:               return "bottom"
        case .right:                return "right"
        case .leading:              return "leading"
        case .trailing:             return "trailing"
        case .width:                return "width"
        case .height:               return "height"
        case .centerX:              return "centerX"
        case .centerY:              return "centerY"
        case .lastBaseline:         return "lastBaseline"
        case .firstBaseline:        return "firstBaseline"
        #if swift(>=5.0)
        @unknown default:           return "unknown"
        #endif
    }
    #endif
}

private func conditionalOptional<T>(from object: Optional<T>) -> Optional<T> {
    return object
}

private func conditionalOptional<T>(from object: T) -> Optional<T> {
    return Optional.some(object)
}

private func descriptionForObject(_ object: AnyObject) -> String {
    let pointerDescription = String(format: "%p", UInt(bitPattern: ObjectIdentifier(object)))
    var desc = ""
    
    desc += type(of: object).description()
    
    if let object = object as? ConstraintView {
        desc += ":\(object.snp.label() ?? pointerDescription)"
    } else if let object = object as? LayoutConstraint {
        desc += ":\(object.label ?? pointerDescription)"
    } else {
        desc += ":\(pointerDescription)"
    }
    
    if let object = object as? LayoutConstraint, let file = object.constraint?.sourceLocation.0, let line = object.constraint?.sourceLocation.1 {
        desc += "@\((file as NSString).lastPathComponent)#\(line)"
    }
    
    desc += ""
    return desc
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public protocol ConstraintRelatableTarget {
}

extension Int: ConstraintRelatableTarget {
}

extension UInt: ConstraintRelatableTarget {
}

extension Float: ConstraintRelatableTarget {
}

extension Double: ConstraintRelatableTarget {
}

extension CGFloat: ConstraintRelatableTarget {
}

extension CGSize: ConstraintRelatableTarget {
}

extension CGPoint: ConstraintRelatableTarget {
}

extension ConstraintInsets: ConstraintRelatableTarget {
}

#if os(iOS) || os(tvOS)
@available(iOS 11.0, tvOS 11.0, *)
extension ConstraintDirectionalInsets: ConstraintRelatableTarget {
}
#endif

extension ConstraintItem: ConstraintRelatableTarget {
}

extension ConstraintView: ConstraintRelatableTarget {
}

@available(iOS 9.0, OSX 10.11, *)
extension ConstraintLayoutGuide: ConstraintRelatableTarget {
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class LayoutConstraint : NSLayoutConstraint {
    
    public var label: String? {
        get {
            return self.identifier
        }
        set {
            self.identifier = newValue
        }
    }
    
    internal weak var constraint: Constraint? = nil
    
}

internal func ==(lhs: LayoutConstraint, rhs: LayoutConstraint) -> Bool {
    // If firstItem or secondItem on either constraint has a dangling pointer
    // this comparison can cause a crash. The solution for this is to ensure
    // your layout code hold strong references to things like Views, LayoutGuides
    // and LayoutAnchors as SnapKit will not keep strong references to any of these.
    guard lhs.firstAttribute == rhs.firstAttribute &&
          lhs.secondAttribute == rhs.secondAttribute &&
          lhs.relation == rhs.relation &&
          lhs.priority == rhs.priority &&
          lhs.multiplier == rhs.multiplier &&
          lhs.secondItem === rhs.secondItem &&
          lhs.firstItem === rhs.firstItem else {
        return false
    }
    return true
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#endif
    
    
@available(iOS 9.0, OSX 10.11, *)
public extension ConstraintLayoutGuide {
    
    var snp: ConstraintLayoutGuideDSL {
        return ConstraintLayoutGuideDSL(guide: self)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


#if os(iOS) || os(tvOS)
    @available(iOS 11.0, tvOS 11.0, *)
    public typealias ConstraintDirectionalInsets = NSDirectionalEdgeInsets
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


@available(iOS 8.0, *)
public struct ConstraintLayoutSupportDSL: ConstraintDSL {
    
    public var target: AnyObject? {
        return self.support
    }
    
    internal let support: ConstraintLayoutSupport
    
    internal init(support: ConstraintLayoutSupport) {
        self.support = support
        
    }
    
    public var top: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.top)
    }
    
    public var bottom: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.bottom)
    }
    
    public var height: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.height)
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif


public class ConstraintMakerRelatable {
    
    internal let description: ConstraintDescription
    
    internal init(_ description: ConstraintDescription) {
        self.description = description
    }
    
    internal func relatedTo(_ other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt) -> ConstraintMakerEditable {
        let related: ConstraintItem
        let constant: ConstraintConstantTarget
        
        if let other = other as? ConstraintItem {
            guard other.attributes == ConstraintAttributes.none ||
                  other.attributes.layoutAttributes.count <= 1 ||
                  other.attributes.layoutAttributes == self.description.attributes.layoutAttributes ||
                  other.attributes == .edges && self.description.attributes == .margins ||
                  other.attributes == .margins && self.description.attributes == .edges ||
                  other.attributes == .directionalEdges && self.description.attributes == .directionalMargins ||
                  other.attributes == .directionalMargins && self.description.attributes == .directionalEdges else {
                fatalError("Cannot constraint to multiple non identical attributes. (\(file), \(line))");
            }
            
            related = other
            constant = 0.0
        } else if let other = other as? ConstraintView {
            related = ConstraintItem(target: other, attributes: ConstraintAttributes.none)
            constant = 0.0
        } else if let other = other as? ConstraintConstantTarget {
            related = ConstraintItem(target: nil, attributes: ConstraintAttributes.none)
            constant = other
        } else if #available(iOS 9.0, OSX 10.11, *), let other = other as? ConstraintLayoutGuide {
            related = ConstraintItem(target: other, attributes: ConstraintAttributes.none)
            constant = 0.0
        } else {
            fatalError("Invalid constraint. (\(file), \(line))")
        }
        
        let editable = ConstraintMakerEditable(self.description)
        editable.description.sourceLocation = (file, line)
        editable.description.relation = relation
        editable.description.related = related
        editable.description.constant = constant
        return editable
    }
    
    @discardableResult
    public func equalTo(_ other: ConstraintRelatableTarget, _ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        return self.relatedTo(other, relation: .equal, file: file, line: line)
    }
    
    @discardableResult
    public func equalToSuperview(_ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `equalToSuperview`.")
        }
        return self.relatedTo(other, relation: .equal, file: file, line: line)
    }
    
    @discardableResult
    public func lessThanOrEqualTo(_ other: ConstraintRelatableTarget, _ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        return self.relatedTo(other, relation: .lessThanOrEqual, file: file, line: line)
    }
    
    @discardableResult
    public func lessThanOrEqualToSuperview(_ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `lessThanOrEqualToSuperview`.")
        }
        return self.relatedTo(other, relation: .lessThanOrEqual, file: file, line: line)
    }
    
    @discardableResult
    public func greaterThanOrEqualTo(_ other: ConstraintRelatableTarget, _ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        return self.relatedTo(other, relation: .greaterThanOrEqual, file: file, line: line)
    }
    
    @discardableResult
    public func greaterThanOrEqualToSuperview(_ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `greaterThanOrEqualToSuperview`.")
        }
        return self.relatedTo(other, relation: .greaterThanOrEqual, file: file, line: line)
    }
}
//
//  KeyboardTrackingView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 5/20/19.
//  Copyright © 2019 SwiftKick Mobile. All rights reserved.
//

import UIKit

public protocol KeyboardTrackingViewDelegate: AnyObject {
    func keyboardTrackingViewWillChange(change: KeyboardTrackingView.Change, userInfo: [AnyHashable : Any])
    func keyboardTrackingViewDidChange(change: KeyboardTrackingView.Change, userInfo: [AnyHashable : Any])
}

/// A view that adjusts it's height based on keyboard hide and show notifications.
/// Pin it to the bottom of the screen using Auto Layout and then pin views that
/// should avoid the keyboard to the top of it. Supply an instance of this class
/// on `SwiftMessages.Config.keyboardTrackingView` or `SwiftMessagesSegue.keyboardTrackingView`
/// for automatic keyboard avoidance for the entire SwiftMessages view or view controller.
open class KeyboardTrackingView: UIView {

    public enum Change {
        case show
        case hide
        case frame
    }

    public weak var delegate: KeyboardTrackingViewDelegate?

    /// Typically, when a view controller is not being displayed, keyboard
    /// tracking should be paused to avoid responding to keyboard events
    /// caused by other view controllers or apps. Setting `isPaused = false` in
    /// `viewWillAppear` and `isPaused = true` in `viewWillDisappear` usually works. This class
    /// automatically pauses and resumes when the app resigns and becomes active, respectively.
    open var isPaused = false {
        didSet {
            if !isPaused {
                isAutomaticallyPaused = false
            }
        }
    }

    /// The margin to maintain between the keyboard and the top of the view.
    open var topMargin: CGFloat = 0

    /// Subclasses can override this to do something before the change.
    open func willChange(
        change: KeyboardTrackingView.Change,
        userInfo: [AnyHashable : Any]
    ) {}

    /// Subclasses can override this to do something after the change.
    open func didChange(
        change: KeyboardTrackingView.Change,
        userInfo: [AnyHashable : Any]
    ) {}

    override public init(frame: CGRect) {
        super.init(frame: frame)
        postInit()
    }

    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }

    open override func awakeFromNib() {
        super.awakeFromNib()
        postInit()
    }

    private var isAutomaticallyPaused = false
    private var heightConstraint: NSLayoutConstraint!

    private func postInit() {
        translatesAutoresizingMaskIntoConstraints = false
        heightConstraint = heightAnchor.constraint(equalToConstant: 0)
        heightConstraint.isActive = true
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow(_:)), name: UIResponder.keyboardWillShowNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow(_:)), name: UIResponder.keyboardWillChangeFrameNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide(_:)), name: UIResponder.keyboardWillHideNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(pause), name: UIApplication.willResignActiveNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(resume), name: UIApplication.didBecomeActiveNotification, object: nil)
        backgroundColor = .clear
    }

    @objc private func keyboardWillChangeFrame(_ notification: Notification) {
        show(change: .frame, notification)
    }

    @objc private func keyboardWillShow(_ notification: Notification) {
        show(change: .show, notification)
    }

    @objc private func keyboardWillHide(_ notification: Notification) {
        guard !(isPaused || isAutomaticallyPaused),
            let userInfo = (notification as NSNotification).userInfo else { return }
        guard heightConstraint.constant != 0 else { return }
        delegate?.keyboardTrackingViewWillChange(change: .hide, userInfo: userInfo)
        animateKeyboardChange(change: .hide, height: 0, userInfo: userInfo)
    }

    @objc private func pause() {
        isAutomaticallyPaused = true
    }

    @objc private func resume() {
        isAutomaticallyPaused = false
    }

    private func show(change: Change, _ notification: Notification) {
        guard !(isPaused || isAutomaticallyPaused),
            let userInfo = (notification as NSNotification).userInfo,
            let value = userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue else { return }
        willChange(change: change, userInfo: userInfo)
        delegate?.keyboardTrackingViewWillChange(change: change, userInfo: userInfo)
        let keyboardRect = value.cgRectValue
        let thisRect = convert(bounds, to: nil)
        let newHeight = max(0, thisRect.maxY - keyboardRect.minY) + topMargin
        guard heightConstraint.constant != newHeight else { return }
        animateKeyboardChange(change: change, height: newHeight, userInfo: userInfo)
    }

    private func animateKeyboardChange(change: Change, height: CGFloat, userInfo: [AnyHashable: Any]) {
        self.heightConstraint.constant = height
        if let durationNumber = userInfo[UIResponder.keyboardAnimationDurationUserInfoKey] as? NSNumber,
            let curveNumber = userInfo[UIResponder.keyboardAnimationCurveUserInfoKey] as? NSNumber {
            CATransaction.begin()
            CATransaction.setCompletionBlock {
                self.didChange(change: change, userInfo: userInfo)
                self.delegate?.keyboardTrackingViewDidChange(change: change, userInfo: userInfo)
            }
            UIView.beginAnimations(nil, context: nil)
            UIView.setAnimationDuration(durationNumber.doubleValue)
            UIView.setAnimationCurve(UIView.AnimationCurve(rawValue: curveNumber.intValue)!)
            UIView.setAnimationBeginsFromCurrentState(true)
            self.superview?.layoutIfNeeded()
            UIView.commitAnimations()
            CATransaction.commit()
        }
    }
}
//
//  MaskingView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 3/11/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit


class MaskingView: PassthroughView {

    func install(keyboardTrackingView: KeyboardTrackingView) {
        self.keyboardTrackingView = keyboardTrackingView
        keyboardTrackingView.translatesAutoresizingMaskIntoConstraints = false
        addSubview(keyboardTrackingView)
        keyboardTrackingView.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = true
        keyboardTrackingView.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true
        keyboardTrackingView.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true
    }

    var accessibleElements: [NSObject] = []

    weak var backgroundView: UIView? {
        didSet {
            oldValue?.removeFromSuperview()
            if let view = backgroundView {
                view.isUserInteractionEnabled = false
                view.frame = bounds
                view.autoresizingMask = [.flexibleWidth, .flexibleHeight]
                addSubview(view)
                sendSubviewToBack(view)
            }
        }
    }

    override func accessibilityElementCount() -> Int {
        return accessibleElements.count
    }

    override func accessibilityElement(at index: Int) -> Any? {
        return accessibleElements[index]
    }

    override func index(ofAccessibilityElement element: Any) -> Int {
        guard let object = element as? NSObject else { return 0 }
        return accessibleElements.firstIndex(of: object) ?? 0
    }

    init() {
        super.init(frame: CGRect.zero)
        clipsToBounds = true
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        clipsToBounds = true
    }

    private var keyboardTrackingView: KeyboardTrackingView?

    override func addSubview(_ view: UIView) {
        super.addSubview(view)
        guard let keyboardTrackingView = keyboardTrackingView,
            view != keyboardTrackingView,
            view != backgroundView else { return }
        let offset: CGFloat
        if let adjustable = view as? MarginAdjustable {
            offset = -adjustable.bounceAnimationOffset
        } else {
            offset = 0
        }
        keyboardTrackingView.topAnchor.constraint(
            greaterThanOrEqualTo: view.bottomAnchor,
            constant: offset
        ).with(priority: UILayoutPriority(250)).isActive = true
    }
}
//
//  UIViewController+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/5/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

extension UIViewController {
    
    func sm_selectPresentationContextTopDown(_ config: SwiftMessages.Config) -> UIViewController {
        let topBottomStyle = config.presentationStyle.topBottomStyle
        if let presented = presentedViewController {
            return presented.sm_selectPresentationContextTopDown(config)
        } else if case .top? = topBottomStyle, let navigationController = sm_selectNavigationControllerTopDown() {
            return navigationController
        } else if case .bottom? = topBottomStyle, let tabBarController = sm_selectTabBarControllerTopDown() {
            return tabBarController
        }
        return WindowViewController.newInstance(config: config)
    }
    
    fileprivate func sm_selectNavigationControllerTopDown() -> UINavigationController? {
        if let presented = presentedViewController {
            return presented.sm_selectNavigationControllerTopDown()
        } else if let navigationController = self as? UINavigationController {
            if navigationController.sm_isVisible(view: navigationController.navigationBar) {
                return navigationController
            }
            return navigationController.topViewController?.sm_selectNavigationControllerTopDown()
        } else if let tabBarController = self as? UITabBarController {
            return tabBarController.selectedViewController?.sm_selectNavigationControllerTopDown()
        }
        return nil
    }

    fileprivate func sm_selectTabBarControllerTopDown() -> UITabBarController? {
        if let presented = presentedViewController {
            return presented.sm_selectTabBarControllerTopDown()
        } else if let navigationController = self as? UINavigationController {
            return navigationController.topViewController?.sm_selectTabBarControllerTopDown()
        } else if let tabBarController = self as? UITabBarController {
            if tabBarController.sm_isVisible(view: tabBarController.tabBar) {
                return tabBarController
            }
            return tabBarController.selectedViewController?.sm_selectTabBarControllerTopDown()
        }
        return nil
    }

    func sm_selectPresentationContextBottomUp(_ config: SwiftMessages.Config) -> UIViewController {
        let topBottomStyle = config.presentationStyle.topBottomStyle
        if let parent = parent {
            if let navigationController = parent as? UINavigationController {
                if case .top? = topBottomStyle, navigationController.sm_isVisible(view: navigationController.navigationBar) {
                    return navigationController
                }
                return navigationController.sm_selectPresentationContextBottomUp(config)
            } else if let tabBarController = parent as? UITabBarController {
                if case .bottom? = topBottomStyle, tabBarController.sm_isVisible(view: tabBarController.tabBar) {
                    return tabBarController
                }
                return tabBarController.sm_selectPresentationContextBottomUp(config)
            }
        }
        if self.view is UITableView {
            // Never select scroll view as presentation context
            // because, you know, it scrolls.
            if let parent = self.parent {
                return parent.sm_selectPresentationContextBottomUp(config)
            } else {
                return WindowViewController.newInstance(config: config)
            }
        }
        return self
    }
    
    func sm_isVisible(view: UIView) -> Bool {
        if view.isHidden { return false }
        if view.alpha == 0.0 { return false }
        let frame = self.view.convert(view.bounds, from: view)
        if !self.view.bounds.intersects(frame) { return false }
        return true
    }
}

extension SwiftMessages.PresentationStyle {
    /// A temporary workaround to allow custom presentation contexts using `TopBottomAnimation`
    /// to display properly behind bars. THe long term solution is to refactor all of the
    /// presentation context logic to work with safe area insets.
    var topBottomStyle: TopBottomAnimation.Style? {
        switch self {
        case .top: return .top
        case .bottom: return .bottom
        case .custom(let animator): return (animator as? TopBottomAnimation)?.style
        case .center: return nil
        }
    }
}
//
//  SwiftMessages.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/1/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

private let globalInstance = SwiftMessages()

/**
 The `SwiftMessages` class provides the interface for showing and hiding messages.
 It behaves like a queue, only showing one message at a time. Message views that
 adopt the `Identifiable` protocol (as `MessageView` does) will have duplicates removed.
 */
open class SwiftMessages {
    
    /**
     Specifies whether the message view is displayed at the top or bottom
     of the selected presentation container.
    */
    public enum PresentationStyle {
        
        /**
         Message view slides down from the top.
        */
        case top

        /**
         Message view slides up from the bottom.
         */
        case bottom

        /**
         Message view fades into the center.
         */
        case center

        /**
         User-defined animation
        */
        case custom(animator: Animator)
    }

    /**
     Specifies how the container for presenting the message view
     is selected.
    */
    public enum PresentationContext {
        
        /**
         Displays the message view under navigation bars and tab bars if an
         appropriate one is found. Otherwise, it is displayed in a new window
         at level `UIWindow.Level.normal`. Use this option to automatically display
         under bars, where applicable. Because this option involves a top-down
         search, an appropriate context might not be found when the view controller
         hierarchy incorporates custom containers. If this is the case, the
         .ViewController option can provide a more targeted context.
        */
        case automatic

        /**
         Displays the message in a new window at the specified window level.
         SwiftMessages automatically increases the top margins of any message
         view that adopts the `MarginInsetting` protocol (as `MessageView` does)
         to account for the status bar. As of iOS 13, windows can no longer cover the
         status bar. The only alternative is to set `Config.prefersStatusBarHidden = true`
         to hide it.
        */
        case window(windowLevel: UIWindow.Level)

        /**
         Displays the message in a new window, at the specified window level,
         in the specified window scene. SwiftMessages automatically increases the top margins
         of any message view that adopts the `MarginInsetting` protocol (as `MessageView` does)
         to account for the status bar. As of iOS 13, windows can no longer cover the
         status bar. The only alternative is to set `Config.prefersStatusBarHidden = true`
         to hide it. The `WindowScene` protocol works around the change in Xcode 13 that prevents
         using `@availability` attribute with `enum` cases containing associated values.
        */
        case windowScene(_: WindowScene, windowLevel: UIWindow.Level)

        /**
         Displays the message view under navigation bars and tab bars if an
         appropriate one is found using the given view controller as a starting
         point and searching up the parent view controller chain. Otherwise, it
         is displayed in the given view controller's view. This option can be used
         for targeted placement in a view controller hierarchy.
        */
        case viewController(_: UIViewController)

        /**
         Displays the message view in the given container view.
         */
        case view(_: UIView)
    }
    
    /**
     Specifies the duration of the message view's time on screen before it is
     automatically hidden.
    */
    public enum Duration {
        
        /**
         Hide the message view after the default duration.
        */
        case automatic
        
        /**
         Disables automatic hiding of the message view.
        */
        case forever
        
        /**
         Hide the message view after the speficied number of seconds.
         
         - Parameter seconds: The number of seconds.
        */
        case seconds(seconds: TimeInterval)

        /**
         The `indefinite` option is similar to `forever` in the sense that
         the message view will not be automatically hidden. However, it
         provides two options that can be useful in some scenarios:
         
            - `delay`: wait the specified time interval before displaying
                       the message. If you hide the message during the delay
                       interval by calling either `hideAll()` or `hide(id:)`,
                       the message will not be displayed. This is not the case for
                       `hide()` because it only acts on a visible message. Messages
                       shown during another message's delay window are displayed first.
            - `minimum`: if the message is displayed, ensure that it is displayed
                         for a minimum time interval. If you explicitly hide the
                         during this interval, the message will be hidden at the
                         end of the interval.

         This option is useful for displaying a message when a process is taking
         too long but you don't want to display the message if the process completes
         in a reasonable amount of time. The value `indefinite(delay: 0, minimum: 0)`
         is equivalent to `forever`.
         
         For example, if a URL load is expected to complete in 2 seconds, you may use
         the value `indefinite(delay: 2, minimum 1)` to ensure that the message will not
         be displayed in most cases, but will be displayed for at least 1 second if
         the operation takes longer than 2 seconds. By specifying a minimum duration,
         you can avoid hiding the message too fast if the operation finishes right
         after the delay interval.
        */
        case indefinite(delay: TimeInterval, minimum: TimeInterval)
    }
    
    /**
     Specifies options for dimming the background behind the message view
     similar to a popover view controller.
    */
    public enum DimMode {
        
        /**
         Don't dim the background behind the message view.
        */
        case none

        /**
         Dim the background behind the message view a gray color.
         
         - `interactive`: Specifies whether or not tapping the
                          dimmed area dismisses the message view.
         */
        case gray(interactive: Bool)

        /**
         Dim the background behind the message view using the given color.
         SwiftMessages does not apply alpha transparency to the color, so any alpha
         must be baked into the `UIColor` instance.
         
         - `color`: The color of the dim view.
         - `interactive`: Specifies whether or not tapping the
                          dimmed area dismisses the message view.
         */
        case color(color: UIColor, interactive: Bool)

        /**
         Dim the background behind the message view using a blur effect with
         the given style

         - `style`: The blur effect style to use
         - `alpha`: The alpha level of the blur
         - `interactive`: Specifies whether or not tapping the
         dimmed area dismisses the message view.
         */
        case blur(style: UIBlurEffect.Style, alpha: CGFloat, interactive: Bool)

        public var interactive: Bool {
            switch self {
            case .gray(let interactive):
                return interactive
            case .color(_, let interactive):
                return interactive
            case .blur (_, _, let interactive):
                return interactive
            case .none:
                return false
            }
        }

        public var modal: Bool {
            switch self {
            case .gray, .color, .blur:
                return true
            case .none:
                return false
            }
        }
    }

    /**
     Specifies events in the message lifecycle.
    */
    public enum Event {
        case willShow(UIView)
        case didShow(UIView)
        case willHide(UIView)
        case didHide(UIView)

        public var view: UIView {
            switch self {
            case .willShow(let view): return view
            case .didShow(let view): return view
            case .willHide(let view): return view
            case .didHide(let view): return view
            }
        }

        public var id: String? {
            return (view as? Identifiable)?.id
        }
    }
    
    /**
     A closure that takes an `Event` as an argument.
     */
    public typealias EventListener = (Event) -> Void
    
    /**
     The `Config` struct specifies options for displaying a single message view. It is
     provided as an optional argument to one of the `MessageView.show()` methods.
     */
    public struct Config {
        
        public init() {}
        
        /**
         Specifies whether the message view is displayed at the top or bottom
         of the selected presentation container. The default is `.Top`.
         */
        public var presentationStyle = PresentationStyle.top

        /**
         Specifies how the container for presenting the message view
         is selected. The default is `.Automatic`.
         */
        public var presentationContext = PresentationContext.automatic {
            didSet {
                if case .windowScene = presentationContext {
                    guard #available(iOS 13.0, *) else {
                        assertionFailure("windowScene is not supported below iOS 13.0.")
                        return
                    }
                }
            }
        }

        /**
         Specifies the duration of the message view's time on screen before it is
         automatically hidden. The default is `.Automatic`.
         */
        public var duration = Duration.automatic
        
        /**
         Specifies options for dimming the background behind the message view
         similar to a popover view controller. The default is `.None`.
         */
        public var dimMode = DimMode.none
        
        /**
         Specifies whether or not the interactive pan-to-hide gesture is enabled
         on the message view. For views that implement the `BackgroundViewable` 
         protocol (as `MessageView` does), the pan gesture recognizer is installed
         in the `backgroundView`, which allows for card-style views with transparent
         margins that shouldn't be interactive. Otherwise, it is installed in
         the message view itself. The default is `true`.
        */
        public var interactiveHide = true
        
        /**
         Specifies the preferred status bar style when the view is being
         displayed in a window. This can be useful when the view is being
         displayed behind the status bar and the message view has a background
         color that needs a different status bar style than the current one.
         The default is `nil`.
         */
        public var preferredStatusBarStyle: UIStatusBarStyle?

        /**
         Specifies the preferred status bar visibility when the view is being
         displayed in a window. As of iOS 13, windows can no longer cover the
         status bar. The only alternative is to hide the status bar by setting
         this options to `true`. Default is `nil`.
         */
        public var prefersStatusBarHidden: Bool?

        /**
         If a view controller is created to host the message view, should the view 
         controller auto rotate?  The default is 'true', meaning it should auto
         rotate.
         */
        public var shouldAutorotate = true

        /**
         Specified whether or not duplicate `Identifiable` messages are ignored.
         The default is `true`.
        */
        public var ignoreDuplicates = true
        
        /**
         Specifies an optional array of event listeners.
        */
        public var eventListeners: [EventListener] = []
        
        /**
         Specifies that in cases where the message is displayed in its own window,
         such as with `.window` presentation context, the window should become
         the key window. This option should only be used if the message view
         needs to receive non-touch events, such as keyboard input. From Apple's
         documentation https://developer.apple.com/reference/uikit/uiwindow:
         
         > Whereas touch events are delivered to the window where they occurred,
         > events that do not have a relevant coordinate value are delivered to
         > the key window. Only one window at a time can be the key window, and
         > you can use a window’s keyWindow property to determine its status.
         > Most of the time, your app’s main window is the key window, but UIKit
         > may designate a different window as needed.
         */
        public var becomeKeyWindow: Bool?

        /**
         The `dimMode` background will use this accessibility
         label, e.g. "dismiss" when the `interactive` option is used.
        */
        public var dimModeAccessibilityLabel: String = "dismiss"

        /**
         The user interface style to use when SwiftMessages displays a message its own window.
         Use with apps that don't support dark mode to prevent messages from adopting the
         system's interface style.
        */
        @available(iOS 13, *)
        public var overrideUserInterfaceStyle: UIUserInterfaceStyle {
            // Note that this is modelled as a computed property because
            // Swift doesn't allow `@available` with stored properties.
            get {
                guard let rawValue = overrideUserInterfaceStyleRawValue else { return .unspecified }
                return UIUserInterfaceStyle(rawValue: rawValue) ?? .unspecified
            }
            set {
                overrideUserInterfaceStyleRawValue = newValue.rawValue
            }
        }
        private var overrideUserInterfaceStyleRawValue: Int?

        /**
         If specified, SwiftMessages calls this closure when an instance of
         `WindowViewController` is needed. Use this if you need to supply a custom subclass
         of `WindowViewController`.
         */
        public var windowViewController: ((_ config: SwiftMessages.Config) -> WindowViewController)?

        /**
         Supply an instance of `KeyboardTrackingView` to have the message view avoid the keyboard.
         */
        public var keyboardTrackingView: KeyboardTrackingView?
    }
    
    /**
     Not much to say here.
     */
    public init() {}
    
    /**
     Adds the given configuration and view to the message queue to be displayed.
     
     - Parameter config: The configuration options.
     - Parameter view: The view to be displayed.
     */
    open func show(config: Config, view: UIView) {
        let presenter = Presenter(config: config, view: view, delegate: self)
        messageQueue.sync {
            enqueue(presenter: presenter)
        }
    }
    
    /**
     Adds the given view to the message queue to be displayed
     with default configuration options.
     
     - Parameter config: The configuration options.
     - Parameter view: The view to be displayed.
     */
    public func show(view: UIView) {
        show(config: defaultConfig, view: view)
    }
    
    /// A block that returns an arbitrary view.
    public typealias ViewProvider = () -> UIView

    /**
     Adds the given configuration and view provider to the message queue to be displayed.

     The `viewProvider` block is guaranteed to be called on the main queue where
     it is safe to interact with `UIKit` components. This variant of `show()` is
     recommended when the message might be added from a background queue.
     
     - Parameter config: The configuration options.
     - Parameter viewProvider: A block that returns the view to be displayed.
     */
    open func show(config: Config, viewProvider: @escaping ViewProvider) {
        DispatchQueue.main.async { [weak self] in
            guard let strongSelf = self else { return }
            let view = viewProvider()
            strongSelf.show(config: config, view: view)
        }
    }
    
    /**
     Adds the given view provider to the message queue to be displayed
     with default configuration options.
     
     The `viewProvider` block is guaranteed to be called on the main queue where
     it is safe to interact with `UIKit` components. This variant of `show()` is
     recommended when the message might be added from a background queue.
     
     - Parameter viewProvider: A block that returns the view to be displayed.
     */
    public func show(viewProvider: @escaping ViewProvider) {
        show(config: defaultConfig, viewProvider: viewProvider)
    }
    
    /**
     Hide the current message being displayed by animating it away.
     */
    open func hide(animated: Bool = true) {
        messageQueue.sync {
            hideCurrent(animated: animated)
        }
    }

    /**
     Hide the current message, if there is one, by animating it away and
     clear the message queue.
     */
    open func hideAll() {
        messageQueue.sync {
            queue.removeAll()
            delays.removeAll()
            counts.removeAll()
            hideCurrent()
        }
    }

    /**
     Hide a message with the given `id`. If the specified message is
     currently being displayed, it will be animated away. Works with message
     views, such as `MessageView`, that adopt the `Identifiable` protocol.
     - Parameter id: The identifier of the message to remove.
     */
    open func hide(id: String) {
        messageQueue.sync {
            if id == _current?.id {
                hideCurrent()
            }
            queue = queue.filter { $0.id != id }
            delays.remove(id: id)
            counts[id] = nil
        }
    }

    /**
     Hide the message when the number of calls to show() and hideCounted(id:) for a
     given message ID are equal. This can be useful for messages that may be
     shown from  multiple code paths to ensure that all paths are ready to hide.
     */
    open func hideCounted(id: String) {
        messageQueue.sync {
            if let count = counts[id] {
                if count < 2 {
                    counts[id] = nil
                } else {
                    counts[id] = count - 1
                    return
                }
            }
            if id == _current?.id {
                hideCurrent()
            }
            queue = queue.filter { $0.id != id }
            delays.remove(id: id)
        }
    }

    /**
     Get the count of a message with the given ID (see `hideCounted(id:)`)
     */
    public func count(id: String) -> Int {
        return counts[id] ?? 0
    }

    /**
     Explicitly set the count of a message with the given ID (see `hideCounted(id:)`).
     Not sure if there's a use case for this, but why not?!
     */
    public func set(count: Int, for id: String) {
        guard counts[id] != nil else { return }
        return counts[id] = count
    }

    /**
     Specifies the default configuration to use when calling the variants of
     `show()` that don't take a `config` argument or as a base for custom configs.
     */
    public var defaultConfig = Config()

    /**
     Specifies the amount of time to pause between removing a message
     and showing the next. Default is 0.5 seconds.
     */
    open var pauseBetweenMessages: TimeInterval = 0.5

    /// Type for keeping track of delayed presentations
    fileprivate class Delays {

        fileprivate func add(presenter: Presenter) {
            presenters.insert(presenter)
        }

        @discardableResult
        fileprivate func remove(presenter: Presenter) -> Bool {
            guard presenters.contains(presenter) else { return false }
            presenters.remove(presenter)
            return true
        }

        fileprivate func remove(id: String) {
            presenters = presenters.filter { $0.id != id }
        }

        fileprivate func removeAll() {
            presenters.removeAll()
        }

        private var presenters = Set<Presenter>()
    }

    func show(presenter: Presenter) {
        messageQueue.sync {
            enqueue(presenter: presenter)
        }
    }

    fileprivate let messageQueue = DispatchQueue(label: "it.swiftkick.SwiftMessages", attributes: [])
    fileprivate var queue: [Presenter] = []
    fileprivate var delays = Delays()
    fileprivate var counts: [String : Int] = [:]
    fileprivate var _current: Presenter? = nil {
        didSet {
            if oldValue != nil {
                let delayTime = DispatchTime.now() + pauseBetweenMessages
                messageQueue.asyncAfter(deadline: delayTime) { [weak self] in
                    self?.dequeueNext()
                }
            }
        }
    }

    fileprivate func enqueue(presenter: Presenter) {
        if presenter.config.ignoreDuplicates {
            counts[presenter.id] = (counts[presenter.id] ?? 0) + 1
            if _current?.id == presenter.id && _current?.isHiding == false { return }
            if queue.filter({ $0.id == presenter.id }).count > 0 { return }
        }
        func doEnqueue() {
            queue.append(presenter)
            dequeueNext()
        }
        if let delay = presenter.delayShow {
            delays.add(presenter: presenter)
            messageQueue.asyncAfter(deadline: .now() + delay) { [weak self] in
                // Don't enqueue if the view has been hidden during the delay window.
                guard let strongSelf = self, strongSelf.delays.remove(presenter: presenter) else { return }
                doEnqueue()
            }
        } else {
            doEnqueue()
        }
    }
    
    fileprivate func dequeueNext() {
        guard self._current == nil, queue.count > 0 else { return }
        let current = queue.removeFirst()
        self._current = current
        // Set `autohideToken` before the animation starts in case
        // the dismiss gesture begins before we've queued the autohide
        // block on animation completion.
        self.autohideToken = current
        current.showDate = CACurrentMediaTime()
        DispatchQueue.main.async { [weak self] in
            guard let strongSelf = self else { return }
            do {
                try current.show { completed in
                    guard let strongSelf = self else { return }
                    guard completed else {
                        strongSelf.messageQueue.sync {
                            strongSelf.internalHide(presenter: current)
                        }
                        return
                    }
                    if current === strongSelf.autohideToken {
                        strongSelf.queueAutoHide()
                    }
                }
            } catch {
                strongSelf.messageQueue.sync {
                    strongSelf._current = nil
                }
            }
        }
    }

    fileprivate func internalHide(presenter: Presenter) {
        if presenter == _current {
            hideCurrent()
        } else {
            queue = queue.filter { $0 != presenter }
            delays.remove(presenter: presenter)
        }
    }
 
    fileprivate func hideCurrent(animated: Bool = true) {
        guard let current = _current, !current.isHiding else { return }
        let action = { [weak self] in
            current.hide(animated: animated) { (completed) in
                guard completed, let strongSelf = self else { return }
                strongSelf.messageQueue.sync {
                    guard strongSelf._current === current else { return }
                    strongSelf.counts[current.id] = nil
                    strongSelf._current = nil
                }
            }
        }
        let delay = current.delayHide ?? 0
        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
            action()
        }
    }

    fileprivate weak var autohideToken: AnyObject?

    fileprivate func queueAutoHide() {
        guard let current = _current else { return }
        autohideToken = current
        if let pauseDuration = current.pauseDuration {
            let delayTime = DispatchTime.now() + pauseDuration
            messageQueue.asyncAfter(deadline: delayTime, execute: {
                // Make sure we've still got a green light to auto-hide.
                if self.autohideToken !== current { return }
                self.internalHide(presenter: current)
            })
        }
    }

    deinit {
        // Prevent orphaned messages
        hideCurrent()
    }
}

/*
 MARK: - Accessing messages
 */

extension SwiftMessages {

    /**
     Returns the message view of type `T` if it is currently being shown or hidden.

     - Returns: The view of type `T` if it is currently being shown or hidden.
     */
    public func current<T: UIView>() -> T? {
        var view: T?
        messageQueue.sync {
            view = _current?.view as? T
        }
        return view
    }

    /**
     Returns a message view with the given `id` if it is currently being shown or hidden.

     - Parameter id: The id of a message that adopts `Identifiable`.
     - Returns: The view with matching id if currently being shown or hidden.
    */
    public func current<T: UIView>(id: String) -> T? {
        var view: T?
        messageQueue.sync {
            if let current = _current, current.id == id {
                view = current.view as? T
            }
        }
        return view
    }

    /**
     Returns a message view with the given `id` if it is currently in the queue to be shown.

     - Parameter id: The id of a message that adopts `Identifiable`.
     - Returns: The view with matching id if currently queued to be shown.
     */
    public func queued<T: UIView>(id: String) -> T? {
        var view: T?
        messageQueue.sync {
            if let queued = queue.first(where: { $0.id == id }) {
                view = queued.view as? T
            }
        }
        return view
    }

    /**
     Returns a message view with the given `id` if it is currently being 
     shown, hidden or in the queue to be shown.

     - Parameter id: The id of a message that adopts `Identifiable`.
     - Returns: The view with matching id if currently queued to be shown.
     */
    public func currentOrQueued<T: UIView>(id: String) -> T? {
        return current(id: id) ?? queued(id: id)
    }
}

/*
 MARK: - PresenterDelegate
 */

extension SwiftMessages: PresenterDelegate {

    func hide(presenter: Presenter) {
        messageQueue.sync {
            self.internalHide(presenter: presenter)
        }
    }

    public func hide(animator: Animator) {
        messageQueue.sync {
            guard let presenter = self.presenter(forAnimator: animator) else { return }
            self.internalHide(presenter: presenter)
        }
    }

    public func panStarted(animator: Animator) {
        autohideToken = nil
    }

    public func panEnded(animator: Animator) {
        queueAutoHide()
    }

    private func presenter(forAnimator animator: Animator) -> Presenter? {
        if let current = _current, animator === current.animator {
            return current
        }
        let queued = queue.filter { $0.animator === animator }
        return queued.first
    }
}

/**
 MARK: - Creating views from nibs

 This extension provides several convenience functions for instantiating views from nib files.
 SwiftMessages provides several default nib files in the Resources folder that can be
 drag-and-dropped into a project as a starting point and modified.
 */

extension SwiftMessages {
    
    /**
     Loads a nib file with the same name as the generic view type `T` and returns
     the first view found in the nib file with matching type `T`. For example, if
     the generic type is `MyView`, a nib file named `MyView.nib` is loaded and the
     first top-level view of type `MyView` is returned. The main bundle is searched
     first followed by the SwiftMessages bundle.
     
     - Parameter filesOwner: An optional files owner.
     
     - Throws: `Error.CannotLoadViewFromNib` if a view matching the
       generic type `T` is not found in the nib.
     
     - Returns: An instance of generic view type `T`.
     */
    public class func viewFromNib<T: UIView>(_ filesOwner: AnyObject = NSNull.init()) throws -> T {
        let name = T.description().components(separatedBy: ".").last
        assert(name != nil)
        let view: T = try internalViewFromNib(named: name!, bundle: nil, filesOwner: filesOwner)
        return view
    }
    
    /**
     Loads a nib file with specified name and returns the first view found in the  nib file
     with matching type `T`. The main bundle is searched first followed by the SwiftMessages bundle.
     
     - Parameter name: The name of the nib file (excluding the .xib extension).
     - Parameter filesOwner: An optional files owner.
     
     - Throws: `Error.CannotLoadViewFromNib` if a view matching the
     generic type `T` is not found in the nib.
     
     - Returns: An instance of generic view type `T`.
     */
    public class func viewFromNib<T: UIView>(named name: String, filesOwner: AnyObject = NSNull.init()) throws -> T {
        let view: T = try internalViewFromNib(named: name, bundle: nil, filesOwner: filesOwner)
        return view
    }
    
    /**
     Loads a nib file with specified name in the specified bundle and returns the
     first view found in the  nib file with matching type `T`.
     
     - Parameter name: The name of the nib file (excluding the .xib extension).
     - Parameter bundle: The name of the bundle containing the nib file.
     - Parameter filesOwner: An optional files owner.
     
     - Throws: `Error.CannotLoadViewFromNib` if a view matching the
     generic type `T` is not found in the nib.
     
     - Returns: An instance of generic view type `T`.
     */
    public class func viewFromNib<T: UIView>(named name: String, bundle: Bundle, filesOwner: AnyObject = NSNull.init()) throws -> T {
        let view: T = try internalViewFromNib(named: name, bundle: bundle, filesOwner: filesOwner)
        return view
    }
    
    fileprivate class func internalViewFromNib<T: UIView>(named name: String, bundle: Bundle? = nil, filesOwner: AnyObject = NSNull.init()) throws -> T {
        let resolvedBundle: Bundle
        if let bundle = bundle {
            resolvedBundle = bundle
        } else {
            if Bundle.main.path(forResource: name, ofType: "nib") != nil {
                resolvedBundle = Bundle.main
            } else {
                resolvedBundle = Bundle.sm_frameworkBundle()
            }
        }
        let arrayOfViews = resolvedBundle.loadNibNamed(name, owner: filesOwner, options: nil) ?? []
        #if swift(>=4.1)
        guard let view = arrayOfViews.compactMap( { $0 as? T} ).first else { throw SwiftMessagesError.cannotLoadViewFromNib(nibName: name) }
        #else
        guard let view = arrayOfViews.flatMap( { $0 as? T} ).first else { throw SwiftMessagesError.cannotLoadViewFromNib(nibName: name) }
        #endif
        return view
    }
}

/*
 MARK: - Static APIs
 
 This extension provides a shared instance of `SwiftMessages` and a static API wrapper around
 this instance for simplified syntax. For example, `SwiftMessages.show()` is equivalent
 to `SwiftMessages.sharedInstance.show()`.
 */

extension SwiftMessages {
    
    /**
     A default shared instance of `SwiftMessages`. The `SwiftMessages` class provides
     a set of static APIs that wrap calls to this instance. For example, `SwiftMessages.show()`
     is equivalent to `SwiftMessages.sharedInstance.show()`.
     */
    public static var sharedInstance: SwiftMessages {
        return globalInstance
    }
    
    public static func show(viewProvider: @escaping ViewProvider) {
        globalInstance.show(viewProvider: viewProvider)
    }
    
    public static func show(config: Config, viewProvider: @escaping ViewProvider) {
        globalInstance.show(config: config, viewProvider: viewProvider)
    }
    
    public static func show(view: UIView) {
        globalInstance.show(view: view)
    }

    public static func show(config: Config, view: UIView) {
        globalInstance.show(config: config, view: view)
    }

    public static func hide(animated: Bool = true) {
        globalInstance.hide(animated: animated)
    }
    
    public static func hideAll() {
        globalInstance.hideAll()
    }
    
    public static func hide(id: String) {
        globalInstance.hide(id: id)
    }

    public static func hideCounted(id: String) {
        globalInstance.hideCounted(id: id)
    }

    public static var defaultConfig: Config {
        get {
            return globalInstance.defaultConfig
        }
        set {
            globalInstance.defaultConfig = newValue
        }
    }
    
    public static var pauseBetweenMessages: TimeInterval {
        get {
            return globalInstance.pauseBetweenMessages
        }
        set {
            globalInstance.pauseBetweenMessages = newValue
        }
    }

    public static func current<T: UIView>(id: String) -> T? {
        return globalInstance.current(id: id)
    }

    public static func queued<T: UIView>(id: String) -> T? {
        return globalInstance.queued(id: id)
    }

    public static func currentOrQueued<T: UIView>(id: String) -> T? {
        return globalInstance.currentOrQueued(id: id)
    }

    public static func count(id: String) -> Int {
        return globalInstance.count(id: id)
    }

    public static func set(count: Int, for id: String) {
        globalInstance.set(count: count, for: id)
    }
}
//
//  PhysicsAnimation.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/14/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

public class PhysicsAnimation: NSObject, Animator {

    public enum Placement {
        case top
        case center
        case bottom
    }

    open var placement: Placement = .center

    open var showDuration: TimeInterval = 0.5

    open var hideDuration: TimeInterval = 0.15

    public var panHandler = PhysicsPanHandler()

    public weak var delegate: AnimationDelegate?
    weak var messageView: UIView?
    weak var containerView: UIView?
    var context: AnimationContext?

    public override init() {}

    init(delegate: AnimationDelegate) {
        self.delegate = delegate
    }

    public func show(context: AnimationContext, completion: @escaping AnimationCompletion) {
        NotificationCenter.default.addObserver(self, selector: #selector(adjustMargins), name: UIDevice.orientationDidChangeNotification, object: nil)
        install(context: context)
        showAnimation(context: context, completion: completion)
    }

    public func hide(context: AnimationContext, completion: @escaping AnimationCompletion) {
        NotificationCenter.default.removeObserver(self)
        if panHandler.isOffScreen {
            context.messageView.alpha = 0
            panHandler.state?.stop()
        }
        let view = context.messageView
        self.context = context
        CATransaction.begin()
        CATransaction.setCompletionBlock {
            view.alpha = 1
            view.transform = CGAffineTransform.identity
            completion(true)
        }
        UIView.animate(withDuration: hideDuration, delay: 0, options: [.beginFromCurrentState, .curveEaseIn, .allowUserInteraction], animations: {
            view.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)
        }, completion: nil)
        UIView.animate(withDuration: hideDuration, delay: 0, options: [.beginFromCurrentState, .curveEaseIn, .allowUserInteraction], animations: {
            view.alpha = 0
        }, completion: nil)
        CATransaction.commit()
    }

    func install(context: AnimationContext) {
        let view = context.messageView
        let container = context.containerView
        messageView = view
        containerView = container
        self.context = context
        view.translatesAutoresizingMaskIntoConstraints = false
        container.addSubview(view)
        switch placement {
        case .center:
            view.centerYAnchor.constraint(equalTo: container.centerYAnchor).with(priority: UILayoutPriority(200)).isActive = true
        case .top:
            view.topAnchor.constraint(equalTo: container.topAnchor).with(priority: UILayoutPriority(200)).isActive = true
        case .bottom:
            view.bottomAnchor.constraint(equalTo: container.bottomAnchor).with(priority: UILayoutPriority(200)).isActive = true
        }
        NSLayoutConstraint(item: view, attribute: .leading, relatedBy: .equal, toItem: container, attribute: .leading, multiplier: 1, constant: 0).isActive = true
        NSLayoutConstraint(item: view, attribute: .trailing, relatedBy: .equal, toItem: container, attribute: .trailing, multiplier: 1, constant: 0).isActive = true
        // Important to layout now in order to get the right safe area insets
        container.layoutIfNeeded()
        adjustMargins()
        container.layoutIfNeeded()
        installInteractive(context: context)
    }

    @objc public func adjustMargins() {
        guard let adjustable = messageView as? MarginAdjustable & UIView,
            let context = context else { return }
        adjustable.preservesSuperviewLayoutMargins = false
        if #available(iOS 11, *) {
            adjustable.insetsLayoutMarginsFromSafeArea = false
        }
        adjustable.layoutMargins = adjustable.defaultMarginAdjustment(context: context)
    }

    func showAnimation(context: AnimationContext, completion: @escaping AnimationCompletion) {
        let view = context.messageView
        view.alpha = 0.25
        view.transform = CGAffineTransform(scaleX: 0.6, y: 0.6)
        CATransaction.begin()
        CATransaction.setCompletionBlock {
            completion(true)
        }
        UIView.animate(withDuration: showDuration, delay: 0, usingSpringWithDamping: 0.6, initialSpringVelocity: 0, options: [.beginFromCurrentState, .curveLinear, .allowUserInteraction], animations: {
            view.transform = CGAffineTransform.identity
        }, completion: nil)
        UIView.animate(withDuration: 0.3 * showDuration, delay: 0, options: [.beginFromCurrentState, .curveLinear, .allowUserInteraction], animations: {
            view.alpha = 1
        }, completion: nil)
        CATransaction.commit()
    }

    func installInteractive(context: AnimationContext) {
        guard context.interactiveHide else { return }
        panHandler.configure(context: context, animator: self)
    }
}


//
//  UIEdgeInsets+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 5/23/18.
//  Copyright © 2018 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension UIEdgeInsets {
    public static func +(left: UIEdgeInsets, right: UIEdgeInsets) -> UIEdgeInsets {
        let topSum = left.top + right.top
        let leftSum = left.left + right.left
        let bottomSum = left.bottom + right.bottom
        let rightSum = left.right + right.right
        return UIEdgeInsets(top: topSum, left: leftSum, bottom: bottomSum, right: rightSum)
    }

    public static func -(left: UIEdgeInsets, right: UIEdgeInsets) -> UIEdgeInsets {
        let topSum = left.top - right.top
        let leftSum = left.left - right.left
        let bottomSum = left.bottom - right.bottom
        let rightSum = left.right - right.right
        return UIEdgeInsets(top: topSum, left: leftSum, bottom: bottomSum, right: rightSum)
    }
}
//
//  AccessibleMessage.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 3/11/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import Foundation

/**
 Message views that `AccessibleMessage`, as `MessageView` does will
 have proper accessibility behavior when displaying messages.
 `MessageView` implements this protocol.
 */
public protocol AccessibleMessage {
    var accessibilityMessage: String? { get }
    var accessibilityElement: NSObject? { get }
    var additionalAccessibilityElements: [NSObject]? { get }
}
//
//  Error.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/7/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import Foundation

/**
 The `SwiftMessagesError` enum contains the errors thrown by SwiftMessages.
 */
enum SwiftMessagesError: Error {
    case cannotLoadViewFromNib(nibName: String)
    case noRootViewController
}
//
//  PassthroughView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/5/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

class PassthroughView: UIControl {

    var tappedHander: (() -> Void)?

    override init(frame: CGRect) {
        super.init(frame: frame)
        initCommon()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        initCommon()
    }

    private func initCommon() {
        addTarget(self, action: #selector(tapped), for: .touchUpInside)
    }

    @objc func tapped() {
        tappedHander?()
    }
    
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        let view = super.hitTest(point, with: event)
        return view == self && tappedHander == nil ? nil : view
    }
}
//
//  WindowViewController.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/1/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

open class WindowViewController: UIViewController
{
    override open var shouldAutorotate: Bool {
        return config.shouldAutorotate
    }

    convenience public init() {
        self.init(config: SwiftMessages.Config())
    }

    public init(config: SwiftMessages.Config) {
        self.config = config
        let view = PassthroughView()
        let window = PassthroughWindow(hitTestView: view)
        self.window = window
        super.init(nibName: nil, bundle: nil)
        self.view = view
        window.rootViewController = self
        window.windowLevel = config.windowLevel ?? UIWindow.Level.normal
        if #available(iOS 13, *) {
            window.overrideUserInterfaceStyle = config.overrideUserInterfaceStyle
        }
    }

    func install() {
        if #available(iOS 13, *) {
            window?.windowScene = config.windowScene
            #if !SWIFTMESSAGES_APP_EXTENSIONS
            previousKeyWindow = UIWindow.keyWindow
            #endif
            show(
                becomeKey: config.shouldBecomeKeyWindow,
                frame: config.windowScene?.coordinateSpace.bounds
            )
        } else {
            show(becomeKey: config.shouldBecomeKeyWindow)
        }
    }

    private func show(becomeKey: Bool, frame: CGRect? = nil) {
        guard let window = window else { return }
        window.frame = frame ?? UIScreen.main.bounds
        if becomeKey {
            window.makeKeyAndVisible()
        } else {
            window.isHidden = false
        }
    }
    
    func uninstall() {
        if window?.isKeyWindow == true {
            previousKeyWindow?.makeKey()
        }
        if #available(iOS 13, *) {
            window?.windowScene = nil
        }
        window?.isHidden = true
        window = nil
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override open var preferredStatusBarStyle: UIStatusBarStyle {
        return config.preferredStatusBarStyle ?? super.preferredStatusBarStyle
    }

    open override var prefersStatusBarHidden: Bool {
        return config.prefersStatusBarHidden ?? super.prefersStatusBarHidden
    }

    // MARK: - Variables

    private var window: UIWindow?
    private weak var previousKeyWindow: UIWindow?

    let config: SwiftMessages.Config
}

extension WindowViewController {
    static func newInstance(config: SwiftMessages.Config) -> WindowViewController {
        return config.windowViewController?(config) ?? WindowViewController(config: config)
    }
}
//
//  MarginAdjustable+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 11/5/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension MarginAdjustable where Self: UIView {
    public func defaultMarginAdjustment(context: AnimationContext) -> UIEdgeInsets {
        var layoutMargins: UIEdgeInsets = layoutMarginAdditions
        var safeAreaInsets: UIEdgeInsets = {
            guard respectSafeArea else { return .zero }
            if #available(iOS 11, *) {
                insetsLayoutMarginsFromSafeArea = false
                return self.safeAreaInsets
            } else {
                #if SWIFTMESSAGES_APP_EXTENSIONS
                let application: UIApplication? = nil
                #else
                let application: UIApplication? = UIApplication.shared
                #endif
                if !context.safeZoneConflicts.isDisjoint(with: [.statusBar]),
                   let app = application,
                   app.statusBarOrientation == .portrait || app.statusBarOrientation == .portraitUpsideDown {
                    let frameInWindow = convert(bounds, to: window)
                    let top = max(0, 20 - frameInWindow.minY)
                    return UIEdgeInsets(top: top, left: 0, bottom: 0, right: 0)
                } else {
                    return .zero
                }
            }
        }()
        if !context.safeZoneConflicts.isDisjoint(with: .overStatusBar) {
            safeAreaInsets.top = 0
        }
        layoutMargins = collapseLayoutMarginAdditions
            ? layoutMargins.collapse(toInsets: safeAreaInsets)
            : layoutMargins + safeAreaInsets
        return layoutMargins
    }
}

extension UIEdgeInsets {
    func collapse(toInsets insets: UIEdgeInsets) -> UIEdgeInsets {
        let top = self.top.collapse(toInset: insets.top)
        let left = self.left.collapse(toInset: insets.left)
        let bottom = self.bottom.collapse(toInset: insets.bottom)
        let right = self.right.collapse(toInset: insets.right)
        return UIEdgeInsets(top: top, left: left, bottom: bottom, right: right)
    }
}

extension CGFloat {
    func collapse(toInset inset: CGFloat) -> CGFloat {
        return Swift.max(self, inset)
    }
}
//
//  MarginAdjustable.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/5/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/*
 Message views that implement the `MarginAdjustable` protocol will have their
 `layoutMargins` adjusted by SwiftMessages to account for the height of the
 status bar (when displayed under the status bar) and a small amount of
 overshoot in the bounce animation. `MessageView` implements this protocol
 by way of its parent class `BaseView`.
 
 For the effect of this protocol to work, subviews should be pinned to the
 message view's margins and the `layoutMargins` property should not be modified.
 
 This protocol is optional. A message view that doesn't implement `MarginAdjustable`
 is responsible for setting is own internal margins appropriately.
 */
public protocol MarginAdjustable {

    /// The amount to add to the safe area insets in calculating
    /// the layout margins.
    var layoutMarginAdditions: UIEdgeInsets { get }

    /// When `true`, SwiftMessages automatically collapses layout margin additions (topLayoutMarginAddition, etc.)
    /// when the default layout margins are greater than zero. This is typically used when a margin addition is only
    /// needed when the safe area inset is zero for a given edge. When the safe area inset for a given edge is non-zero,
    /// the additional margin is not added.
    var collapseLayoutMarginAdditions: Bool { get set }


    /// Start margins from the safe area.
    var respectSafeArea: Bool { get set }

    var bounceAnimationOffset: CGFloat { get set }
}

//
//  NSLayoutConstraint+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 5/18/19.
//  Copyright © 2019 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension NSLayoutConstraint {
    func with(priority: UILayoutPriority) -> NSLayoutConstraint {
        self.priority = priority
        return self
    }
}
//
//  CornerRoundingView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 7/28/18.
//  Copyright © 2018 SwiftKick Mobile. All rights reserved.
//

import UIKit

/// A background view that messages can use for rounding all or a subset of corners with squircles
/// (the smoother method of rounding corners that you see on app icons).
open class CornerRoundingView: UIView {

    /// Specifies the corner radius to use.
    @IBInspectable
    open var cornerRadius: CGFloat = 0 {
        didSet {
            updateMaskPath()
        }
    }

    /// Set to `true` for layouts where only the leading corners should be
    /// rounded. For example, the layout in TabView.xib rounds the bottom corners
    /// when displayed from the top and the top corners when displayed from the bottom.
    /// When this property is `true`, the `roundedCorners` property will be overwritten
    /// by relevant animators (e.g. `TopBottomAnimation`).
    @IBInspectable
    open var roundsLeadingCorners: Bool = false

    /// Specifies which corners should be rounded. When `roundsLeadingCorners = true`, relevant
    /// relevant animators (e.g. `TopBottomAnimation`) will overwrite the value of this property.
    open var roundedCorners: UIRectCorner = [.allCorners] {
        didSet {
            updateMaskPath()
        }
    }

    override public init(frame: CGRect) {
        super.init(frame: frame)
        sharedInit()
    }

    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        sharedInit()
    }

    private func sharedInit() {
        layer.mask = shapeLayer
    }

    private let shapeLayer = CAShapeLayer()

    override open func layoutSubviews() {
        super.layoutSubviews()
        updateMaskPath()
    }

    private func updateMaskPath() {
        let newPath = UIBezierPath(roundedRect: layer.bounds, byRoundingCorners: roundedCorners, cornerRadii: cornerRadii).cgPath
        // Update the `shapeLayer's` path with animation if we detect our `layer's` size is being animated.
        // This is a workaround needed for smooth rotation animations.
        if let foundAnimation = layer.findAnimation(forKeyPath: "bounds.size") {
            // Update the `shapeLayer's` path with animation, copying the relevant properties
            // from the found animation.
            let animation = CABasicAnimation(keyPath: "path")
            animation.duration = foundAnimation.duration
            animation.timingFunction = foundAnimation.timingFunction
            animation.fromValue = shapeLayer.path
            animation.toValue = newPath
            shapeLayer.add(animation, forKey: "path")
            shapeLayer.path = newPath
        } else {
            // Update the `shapeLayer's` path  without animation
            shapeLayer.path = newPath
        }
    }

    private var cornerRadii: CGSize {
        return CGSize(width: cornerRadius, height: cornerRadius)
    }
}
//
//  Animator.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/4/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

public typealias AnimationCompletion = (_ completed: Bool) -> Void

public protocol AnimationDelegate: AnyObject {
    func hide(animator: Animator)
    func panStarted(animator: Animator)
    func panEnded(animator: Animator)
}

/**
 An option set representing the known types of safe area conflicts
 that could require margin adjustments on the message view in order to
 get the layouts to look right.
 */
public struct SafeZoneConflicts: OptionSet {
    public let rawValue: Int

    public init(rawValue: Int) {
        self.rawValue = rawValue
    }

    /// Message view behind status bar
    public static let statusBar = SafeZoneConflicts(rawValue: 1 << 0)

    /// Message view behind the sensor notch on iPhone X
    public static let sensorNotch = SafeZoneConflicts(rawValue: 1 << 1)

    /// Message view behind home indicator on iPhone X
    public static let homeIndicator = SafeZoneConflicts(rawValue: 1 << 2)

    /// Message view is over the status bar on an iPhone 8 or lower. This is a special
    /// case because we logically expect the top safe area to be zero, but it is reported as 20
    /// (which seems like an iOS bug). We use the `overStatusBar` to indicate this special case.
    public static let overStatusBar = SafeZoneConflicts(rawValue: 1 << 3)
}

public class AnimationContext {

    public let messageView: UIView
    public let containerView: UIView
    public let safeZoneConflicts: SafeZoneConflicts
    public let interactiveHide: Bool

    init(messageView: UIView, containerView: UIView, safeZoneConflicts: SafeZoneConflicts, interactiveHide: Bool) {
        self.messageView = messageView
        self.containerView = containerView
        self.safeZoneConflicts = safeZoneConflicts
        self.interactiveHide = interactiveHide
    }
}

public protocol Animator: AnyObject {

    /// Adopting classes should declare as `weak`.
    var delegate: AnimationDelegate? { get set }

    func show(context: AnimationContext, completion: @escaping AnimationCompletion)

    func hide(context: AnimationContext, completion: @escaping AnimationCompletion)

    /// The show animation duration. If the animation duration is unknown, such as if using `UIDynamicAnimator`,
    /// then provide an estimate. This value is used by `SwiftMessagesSegue`.
    var showDuration: TimeInterval { get }

    /// The hide animation duration. If the animation duration is unknown, such as if using `UIDynamicAnimator`,
    /// then provide an estimate. This value is used by `SwiftMessagesSegue`.
    var hideDuration: TimeInterval { get }
}

//
//  BackgroundViewable.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/15/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/**
 Message views that implement the `BackgroundViewable` protocol will have the
 pan-to-hide gesture recognizer installed in the `backgroundView`. Message views
 always span the full width of the containing view. Typically, the `backgroundView`
 property defines the message view's visible region, allowing for card-style views
 where the message view background is transparent and the background view is inset
 from by some amount. See CardView.nib, for example.
 
 This protocol is optional. Message views that don't implement `BackgroundViewable`
 will have the pan-to-hide gesture installed in the message view itself.
 */
public protocol BackgroundViewable {
    var backgroundView: UIView! { get }
}//
//  UIWindow+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 3/11/21.
//  Copyright © 2021 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension UIWindow {
    #if !SWIFTMESSAGES_APP_EXTENSIONS
    static var keyWindow: UIWindow? {
        if #available(iOS 13.0, *) {
            return UIApplication.shared.connectedScenes
                .sorted { $0.activationState.sortPriority < $1.activationState.sortPriority }
                .compactMap { $0 as? UIWindowScene }
                .compactMap { $0.windows.first { $0.isKeyWindow } }
                .first
        } else {
            return UIApplication.shared.keyWindow
        }
    }
    #endif
}

@available(iOS 13.0, *)
private extension UIScene.ActivationState {
    var sortPriority: Int {
        switch self {
        case .foregroundActive: return 1
        case .foregroundInactive: return 2
        case .background: return 3
        case .unattached: return 4
        @unknown default: return 5
        }
    }
}
//
//  MessagePresenter.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 7/30/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

protocol PresenterDelegate: AnimationDelegate {
    func hide(presenter: Presenter)
}

class Presenter: NSObject {

    // MARK: - API

    init(config: SwiftMessages.Config, view: UIView, delegate: PresenterDelegate) {
        self.config = config
        self.view = view
        self.delegate = delegate
        self.animator = Presenter.animator(forPresentationStyle: config.presentationStyle, delegate: delegate)
        if let identifiable = view as? Identifiable {
            id = identifiable.id
        } else {
            var mutableView = view
            id = withUnsafePointer(to: &mutableView) { "\($0)" }
        }

        super.init()
    }
    
    var id: String
    var config: SwiftMessages.Config
    let maskingView = MaskingView()
    let animator: Animator
    var isHiding = false
    let view: UIView

    var delayShow: TimeInterval? {
        if case .indefinite(let delay, _) = config.duration { return delay }
        return nil
    }

    var showDate: CFTimeInterval?

    /// Returns the required delay for hiding based on time shown
    var delayHide: TimeInterval? {
        if interactivelyHidden { return 0 }
        if case .indefinite(_, let minimum) = config.duration, let showDate = showDate {
            let timeIntervalShown = CACurrentMediaTime() - showDate
            return max(0, minimum - timeIntervalShown)
        }
        return nil
    }

    var pauseDuration: TimeInterval? {
        let duration: TimeInterval?
        switch self.config.duration {
        case .automatic:
            duration = 2
        case .seconds(let seconds):
            duration = seconds
        case .forever, .indefinite:
            duration = nil
        }
        return duration
    }

    // MARK: - Constants

    enum PresentationContext {
        case viewController(_: Weak<UIViewController>)
        case view(_: Weak<UIView>)
        
        func viewControllerValue() -> UIViewController? {
            switch self {
            case .viewController(let weak):
                return weak.value
            case .view:
                return nil
            }
        }
        
        func viewValue() -> UIView? {
            switch self {
            case .viewController(let weak):
                return weak.value?.view
            case .view(let weak):
                return weak.value
            }
        }
    }

    // MARK: - Variables

    private weak var delegate: PresenterDelegate?
    private var presentationContext = PresentationContext.viewController(Weak<UIViewController>(value: nil))

    private var interactivelyHidden = false;

    // MARK: - Showing and hiding

    private static func animator(forPresentationStyle style: SwiftMessages.PresentationStyle, delegate: AnimationDelegate) -> Animator {
        switch style {
        case .top:
            return TopBottomAnimation(style: .top, delegate: delegate)
        case .bottom:
            return TopBottomAnimation(style: .bottom, delegate: delegate)
        case .center:
            return PhysicsAnimation(delegate: delegate)
        case .custom(let animator):
            animator.delegate = delegate
            return animator
        }
    }

    func show(completion: @escaping AnimationCompletion) throws {
        try presentationContext = getPresentationContext()
        install()
        self.config.eventListeners.forEach { $0(.willShow(self.view)) }
        showAnimation() { completed in
            completion(completed)
            if completed {
                if self.config.dimMode.modal {
                    self.showAccessibilityFocus()
                } else {
                    self.showAccessibilityAnnouncement()
                }
                self.config.eventListeners.forEach { $0(.didShow(self.view)) }
            }
        }
    }

    private func showAnimation(completion: @escaping AnimationCompletion) {

        func dim(_ color: UIColor) {
            self.maskingView.backgroundColor = UIColor.clear
            UIView.animate(withDuration: 0.2, animations: {
                self.maskingView.backgroundColor = color
            })
        }

        func blur(style: UIBlurEffect.Style, alpha: CGFloat) {
            let blurView = UIVisualEffectView(effect: nil)
            blurView.alpha = alpha
            maskingView.backgroundView = blurView
            UIView.animate(withDuration: 0.3) {
                blurView.effect = UIBlurEffect(style: style)
            }
        }

        let context = animationContext()
        animator.show(context: context) { (completed) in
            completion(completed)
        }
        switch config.dimMode {
        case .none:
            break
        case .gray:
            dim(UIColor(white: 0, alpha: 0.3))
        case .color(let color, _):
            dim(color)
        case .blur(let style, let alpha, _):
            blur(style: style, alpha: alpha)
        }
    }

    private func showAccessibilityAnnouncement() {
        guard let accessibleMessage = view as? AccessibleMessage,
            let message = accessibleMessage.accessibilityMessage else { return }
        UIAccessibility.post(notification: UIAccessibility.Notification.announcement, argument: message)
    }

    private func showAccessibilityFocus() {
        guard let accessibleMessage = view as? AccessibleMessage,
            let focus = accessibleMessage.accessibilityElement ?? accessibleMessage.additionalAccessibilityElements?.first else { return }
        UIAccessibility.post(notification: UIAccessibility.Notification.layoutChanged, argument: focus)
    }

    func hide(animated: Bool, completion: @escaping AnimationCompletion) {
        isHiding = true
        self.config.eventListeners.forEach { $0(.willHide(self.view)) }
        let context = animationContext()
        let action = {
            if let viewController = self.presentationContext.viewControllerValue() as? WindowViewController {
                viewController.uninstall()
            }
            self.maskingView.removeFromSuperview()
            completion(true)
            self.config.eventListeners.forEach { $0(.didHide(self.view)) }
        }
        guard animated else {
            action()
            return
        }
        animator.hide(context: context) { (completed) in
            action()
        }

        func undim() {
            UIView.animate(withDuration: 0.2, delay: 0, options: .beginFromCurrentState, animations: {
                self.maskingView.backgroundColor = UIColor.clear
            }, completion: nil)
        }

        func unblur() {
            guard let view = maskingView.backgroundView as? UIVisualEffectView else { return }
            UIView.animate(withDuration: 0.2, delay: 0, options: .beginFromCurrentState, animations: { 
                view.effect = nil
            }, completion: nil)
        }
        
        switch config.dimMode {
        case .none:
            break
        case .gray:
            undim()
        case .color:
            undim()
        case .blur:
            unblur()
        }
    }

    private func animationContext() -> AnimationContext {
        return AnimationContext(messageView: view, containerView: maskingView, safeZoneConflicts: safeZoneConflicts(), interactiveHide: config.interactiveHide)
    }

    private func safeZoneConflicts() -> SafeZoneConflicts {
        guard let window = maskingView.window else { return [] }
        let windowLevel: UIWindow.Level = {
            if let vc = presentationContext.viewControllerValue() as? WindowViewController {
                return vc.config.windowLevel ?? .normal
            }
            return .normal
        }()
        // `underNavigationBar` and `underTabBar` should look up the presentation context's hierarchy
        // for cases where both should be true (probably not an issue for typical height messages, though).
        let underNavigationBar: Bool = {
            if let vc = presentationContext.viewControllerValue() as? UINavigationController { return vc.sm_isVisible(view: vc.navigationBar) }
            return false
        }()
        let underTabBar: Bool = {
            if let vc = presentationContext.viewControllerValue() as? UITabBarController { return vc.sm_isVisible(view: vc.tabBar) }
            return false
        }()
        if #available(iOS 11, *) {
            if windowLevel > .normal {
                // seeing `maskingView.safeAreaInsets.top` value of 20 on
                // iPhone 8 with status bar window level. This seems like an iOS bug since
                // the message view's window is above the status bar. Applying a special rule
                // to allow the animator to revove this amount from the layout margins if needed.
                // This may need to be reworked if any future device has a legitimate 20pt top safe area,
                // such as with a potentially smaller notch.
                if maskingView.safeAreaInsets.top == 20 {
                    return [.overStatusBar]
                } else {
                    var conflicts: SafeZoneConflicts = []
                    if maskingView.safeAreaInsets.top > 0 {
                        conflicts.formUnion(.sensorNotch)
                    }
                    if maskingView.safeAreaInsets.bottom > 0 {
                        conflicts.formUnion(.homeIndicator)
                    }
                    return conflicts
                }
            }
            var conflicts: SafeZoneConflicts = []
            if !underNavigationBar {
                conflicts.formUnion(.sensorNotch)
            }
            if !underTabBar {
                conflicts.formUnion(.homeIndicator)
            }
            return conflicts
        } else {
            #if SWIFTMESSAGES_APP_EXTENSIONS
            return []
            #else
            if UIApplication.shared.isStatusBarHidden { return [] }
            if (windowLevel > UIWindow.Level.normal) || underNavigationBar { return [] }
            let statusBarFrame = UIApplication.shared.statusBarFrame
            let statusBarWindowFrame = window.convert(statusBarFrame, from: nil)
            let statusBarViewFrame = maskingView.convert(statusBarWindowFrame, from: nil)
            return statusBarViewFrame.intersects(maskingView.bounds) ? SafeZoneConflicts.statusBar : []
            #endif
        }
    }

    private func getPresentationContext() throws -> PresentationContext {

        func newWindowViewController() -> UIViewController {
            let viewController = WindowViewController.newInstance(config: config)
            return viewController
        }

        switch config.presentationContext {
        case .automatic:
            #if SWIFTMESSAGES_APP_EXTENSIONS
            throw SwiftMessagesError.noRootViewController
            #else
            if let rootViewController = UIWindow.keyWindow?.rootViewController {
                let viewController = rootViewController.sm_selectPresentationContextTopDown(config)
                return .viewController(Weak(value: viewController))
            } else {
                throw SwiftMessagesError.noRootViewController
            }
            #endif
        case .window:
            let viewController = newWindowViewController()
            return .viewController(Weak(value: viewController))
        case .windowScene:
            let viewController = newWindowViewController()
            return .viewController(Weak(value: viewController))
        case .viewController(let viewController):
            let viewController = viewController.sm_selectPresentationContextBottomUp(config)
            return .viewController(Weak(value: viewController))
        case .view(let view):
            return .view(Weak(value: view))
        }
    }

    /*
     MARK: - Installation
     */

    func install() {

        func topLayoutConstraint(view: UIView, containerView: UIView, viewController: UIViewController?) -> NSLayoutConstraint {
            if case .top = config.presentationStyle.topBottomStyle, let nav = viewController as? UINavigationController, nav.sm_isVisible(view: nav.navigationBar) {
                return NSLayoutConstraint(item: view, attribute: .top, relatedBy: .equal, toItem: nav.navigationBar, attribute: .bottom, multiplier: 1.00, constant: 0.0)
            }
            return NSLayoutConstraint(item: view, attribute: .top, relatedBy: .equal, toItem: containerView, attribute: .top, multiplier: 1.00, constant: 0.0)
        }

        func bottomLayoutConstraint(view: UIView, containerView: UIView, viewController: UIViewController?) -> NSLayoutConstraint {
            if case .bottom = config.presentationStyle.topBottomStyle, let tab = viewController as? UITabBarController, tab.sm_isVisible(view: tab.tabBar) {
                return NSLayoutConstraint(item: view, attribute: .bottom, relatedBy: .equal, toItem: tab.tabBar, attribute: .top, multiplier: 1.00, constant: 0.0)
            }
            return NSLayoutConstraint(item: view, attribute: .bottom, relatedBy: .equal, toItem: containerView, attribute: .bottom, multiplier: 1.00, constant: 0.0)
        }

        func installMaskingView(containerView: UIView) {
            maskingView.translatesAutoresizingMaskIntoConstraints = false
            if let nav = presentationContext.viewControllerValue() as? UINavigationController {
                containerView.insertSubview(maskingView, belowSubview: nav.navigationBar)
            } else if let tab = presentationContext.viewControllerValue() as? UITabBarController {
                containerView.insertSubview(maskingView, belowSubview: tab.tabBar)
            } else {
                containerView.addSubview(maskingView)
            }
            maskingView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor).isActive = true
            maskingView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor).isActive = true
            topLayoutConstraint(view: maskingView, containerView: containerView, viewController: presentationContext.viewControllerValue()).isActive = true
            bottomLayoutConstraint(view: maskingView, containerView: containerView, viewController: presentationContext.viewControllerValue()).isActive = true
            if let keyboardTrackingView = config.keyboardTrackingView {
                maskingView.install(keyboardTrackingView: keyboardTrackingView)
            }
            // Update the container view's layout in order to know the masking view's frame
            containerView.layoutIfNeeded()
        }

        func installInteractive() {
            guard config.dimMode.modal else { return }
            if config.dimMode.interactive {
                maskingView.tappedHander = { [weak self] in
                    guard let strongSelf = self else { return }
                    strongSelf.interactivelyHidden = true
                    strongSelf.delegate?.hide(presenter: strongSelf)
                }
            } else {
                // There's no action to take, but the presence of
                // a tap handler prevents interaction with underlying views.
                maskingView.tappedHander = { }
            }
        }

        func installAccessibility() {
            var elements: [NSObject] = []
            if let accessibleMessage = view as? AccessibleMessage {
                if let message = accessibleMessage.accessibilityMessage {
                    let element = accessibleMessage.accessibilityElement ?? view
                    element.isAccessibilityElement = true
                    if element.accessibilityLabel == nil {
                        element.accessibilityLabel = message
                    }
                    elements.append(element)
                }
                if let additional = accessibleMessage.additionalAccessibilityElements {
                    elements += additional
                }
            } else {
                    elements += [view]
            }
            if config.dimMode.interactive {
                let dismissView = UIView(frame: maskingView.bounds)
                dismissView.translatesAutoresizingMaskIntoConstraints = true
                dismissView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
                maskingView.addSubview(dismissView)
                maskingView.sendSubviewToBack(dismissView)
                dismissView.isUserInteractionEnabled = false
                dismissView.isAccessibilityElement = true
                dismissView.accessibilityLabel = config.dimModeAccessibilityLabel
                dismissView.accessibilityTraits = UIAccessibilityTraits.button
                elements.append(dismissView)
            }
            if config.dimMode.modal {
                maskingView.accessibilityViewIsModal = true
            }
            maskingView.accessibleElements = elements
        }

        guard let containerView = presentationContext.viewValue() else { return }
        (presentationContext.viewControllerValue() as? WindowViewController)?.install()
        installMaskingView(containerView: containerView)
        installInteractive()
        installAccessibility()
    }
}


//
//  NSBundle+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/8/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import Foundation

private class BundleToken {}

extension Bundle {
    // This is copied method from SPM generated Bundle.module for CocoaPods support
    static func sm_frameworkBundle() -> Bundle {

        let candidates = [
            // Bundle should be present here when the package is linked into an App.
            Bundle.main.resourceURL,

            // Bundle should be present here when the package is linked into a framework.
            Bundle(for: BundleToken.self).resourceURL,

            // For command-line tools.
            Bundle.main.bundleURL,
        ]

        let bundleNames = [
            // For Swift Package Manager
            "SwiftMessages_SwiftMessages",

            // For Carthage
            "SwiftMessages",
        ]

        for bundleName in bundleNames {
            for candidate in candidates {
                let bundlePath = candidate?.appendingPathComponent(bundleName + ".bundle")
                if let bundle = bundlePath.flatMap(Bundle.init(url:)) {
                    return bundle
                }
            }
        }

        // Return whatever bundle this code is in as a last resort.
        return Bundle(for: BundleToken.self)
    }
}
//
//  CALayer+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/3/18.
//  Copyright © 2018 SwiftKick Mobile. All rights reserved.
//

import QuartzCore

extension CALayer {
    func findAnimation(forKeyPath keyPath: String) -> CABasicAnimation? {
        return animationKeys()?
            .compactMap({ animation(forKey: $0) as? CABasicAnimation })
            .filter({ $0.keyPath == keyPath })
            .first
    }
}
//
//  Identifiable.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/1/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import Foundation

/**
 Message views that adopt the `Identifiable` protocol will have duplicate messages
 removed from the `MessageView` queue. Typically, the `id` would be set to a string
 representation of the content of the message view. For example, `MessageView`, combines
 the title and message body text.
 
 This protocol is optional. Message views that don't adopt `Identifiable` will not
 have duplicates removed.
 */
public protocol Identifiable {
    var id: String { get }
}
import Foundation
import UIKit

/// A workaround for the change in Xcode 13 that prevents using `@availability` attribute
/// with `enum` cases containing associated values.
public protocol WindowScene {}

@available(iOS 13.0, *)
extension UIWindowScene: WindowScene {}
//
//  Theme.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/7/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/// The theme enum specifies the built-in theme options
public enum Theme {
    case info
    case success
    case warning
    case error
}

/// The Icon enum provides type-safe access to the included icons.
public enum Icon: String {
    
    case error = "errorIcon"
    case warning = "warningIcon"
    case success = "successIcon"
    case info = "infoIcon"
    case errorLight = "errorIconLight"
    case warningLight = "warningIconLight"
    case successLight = "successIconLight"
    case infoLight = "infoIconLight"
    case errorSubtle = "errorIconSubtle"
    case warningSubtle = "warningIconSubtle"
    case successSubtle = "successIconSubtle"
    case infoSubtle = "infoIconSubtle"
    
    /// Returns the associated image.
    public var image: UIImage {
        return UIImage(named: rawValue, in: Bundle.sm_frameworkBundle(), compatibleWith: nil)!.withRenderingMode(.alwaysTemplate)
    }
}

/// The IconStyle enum specifies the different variations of the included icons.
public enum IconStyle {
    
    case `default`
    case light
    case subtle
    case none
    
    /// Returns the image for the given theme
    public func image(theme: Theme) -> UIImage? {
        switch (theme, self) {
        case (.info, .default): return Icon.info.image
        case (.info, .light): return Icon.infoLight.image
        case (.info, .subtle): return Icon.infoSubtle.image
        case (.success, .default): return Icon.success.image
        case (.success, .light): return Icon.successLight.image
        case (.success, .subtle): return Icon.successSubtle.image
        case (.warning, .default): return Icon.warning.image
        case (.warning, .light): return Icon.warningLight.image
        case (.warning, .subtle): return Icon.warningSubtle.image
        case (.error, .default): return Icon.error.image
        case (.error, .light): return Icon.errorLight.image
        case (.error, .subtle): return Icon.errorSubtle.image
        default: return nil
        }
    }
}
//
//  PassthroughWindow.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/5/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

class PassthroughWindow: UIWindow {

    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        // iOS has started embedding the SwiftMessages view in private views that block
        // interaction with views underneath, essentially making the window behave like a modal.
        // To work around this, we'll ignore hit test results on these views.
        let view = super.hitTest(point, with: event)
        if let view = view,
            let hitTestView = hitTestView,
            hitTestView.isDescendant(of: view) && hitTestView != view {
            return nil
        }
        return view
    }

    init(hitTestView: UIView) {
        self.hitTestView = hitTestView
        super.init(frame: .zero)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    private weak var hitTestView: UIView?
}
//
//  PhysicsPanHandler.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/25/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

open class PhysicsPanHandler {

    public var hideDelay: TimeInterval = 0.2

    public struct MotionSnapshot {
        var angle: CGFloat
        var time: CFAbsoluteTime
    }

    public final class State {

        weak var messageView: UIView?
        weak var containerView: UIView?
        var dynamicAnimator: UIDynamicAnimator
        var itemBehavior: UIDynamicItemBehavior
        var attachmentBehavior: UIAttachmentBehavior? {
            didSet {
                if let oldValue = oldValue {
                    dynamicAnimator.removeBehavior(oldValue)
                }
                if let attachmentBehavior = attachmentBehavior {
                    dynamicAnimator.addBehavior(attachmentBehavior)
                    addSnapshot()
                }
            }
        }
        var snapshots: [MotionSnapshot] = []

        public init(messageView: UIView, containerView: UIView) {
            self.messageView = messageView
            self.containerView = containerView
            let dynamicAnimator = UIDynamicAnimator(referenceView: containerView)
            let itemBehavior = UIDynamicItemBehavior(items: [messageView])
            itemBehavior.allowsRotation = true
            dynamicAnimator.addBehavior(itemBehavior)
            self.itemBehavior = itemBehavior
            self.dynamicAnimator = dynamicAnimator
        }

        func update(attachmentAnchorPoint anchorPoint: CGPoint) {
            addSnapshot()
            attachmentBehavior?.anchorPoint = anchorPoint
        }

        func addSnapshot() {
            let angle = messageView?.angle ?? snapshots.last?.angle ?? 0
            let time = CFAbsoluteTimeGetCurrent()
            snapshots.append(MotionSnapshot(angle: angle, time: time))
        }

        public func stop() {
            guard let messageView = messageView else {
                dynamicAnimator.removeAllBehaviors()
                return
            }
            let center = messageView.center
            let transform = messageView.transform
            dynamicAnimator.removeAllBehaviors()
            messageView.center = center
            messageView.transform = transform
        }

        public var angularVelocity: CGFloat {
            guard let last = snapshots.last else { return 0 }
            for previous in snapshots.reversed() {
                // Ignore snapshots where the angle or time hasn't changed to avoid degenerate cases.
                if previous.angle != last.angle && previous.time != last.time {
                    return (last.angle - previous.angle) / CGFloat(last.time - previous.time)
                }
            }
            return 0
        }
    }

    weak var animator: Animator?
    weak var messageView: UIView?
    weak var containerView: UIView?
    private(set) public var state: State?
    private(set) public var isOffScreen = false
    private var restingCenter: CGPoint?

    public init() {}

    public private(set) lazy var pan: UIPanGestureRecognizer = {
        let pan = UIPanGestureRecognizer()
        pan.addTarget(self, action: #selector(pan(_:)))
        return pan
    }()

    func configure(context: AnimationContext, animator: Animator) {
        if let oldView = (messageView as? BackgroundViewable)?.backgroundView ?? messageView {
            oldView.removeGestureRecognizer(pan)
        }
        messageView = context.messageView
        let view = (messageView as? BackgroundViewable)?.backgroundView ?? messageView
        view?.addGestureRecognizer(pan)
        containerView = context.containerView
        self.animator = animator
    }

    @objc func pan(_ pan: UIPanGestureRecognizer) {
        guard let messageView = messageView, let containerView = containerView, let animator = animator else { return }
        let anchorPoint = pan.location(in: containerView)
        switch pan.state {
        case .began:
            animator.delegate?.panStarted(animator: animator)
            let state = State(messageView: messageView, containerView: containerView)
            self.state = state
            let center = messageView.center
            restingCenter = center
            let offset = UIOffset(horizontal: anchorPoint.x - center.x, vertical: anchorPoint.y - center.y)
            let attachmentBehavior = UIAttachmentBehavior(item: messageView, offsetFromCenter: offset, attachedToAnchor: anchorPoint)
            state.attachmentBehavior = attachmentBehavior
            state.itemBehavior.action = { [weak self, weak messageView, weak containerView] in
                guard let self = self, !self.isOffScreen, let messageView = messageView, let containerView = containerView, let animator = self.animator else { return }
                let view = (messageView as? BackgroundViewable)?.backgroundView ?? messageView
                let frame = containerView.convert(view.bounds, from: view)
                if !containerView.bounds.intersects(frame) {
                    self.isOffScreen = true
                    DispatchQueue.main.asyncAfter(deadline: .now() + self.hideDelay) {
                        animator.delegate?.hide(animator: animator)
                    }
                }
            }
        case .changed:
            guard let state = state else { return }
            state.update(attachmentAnchorPoint: anchorPoint)
        case .ended, .cancelled:
            guard let state = state else { return }
            state.update(attachmentAnchorPoint: anchorPoint)
            let velocity = pan.velocity(in: containerView)
            let angularVelocity = state.angularVelocity
            let speed = sqrt(pow(velocity.x, 2) + pow(velocity.y, 2))
            // The multiplier on angular velocity was determined by hand-tuning
            let energy = sqrt(pow(speed, 2) + pow(angularVelocity * 75, 2))
            if energy > 200 && speed > 600 {
                // Limit the speed and angular velocity to reasonable values
                let speedScale = speed > 0 ? min(1, 1800 / speed) : 1
                let escapeVelocity = CGPoint(x: velocity.x * speedScale, y: velocity.y * speedScale)
                let angularSpeedScale = min(1, 10 / abs(angularVelocity))
                let escapeAngularVelocity = angularVelocity * angularSpeedScale
                state.itemBehavior.addLinearVelocity(escapeVelocity, for: messageView)
                state.itemBehavior.addAngularVelocity(escapeAngularVelocity, for: messageView)
                state.attachmentBehavior = nil
            } else {
                state.stop()
                self.state = nil
                animator.delegate?.panEnded(animator: animator)
                UIView.animate(withDuration: 0.5, delay: 0, usingSpringWithDamping: 0.65, initialSpringVelocity: 0, options: .beginFromCurrentState, animations: {
                    messageView.center = self.restingCenter ?? CGPoint(x: containerView.bounds.width / 2, y: containerView.bounds.height / 2)
                    messageView.transform = CGAffineTransform.identity
                }, completion: nil)
            }
        default:
            break
        }
    }
}

extension UIView {
    var angle: CGFloat {
        // http://stackoverflow.com/a/2051861/1271826
        return atan2(transform.b, transform.a)
    }
}
//
//  SwiftMessages.Config+Extensions.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 12/26/20.
//  Copyright © 2020 SwiftKick Mobile. All rights reserved.
//

import UIKit

extension SwiftMessages.Config {
    var windowLevel: UIWindow.Level? {
        switch presentationContext {
        case .window(let level): return level
        case .windowScene(_, let level): return level
        default: return nil
        }
    }

    @available (iOS 13.0, *)
    var windowScene: UIWindowScene? {
        switch presentationContext {
        case .windowScene(let scene, _): return scene as? UIWindowScene
        default:
            #if SWIFTMESSAGES_APP_EXTENSIONS
            return nil
            #else
            return UIWindow.keyWindow?.windowScene
            #endif
        }
    }

    var shouldBecomeKeyWindow: Bool {
        if let becomeKeyWindow = becomeKeyWindow { return becomeKeyWindow }
        switch dimMode {
        case .gray, .color, .blur:
            // Should become key window in modal presentation style
            // for proper VoiceOver handling.
            return true
        case .none:
            return false
        }
    }
}
//
//  TopBottomAnimation.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/4/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import UIKit

public class TopBottomAnimation: NSObject, Animator {

    public enum Style {
        case top
        case bottom
    }

    public weak var delegate: AnimationDelegate?

    public let style: Style

    public var showDuration: TimeInterval = 0.4

    public var hideDuration: TimeInterval = 0.2

    public var springDamping: CGFloat = 0.8

    public var closeSpeedThreshold: CGFloat = 750.0;

    public var closePercentThreshold: CGFloat = 0.33;

    public var closeAbsoluteThreshold: CGFloat = 75.0;

    public private(set) lazy var panGestureRecognizer: UIPanGestureRecognizer = {
        let pan = UIPanGestureRecognizer()
        pan.addTarget(self, action: #selector(pan(_:)))
        return pan
    }()

    weak var messageView: UIView?
    weak var containerView: UIView?
    var context: AnimationContext?

    public init(style: Style) {
        self.style = style
    }

    init(style: Style, delegate: AnimationDelegate) {
        self.style = style
        self.delegate = delegate
    }

    public func show(context: AnimationContext, completion: @escaping AnimationCompletion) {
        NotificationCenter.default.addObserver(self, selector: #selector(adjustMargins), name: UIDevice.orientationDidChangeNotification, object: nil)
        install(context: context)
        showAnimation(completion: completion)
    }

    public func hide(context: AnimationContext, completion: @escaping AnimationCompletion) {
        NotificationCenter.default.removeObserver(self)
        let view = context.messageView
        self.context = context
        UIView.animate(withDuration: hideDuration, delay: 0, options: [.beginFromCurrentState, .curveEaseIn], animations: {
            switch self.style {
            case .top:
                view.transform = CGAffineTransform(translationX: 0, y: -view.frame.height)
            case .bottom:
                view.transform = CGAffineTransform(translationX: 0, y: view.frame.maxY + view.frame.height)
            }
        }, completion: { completed in
            #if SWIFTMESSAGES_APP_EXTENSIONS
            completion(completed)
            #else
            // Fix #131 by always completing if application isn't active.
            completion(completed || UIApplication.shared.applicationState != .active)
            #endif
        })
    }

    func install(context: AnimationContext) {
        let view = context.messageView
        let container = context.containerView
        messageView = view
        containerView = container
        self.context = context
        if let adjustable = context.messageView as? MarginAdjustable {
            bounceOffset = adjustable.bounceAnimationOffset
        }
        view.translatesAutoresizingMaskIntoConstraints = false
        container.addSubview(view)
        view.leadingAnchor.constraint(equalTo: container.leadingAnchor).isActive = true
        view.trailingAnchor.constraint(equalTo: container.trailingAnchor).isActive = true
        switch style {
        case .top:
            view.topAnchor.constraint(equalTo: container.topAnchor, constant: -bounceOffset).with(priority: UILayoutPriority(200)).isActive = true
        case .bottom:
            view.bottomAnchor.constraint(equalTo: container.bottomAnchor, constant: bounceOffset).with(priority: UILayoutPriority(200)).isActive = true
        }
        // Important to layout now in order to get the right safe area insets
        container.layoutIfNeeded()
        adjustMargins()
        container.layoutIfNeeded()
        let animationDistance = view.frame.height
        switch style {
        case .top:
            view.transform = CGAffineTransform(translationX: 0, y: -animationDistance)
        case .bottom:
            view.transform = CGAffineTransform(translationX: 0, y: animationDistance)
        }
        if context.interactiveHide {
            if let view = view as? BackgroundViewable {
                view.backgroundView.addGestureRecognizer(panGestureRecognizer)
            } else {
                view.addGestureRecognizer(panGestureRecognizer)
            }
        }
        if let view = view as? BackgroundViewable,
            let cornerRoundingView = view.backgroundView as? CornerRoundingView,
            cornerRoundingView.roundsLeadingCorners {
            switch style {
            case .top:
                cornerRoundingView.roundedCorners = [.bottomLeft, .bottomRight]
            case .bottom:
                cornerRoundingView.roundedCorners = [.topLeft, .topRight]
            }
        }
    }

    @objc public func adjustMargins() {
        guard let adjustable = messageView as? MarginAdjustable & UIView,
            let context = context else { return }
        adjustable.preservesSuperviewLayoutMargins = false
        if #available(iOS 11, *) {
            adjustable.insetsLayoutMarginsFromSafeArea = false
        }
        var layoutMargins = adjustable.defaultMarginAdjustment(context: context)
        switch style {
        case .top:
            layoutMargins.top += bounceOffset
        case .bottom:
            layoutMargins.bottom += bounceOffset
        }
        adjustable.layoutMargins = layoutMargins
    }

    func showAnimation(completion: @escaping AnimationCompletion) {
        guard let view = messageView else {
            completion(false)
            return
        }
        let animationDistance = abs(view.transform.ty)
        // Cap the initial velocity at zero because the bounceOffset may not be great
        // enough to allow for greater bounce induced by a quick panning motion.
        let initialSpringVelocity = animationDistance == 0.0 ? 0.0 : min(0.0, closeSpeed / animationDistance)
        UIView.animate(withDuration: showDuration, delay: 0.0, usingSpringWithDamping: springDamping, initialSpringVelocity: initialSpringVelocity, options: [.beginFromCurrentState, .curveLinear, .allowUserInteraction], animations: {
            view.transform = .identity
        }, completion: { completed in
            // Fix #131 by always completing if application isn't active.
            #if SWIFTMESSAGES_APP_EXTENSIONS
            completion(completed)
            #else
            completion(completed || UIApplication.shared.applicationState != .active)
            #endif
        })
    }

    fileprivate var bounceOffset: CGFloat = 5

    /*
     MARK: - Pan to close
     */

    fileprivate var closing = false
    fileprivate var rubberBanding = false
    fileprivate var closeSpeed: CGFloat = 0.0
    fileprivate var closePercent: CGFloat = 0.0
    fileprivate var panTranslationY: CGFloat = 0.0

    @objc func pan(_ pan: UIPanGestureRecognizer) {
        switch pan.state {
        case .changed:
            guard let view = messageView else { return }
            let height = view.bounds.height - bounceOffset
            if height <= 0 { return }
            var velocity = pan.velocity(in: view)
            var translation = pan.translation(in: view)
            if case .top = style {
                velocity.y *= -1.0
                translation.y *= -1.0
            }
            var translationAmount = translation.y >= 0 ? translation.y : -pow(abs(translation.y), 0.7)
            if !closing {
                // Turn on rubber banding if background view is inset from message view.
                if let background = (messageView as? BackgroundViewable)?.backgroundView, background != view {
                    switch style {
                    case .top:
                        rubberBanding = background.frame.minY > 0
                    case .bottom:
                        rubberBanding = background.frame.maxY < view.bounds.height
                    }
                }
                if !rubberBanding && translationAmount < 0 { return }
                closing = true
                delegate?.panStarted(animator: self)
            }
            if !rubberBanding && translationAmount < 0 { translationAmount = 0 }
            switch style {
            case .top:
                view.transform = CGAffineTransform(translationX: 0, y: -translationAmount)
            case .bottom:
                view.transform = CGAffineTransform(translationX: 0, y: translationAmount)
            }
            closeSpeed = velocity.y
            closePercent = translation.y / height
            panTranslationY = translation.y
        case .ended, .cancelled:
            if closeSpeed > closeSpeedThreshold || closePercent > closePercentThreshold || panTranslationY > closeAbsoluteThreshold {
                delegate?.hide(animator: self)
            } else {
                closing = false
                rubberBanding = false
                closeSpeed = 0.0
                closePercent = 0.0
                panTranslationY = 0.0
                showAnimation(completion: { (completed) in
                    self.delegate?.panEnded(animator: self)
                })
            }
        default:
            break
        }
    }
}

//
//  BaseView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 8/17/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/**
 The `BaseView` class is a reusable message view base class that implements some
 of the optional SwiftMessages protocols and provides some convenience functions
 and a configurable tap handler. Message views do not need to inherit from `BaseVew`.
 */
open class BaseView: UIView, BackgroundViewable, MarginAdjustable {

    /*
     MARK: - IB outlets
     */

    /**
     Fulfills the `BackgroundViewable` protocol and is the target for
     the optional `tapHandler` block. Defaults to `self`.
     */
    @IBOutlet open weak var backgroundView: UIView! {
        didSet {
            if let old = oldValue {
                old.removeGestureRecognizer(tapRecognizer)
            }
            installTapRecognizer()
            updateBackgroundHeightConstraint()
        }
    }

    // The `contentView` property was removed because it no longer had any functionality
    // in the framework. This is a minor backwards incompatible change. If you've copied
    // one of the included nib files from a previous release, you may get a key-value
    // coding runtime error related to contentView, in which case you can subclass the
    // view and add a `contentView` property or you can remove the outlet connection in
    // Interface Builder.
    // @IBOutlet public var contentView: UIView!

    /*
     MARK: - Initialization
     */

    public required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        backgroundView = self
        layoutMargins = UIEdgeInsets.zero
    }

    public override init(frame: CGRect) {
        super.init(frame: frame)
        backgroundView = self
        layoutMargins = UIEdgeInsets.zero
    }

    /*
     MARK: - Installing background and content
     */

    /**
     A convenience function for installing a content view as a subview of `backgroundView`
     and pinning the edges to `backgroundView` with the specified `insets`.

     - Parameter contentView: The view to be installed into the background view
       and assigned to the `contentView` property.
     - Parameter insets: The amount to inset the content view from the background view.
       Default is zero inset.
     */
    open func installContentView(_ contentView: UIView, insets: UIEdgeInsets = UIEdgeInsets.zero) {
        contentView.translatesAutoresizingMaskIntoConstraints = false
        backgroundView.addSubview(contentView)
        contentView.topAnchor.constraint(equalTo: backgroundView.topAnchor, constant: insets.top).isActive = true
        contentView.bottomAnchor.constraint(equalTo: backgroundView.bottomAnchor, constant: -insets.bottom).isActive = true
        contentView.leftAnchor.constraint(equalTo: backgroundView.leftAnchor, constant: insets.left).isActive = true
        contentView.rightAnchor.constraint(equalTo: backgroundView.rightAnchor, constant: -insets.right).isActive = true
        contentView.heightAnchor.constraint(equalToConstant: 350).with(priority: UILayoutPriority(rawValue: 200)).isActive = true
    }

    /**
     A convenience function for installing a background view and pinning to the layout margins.
     This is useful for creating programatic layouts where the background view needs to be
     inset from the message view's edges (like a card-style layout).

     - Parameter backgroundView: The view to be installed as a subview and
       assigned to the `backgroundView` property.
     - Parameter insets: The amount to inset the content view from the margins. Default is zero inset.
     */
    open func installBackgroundView(_ backgroundView: UIView, insets: UIEdgeInsets = UIEdgeInsets.zero) {
        backgroundView.translatesAutoresizingMaskIntoConstraints = false
        if backgroundView != self {
            backgroundView.removeFromSuperview()
        }
        addSubview(backgroundView)
        self.backgroundView = backgroundView
        backgroundView.centerXAnchor.constraint(equalTo: centerXAnchor).with(priority: UILayoutPriority(rawValue: 950)).isActive = true
        backgroundView.topAnchor.constraint(equalTo: layoutMarginsGuide.topAnchor, constant: insets.top).with(priority: UILayoutPriority(rawValue: 900)).isActive = true
        backgroundView.bottomAnchor.constraint(equalTo: layoutMarginsGuide.bottomAnchor, constant: -insets.bottom).with(priority: UILayoutPriority(rawValue: 900)).isActive = true
        backgroundView.heightAnchor.constraint(equalToConstant: 350).with(priority: UILayoutPriority(rawValue: 200)).isActive = true
        layoutConstraints = [
            backgroundView.leftAnchor.constraint(equalTo: layoutMarginsGuide.leftAnchor, constant: insets.left).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.rightAnchor.constraint(equalTo: layoutMarginsGuide.rightAnchor, constant: -insets.right).with(priority: UILayoutPriority(rawValue: 900)),
        ]
        regularWidthLayoutConstraints = [
            backgroundView.leftAnchor.constraint(greaterThanOrEqualTo: layoutMarginsGuide.leftAnchor, constant: insets.left).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.rightAnchor.constraint(lessThanOrEqualTo: layoutMarginsGuide.rightAnchor, constant: -insets.right).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.widthAnchor.constraint(lessThanOrEqualToConstant: 500).with(priority: UILayoutPriority(rawValue: 950)),
            backgroundView.widthAnchor.constraint(equalToConstant: 500).with(priority: UILayoutPriority(rawValue: 200)),
        ]
        installTapRecognizer()
    }

    /**
     A convenience function for installing a background view and pinning to the horizontal
     layout margins and to the vertical edges. This is useful for creating programatic layouts where
     the background view needs to be inset from the message view's horizontal edges (like a tab-style layout).

     - Parameter backgroundView: The view to be installed as a subview and
       assigned to the `backgroundView` property.
     - Parameter insets: The amount to inset the content view from the horizontal margins and vertical edges.
       Default is zero inset.
     */
    open func installBackgroundVerticalView(_ backgroundView: UIView, insets: UIEdgeInsets = UIEdgeInsets.zero) {
        backgroundView.translatesAutoresizingMaskIntoConstraints = false
        if backgroundView != self {
            backgroundView.removeFromSuperview()
        }
        addSubview(backgroundView)
        self.backgroundView = backgroundView
        backgroundView.centerXAnchor.constraint(equalTo: centerXAnchor).with(priority: UILayoutPriority(rawValue: 950)).isActive = true
        backgroundView.topAnchor.constraint(equalTo: topAnchor, constant: insets.top).with(priority: UILayoutPriority(rawValue: 1000)).isActive = true
        backgroundView.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -insets.bottom).with(priority: UILayoutPriority(rawValue: 1000)).isActive = true
        backgroundView.heightAnchor.constraint(equalToConstant: 350).with(priority: UILayoutPriority(rawValue: 200)).isActive = true
        layoutConstraints = [
            backgroundView.leftAnchor.constraint(equalTo: layoutMarginsGuide.leftAnchor, constant: insets.left).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.rightAnchor.constraint(equalTo: layoutMarginsGuide.rightAnchor, constant: -insets.right).with(priority: UILayoutPriority(rawValue: 900)),
        ]
        regularWidthLayoutConstraints = [
            backgroundView.leftAnchor.constraint(greaterThanOrEqualTo: layoutMarginsGuide.leftAnchor, constant: insets.left).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.rightAnchor.constraint(lessThanOrEqualTo: layoutMarginsGuide.rightAnchor, constant: -insets.right).with(priority: UILayoutPriority(rawValue: 900)),
            backgroundView.widthAnchor.constraint(lessThanOrEqualToConstant: 500).with(priority: UILayoutPriority(rawValue: 950)),
            backgroundView.widthAnchor.constraint(equalToConstant: 500).with(priority: UILayoutPriority(rawValue: 200)),
        ]
        installTapRecognizer()
    }

    /*
     MARK: - Tap handler
     */

    /**
     An optional tap handler that will be called when the `backgroundView` is tapped.
     */
    open var tapHandler: ((_ view: BaseView) -> Void)? {
        didSet {
            installTapRecognizer()
        }
    }

    fileprivate lazy var tapRecognizer: UITapGestureRecognizer = {
        let tapRecognizer = UITapGestureRecognizer(target: self, action: #selector(MessageView.tapped))
        return tapRecognizer
    }()

    @objc func tapped() {
        tapHandler?(self)
    }

    fileprivate func installTapRecognizer() {
        guard let backgroundView = backgroundView else { return }
        removeGestureRecognizer(tapRecognizer)
        backgroundView.removeGestureRecognizer(tapRecognizer)
        if tapHandler != nil {
            // Only install the tap recognizer if there is a tap handler,
            // which makes it slightly nicer if one wants to install
            // a custom gesture recognizer.
            backgroundView.addGestureRecognizer(tapRecognizer)
        }
    }

    open override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
        if backgroundView != self {
            let backgroundViewPoint = convert(point, to: backgroundView)
            return backgroundView.point(inside: backgroundViewPoint, with: event)
        }
        return super.point(inside: point, with: event)
    }

    /*
     MARK: - MarginAdjustable

     These properties fulfill the `MarginAdjustable` protocol and are exposed
     as `@IBInspectables` so that they can be adjusted directly in nib files
     (see MessageView.nib).
     */

    public var layoutMarginAdditions: UIEdgeInsets {
        get {
            return UIEdgeInsets(top: topLayoutMarginAddition, left: leftLayoutMarginAddition, bottom: bottomLayoutMarginAddition, right: rightLayoutMarginAddition)
        }
        set {
            topLayoutMarginAddition = newValue.top
            leftLayoutMarginAddition = newValue.left
            bottomLayoutMarginAddition = newValue.bottom
            rightLayoutMarginAddition = newValue.right
        }
    }

    /// Start margins from the safe area.
    open var respectSafeArea: Bool = true

    /// IBInspectable access to layoutMarginAdditions.top
    open var topLayoutMarginAddition: CGFloat = 0

    /// IBInspectable access to layoutMarginAdditions.left
    open var leftLayoutMarginAddition: CGFloat = 0

    /// IBInspectable access to layoutMarginAdditions.bottom
    open var bottomLayoutMarginAddition: CGFloat = 0

    /// IBInspectable access to layoutMarginAdditions.right
    open var rightLayoutMarginAddition: CGFloat = 0

    open var collapseLayoutMarginAdditions: Bool = true

    open var bounceAnimationOffset: CGFloat = 5

    /*
     MARK: - Setting the height
     */

    /**
     An optional explicit height for the background view, which can be used if
     the message view's intrinsic content size does not produce the desired height.
     */
    open var backgroundHeight: CGFloat? {
        didSet {
            updateBackgroundHeightConstraint()
        }
    }

    private func updateBackgroundHeightConstraint() {
        if let existing = backgroundHeightConstraint {
            let view = existing.firstItem as! UIView
            view.removeConstraint(existing)
            backgroundHeightConstraint = nil
        }
        if let height = backgroundHeight, let backgroundView = backgroundView {
            let constraint = NSLayoutConstraint(item: backgroundView, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1, constant: height)
            backgroundView.addConstraint(constraint)
            backgroundHeightConstraint = constraint
        }
    }

    private var backgroundHeightConstraint: NSLayoutConstraint?

    /*
     Mark: - Layout
    */

    open override func updateConstraints() {
        super.updateConstraints()
        let on: [NSLayoutConstraint]
        let off: [NSLayoutConstraint]
        switch traitCollection.horizontalSizeClass {
        case .regular:
            on = regularWidthLayoutConstraints
            off = layoutConstraints
        default:
            on = layoutConstraints
            off = regularWidthLayoutConstraints
        }
        on.forEach { $0.isActive = true }
        off.forEach { $0.isActive = false }
    }

    private var layoutConstraints: [NSLayoutConstraint] = []
    private var regularWidthLayoutConstraints: [NSLayoutConstraint] = []
}

/*
 MARK: - Theming
 */

extension BaseView {

    /// A convenience function to configure a default drop shadow effect.
    /// The shadow is to this view's layer instead of that of the background view
    /// because the background view may be masked. So, when modifying the drop shadow,
    /// be sure to set the shadow properties of this view's layer. The shadow path is
    /// updated for you automatically.
    open func configureDropShadow() {
        layer.shadowColor = UIColor.black.cgColor
        layer.shadowOffset = CGSize(width: 0.0, height: 2.0)
        layer.shadowRadius = 6.0
        layer.shadowOpacity = 0.4
        layer.masksToBounds = false
        updateShadowPath()
    }

    /// A convenience function to turn off drop shadow
    open func configureNoDropShadow() {
        layer.shadowOpacity = 0
    }

    private func updateShadowPath() {
        backgroundView?.layoutIfNeeded()
        let shadowLayer = backgroundView?.layer ?? layer
        let shadowRect = layer.convert(shadowLayer.bounds, from: shadowLayer)
        let shadowPath: CGPath?
        if let backgroundMaskLayer = shadowLayer.mask as? CAShapeLayer,
            let backgroundMaskPath = backgroundMaskLayer.path {
            var transform = CGAffineTransform(translationX: shadowRect.minX, y: shadowRect.minY)
            shadowPath = backgroundMaskPath.copy(using: &transform)
        } else {
            shadowPath = UIBezierPath(roundedRect: shadowRect, cornerRadius: shadowLayer.cornerRadius).cgPath
        }
        // This is a workaround needed for smooth rotation animations.
        if let foundAnimation = layer.findAnimation(forKeyPath: "bounds.size") {
            // Update the layer's `shadowPath` with animation, copying the relevant properties
            // from the found animation.
            let animation = CABasicAnimation(keyPath: "shadowPath")
            animation.duration = foundAnimation.duration
            animation.timingFunction = foundAnimation.timingFunction
            animation.fromValue = layer.shadowPath
            animation.toValue = shadowPath
            layer.add(animation, forKey: "shadowPath")
            layer.shadowPath = shadowPath
        } else {
            // Update the layer's `shadowPath` without animation
            layer.shadowPath = shadowPath        }
    }

    open override func layoutSubviews() {
        super.layoutSubviews()
        updateShadowPath()
    }
}

/*
 MARK: - Configuring the width

 This extension provides a few convenience functions for configuring the
 background view's width. You are encouraged to write your own such functions
 if these don't exactly meet your needs.
 */

extension BaseView {

    /**
     A shortcut for configuring the left and right layout margins. For views that
     have `backgroundView` as a subview of `MessageView`, the background view should
     be pinned to the left and right `layoutMargins` in order for this configuration to work.
     */
    public func configureBackgroundView(sideMargin: CGFloat) {
        layoutMargins.left = sideMargin
        layoutMargins.right = sideMargin
    }

    /**
     A shortcut for adding a width constraint to the `backgroundView`. When calling this
     method, it is important to ensure that the width constraint doesn't conflict with
     other constraints. The CardView.nib and TabView.nib layouts are compatible with
     this method.
     */
    public func configureBackgroundView(width: CGFloat) {
        guard let backgroundView = backgroundView else { return }
        let constraint = NSLayoutConstraint(item: backgroundView, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1, constant: width)
        backgroundView.addConstraint(constraint)
    }
}
//
//  Weak.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 6/4/17.
//  Copyright © 2017 SwiftKick Mobile. All rights reserved.
//

import Foundation

public class Weak<T: AnyObject> {
    public weak var value : T?
    public init(value: T?) {
        self.value = value
    }
}
//
//  SwiftMessagesSegue.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 5/30/18.
//  Copyright © 2018 SwiftKick Mobile. All rights reserved.
//

import UIKit

/**
 `SwiftMessagesSegue` is a configurable subclass of `UIStoryboardSegue` that utilizes
 SwiftMessages to present and dismiss modal view controllers. It performs these transitions by
 becoming your view controller's `transitioningDelegate` and calling SwiftMessage's `show()`
 and `hide()` under the hood.

 To use `SwiftMessagesSegue` with Interface Builder, control-drag a segue, then select
 "swift messages" from the Segue Type dialog. This configures a default transition. There are
 two suggested ways to further configure the transition by setting options on `SwiftMessagesSegue`.
 First, and recommended, you may subclass `SwiftMessagesSegue` and override `init(identifier:source:destination:)`.
 Subclasses will automatically appear in the segue type dialog using an auto-generated name (for example, the
 name for "VeryNiceSegue" would be "very nice"). Second, you may override `prepare(for:sender:)` in the
 presenting view controller and downcast the segue to `SwiftMessagesSegue`.

 `SwiftMessagesSegue` can be used without an associated storyboard or segue by doing the following in
 the presenting view controller.

     let destinationVC = ... // make a reference to a destination view controller
     let segue = SwiftMessagesSegue(identifier: nil, source: self, destination: destinationVC)
     ... // do any configuration here
     segue.perform()

 To dismiss, call the UIKit API on the presenting view controller:

     dismiss(animated: true, completion: nil)

 It is not necessary to retain `segue` because it retains itself until dismissal. However, you can
 retain it if you plan to `perform()` more than once.

 #### Present the controller on top of all controllers

 If you don't know the presenter or you don't want to pass it as a source, like when you
 have a completely separated message controller, you can pass a `WindowViewController`
 as the `source` argument of the segue's initializer.

 By default, the window will be shown in the current window scene at `.normal` window level.
 However, these parameters can be customized by initializing the view controller with a `SwiftMessages.Config` that has the `SwiftMessages.Config.presentationContext` set to either `.window` or `.windowScene`:

 + note: Some additional details:
 1. Your view controller's view will be embedded in a `SwiftMessages.BaseView` in order to
 utilize some SwiftMessages features. This view can be accessed and configured via the
 `SwiftMessagesSegue.messageView` property. For example, you may configure a default drop
 shadow by calling `segue.messageView.configureDropShadow()`.
 2. SwiftMessagesSegue provides static default view controller sizing based on device.
 However, it is recommended that you specify sizing appropriate for your content using
 one of the following methods.
    1. Define sufficient width and height constraints in your view controller.
    2. Set `preferredContentSize` (a.k.a "Use Preferred Explicit Size" in Interface Builder's
       attribute inspector). Zeros are ignored, e.g. `CGSize(width: 0, height: 350)` only
       affects the height.
    3. Add explicit width and/or height constraints to `segue.messageView.backgroundView`.
    Note that `Layout.topMessage` and `Layout.bottomMessage` are always full screen width.
    For other layouts, the there is a maximum 500pt width on iPad (regular horizontal size class)
    at 950 priority, which can be overridden by adding higher-priority constraints.
 
 See the "View Controllers" selection in the Demo app for examples.
 */

open class SwiftMessagesSegue: UIStoryboardSegue {

    /**
     Specifies one of the pre-defined layouts, mirroring a subset of `MessageView.Layout`.
     */
    public enum Layout {

        /// The standard message view layout on top.
        case topMessage

        /// The standard message view layout on bottom.
        case bottomMessage

        /// A floating card-style view with rounded corners on top
        case topCard

        /// A floating tab-style view with rounded corners on bottom
        case topTab

        /// A floating card-style view with rounded corners on bottom
        case bottomCard

        /// A floating tab-style view with rounded corners on top
        case bottomTab

        /// A floating card-style view typically used with `.center` presentation style.
        case centered
    }

    /**
     Specifies how the view controller's view is installed into the
     containing message view.
     */
    public enum Containment {

        /**
         The view controller's view is installed for edge-to-edge display, extending into the safe areas
         to the device edges. This is done by calling `messageView.installContentView(:insets:)`
         See that method's documentation for additional details.
        */
        case content

        /**
         The view controller's view is installed for card-style layouts, inset from the margins
         and avoiding safe areas. This is done by calling `messageView.installBackgroundView(:insets:)`.
         See that method's documentation for details.
        */
        case background

        /**
         The view controller's view is installed for tab-style layouts, inset from the side margins, but extending
         to the device edge on the top or bottom. This is done by calling `messageView.installBackgroundVerticalView(:insets:)`.
         See that method's documentation for details.
         */
        case backgroundVertical
    }

    /// The presentation style to use. See the SwiftMessages.PresentationStyle for details.
    public var presentationStyle: SwiftMessages.PresentationStyle {
        get { return messenger.defaultConfig.presentationStyle }
        set { messenger.defaultConfig.presentationStyle = newValue }
    }

    /// The dim mode to use. See the SwiftMessages.DimMode for details.
    public var dimMode: SwiftMessages.DimMode {
        get { return messenger.defaultConfig.dimMode}
        set { messenger.defaultConfig.dimMode = newValue }
    }
    
    // duration
    public var duration: SwiftMessages.Duration {
        get { return messenger.defaultConfig.duration}
        set { messenger.defaultConfig.duration = newValue }
    }

    /// Specifies whether or not the interactive pan-to-hide gesture is enabled
    /// on the message view. The default value is `true`, but may not be appropriate
    /// for view controllers that use swipe or pan gestures.
    public var interactiveHide: Bool {
        get { return messenger.defaultConfig.interactiveHide }
        set { messenger.defaultConfig.interactiveHide = newValue }
    }

    /// Specifies an optional array of event listeners.
    public var eventListeners: [SwiftMessages.EventListener] {
        get { return messenger.defaultConfig.eventListeners }
        set { messenger.defaultConfig.eventListeners = newValue }
    }

    /**
     Normally, the destination view controller's `modalPresentationStyle` is changed
     to `.custom` in the `perform()` function. Set this property to `false` to prevent it from
     being overridden.
    */
    public var overrideModalPresentationStyle: Bool = true

    /**
     The view that is passed to `SwiftMessages.show(config:view:)` during presentation.
     The view controller's view is installed into `containerView`, which is itself installed
     into `messageView`. `SwiftMessagesSegue` does this installation automatically based on the
     value of the `containment` property. `BaseView` is the parent of `MessageView` and provides a
     number of configuration options that you may use. For example, you may configure a default drop
     shadow by calling `messageView.configureDropShadow()`.
     */
    public var messageView = BaseView()

    /**
     The view controller's view is embedded in `containerView` before being installed into
     `messageView`. This view provides configurable squircle (round) corners (see the parent
     class `CornerRoundingView`).
    */
    public var containerView: CornerRoundingView = CornerRoundingView()

    /**
     Specifies how the view controller's view is installed into the
     containing message view. See `Containment` for details.
     */
    public var containment: Containment = .content

    /**
     Supply an instance of `KeyboardTrackingView` to have the message view avoid the keyboard.
     */
    public var keyboardTrackingView: KeyboardTrackingView? {
        get {
            return messenger.defaultConfig.keyboardTrackingView
        }
        set {
            messenger.defaultConfig.keyboardTrackingView = newValue
        }
    }

    private var messenger = SwiftMessages()
    private var selfRetainer: SwiftMessagesSegue? = nil
    private lazy var hider = { return TransitioningDismisser(segue: self) }()

    private lazy var presenter = {
        return Presenter(config: messenger.defaultConfig, view: messageView, delegate: messenger)
    }()

    override open func perform() {
        (source as? WindowViewController)?.install()
        selfRetainer = self
        if overrideModalPresentationStyle {
            destination.modalPresentationStyle = .custom
        }
        destination.transitioningDelegate = self
        source.present(destination, animated: true, completion: nil)
    }

    override public init(identifier: String?, source: UIViewController, destination: UIViewController) {
        super.init(identifier: identifier, source: source, destination: destination)
        dimMode = .gray(interactive: true)
        messenger.defaultConfig.duration = .forever
    }

    fileprivate let safeAreaWorkaroundViewController = UIViewController()
}

extension SwiftMessagesSegue {
    /// A convenience method for configuring some pre-defined layouts that mirror a subset of `MessageView.Layout`.
    public func configure(layout: Layout) {
        messageView.bounceAnimationOffset = 0
        containment = .content
        containerView.cornerRadius = 0
        containerView.roundsLeadingCorners = false
        messageView.configureDropShadow()
        switch layout {
        case .topMessage:
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)
            messageView.collapseLayoutMarginAdditions = false
            let animation = TopBottomAnimation(style: .top)
            animation.springDamping = 1
            presentationStyle = .custom(animator: animation)
        case .bottomMessage:
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)
            messageView.collapseLayoutMarginAdditions = false
            let animation = TopBottomAnimation(style: .bottom)
            animation.springDamping = 1
            presentationStyle = .custom(animator: animation)
        case .topCard:
            containment = .background
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            presentationStyle = .top
        case .bottomCard:
            containment = .background
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            presentationStyle = .bottom
        case .topTab:
            containment = .backgroundVertical
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 20, left: 10, bottom: 20, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            containerView.roundsLeadingCorners = true
            let animation = TopBottomAnimation(style: .top)
            animation.springDamping = 1
            presentationStyle = .custom(animator: animation)
        case .bottomTab:
            containment = .backgroundVertical
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 20, left: 10, bottom: 20, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            containerView.roundsLeadingCorners = true
            let animation = TopBottomAnimation(style: .bottom)
            animation.springDamping = 1
            presentationStyle = .custom(animator: animation)
        case .centered:
            containment = .background
            messageView.layoutMarginAdditions = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
            messageView.collapseLayoutMarginAdditions = true
            containerView.cornerRadius = 15
            presentationStyle = .center
        }
    }
}

extension SwiftMessagesSegue: UIViewControllerTransitioningDelegate {
    public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        let shower = TransitioningPresenter(segue: self)
        messenger.defaultConfig.eventListeners.append { [unowned self] in
            switch $0 {
            case .didShow:
                shower.completeTransition?(true)
            case .didHide:
                if let completeTransition = self.hider.completeTransition {
                    completeTransition(true)
                } else {
                    // Case where message is internally hidden by SwiftMessages, such as with a
                    // dismiss gesture, rather than by view controller dismissal.
                    source.dismiss(animated: false, completion: nil)
                }
                (source as? WindowViewController)?.uninstall()
                self.selfRetainer = nil
            default: break
            }
        }
        return shower
    }

    public func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        return hider
    }
}

extension SwiftMessagesSegue {
    private class TransitioningPresenter: NSObject, UIViewControllerAnimatedTransitioning {

        fileprivate private(set) var completeTransition: ((Bool) -> Void)?
        private weak var segue: SwiftMessagesSegue?

        fileprivate init(segue: SwiftMessagesSegue) {
            self.segue = segue
        }

        func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
            return segue?.presenter.animator.showDuration ?? 0.5
        }

        func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
            guard let segue = segue,
                let toView = transitionContext.view(forKey: .to) else {
                transitionContext.completeTransition(false)
                return
            }
            if #available(iOS 12, *) {}
            else if #available(iOS 11.0, *) {
                // This works around a bug in iOS 11 where the safe area of `messageView` (
                // and all ancestor views) is not set except on iPhone X. By assigning `messageView`
                // to a view controller, its safe area is set consistently. This bug has been resolved as
                // of Xcode 10 beta 2.
                segue.safeAreaWorkaroundViewController.view = segue.presenter.maskingView
            }
            completeTransition = transitionContext.completeTransition
            let transitionContainer = transitionContext.containerView
            toView.translatesAutoresizingMaskIntoConstraints = false
            segue.containerView.addSubview(toView)
            segue.containerView.topAnchor.constraint(equalTo: toView.topAnchor).isActive = true
            segue.containerView.bottomAnchor.constraint(equalTo: toView.bottomAnchor).isActive = true
            segue.containerView.leadingAnchor.constraint(equalTo: toView.leadingAnchor).isActive = true
            segue.containerView.trailingAnchor.constraint(equalTo: toView.trailingAnchor).isActive = true
            // Install the `toView` into the message view.
            switch segue.containment {
            case .content:
                segue.messageView.installContentView(segue.containerView)
            case .background:
                segue.messageView.installBackgroundView(segue.containerView)
            case .backgroundVertical:
                segue.messageView.installBackgroundVerticalView(segue.containerView)
            }
            let toVC = transitionContext.viewController(forKey: .to)
            if let preferredHeight = toVC?.preferredContentSize.height,
                preferredHeight > 0 {
                segue.containerView.heightAnchor.constraint(equalToConstant: preferredHeight).with(priority: UILayoutPriority(rawValue: 951)).isActive = true
            }
            if let preferredWidth = toVC?.preferredContentSize.width,
                preferredWidth > 0 {
                segue.containerView.widthAnchor.constraint(equalToConstant: preferredWidth).with(priority: UILayoutPriority(rawValue: 951)).isActive = true
            }
            segue.presenter.config.presentationContext = .view(transitionContainer)
            segue.messenger.show(presenter: segue.presenter)
        }
    }
}

extension SwiftMessagesSegue {
    private class TransitioningDismisser: NSObject, UIViewControllerAnimatedTransitioning {

        fileprivate private(set) var completeTransition: ((Bool) -> Void)?
        private weak var segue: SwiftMessagesSegue?

        fileprivate init(segue: SwiftMessagesSegue) {
            self.segue = segue
        }

        func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
            return segue?.presenter.animator.hideDuration ?? 0.5
        }

        func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
            guard let messenger = segue?.messenger else {
                transitionContext.completeTransition(false)
                return
            }
            completeTransition = transitionContext.completeTransition
            messenger.hide()
        }
    }
}
//
//  MessageView.swift
//  SwiftMessages
//
//  Created by Timothy Moose on 7/30/16.
//  Copyright © 2016 SwiftKick Mobile LLC. All rights reserved.
//

import UIKit

/*
 */
open class MessageView: BaseView, Identifiable, AccessibleMessage {
    
    /*
     MARK: - Button tap handler
     */
    
    /// An optional button tap handler. The `button` is automatically
    /// configured to call this tap handler on `.TouchUpInside`.
    open var buttonTapHandler: ((_ button: UIButton) -> Void)?
    
    @objc func buttonTapped(_ button: UIButton) {
        buttonTapHandler?(button)
    }

    /*
     MARK: - Touch handling
     */

    open override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
        // Only accept touches within the background view. Anything outside of the
        // background view's bounds should be transparent and does not need to receive
        // touches. This helps with tap dismissal when using `DimMode.gray` and `DimMode.color`.
        return backgroundView == self
            ? super.point(inside: point, with: event)
            : backgroundView.point(inside: convert(point, to: backgroundView), with: event)
    }

    /*
     MARK: - IB outlets
     */
    
    /// An optional title label.
    @IBOutlet open var titleLabel: UILabel?
    
    /// An optional body text label.
    @IBOutlet open var bodyLabel: UILabel?
    
    /// An optional icon image view.
    @IBOutlet open var iconImageView: UIImageView?
    
    /// An optional icon label (e.g. for emoji character, icon font, etc.).
    @IBOutlet open var iconLabel: UILabel?
    
    /// An optional button. This buttons' `.TouchUpInside` event will automatically
    /// invoke the optional `buttonTapHandler`, but its fine to add other target
    /// action handlers can be added.
    @IBOutlet open var button: UIButton? {
        didSet {
            if let old = oldValue {
                old.removeTarget(self, action: #selector(MessageView.buttonTapped(_:)), for: .touchUpInside)
            }
            if let button = button {
                button.addTarget(self, action: #selector(MessageView.buttonTapped(_:)), for: .touchUpInside)
            }
        }
    }
    
    /*
     MARK: - Identifiable
     */
    
    open var id: String {
        get {
            return customId ?? "MessageView:title=\(String(describing: titleLabel?.text)), body=\(String(describing: bodyLabel?.text))"
        }
        set {
            customId = newValue
        }
    }
    
    private var customId: String?

    /*
     MARK: - AccessibleMessage
     */

    /**
     An optional prefix for the `accessibilityMessage` that can
     be used to further clarify the message for VoiceOver. For example,
     the view's background color or icon might convey that a message is
     a warning, in which case one may specify the value "warning".
     */
    open var accessibilityPrefix: String?

    open var accessibilityMessage: String? {
        #if swift(>=4.1)
        let components = [accessibilityPrefix, titleLabel?.text, bodyLabel?.text].compactMap { $0 }
        #else
        let components = [accessibilityPrefix, titleLabel?.text, bodyLabel?.text].flatMap { $0 }
        #endif
        guard components.count > 0 else { return nil }
        return components.joined(separator: ", ")
    }

    public var accessibilityElement: NSObject? {
        return backgroundView
    }

    open var additionalAccessibilityElements: [NSObject]? {
        var elements: [NSObject] = []
        func getAccessibleSubviews(view: UIView) {
            for subview in view.subviews {
                if subview.isAccessibilityElement {
                    elements.append(subview)
                } else {
                    // Only doing this for non-accessible `subviews`, which avoids
                    // including button labels, etc.
                    getAccessibleSubviews(view: subview)
                }
            }
        }
        getAccessibleSubviews(view: self.backgroundView)
        return elements
    }
}

/*
 MARK: - Creating message views
 
 This extension provides several convenience functions for instantiating
 `MessageView` from the included nib files in a type-safe way. These nib 
 files can be found in the Resources folder and can be drag-and-dropped 
 into a project and modified. You may still use these APIs if you've
 copied the nib files because SwiftMessages looks for them in the main
 bundle first. See `SwiftMessages` for additional nib loading options.
 */

extension MessageView {
    
    /**
     Specifies one of the nib files included in the Resources folders.
     */
    public enum Layout: String {
        
        /**
         The standard message view that stretches across the full width of the
         container view.
         */
        case messageView = "MessageView"
        
        /**
         A floating card-style view with rounded corners.
         */
        case cardView = "CardView"

        /**
         Like `CardView` with one end attached to the super view.
         */
        case tabView = "TabView"

        /**
         A 20pt tall view that can be used to overlay the status bar.
         Note that this layout will automatically grow taller if displayed
         directly under the status bar (see the `ContentInsetting` protocol).
         */
        case statusLine = "StatusLine"

        /**
         A floating card-style view with elements centered and arranged vertically.
         This view is typically used with `.center` presentation style.         
         */
        case centeredView = "CenteredView"
    }
    
    /**
     Loads the nib file associated with the given `Layout` and returns the first
     view found in the nib file with the matching type `T: MessageView`.
     
     - Parameter layout: The `Layout` option to use.
     - Parameter filesOwner: An optional files owner.
     
     - Returns: An instance of generic view type `T: MessageView`.
     */
    public static func viewFromNib<T: MessageView>(layout: Layout, filesOwner: AnyObject = NSNull.init()) -> T {
        return try! SwiftMessages.viewFromNib(named: layout.rawValue)
    }
    
    /**
     Loads the nib file associated with the given `Layout` from
     the given bundle and returns the first view found in the nib
     file with the matching type `T: MessageView`.
     
     - Parameter layout: The `Layout` option to use.
     - Parameter bundle: The name of the bundle containing the nib file.
     - Parameter filesOwner: An optional files owner.
     
     - Returns: An instance of generic view type `T: MessageView`.
     */
    public static func viewFromNib<T: MessageView>(layout: Layout, bundle: Bundle, filesOwner: AnyObject = NSNull.init()) -> T {
        return try! SwiftMessages.viewFromNib(named: layout.rawValue, bundle: bundle, filesOwner: filesOwner)
    }
}

/*
 MARK: - Layout adjustments

 This extension provides a few convenience functions for adjusting the layout.
 */

extension MessageView {
    /**
     Constrains the image view to a specified size. By default, the size of the
     image view is determined by its `intrinsicContentSize`.
     
     - Parameter size: The size to be translated into Auto Layout constraints.
     - Parameter contentMode: The optional content mode to apply.
     */
    public func configureIcon(withSize size: CGSize, contentMode: UIView.ContentMode? = nil) {
        var views: [UIView] = []
        if let iconImageView = iconImageView { views.append(iconImageView) }
        if let iconLabel = iconLabel { views.append(iconLabel) }
        views.forEach {
            let constraints = [$0.heightAnchor.constraint(equalToConstant: size.height),
                               $0.widthAnchor.constraint(equalToConstant: size.width)]
            constraints.forEach { $0.priority = UILayoutPriority(999.0) }
            $0.addConstraints(constraints)
            if let contentMode = contentMode {
                $0.contentMode = contentMode
            }
        }
    }
}

/*
 MARK: - Theming
 
 This extension provides a few convenience functions for setting styles,
 colors and icons. You are encouraged to write your own such functions
 if these don't exactly meet your needs.
 */

extension MessageView {
    
    /**
     A convenience function for setting some pre-defined colors and icons.
     
     - Parameter theme: The theme type to use.
     - Parameter iconStyle: The icon style to use. Defaults to `.Default`.
     */
    public func configureTheme(_ theme: Theme, iconStyle: IconStyle = .default) {
        let iconImage = iconStyle.image(theme: theme)
        let backgroundColor: UIColor
        let foregroundColor: UIColor
        let defaultBackgroundColor: UIColor
        let defaultForegroundColor: UIColor
        switch theme {
        case .info:
            defaultBackgroundColor = UIColor(red: 225.0/255.0, green: 225.0/255.0, blue: 225.0/255.0, alpha: 1.0)
            defaultForegroundColor = UIColor.darkText
        case .success:
            defaultBackgroundColor = UIColor(red: 97.0/255.0, green: 161.0/255.0, blue: 23.0/255.0, alpha: 1.0)
            defaultForegroundColor = UIColor.white
        case .warning:
            defaultBackgroundColor = UIColor(red: 246.0/255.0, green: 197.0/255.0, blue: 44.0/255.0, alpha: 1.0)
            defaultForegroundColor = UIColor.white
        case .error:
            defaultBackgroundColor = UIColor(red: 249.0/255.0, green: 66.0/255.0, blue: 47.0/255.0, alpha: 1.0)
            defaultForegroundColor = UIColor.white
        }
        if #available(iOS 13.0, *) {
            switch theme {
            case .info:
                backgroundColor = UIColor {
                    switch $0.userInterfaceStyle {
                    case .dark, .unspecified: return UIColor(red: 125/255.0, green: 125/255.0, blue: 125/255.0, alpha: 1.0)
                    case .light: fallthrough
                    @unknown default:
                        return defaultBackgroundColor
                    }
                }
                foregroundColor = .label
            case .success:
                backgroundColor = UIColor {
                    switch $0.userInterfaceStyle {
                    case .dark, .unspecified: return UIColor(red: 55/255.0, green: 122/255.0, blue: 0/255.0, alpha: 1.0)
                    case .light: fallthrough
                    @unknown default:
                        return defaultBackgroundColor
                    }
                }
                foregroundColor = .white
            case .warning:
                backgroundColor = UIColor {
                    switch $0.userInterfaceStyle {
                    case .dark, .unspecified: return UIColor(red: 239/255.0, green: 184/255.0, blue: 10/255.0, alpha: 1.0)
                    case .light: fallthrough
                    @unknown default:
                        return defaultBackgroundColor
                    }
                }
                foregroundColor = .white
            case .error:
                backgroundColor = UIColor {
                    switch $0.userInterfaceStyle {
                    case .dark, .unspecified: return UIColor(red: 195/255.0, green: 12/255.0, blue: 12/255.0, alpha: 1.0)
                    case .light: fallthrough
                    @unknown default:
                        return defaultBackgroundColor
                    }
                }
                foregroundColor = .white
            }
        } else {
            backgroundColor = defaultBackgroundColor
            foregroundColor = defaultForegroundColor
        }
        configureTheme(backgroundColor: backgroundColor, foregroundColor: foregroundColor, iconImage: iconImage)
    }
    
    /**
     A convenience function for setting a foreground and background color.
     Note that images will only display the foreground color if they're
     configured with UIImageRenderingMode.AlwaysTemplate.
     
     - Parameter backgroundColor: The background color to use.
     - Parameter foregroundColor: The foreground color to use.
     */
    public func configureTheme(backgroundColor: UIColor, foregroundColor: UIColor, iconImage: UIImage? = nil, iconText: String? = nil) {
        iconImageView?.image = iconImage
        iconLabel?.text = iconText
        iconImageView?.tintColor = foregroundColor
        let backgroundView = self.backgroundView ?? self
        backgroundView.backgroundColor = backgroundColor
        iconLabel?.textColor = foregroundColor
        titleLabel?.textColor = foregroundColor
        bodyLabel?.textColor = foregroundColor
        button?.backgroundColor = foregroundColor
        button?.tintColor = backgroundColor
        button?.contentEdgeInsets = UIEdgeInsets(top: 7.0, left: 7.0, bottom: 7.0, right: 7.0)
        button?.layer.cornerRadius = 5.0
        iconImageView?.isHidden = iconImageView?.image == nil
        iconLabel?.isHidden = iconLabel?.text == nil
    }
}

/*
 MARK: - Configuring the content
 
 This extension provides a few convenience functions for configuring the
 message content. You are encouraged to write your own such functions
 if these don't exactly meet your needs.
 
 SwiftMessages does not try to be clever by adjusting the layout based on 
 what content you configure. All message elements are optional and it is
 up to you to hide or remove elements you don't need. The easiest way to
 remove unwanted elements is to drag-and-drop one of the included nib
 files into your project as a starting point and make changes.
 */

extension MessageView {
    
    /**
     Sets the message body text.
     
     - Parameter body: The message body text to use.
     */
    public func configureContent(body: String) {
        bodyLabel?.text = body
    }
    
    /**
     Sets the message title and body text.
     
     - Parameter title: The message title to use.
     - Parameter body: The message body text to use.
     */
    public func configureContent(title: String, body: String) {
        configureContent(body: body)
        titleLabel?.text = title
    }
    
    /**
     Sets the message title, body text and icon image. Also hides the
     `iconLabel`.
     
     - Parameter title: The message title to use.
     - Parameter body: The message body text to use.
     - Parameter iconImage: The icon image to use.
     */
    public func configureContent(title: String, body: String, iconImage: UIImage) {
        configureContent(title: title, body: body)
        iconImageView?.image = iconImage
        iconImageView?.isHidden = false
        iconLabel?.text = nil
        iconLabel?.isHidden = true
    }
    
    /**
     Sets the message title, body text and icon text (e.g. an emoji).
     Also hides the `iconImageView`.
     
     - Parameter title: The message title to use.
     - Parameter body: The message body text to use.
     - Parameter iconText: The icon text to use (e.g. an emoji).
     */
    public func configureContent(title: String, body: String, iconText: String) {
        configureContent(title: title, body: body)
        iconLabel?.text = iconText
        iconLabel?.isHidden = false
        iconImageView?.isHidden = true
        iconImageView?.image = nil
    }
    
    /**
     Sets all configurable elements.
     
     - Parameter title: The message title to use.
     - Parameter body: The message body text to use.
     - Parameter iconImage: The icon image to use.
     - Parameter iconText: The icon text to use (e.g. an emoji).
     - Parameter buttonImage: The button image to use.
     - Parameter buttonTitle: The button title to use.
     - Parameter buttonTapHandler: The button tap handler block to use.
     */
    public func configureContent(title: String?, body: String?, iconImage: UIImage?, iconText: String?, buttonImage: UIImage?, buttonTitle: String?, buttonTapHandler: ((_ button: UIButton) -> Void)?) {
        titleLabel?.text = title
        bodyLabel?.text = body
        iconImageView?.image = iconImage
        iconLabel?.text = iconText
        button?.setImage(buttonImage, for: .normal)
        button?.setTitle(buttonTitle, for: .normal)
        self.buttonTapHandler = buttonTapHandler
        iconImageView?.isHidden = iconImageView?.image == nil
        iconLabel?.isHidden = iconLabel?.text == nil
    }
}


//
//  MarqueeLabel.swift
//
//  Created by Charles Powell on 8/6/14.
//  Copyright (c) 2015 Charles Powell. All rights reserved.
//

import UIKit
import QuartzCore

@IBDesignable

open class MarqueeLabel: UILabel, CAAnimationDelegate {
    
    /**
     An enum that defines the types of `MarqueeLabel` scrolling
     
     - Left: Scrolls left after the specified delay, and does not return to the original position.
     - LeftRight: Scrolls left first, then back right to the original position.
     - Right: Scrolls right after the specified delay, and does not return to the original position.
     - RightLeft: Scrolls right first, then back left to the original position.
     - Continuous: Continuously scrolls left (with a pause at the original position if animationDelay is set).
     - ContinuousReverse: Continuously scrolls right (with a pause at the original position if animationDelay is set).
     */
    public enum MarqueeType: CaseIterable {
        case left
        case leftRight
        case right
        case rightLeft
        case continuous
        case continuousReverse
    }
    
    //
    // MARK: - Public properties
    //
    
    /**
     Defines the direction and method in which the `MarqueeLabel` instance scrolls.
     `MarqueeLabel` supports six default types of scrolling: `Left`, `LeftRight`, `Right`, `RightLeft`, `Continuous`, and `ContinuousReverse`.
     
     Given the nature of how text direction works, the options for the `type` property require specific text alignments
     and will set the textAlignment property accordingly.
     
     - `LeftRight` and `Left` types are ONLY compatible with a label text alignment of `NSTextAlignment.left`.
     - `RightLeft` and `Right` types are ONLY compatible with a label text alignment of `NSTextAlignment.right`.
     - `Continuous` and `ContinuousReverse` allow the use of `NSTextAlignment.left`, `.right`, or `.center` alignments,
        however the text alignment only has an effect when label text is short enough that scrolling is not required.
        When scrolling, the labels are effectively center-aligned.
     
     Defaults to `Continuous`.
     
     - Note: Note that any `leadingBuffer` value will affect the text alignment location relative to the frame position,
     including  with `.center` alignment, where the center alignment location will be shifted left (for `.continuous`) or
     right (for `.continuousReverse`) by one-half (1/2) the `.leadingBuffer` amount. Use the `.trailingBuffer` property to
     add a buffer between text "loops" without affecting alignment location.
     
     - SeeAlso: textAlignment
     - SeeAlso: leadingBuffer
     */
    open var type: MarqueeType = .continuous {
        didSet {
            if type == oldValue {
                return
            }
            updateAndScroll()
        }
    }
    
    /**
     An optional custom scroll "sequence", defined by an array of `ScrollStep` or `FadeStep` instances. A sequence
     defines a single scroll/animation loop, which will continue to be automatically repeated like the default types.
     
     A `type` value is still required when using a custom sequence. The `type` value defines the `home` and `away`
     values used in the `ScrollStep` instances, and the `type` value determines which way the label will scroll.
     
     When a custom sequence is not supplied, the default sequences are used per the defined `type`.
     
     `ScrollStep` steps are the primary step types, and define the position of the label at a given time in the sequence.
     `FadeStep` steps are secondary steps that define the edge fade state (leading, trailing, or both) around the `ScrollStep`
     steps.
     
     Defaults to nil.
     
     - Attention: Use of the `scrollSequence` property requires understanding of how MarqueeLabel works for effective
     use. As a reference, it is suggested to review the methodology used to build the sequences for the default types.
     
     - SeeAlso: type
     - SeeAlso: ScrollStep
     - SeeAlso: FadeStep
     */
    open var scrollSequence: [MarqueeStep]?

    /**
     Specifies the animation curve used in the scrolling motion of the labels.
     Allowable options:
     
     - `UIViewAnimationOptionCurveEaseInOut`
     - `UIViewAnimationOptionCurveEaseIn`
     - `UIViewAnimationOptionCurveEaseOut`
     - `UIViewAnimationOptionCurveLinear`
     
     Defaults to `UIViewAnimationOptionCurveEaseInOut`.
     */
    open var animationCurve: UIView.AnimationCurve = .linear
    
    /**
     A boolean property that sets whether the `MarqueeLabel` should behave like a normal `UILabel`.
     
     When set to `true` the `MarqueeLabel` will behave and look like a normal `UILabel`, and  will not begin any scrolling animations.
     Changes to this property take effect immediately, removing any in-flight animation as well as any edge fade. Note that `MarqueeLabel`
     will respect the current values of the `lineBreakMode` and `textAlignment`properties while labelized.
     
     To simply prevent automatic scrolling, use the `holdScrolling` property.
     
     Defaults to `false`.
     
     - SeeAlso: holdScrolling
     - SeeAlso: lineBreakMode
     - Note: The label will not automatically scroll when this property is set to `true`.
     - Warning: The UILabel default setting for the `lineBreakMode` property is `NSLineBreakByTruncatingTail`, which truncates
     the text adds an ellipsis glyph (...). Set the `lineBreakMode` property to `NSLineBreakByClipping` in order to avoid the
     ellipsis, especially if using an edge transparency fade.
     */
    open var labelize: Bool = false {
        didSet {
            if labelize != oldValue {
                updateAndScroll()
            }
        }
    }
    
    /**
     A boolean property that sets whether the `MarqueeLabel` should hold (prevent) automatic label scrolling.
     
     When set to `true`, `MarqueeLabel` will not automatically scroll even its text is larger than the specified frame,
     although the specified edge fades will remain.
     
     To set `MarqueeLabel` to act like a normal UILabel, use the `labelize` property.
     
     Defaults to `false`.
     
     - Note: The label will not automatically scroll when this property is set to `true`.
     - SeeAlso: labelize
     */
    open var holdScrolling: Bool = false {
        didSet {
            if holdScrolling != oldValue {
                if oldValue == true && !(awayFromHome || labelize ) && labelShouldScroll() {
                    updateAndScroll()
                }
            }
        }
    }
    
    /**
     A boolean property that sets whether the `MarqueeLabel` should scroll, even if the specificed test string
     can be fully contained within the label frame.
     
     If this property is set to `true`, the `MarqueeLabel` will automatically scroll regardless of text string
     length, although this can still be overridden by the `tapToScroll` and `holdScrolling` properties.
     
     Defaults to `false`.
     
     - Warning: Forced scrolling may have unexpected edge cases or have unusual characteristics compared to the
     'normal' scrolling feature.
     
     - SeeAlso: holdScrolling
     - SeeAlso: tapToScroll
     */
    public var forceScrolling: Bool = false {
        didSet {
            if forceScrolling != oldValue {
                if !(awayFromHome || holdScrolling || tapToScroll ) && labelShouldScroll() {
                    updateAndScroll()
                }
            }
        }
    }
	
    /**
     A boolean property that sets whether the `MarqueeLabel` should only begin a scroll when tapped.
     
     If this property is set to `true`, the `MarqueeLabel` will only begin a scroll animation cycle when tapped. The label will
     not automatically being a scroll. This setting overrides the setting of the `holdScrolling` property.
     
     Defaults to `false`.
     
     - Note: The label will not automatically scroll when this property is set to `false`.
     - SeeAlso: holdScrolling
     */
    open var tapToScroll: Bool = false {
        didSet {
            if tapToScroll != oldValue {
                if tapToScroll {
                    let tapRecognizer = UITapGestureRecognizer(target: self, action: #selector(MarqueeLabel.labelWasTapped(_:)))
                    self.addGestureRecognizer(tapRecognizer)
                    isUserInteractionEnabled = true
                } else {
                    if let recognizer = self.gestureRecognizers!.first as UIGestureRecognizer? {
                        self.removeGestureRecognizer(recognizer)
                    }
                    isUserInteractionEnabled = false
                }
            }
        }
    }
    
    /**
     A read-only boolean property that indicates if the label's scroll animation has been paused.
     
     - SeeAlso: pauseLabel
     - SeeAlso: unpauseLabel
     */
    open var isPaused: Bool {
        return (sublabel.layer.speed == 0.0)
    }
    
    /**
     A boolean property that indicates if the label is currently away from the home location.
     
     The "home" location is the traditional location of `UILabel` text. This property essentially reflects if a scroll animation is underway.
     */
    open var awayFromHome: Bool {
        if let presentationLayer = sublabel.layer.presentation() {
            return !(presentationLayer.position.x == homeLabelFrame.origin.x)
        }
        
        return false
    }
    
    /**
     An optional CGFloat computed value that provides the current scroll animation position, as a value between
     0.0 and 1.0. A value of 0.0 indicates the label is "at home" (`awayFromHome` will be false). A value
     of 1.0 indicates the label is at the "away" position (and `awayFromHome` will be true).
     
     Will return nil when the label presentation layer is nil.
     
     - Note: For `leftRight` and `rightLeft` type labels this value will increase and reach 1.0 when the label animation reaches the
     maximum displacement, as the left or right edge of the label (respectively) is shown. As the scroll reverses,
     the value will decrease back to 0.0.
     
     - Note: For `continuous` and`continuousReverse` type labels, this value will increase from 0.0 and reach 1.0 just as the
     label loops around and comes to a stop at the original home position. When that position is reached, the value will
     jump from 1.0 directly to 0.0 and begin to increase from 0.0 again.
     */
    open var animationPosition: CGFloat? {
        guard let presentationLayer = sublabel.layer.presentation() else {
            return nil
        }
        
        // No dividing by zero!
        if awayOffset == 0.0 {
            return 0.0
        }
        
        let progressFraction = abs((presentationLayer.position.x - homeLabelFrame.origin.x) / awayOffset)
        return progressFraction
    }
    
    /**
     The `MarqueeLabel` scrolling speed may be defined by one of two ways:
     - Rate(CGFloat): The speed is defined by a rate of motion, in units of points per second.
     - Duration(CGFloat): The speed is defined by the time to complete a scrolling animation cycle, in units of seconds.
     
     Each case takes an associated `CGFloat` value, which is the rate/duration desired.
     */
    public enum SpeedLimit {
        case rate(CGFloat)
        case duration(CGFloat)
        
        var value: CGFloat {
            switch self {
            case .rate(let rate):
                return rate
            case .duration(let duration):
                return duration
            }
        }
    }
    
    /**
     Defines the speed of the `MarqueeLabel` scrolling animation.
     
     The speed is set by specifying a case of the `SpeedLimit` enum along with an associated value.
     
     - SeeAlso: SpeedLimit
     */
    open var speed: SpeedLimit = .duration(7.0) {
        didSet {
            switch (speed, oldValue) {
            case (.rate(let a), .rate(let b)) where a == b:
                return
            case (.duration(let a), .duration(let b)) where a == b:
                return
            default:
                updateAndScroll()
            }
        }
    }
    
    @available(*, deprecated, message: "Use speed property instead")
    open var scrollDuration: CGFloat {
        get {
            switch speed {
            case .duration(let duration): return duration
            case .rate(_): return 0.0
            }
        }
        set {
            speed = .duration(newValue)
        }
    }
    
    @available(*, deprecated, message : "Use speed property instead")
    open var scrollRate: CGFloat {
        get {
            switch speed {
            case .duration(_): return 0.0
            case .rate(let rate): return rate
            }
        }
        set {
            speed = .rate(newValue)
        }
    }

    
    /**
     A buffer (offset) between the leading edge of the label text and the label frame.
     
     This property adds additional space between the leading edge of the label text and the label frame. The
     leading edge is the edge of the label text facing the direction of scroll (i.e. the edge that animates
     offscreen first during scrolling).
     
     Defaults to `0`.
     
     - Note: The value set to this property affects label positioning at all times (including when `labelize` is set to `true`),
     including when the text string length is short enough that the label does not need to scroll.
     - Note: For Continuous-type labels, the smallest value of `leadingBuffer`, `trailingBuffer`, and `fadeLength`
     is used as spacing between the two label instances. Zero is an allowable value for all three properties.
     
     - SeeAlso: trailingBuffer
     */
    open var leadingBuffer: CGFloat = 0.0 {
        didSet {
            if leadingBuffer != oldValue {
                updateAndScroll()
            }
        }
    }
    
    /**
     A buffer (offset) between the trailing edge of the label text and the label frame.
     
     This property adds additional space (buffer) between the trailing edge of the label text and the label frame. The
     trailing edge is the edge of the label text facing away from the direction of scroll (i.e. the edge that animates
     offscreen last during scrolling).
     
     Defaults to `0`.
     
     - Note: The value set to this property has no effect when the `labelize` property is set to `true`.
     
     - Note: For Continuous-type labels, the smallest value of `leadingBuffer`, `trailingBuffer`, and `fadeLength`
     is used as spacing between the two label instances. Zero is an allowable value for all three properties.
     
     - SeeAlso: leadingBuffer
     */
    open var trailingBuffer: CGFloat = 0.0 {
        didSet {
            if trailingBuffer != oldValue {
                updateAndScroll()
            }
        }
    }
    
    /**
     The length of transparency fade at the left and right edges of the frame.
     
     This propery sets the size (in points) of the view edge transparency fades on the left and right edges of a `MarqueeLabel`. The
     transparency fades from an alpha of 1.0 (fully visible) to 0.0 (fully transparent) over this distance. Values set to this property
     will be sanitized to prevent a fade length greater than 1/2 of the frame width.
     
     Defaults to `0`.
     */
    open var fadeLength: CGFloat = 0.0 {
        didSet {
            if fadeLength != oldValue {
                applyGradientMask(fadeLength, animated: true)
                updateAndScroll()
            }
        }
    }
    
    
    /**
     The length of delay in seconds that the label pauses at the completion of a scroll.
     */
    open var animationDelay: CGFloat = 1.0
    
    
    /** The read-only/computed duration of the scroll animation (not including delay).
     
     The value of this property is calculated from the value set to the `speed` property. If a duration-type speed is
     used to set the label animation speed, `animationDuration` will be equivalent to that value.
     */
    public var animationDuration: CGFloat {
        switch self.speed {
        case .rate(let rate):
            return CGFloat(abs(self.awayOffset) / rate)
        case .duration(let duration):
            return duration
        }
    }
    
    //
    // MARK: - Class Functions and Helpers
    //
    
    /**
     Convenience method to restart all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
    
     - Parameter controller: The view controller for which to restart all `MarqueeLabel` instances.
    
     - Warning: View controllers that appear with animation (such as from underneath a modal-style controller) can cause some `MarqueeLabel` text
     position "jumping" when this method is used in `viewDidAppear` if scroll animations are already underway. Use this method inside `viewWillAppear:`
     instead to avoid this problem.
    
     - Warning: This method may not function properly if passed the parent view controller when using view controller containment.
    
     - SeeAlso: restartLabel
     - SeeAlso: controllerViewDidAppear:
     - SeeAlso: controllerViewWillAppear:
     */
    open class func restartLabelsOfController(_ controller: UIViewController) {
        MarqueeLabel.notifyController(controller, message: .Restart)
    }
    
    /**
     Convenience method to restart all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
     
     Alternative to `restartLabelsOfController`. This method is retained for backwards compatibility and future enhancements.
     
     - Parameter controller: The view controller that will appear.
     - SeeAlso: restartLabel
     - SeeAlso: controllerViewDidAppear
     */
    open class func controllerViewWillAppear(_ controller: UIViewController) {
        MarqueeLabel.restartLabelsOfController(controller)
    }
    
    /**
     Convenience method to restart all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
     
     Alternative to `restartLabelsOfController`. This method is retained for backwards compatibility and future enhancements.
     
     - Parameter controller: The view controller that did appear.
     - SeeAlso: restartLabel
     - SeeAlso: controllerViewWillAppear
     */
    open class func controllerViewDidAppear(_ controller: UIViewController) {
        MarqueeLabel.restartLabelsOfController(controller)
    }
    
    /**
     Labelizes all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
    
     The `labelize` property of all recognized `MarqueeLabel` instances will be set to `true`.
     
     - Parameter controller: The view controller for which all `MarqueeLabel` instances should be labelized.
     - SeeAlso: labelize
     */
    open class func controllerLabelsLabelize(_ controller: UIViewController) {
        MarqueeLabel.notifyController(controller, message: .Labelize)
    }
    
    /**
     De-labelizes all `MarqueeLabel` instances that have the specified view controller in their next responder chain.
     
     The `labelize` property of all recognized `MarqueeLabel` instances will be set to `false`.
     
     - Parameter controller: The view controller for which all `MarqueeLabel` instances should be de-labelized.
     - SeeAlso: labelize
     */
    open class func controllerLabelsAnimate(_ controller: UIViewController) {
        MarqueeLabel.notifyController(controller, message: .Animate)
    }

    
    //
    // MARK: - Initialization
    //
    
    /**
     Returns a newly initialized `MarqueeLabel` instance with the specified scroll rate and edge transparency fade length.
    
     - Parameter frame: A rectangle specifying the initial location and size of the view in its superview's coordinates. Text (for the given font, font size, etc.) that does not fit in this frame will automatically scroll.
     - Parameter pixelsPerSec: A rate of scroll for the label scroll animation. Must be non-zero. Note that this will be the peak (mid-transition) rate for ease-type animation.
     - Parameter fadeLength: A length of transparency fade at the left and right edges of the `MarqueeLabel` instance's frame.
     - Returns: An initialized `MarqueeLabel` object or nil if the object couldn't be created.
     - SeeAlso: fadeLength
     */
    public init(frame: CGRect, rate: CGFloat, fadeLength fade: CGFloat) {
        speed = .rate(rate)
        fadeLength = CGFloat(min(fade, frame.size.width/2.0))
        super.init(frame: frame)
        setup()
    }
    
    /**
     Returns a newly initialized `MarqueeLabel` instance with the specified scroll rate and edge transparency fade length.
     
     - Parameter frame: A rectangle specifying the initial location and size of the view in its superview's coordinates. Text (for the given font, font size, etc.) that does not fit in this frame will automatically scroll.
     - Parameter scrollDuration: A scroll duration the label scroll animation. Must be non-zero. This will be the duration that the animation takes for one-half of the scroll cycle in the case of left-right and right-left marquee types, and for one loop of a continuous marquee type.
     - Parameter fadeLength: A length of transparency fade at the left and right edges of the `MarqueeLabel` instance's frame.
     - Returns: An initialized `MarqueeLabel` object or nil if the object couldn't be created.
     - SeeAlso: fadeLength
     */
    public init(frame: CGRect, duration: CGFloat, fadeLength fade: CGFloat) {
        speed = .duration(duration)
        fadeLength = CGFloat(min(fade, frame.size.width/2.0))
        super.init(frame: frame)
        setup()
    }
    
    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    /**
     Returns a newly initialized `MarqueeLabel` instance.
     
     The default scroll duration of 7.0 seconds and fade length of 0.0 are used.
     
     - Parameter frame: A rectangle specifying the initial location and size of the view in its superview's coordinates. Text (for the given font, font size, etc.) that does not fit in this frame will automatically scroll.
     - Returns: An initialized `MarqueeLabel` object or nil if the object couldn't be created.
    */
    convenience public override init(frame: CGRect) {
        self.init(frame: frame, duration:7.0, fadeLength:0.0)
    }
    
    private func setup() {
        // Create sublabel
        sublabel = UILabel(frame: self.bounds)
        sublabel.tag = 700
        sublabel.layer.anchorPoint = CGPoint.zero

        // Add sublabel
        addSubview(sublabel)
        
        // Configure self
        super.clipsToBounds = true
        super.numberOfLines = 1
        
        // Add notification observers
        // Custom class notifications
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.restartForViewController(_:)), name: NSNotification.Name(rawValue: MarqueeKeys.Restart.rawValue), object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.labelizeForController(_:)), name: NSNotification.Name(rawValue: MarqueeKeys.Labelize.rawValue), object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.animateForController(_:)), name: NSNotification.Name(rawValue: MarqueeKeys.Animate.rawValue), object: nil)
        // UIApplication state notifications
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.restartLabel), name: UIApplication.didBecomeActiveNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.shutdownLabel), name: UIApplication.didEnterBackgroundNotification, object: nil)
    }
    
    override open func awakeFromNib() {
        super.awakeFromNib()
        forwardPropertiesToSublabel()
    }
    
    @available(iOS 8.0, *)
    override open func prepareForInterfaceBuilder() {
        super.prepareForInterfaceBuilder()
        forwardPropertiesToSublabel()
    }
    
    private func forwardPropertiesToSublabel() {
        /*
        Note that this method is currently ONLY called from awakeFromNib, i.e. when
        text properties are set via a Storyboard. As the Storyboard/IB doesn't currently
        support attributed strings, there's no need to "forward" the super attributedString value.
        */
        
        // Since we're a UILabel, we actually do implement all of UILabel's properties.
        // We don't care about these values, we just want to forward them on to our sublabel.
        let properties = ["baselineAdjustment", "enabled", "highlighted", "highlightedTextColor",
                          "minimumFontSize", "shadowOffset", "textAlignment",
                          "userInteractionEnabled", "adjustsFontSizeToFitWidth", "minimumScaleFactor",
                          "lineBreakMode", "numberOfLines", "contentMode"]
        
        // Iterate through properties
        sublabel.text = super.text
        sublabel.font = super.font
        sublabel.textColor = super.textColor
        sublabel.backgroundColor = super.backgroundColor ?? UIColor.clear
        sublabel.shadowColor = super.shadowColor
        sublabel.shadowOffset = super.shadowOffset
        for prop in properties {
            let value = super.value(forKey: prop)
            sublabel.setValue(value, forKeyPath: prop)
        }
    }
    
    //
    // MARK: - MarqueeLabel Heavy Lifting
    //

    override open func layoutSubviews() {
        super.layoutSubviews()
        
        updateAndScroll()
    }

    override open func willMove(toWindow newWindow: UIWindow?) {
        if newWindow == nil {
            shutdownLabel()
        }
    }
    
    override open func didMoveToWindow() {
        if self.window == nil {
            shutdownLabel()
        } else {
            updateAndScroll()
        }
    }
    
    private func updateAndScroll() {
        // Do not automatically begin scroll if tapToScroll is true
        updateAndScroll(overrideHold: false)
    }
    
    private func updateAndScroll(overrideHold: Bool) {
        // Check if scrolling can occur
        if !labelReadyForScroll() {
            return
        }
        
        // Calculate expected size
        let expectedLabelSize = sublabel.desiredSize()
        
        // Invalidate intrinsic size
        invalidateIntrinsicContentSize()
        
        // Move label to home
        returnLabelToHome()
        
        // Check if label should scroll
        // Note that the holdScrolling propery does not affect this
        if !labelShouldScroll() {
            // Set text alignment and break mode to act like a normal label
            sublabel.textAlignment = super.textAlignment
            sublabel.lineBreakMode = super.lineBreakMode
            sublabel.adjustsFontSizeToFitWidth = super.adjustsFontSizeToFitWidth
            sublabel.minimumScaleFactor = super.minimumScaleFactor
            
            let labelFrame: CGRect
            switch type {
            case .continuousReverse, .rightLeft:
                labelFrame = bounds.divided(atDistance: leadingBuffer, from: CGRectEdge.maxXEdge).remainder.integral
            default:
                labelFrame = CGRect(x: leadingBuffer, y: 0.0, width: bounds.size.width - leadingBuffer, height: bounds.size.height).integral
            }
            
            homeLabelFrame = labelFrame
            awayOffset = 0.0
            
            // Remove any additional sublabels (for continuous types)
            repliLayer?.instanceCount = 1

            // Set the sublabel frame to calculated labelFrame
            sublabel.frame = labelFrame
            
            // Remove fade, as by definition none is needed in this case
            removeGradientMask()
            
            return
        }
        
        // Label DOES need to scroll
        
        // Reset font scaling to off for scrolling
        sublabel.adjustsFontSizeToFitWidth = false
        sublabel.minimumScaleFactor = 0.0
        
        // Spacing between primary and second sublabel must be at least equal to leadingBuffer, and at least equal to the fadeLength
        let minTrailing = minimumTrailingDistance
        
        // Determine positions and generate scroll steps
        let sequence: [MarqueeStep]
        
        switch type {
        case .continuous, .continuousReverse:
            if type == .continuous {
                homeLabelFrame = CGRect(x: leadingBuffer, y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral
                awayOffset = -(homeLabelFrame.size.width + minTrailing)
            } else { // .ContinuousReverse
                homeLabelFrame = CGRect(x: bounds.size.width - (expectedLabelSize.width + leadingBuffer), y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral
                awayOffset = (homeLabelFrame.size.width + minTrailing)
            }
            
            // Find when the lead label will be totally offscreen
            let offsetDistance = awayOffset
            let offscreenAmount = homeLabelFrame.size.width
            let startFadeFraction = abs(offscreenAmount / offsetDistance)
            // Find when the animation will hit that point
            let startFadeTimeFraction = timingFunctionForAnimationCurve(animationCurve).durationPercentageForPositionPercentage(startFadeFraction, duration: (animationDelay + animationDuration))
            let startFadeTime = startFadeTimeFraction * animationDuration
            
            sequence = scrollSequence ?? [
                ScrollStep(timeStep: 0.0, position: .home, edgeFades: .trailing),                   // Starting point, at home, with trailing fade
                ScrollStep(timeStep: animationDelay, position: .home, edgeFades: .trailing),        // Delay at home, maintaining fade state
                FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                          // 0.2 sec after scroll start, fade leading edge in as well
                FadeStep(timeStep: (startFadeTime - animationDuration),                             // Maintain fade state until just before reaching end of scroll animation
                         edgeFades: [.leading, .trailing]),
                ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,             // Ending point (back at home), with animationCurve transition, with trailing fade
                           position: .away, edgeFades: .trailing)
            ]
            
            // Set frame and text
            sublabel.frame = homeLabelFrame
            
            // Configure replication
            // Determine replication count required
            let fitFactor: CGFloat = bounds.size.width/(expectedLabelSize.width + leadingBuffer)
            let repliCount = 1 + Int(ceil(fitFactor))
            repliLayer?.instanceCount = repliCount
            repliLayer?.instanceTransform = CATransform3DMakeTranslation(-awayOffset, 0.0, 0.0)
            
        case .leftRight, .left, .rightLeft, .right:
            if type == .leftRight || type == .left {
                homeLabelFrame = CGRect(x: leadingBuffer, y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral
                awayOffset = bounds.size.width - (expectedLabelSize.width + leadingBuffer + trailingBuffer)
                // Enforce text alignment for this type
                sublabel.textAlignment = NSTextAlignment.left
            } else {
                homeLabelFrame = CGRect(x: bounds.size.width - (expectedLabelSize.width + leadingBuffer), y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral
                awayOffset = (expectedLabelSize.width + trailingBuffer + leadingBuffer) - bounds.size.width
                // Enforce text alignment for this type
                sublabel.textAlignment = NSTextAlignment.right
            }
            // Set frame and text
            sublabel.frame = homeLabelFrame
            
            // Remove any replication
            repliLayer?.instanceCount = 1

            if type == .leftRight || type == .rightLeft {
                sequence = scrollSequence ?? [
                    ScrollStep(timeStep: 0.0, position: .home, edgeFades: .trailing),               // Starting point, at home, with trailing fade
                    ScrollStep(timeStep: animationDelay, position: .home, edgeFades: .trailing),    // Delay at home, maintaining fade state
                    FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                      // 0.2 sec after delay ends, fade leading edge in as well
                    FadeStep(timeStep: -0.2, edgeFades: [.leading, .trailing]),                     // Maintain fade state until 0.2 sec before reaching away position
                    ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,         // Away position, using animationCurve transition, with only leading edge faded in
                        position: .away, edgeFades: .leading),
                    ScrollStep(timeStep: animationDelay, position: .away, edgeFades: .leading),     // Delay at away, maintaining fade state (leading only)
                    FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                      // 0.2 sec after delay ends, fade trailing edge back in as well
                    FadeStep(timeStep: -0.2, edgeFades: [.leading, .trailing]),                     // Maintain fade state until 0.2 sec before reaching home position
                    ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,         // Ending point, back at home, with only trailing fade
                        position: .home, edgeFades: .trailing)
                ]
            } else { // .left or .right
                sequence = scrollSequence ?? [
                    ScrollStep(timeStep: 0.0, position: .home, edgeFades: .trailing),               // Starting point, at home, with trailing fade
                    ScrollStep(timeStep: animationDelay, position: .home, edgeFades: .trailing),    // Delay at home, maintaining fade state
                    FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                      // 0.2 sec after delay ends, fade leading edge in as well
                    FadeStep(timeStep: -0.2, edgeFades: [.leading, .trailing]),                     // Maintain fade state until 0.2 sec before reaching away position
                    ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,         // Away position, using animationCurve transition, with only leading edge faded in
                        position: .away, edgeFades: .leading),
                    ScrollStep(timeStep: animationDelay, position: .away, edgeFades: .leading),     // "Delay" at away, maintaining fade state
                ]
            }
        }
        
        
        
        // Configure gradient for current condition
        applyGradientMask(fadeLength, animated: !self.labelize)
        
        if overrideHold || (!holdScrolling && !overrideHold) {
            beginScroll(sequence)
        }
    }
    
    override open func sizeThatFits(_ size: CGSize) -> CGSize {
        return sizeThatFits(size, withBuffers: true)
    }
    
    open func sizeThatFits(_ size: CGSize, withBuffers: Bool) -> CGSize {
        var fitSize = sublabel.sizeThatFits(size)
        if withBuffers {
            fitSize.width += leadingBuffer
        }
        return fitSize
    }
    
    /**
     Returns the unconstrained size of the specified label text (for a single line).
    */
    open func textLayoutSize() -> CGSize {
        return sublabel.desiredSize()
    }
    
    //
    // MARK: - Animation Handling
    //
    
    open func labelShouldScroll() -> Bool {
        // Check for nil string
        guard sublabel.text != nil else {
            return false
        }
        
        // Check for empty string
        guard !sublabel.text!.isEmpty else {
            return false
        }
        
        var labelTooLarge = false
        if !super.adjustsFontSizeToFitWidth {
            // Usual logic to check if the label string fits
            labelTooLarge = (sublabel.desiredSize().width + leadingBuffer) > self.bounds.size.width + CGFloat.ulpOfOne
        } else {
            // Logic with auto-scale support
            // Create mutable attributed string to modify font sizes in-situ
            let resizedString = NSMutableAttributedString.init(attributedString: sublabel.attributedText!)
            resizedString.beginEditing()
            // Enumerate all font attributes of attributed string
            resizedString.enumerateAttribute(.font, in: NSRange(0..<sublabel.attributedText!.length)) { val, rng, stop in
                if let originalFont = val as? UIFont {
                    // Calculate minimum-factor font size
                    let resizedFontSize = originalFont.pointSize * super.minimumScaleFactor
                    // Create and apply new font attribute to string
                    if let resizedFont = UIFont.init(name: originalFont.fontName, size: resizedFontSize) {
                        resizedString.addAttribute(.font, value: resizedFont, range: rng)
                    }
                }
            }
            resizedString.endEditing()
            
            // Get new expected minimum size
            let expectedMinimumTextSize = resizedString.size()
            
            // If even after shrinking it's too wide, consider the label too large and in need of scrolling
            labelTooLarge = self.bounds.size.width < ceil(expectedMinimumTextSize.width) + CGFloat.ulpOfOne
            
            // Set scale factor on sublabel dependent on result, back to 1.0 if too big to prevent
            // sublabel from shrinking AND scrolling
            sublabel.minimumScaleFactor = labelTooLarge ? 1.0 : super.minimumScaleFactor
        }

        let animationHasDuration = speed.value > 0.0
        return (!labelize && (forceScrolling || labelTooLarge) && animationHasDuration)
    }
    
    private func labelReadyForScroll() -> Bool {
        // Check if we have a superview
        if superview == nil {
            return false
        }
        
        // Check if we are attached to a window
        if window == nil {
            return false
        }
        
        // Check if our view controller is ready
        let viewController = firstAvailableViewController()
        if viewController != nil {
            if !viewController!.isViewLoaded {
                return false
            }
        }
        
        return true
    }
    
    private func returnLabelToHome() {
        // Store if label is away from home at time of call
        let away = awayFromHome
        
        // Remove any gradient animation
        maskLayer?.removeAllAnimations()
        
        // Remove all sublabel position animations
        sublabel.layer.removeAllAnimations()
        
        // Fire completion block if appropriate
        if away {
            // If label was away when this was called, animation did NOT finish
            scrollCompletionBlock?(!away)
        }
        
        // Remove completion block
        scrollCompletionBlock = nil
    }
    
    private func beginScroll(_ sequence: [MarqueeStep]) {
        let scroller = generateScrollAnimation(sequence)
        let fader = generateGradientAnimation(sequence, totalDuration: scroller.duration)
        
        scroll(scroller, fader: fader)
    }
    
    private func scroll(_ scroller: MLAnimation, fader: MLAnimation?) {
        // Check for conditions which would prevent scrolling
        if !labelReadyForScroll() {
            return
        }
        // Convert fader to var
        var fader = fader
        
        // Call pre-animation hook
        labelWillBeginScroll()
        
        // Start animation transactions
        CATransaction.begin()
        CATransaction.setAnimationDuration(TimeInterval(scroller.duration))
        
        // Create gradient animation, if needed
        let gradientAnimation: CAKeyframeAnimation?
        // Check for IBDesignable
        #if !TARGET_INTERFACE_BUILDER
            if fadeLength > 0.0 {
                // Remove any setup animation, but apply final values
                if let setupAnim = maskLayer?.animation(forKey: "setupFade") as? CABasicAnimation, let finalColors = setupAnim.toValue as? [CGColor] {
                    maskLayer?.colors = finalColors
                }
                maskLayer?.removeAnimation(forKey: "setupFade")
                
                // Generate animation if needed
                if let previousAnimation = fader?.anim {
                    gradientAnimation = previousAnimation
                } else {
                    gradientAnimation = nil
                }
                
                // Apply fade animation
                maskLayer?.add(gradientAnimation!, forKey: "gradient")
            } else {
                // No animation needed
                fader = nil
            }
        #else
            fader = nil
        #endif

        scrollCompletionBlock = { [weak self] (finished: Bool) in
            guard self != nil else {
                return
            }
            
            // Call returned home function
            self!.labelReturnedToHome(finished)
            
            // Check to ensure that:
            
            // 1) The instance is still attached to a window - this completion block is called for
            //    many reasons, including if the animation is removed due to the view being removed
            //    from the UIWindow (typically when the view controller is no longer the "top" view)
            guard self!.window != nil else {
                return
            }
            // 2) We don't double fire if an animation already exists
            guard self!.sublabel.layer.animation(forKey: "position") == nil else {
                return
            }
            // 3) We don't start automatically if the animation was unexpectedly interrupted
            guard finished else {
                // Do not continue into the next loop
                return
            }
            // 4) A completion block still exists for the NEXT loop. A notable case here is if
            // returnLabelToHome() was called during a subclass's labelReturnToHome() function
            guard self!.scrollCompletionBlock != nil else {
                return
            }
            
            // Begin again, if conditions met
            if self!.labelShouldScroll() && !self!.tapToScroll && !self!.holdScrolling {
                // Perform completion callback
                self!.scroll(scroller, fader: fader)
            }
        }
        
        // Perform scroll animation
        scroller.anim.setValue(true, forKey: MarqueeKeys.CompletionClosure.rawValue)
        scroller.anim.delegate = self
        if type == .left || type == .right {
            // Make it stay at away permanently
            scroller.anim.isRemovedOnCompletion = false
            scroller.anim.fillMode = .forwards
        }
        sublabel.layer.add(scroller.anim, forKey: "position")
        
        CATransaction.commit()
    }
    
    private func generateScrollAnimation(_ sequence: [MarqueeStep]) -> MLAnimation {
        // Create scroller, which defines the animation to perform
        let homeOrigin = homeLabelFrame.origin
        let awayOrigin = offsetCGPoint(homeLabelFrame.origin, offset: awayOffset)
        
        let scrollSteps = sequence.filter({ $0 is ScrollStep }) as! [ScrollStep]
        let totalDuration = scrollSteps.reduce(0.0) { $0 + $1.timeStep }
        
        // Build scroll data
        var totalTime: CGFloat = 0.0
        var scrollKeyTimes = [NSNumber]()
        var scrollKeyValues = [NSValue]()
        var scrollTimingFunctions = [CAMediaTimingFunction]()
        
        for (offset, step) in scrollSteps.enumerated() {
            // Scroll Times
            totalTime += step.timeStep
            scrollKeyTimes.append(NSNumber(value:Float(totalTime/totalDuration)))
            
            // Scroll Values
            let scrollPosition: CGPoint
            switch step.position {
            case .home:
                scrollPosition = homeOrigin
            case .away:
                scrollPosition = awayOrigin
            case .partial(let frac):
                scrollPosition = offsetCGPoint(homeOrigin, offset: awayOffset*frac)
            }
            scrollKeyValues.append(NSValue(cgPoint:scrollPosition))
            
            // Scroll Timing Functions
            // Only need n-1 timing functions, so discard the first value as it's unused
            if offset == 0 { continue }
            scrollTimingFunctions.append(timingFunctionForAnimationCurve(step.timingFunction))
        }
        
        // Create animation
        let animation = CAKeyframeAnimation(keyPath: "position")
        // Set values
        animation.keyTimes = scrollKeyTimes
        animation.values = scrollKeyValues
        animation.timingFunctions = scrollTimingFunctions
        
        return (anim: animation, duration: totalDuration)
    }
    
    private func generateGradientAnimation(_ sequence: [MarqueeStep], totalDuration: CGFloat) -> MLAnimation {
        // Setup
        var totalTime: CGFloat = 0.0
        var stepTime: CGFloat = 0.0
        var fadeKeyValues = [[CGColor]]()
        var fadeKeyTimes = [NSNumber]()
        var fadeTimingFunctions = [CAMediaTimingFunction]()
        let transp = UIColor.clear.cgColor
        let opaque = UIColor.black.cgColor
        
        // Filter to get only scroll steps and valid precedent/subsequent fade steps
        let fadeSteps = sequence.enumerated().filter { (arg: (offset: Int, element: MarqueeStep)) -> Bool in
            let (offset, element) = arg
            
            // Include all Scroll Steps
            if element is ScrollStep { return true }
            
            // Include all Fade Steps that have a directly preceding or subsequent Scroll Step
            // Exception: Fade Step cannot be first step
            if offset == 0 { return false }
            
            // Subsequent step if 1) positive/zero time step and 2) follows a Scroll Step
            let subsequent = element.timeStep >= 0 && (sequence[max(0, offset - 1)] is ScrollStep)
            // Precedent step if 1) negative time step and 2) precedes a Scroll Step
            let precedent = element.timeStep < 0 && (sequence[min(sequence.count - 1, offset + 1)] is ScrollStep)
            
            return (precedent || subsequent)
        }
        
        for (offset, step) in fadeSteps {
            // Fade times
            if step is ScrollStep {
                totalTime += step.timeStep
                stepTime = totalTime
            } else {
                if step.timeStep >= 0 {
                    // Is a Subsequent
                    stepTime = totalTime + step.timeStep
                } else {
                    // Is a Precedent, grab next step
                    stepTime = totalTime + fadeSteps[offset + 1].element.timeStep + step.timeStep
                }
            }
            fadeKeyTimes.append(NSNumber(value:Float(stepTime/totalDuration)))
            
            // Fade Values
            let values: [CGColor]
            let leading = step.edgeFades.contains(.leading) ? transp : opaque
            let trailing = step.edgeFades.contains(.trailing) ? transp : opaque
            switch type {
            case .leftRight, .left, .continuous:
                values = [leading, opaque, opaque, trailing]
            case .rightLeft, .right, .continuousReverse:
                values = [trailing, opaque, opaque, leading]
            }
            fadeKeyValues.append(values)
            
            // Fade Timing Function
            // Only need n-1 timing functions, so discard the first value as it's unused
            if offset == 0 { continue }
            fadeTimingFunctions.append(timingFunctionForAnimationCurve(step.timingFunction))
        }
        
        // Create new animation
        let animation = CAKeyframeAnimation(keyPath: "colors")
        
        animation.values = fadeKeyValues
        animation.keyTimes = fadeKeyTimes
        animation.timingFunctions = fadeTimingFunctions

        return (anim: animation, duration: max(totalTime, totalDuration))
    }
    
    private func applyGradientMask(_ fadeLength: CGFloat, animated: Bool, firstStep: MarqueeStep? = nil) {
        // Remove any in-flight animations
        maskLayer?.removeAllAnimations()
        
        // Check for zero-length fade
        if fadeLength <= 0.0 {
            removeGradientMask()
            return
        }
        
        // Configure gradient mask without implicit animations
        CATransaction.begin()
        CATransaction.setDisableActions(true)
        
        // Determine if gradient mask needs to be created
        let gradientMask: CAGradientLayer
        if let currentMask = self.maskLayer {
            // Mask layer already configured
            gradientMask = currentMask
        } else {
            // No mask exists, create new mask
            gradientMask = CAGradientLayer()
            gradientMask.shouldRasterize = true
            gradientMask.rasterizationScale = UIScreen.main.scale
            gradientMask.startPoint = CGPoint(x:0.0, y:0.5)
            gradientMask.endPoint = CGPoint(x:1.0, y:0.5)
        }
        
        // Check if there is a mask to layer size mismatch
        if gradientMask.bounds != self.layer.bounds {
            // Adjust stops based on fade length
            let leftFadeStop = fadeLength/self.bounds.size.width
            let rightFadeStop = 1.0 - fadeLength/self.bounds.size.width
            gradientMask.locations = [0.0, leftFadeStop, rightFadeStop, 1.0].map { NSNumber(value: Float($0)) }
        }
        
        gradientMask.bounds = self.layer.bounds
        gradientMask.position = CGPoint(x:self.bounds.midX, y:self.bounds.midY)
        
        // Set up colors
        let transparent = UIColor.clear.cgColor
        let opaque = UIColor.black.cgColor
        
        // Set mask
        self.layer.mask = gradientMask
        
        // Determine colors for non-scrolling label (i.e. at home)
        let adjustedColors: [CGColor]
        let trailingFadeNeeded = self.labelShouldScroll()

        switch type {
        case .continuousReverse, .rightLeft:
            adjustedColors = [(trailingFadeNeeded ? transparent : opaque), opaque, opaque, opaque]
        
        // .Continuous, .LeftRight
        default:
            adjustedColors = [opaque, opaque, opaque, (trailingFadeNeeded ? transparent : opaque)]
        }
        
        // Check for IBDesignable
        #if TARGET_INTERFACE_BUILDER
            gradientMask.colors = adjustedColors
            CATransaction.commit()
        #else
            if animated {
                // Finish transaction
                CATransaction.commit()
                
                // Create animation for color change
                let colorAnimation = GradientSetupAnimation(keyPath: "colors")
                colorAnimation.fromValue = gradientMask.colors
                colorAnimation.toValue = adjustedColors
                colorAnimation.fillMode = .forwards
                colorAnimation.isRemovedOnCompletion = false
                colorAnimation.delegate = self
                gradientMask.add(colorAnimation, forKey: "setupFade")
            } else {
                gradientMask.colors = adjustedColors
                CATransaction.commit()
            }
        #endif
    }
    
    private func removeGradientMask() {
        self.layer.mask = nil
    }
    
    private func timingFunctionForAnimationCurve(_ curve: UIView.AnimationCurve) -> CAMediaTimingFunction {
        let timingFunction: CAMediaTimingFunctionName?
        
        switch curve {
        case .easeIn:
            timingFunction = .easeIn
        case .easeInOut:
            timingFunction = .easeInEaseOut
        case .easeOut:
            timingFunction = .easeOut
        default:
            timingFunction = .linear
        }
        
        return CAMediaTimingFunction(name: timingFunction!)
    }
    
    private func transactionDurationType(_ labelType: MarqueeType, interval: CGFloat, delay: CGFloat) -> TimeInterval {
        switch labelType {
        case .leftRight, .rightLeft:
            return TimeInterval(2.0 * (delay + interval))
        default:
            return TimeInterval(delay + interval)
        }
    }
    
    public func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {
        if let setupAnim = anim as? GradientSetupAnimation {
            if let finalColors = setupAnim.toValue as? [CGColor] {
                maskLayer?.colors = finalColors
            }
            // Remove regardless, since we set removeOnCompletion = false
            maskLayer?.removeAnimation(forKey: "setupFade")
        } else {
            scrollCompletionBlock?(flag)
        }
    }
    
    
    //
    // MARK: - Private details
    //
    
    private var sublabel = UILabel()
    
    fileprivate var homeLabelFrame = CGRect.zero
    fileprivate var awayOffset: CGFloat = 0.0
    
    override open class var layerClass: AnyClass {
        return CAReplicatorLayer.self
    }
    
    fileprivate weak var repliLayer: CAReplicatorLayer? {
        return self.layer as? CAReplicatorLayer
    }
    
    fileprivate weak var maskLayer: CAGradientLayer? {
        return self.layer.mask as! CAGradientLayer?
    }
    
    fileprivate var scrollCompletionBlock: MLAnimationCompletionBlock?
    
    override open func draw(_ layer: CALayer, in ctx: CGContext) {
        // Do NOT call super, to prevent UILabel superclass from drawing into context
        // Label drawing is handled by sublabel and CAReplicatorLayer layer class
        
        // Draw only background color
        if let bgColor = backgroundColor {
            ctx.setFillColor(bgColor.cgColor)
            ctx.fill(layer.bounds)
        }
    }
    
    private var minimumTrailingDistance: CGFloat {
        // Spacing between primary and second sublabel must be at least equal to leadingBuffer, and at least equal to the fadeLengt
        return max(max(leadingBuffer, trailingBuffer), fadeLength)
    }
    
    fileprivate enum MarqueeKeys: String {
        case Restart = "MLViewControllerRestart"
        case Labelize = "MLShouldLabelize"
        case Animate = "MLShouldAnimate"
        case CompletionClosure = "MLAnimationCompletion"
    }
    
    class fileprivate func notifyController(_ controller: UIViewController, message: MarqueeKeys) {
        NotificationCenter.default.post(name: Notification.Name(rawValue: message.rawValue), object: nil, userInfo: ["controller" : controller])
    }
    
    @objc public func restartForViewController(_ notification: Notification) {
        if let controller = (notification as NSNotification).userInfo?["controller"] as? UIViewController {
            if controller === self.firstAvailableViewController() {
                self.restartLabel()
            }
        }
    }
    
    @objc public func labelizeForController(_ notification: Notification) {
        if let controller = (notification as NSNotification).userInfo?["controller"] as? UIViewController {
            if controller === self.firstAvailableViewController() {
                self.labelize = true
            }
        }
    }
    
    @objc public func animateForController(_ notification: Notification) {
        if let controller = (notification as NSNotification).userInfo?["controller"] as? UIViewController {
            if controller === self.firstAvailableViewController() {
                self.labelize = false
            }
        }
    }
    
    
    //
    // MARK: - Label Control
    //
    
    /**
     Overrides any non-size condition which is preventing the receiver from automatically scrolling, and begins a scroll animation.
    
     Currently the only non-size conditions which can prevent a label from scrolling are the `tapToScroll` and `holdScrolling` properties. This
     method will not force a label with a string that fits inside the label bounds (i.e. that would not automatically scroll) to begin a scroll
     animation.
    
     Upon the completion of the first forced scroll animation, the receiver will not automatically continue to scroll unless the conditions
     preventing scrolling have been removed.
    
     - Note: This method has no effect if called during an already in-flight scroll animation.
    
     - SeeAlso: restartLabel
    */
    public func triggerScrollStart() {
        if labelShouldScroll() && !awayFromHome {
            updateAndScroll(overrideHold: true)
        }
    }
    
    /**
     Immediately resets the label to the home position, cancelling any in-flight scroll animation, and restarts the scroll animation if the appropriate conditions are met.
     
     - SeeAlso: resetLabel
     - SeeAlso: triggerScrollStart
     */
    @objc public func restartLabel() {
        // Shutdown the label
        shutdownLabel()
        // Restart scrolling if appropriate
        if labelShouldScroll() && !tapToScroll && !holdScrolling {
            updateAndScroll()
        }
    }
    
    /**
     Resets the label text, recalculating the scroll animation.
     
     The text is immediately returned to the home position, and the scroll animation positions are cleared. Scrolling will not resume automatically after
     a call to this method. To re-initiate scrolling, use either a call to `restartLabel` or make a change to a UILabel property such as text, bounds/frame,
     font, font size, etc.
     
     - SeeAlso: restartLabel
     */
    @available(*, deprecated, message : "Use the shutdownLabel function instead")
    public func resetLabel() {
        returnLabelToHome()
        homeLabelFrame = CGRect.null
        awayOffset = 0.0
    }
    
    /**
     Immediately resets the label to the home position, cancelling any in-flight scroll animation.
     
     The text is immediately returned to the home position. Scrolling will not resume automatically after a call to this method.
     To re-initiate scrolling use a call to `restartLabel` or `triggerScrollStart`, or make a change to a UILabel property such as text, bounds/frame,
     font, font size, etc.
     
     - SeeAlso: restartLabel
     - SeeAlso: triggerScrollStart
     */
    @objc public func shutdownLabel() {
        // Bring label to home location
        returnLabelToHome()
        // Apply gradient mask for home location
        applyGradientMask(fadeLength, animated: false)
    }
    
    /**
     Pauses the text scrolling animation, at any point during an in-progress animation.
     
     - Note: This method has no effect if a scroll animation is NOT already in progress. To prevent automatic scrolling on a newly-initialized label prior to its presentation onscreen, see the `holdScrolling` property.
     
     - SeeAlso: holdScrolling
     - SeeAlso: unpauseLabel
     */
    public func pauseLabel() {
        // Prevent pausing label while not in scrolling animation, or when already paused
        guard !isPaused && awayFromHome else {
            return
        }
        
        // Pause sublabel position animations
        let labelPauseTime = sublabel.layer.convertTime(CACurrentMediaTime(), from: nil)
        sublabel.layer.speed = 0.0
        sublabel.layer.timeOffset = labelPauseTime
        
        // Pause gradient fade animation
        let gradientPauseTime = maskLayer?.convertTime(CACurrentMediaTime(), from:nil)
        maskLayer?.speed = 0.0
        maskLayer?.timeOffset = gradientPauseTime!
    }
    
    /**
     Un-pauses a previously paused text scrolling animation. This method has no effect if the label was not previously paused using `pauseLabel`.
     
     - SeeAlso: pauseLabel
     */
    public func unpauseLabel() {
        // Only unpause if label was previously paused
        guard isPaused else {
            return
        }
        
        // Unpause sublabel position animations
        let labelPausedTime = sublabel.layer.timeOffset
        sublabel.layer.speed = 1.0
        sublabel.layer.timeOffset = 0.0
        sublabel.layer.beginTime = 0.0
        sublabel.layer.beginTime = sublabel.layer.convertTime(CACurrentMediaTime(), from:nil) - labelPausedTime
        
        // Unpause gradient fade animation
        let gradientPauseTime = maskLayer?.timeOffset
        maskLayer?.speed = 1.0
        maskLayer?.timeOffset = 0.0
        maskLayer?.beginTime = 0.0
        maskLayer?.beginTime = maskLayer!.convertTime(CACurrentMediaTime(), from:nil) - gradientPauseTime!
    }
    
    @objc public func labelWasTapped(_ recognizer: UIGestureRecognizer) {
        if labelShouldScroll() && !awayFromHome {
            // Set shouldBeginScroll to true to begin single scroll due to tap
            updateAndScroll(overrideHold: true)
        }
    }
    
    /**
     Function to convert a point from the label view frame coordinates to "text" coordinates, i.e. the equivalent
     position in the (possibly) scrolling label. For example, it can be used to convert the coordinates
     of a tap point on the MarqueeLabel view into that of the scrolling label, in order to determine the
     word or character under the tap point.
     
     If the specified point does not fall inside the bounds of the scrolling label, such as if on a leading
     or trailing buffer area, the function will return nil.
     */
    open func textCoordinateForFramePoint(_ point:CGPoint) -> CGPoint? {
        // Check for presentation layer, if none return input point
        guard let presentationLayer = sublabel.layer.presentation() else { return point }
        // Convert point from MarqueeLabel main layer to sublabel's presentationLayer
        let presentationPoint = presentationLayer.convert(point, from: self.layer)
        // Check if point overlaps into 2nd instance of a continuous type label
        let textPoint: CGPoint?
        let presentationX = presentationPoint.x
        let labelWidth = sublabel.frame.size.width
        
        var containers: [Range<CGFloat>] = []
        switch type {
        case .continuous:
            // First label frame range
            let firstLabel = 0.0 ..< sublabel.frame.size.width
            // Range from end of first label to the minimum trailining distance (i.e. the separator)
            let minTrailing = firstLabel.rangeForExtension(minimumTrailingDistance)
            // Range of second label instance, from end of separator to length
            let secondLabel = minTrailing.rangeForExtension(labelWidth)
            // Add valid ranges to array to check
            containers += [firstLabel, secondLabel]
        case .continuousReverse:
            // First label frame range
            let firstLabel = 0.0 ..< sublabel.frame.size.width
            // Range of second label instance, from end of separator to length
            let secondLabel = -sublabel.frame.size.width ..< -minimumTrailingDistance
            // Add valid ranges to array to check
            containers += [firstLabel, secondLabel]
        case .left, .leftRight, .right, .rightLeft:
            // Only label frame range
            let firstLabel = 0.0 ..< sublabel.frame.size.width
            containers.append(firstLabel)
        }
        
        // Determine which range contains the point, or return nil if in a buffer/margin area
        guard let container = containers.filter({ (rng) -> Bool in
            return rng.contains(presentationX)
        }).first else { return nil }
            
        textPoint = CGPoint(x: (presentationX - container.lowerBound), y: presentationPoint.y)
        return textPoint
    }
    
    /**
     Called when the label animation is about to begin.
     
     The default implementation of this method does nothing. Subclasses may override this method in order to perform any custom actions just as
     the label animation begins. This is only called in the event that the conditions for scrolling to begin are met.
     */
    open func labelWillBeginScroll() {
        // Default implementation does nothing - override to customize
        return
    }
    
    /**
     Called when the label animation has finished, and the label is at the home position.
     
     The default implementation of this method does nothing. Subclasses may override this method in order to perform any custom actions jas as
     the label animation completes, and before the next animation would begin (assuming the scroll conditions are met).
     
     - Parameter finished: A Boolean that indicates whether or not the scroll animation actually finished before the completion handler was called.
     
     - Warning: This method will be called, and the `finished` parameter will be `NO`, when any property changes are made that would cause the label
     scrolling to be automatically reset. This includes changes to label text and font/font size changes.
     */
    open func labelReturnedToHome(_ finished: Bool) {
        // Default implementation does nothing - override to customize
        return
    }
    
    //
    // MARK: - Modified UILabel Functions/Getters/Setters
    //
    
    #if os(iOS)
    override open func forBaselineLayout() -> UIView {
        // Use subLabel view for handling baseline layouts
        return sublabel
    }
    
    override open var forLastBaselineLayout: UIView {
        // Use subLabel view for handling baseline layouts
        return sublabel
    }
    #endif

    override open var text: String? {
        get {
            return sublabel.text
        }
        
        set {
            if sublabel.text == newValue {
                return
            }
            sublabel.text = newValue
            updateAndScroll()
            super.text = text
        }
    }
    
    override open var attributedText: NSAttributedString? {
        get {
            return sublabel.attributedText
        }
        
        set {
            if sublabel.attributedText == newValue {
                return
            }
            sublabel.attributedText = newValue
            updateAndScroll()
            super.attributedText = attributedText
        }
    }
    
    override open var font: UIFont! {
        get {
            return sublabel.font
        }
        
        set {
            if sublabel.font == newValue {
                return
            }
            sublabel.font = newValue
            super.font = newValue
            
            updateAndScroll()
        }
    }
    
    override open var textColor: UIColor! {
        get {
            return sublabel.textColor
        }
        
        set {
            sublabel.textColor = newValue
            super.textColor = newValue
        }
    }
    
    override open var backgroundColor: UIColor? {
        get {
            return sublabel.backgroundColor
        }
        
        set {
            sublabel.backgroundColor = newValue
            super.backgroundColor = newValue
        }
    }
    
    override open var shadowColor: UIColor? {
        get {
            return sublabel.shadowColor
        }
        
        set {
            sublabel.shadowColor = newValue
            super.shadowColor = newValue
        }
    }
    
    override open var shadowOffset: CGSize {
        get {
            return sublabel.shadowOffset
        }
        
        set {
            sublabel.shadowOffset = newValue
            super.shadowOffset = newValue
        }
    }
    
    override open var highlightedTextColor: UIColor? {
        get {
            return sublabel.highlightedTextColor
        }
        
        set {
            sublabel.highlightedTextColor = newValue
            super.highlightedTextColor = newValue
        }
    }
    
    override open var isHighlighted: Bool {
        get {
            return sublabel.isHighlighted
        }
        
        set {
            sublabel.isHighlighted = newValue
            super.isHighlighted = newValue
        }
    }
    
    override open var isEnabled: Bool {
        get {
            return sublabel.isEnabled
        }
        
        set {
            sublabel.isEnabled = newValue
            super.isEnabled = newValue
        }
    }
    
    override open var numberOfLines: Int {
        get {
            return super.numberOfLines
        }
        
        set {
            // By the nature of MarqueeLabel, this is 1
            super.numberOfLines = 1
        }
    }
    
    override open var baselineAdjustment: UIBaselineAdjustment {
        get {
            return sublabel.baselineAdjustment
        }
        
        set {
            sublabel.baselineAdjustment = newValue
            super.baselineAdjustment = newValue
        }
    }
    
    override open var intrinsicContentSize: CGSize {
        var content = sublabel.intrinsicContentSize
        content.width += leadingBuffer
        return content
    }
    
    override open var tintColor: UIColor! {
        get {
            return sublabel.tintColor
        }
        
        set {
            sublabel.tintColor = newValue
            super.tintColor = newValue
        }
    }
    
    override open func tintColorDidChange() {
        super.tintColorDidChange()
        sublabel.tintColorDidChange()
    }
    
    override open var contentMode: UIView.ContentMode {
        get {
            return sublabel.contentMode
        }
        
        set {
            super.contentMode = contentMode
            sublabel.contentMode = newValue
        }
    }
    
    open override var isAccessibilityElement: Bool {
        didSet {
            sublabel.isAccessibilityElement = self.isAccessibilityElement
        }
    }

    //
    // MARK: - Support
    //
    
    fileprivate func offsetCGPoint(_ point: CGPoint, offset: CGFloat) -> CGPoint {
        return CGPoint(x: point.x + offset, y: point.y)
    }
    
    //
    // MARK: - Deinit
    //
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
}


//
// MARK: - Support
//
public protocol MarqueeStep {
    var timeStep: CGFloat { get }
    var timingFunction: UIView.AnimationCurve { get }
    var edgeFades: EdgeFade { get }
}


/**
 `ScrollStep` types define the label position at a specified time delta since the last `ScrollStep` step, as well as
 the animation curve to that position and edge fade state at the position
 */
public struct ScrollStep: MarqueeStep {
    /**
     An enum that provides the possible positions defined by a ScrollStep
     - `home`: The starting, default position of the label
     - `away`: The calculated position that results in the entirety of the label scrolling past.
     - `partial(CGFloat)`: A fractional value, specified by the associated CGFloat value, between the `home` and `away` positions (must be between 0.0 and 1.0).
     
     The `away` position depends on the MarqueeLabel `type` value.
     - For `left`, `leftRight`, `right`, and `rightLeft` types, the `away` position means the trailing edge of the label
        is visible. For `leftRight` and `rightLeft` default types, the scroll animation reverses direction after reaching
        this point and returns to the `home` position.
     - For `continuous` and `continuousReverse` types, the `away` position is the location such that if the scroll is completed
        at this point (i.e. the animation is removed), there will be no visible change in the label appearance.
     */
    public enum Position {
        case home
        case away
        case partial(CGFloat)
    }
    
    /**
     The desired time between this step and the previous `ScrollStep` in a sequence.
    */
    public let timeStep: CGFloat
    
    /**
     The animation curve to utilize between the previous `ScrollStep` in a sequence and this step.
     
     - Note: The animation curve value for the first `ScrollStep` in a sequence has no effect.
     */
    public let timingFunction: UIView.AnimationCurve
    
    /**
     The position of the label for this scroll step.
     - SeeAlso: Position
     */
    public let position: Position
    
    /**
     The option set defining the edge fade state for this scroll step.
     
     Possible options include `.leading` and `.trailing`, corresponding to the leading edge of the label scrolling (i.e. 
     the direction of scroll) and trailing edge of the label.
    */
    public let edgeFades: EdgeFade
    
    public init(timeStep: CGFloat, timingFunction: UIView.AnimationCurve = .linear, position: Position, edgeFades: EdgeFade) {
        self.timeStep = timeStep
        self.position = position
        self.edgeFades = edgeFades
        self.timingFunction = timingFunction
    }
}


/**
 `FadeStep` types allow additional edge fade state definitions, around the states defined by the `ScrollStep` steps of
 a sequence. `FadeStep` steps are defined by the time delta to the preceding or subsequent `ScrollStep` step and the timing
 function to their edge fade state.
 
 - Note: A `FadeStep` cannot be the first step in a sequence. A `FadeStep` defined as such will be ignored.
 */
public struct FadeStep: MarqueeStep {
    /**
     The desired time between this `FadeStep` and the preceding or subsequent `ScrollStep` in a sequence.
     
     `FadeSteps` with a negative `timeStep` value will be associated _only_ with an immediately-subsequent `ScrollStep` step
     in the sequence.
     
     `FadeSteps` with a positive `timeStep` value will be associated _only_ with an immediately-prior `ScrollStep` step in the
     sequence.
     
     - Note: A `FadeStep` with a `timeStep` value of 0.0 will have no effect, and is the same as defining the fade state with
     a `ScrollStep`.
     */
    public let timeStep: CGFloat
    
    /**
     The animation curve to utilize between the previous fade state in a sequence and this step.
     */
    public let timingFunction: UIView.AnimationCurve
    
    /**
     The option set defining the edge fade state for this fade step.
     
     Possible options include `.leading` and `.trailing`, corresponding to the leading edge of the label scrolling (i.e.
     the direction of scroll) and trailing edge of the label.
     
     As an Option Set type, both edge fade states may be defined using an array literal: `[.leading, .trailing]`.
     */
    public let edgeFades: EdgeFade
    
    public init(timeStep: CGFloat, timingFunction: UIView.AnimationCurve = .linear, edgeFades: EdgeFade) {
        self.timeStep = timeStep
        self.timingFunction = timingFunction
        self.edgeFades = edgeFades
    }
}

public struct EdgeFade: OptionSet {
    public let rawValue: Int
    public static let leading = EdgeFade(rawValue: 1 << 0)
    public static let trailing = EdgeFade(rawValue: 1 << 1)

    public init(rawValue: Int) {
        self.rawValue = rawValue
    }
}

// Define helpful typealiases
fileprivate typealias MLAnimationCompletionBlock = (_ finished: Bool) -> Void
fileprivate typealias MLAnimation = (anim: CAKeyframeAnimation, duration: CGFloat)

fileprivate class GradientSetupAnimation: CABasicAnimation {
}

fileprivate extension UILabel {
    func desiredSize() -> CGSize {
        // Bound the expected size
        let maximumLabelSize = CGSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)
        // Calculate the expected size
        var expectedLabelSize = self.sizeThatFits(maximumLabelSize)
        
        #if os(tvOS)
            // Sanitize width to 16384.0 (largest width a UILabel will draw on tvOS)
            expectedLabelSize.width = min(expectedLabelSize.width, 16384.0)
        #else
            // Sanitize width to 5461.0 (largest width a UILabel will draw on an iPhone 6S Plus)
            expectedLabelSize.width = min(expectedLabelSize.width, 5461.0)
        #endif

        // Adjust to own height (make text baseline match normal label)
        expectedLabelSize.height = bounds.size.height
        return expectedLabelSize
    }
}

fileprivate extension Range where Bound == CGFloat {
    func rangeForExtension(_ ext: CGFloat) -> Range {
        return self.upperBound..<(self.upperBound + ext)
    }
}

fileprivate extension UIResponder {
    // Thanks to Phil M
    // http://stackoverflow.com/questions/1340434/get-to-uiviewcontroller-from-uiview-on-iphone
    
    func firstAvailableViewController() -> UIViewController? {
        // convenience function for casting and to "mask" the recursive function
        return self.traverseResponderChainForFirstViewController()
    }
    
    func traverseResponderChainForFirstViewController() -> UIViewController? {
        if let nextResponder = self.next {
            if nextResponder is UIViewController {
                return nextResponder as? UIViewController
            } else if nextResponder is UIView {
                return nextResponder.traverseResponderChainForFirstViewController()
            } else {
                return nil
            }
        }
        return nil
    }
}

fileprivate extension CAMediaTimingFunction {
    
    func durationPercentageForPositionPercentage(_ positionPercentage: CGFloat, duration: CGFloat) -> CGFloat {
        // Finds the animation duration percentage that corresponds with the given animation "position" percentage.
        // Utilizes Newton's Method to solve for the parametric Bezier curve that is used by CAMediaAnimation.
        
        let controlPoints = self.controlPoints()
        let epsilon: CGFloat = 1.0 / (100.0 * CGFloat(duration))
        
        // Find the t value that gives the position percentage we want
        let t_found = solveTforY(positionPercentage, epsilon: epsilon, controlPoints: controlPoints)
        
        // With that t, find the corresponding animation percentage
        let durationPercentage = XforCurveAt(t_found, controlPoints: controlPoints)
        
        return durationPercentage
    }
    
    func solveTforY(_ y_0: CGFloat, epsilon: CGFloat, controlPoints: [CGPoint]) -> CGFloat {
        // Use Newton's Method: http://en.wikipedia.org/wiki/Newton's_method
        // For first guess, use t = y (i.e. if curve were linear)
        var t0 = y_0
        var t1 = y_0
        var f0, df0: CGFloat
        
        for _ in 0..<15 {
            // Base this iteration of t1 calculated from last iteration
            t0 = t1
            // Calculate f(t0)
            f0 = YforCurveAt(t0, controlPoints:controlPoints) - y_0
            // Check if this is close (enough)
            if abs(f0) < epsilon {
                // Done!
                return t0
            }
            // Else continue Newton's Method
            df0 = derivativeCurveYValueAt(t0, controlPoints:controlPoints)
            // Check if derivative is small or zero ( http://en.wikipedia.org/wiki/Newton's_method#Failure_analysis )
            if abs(df0) < 1e-6 {
                break
            }
            // Else recalculate t1
            t1 = t0 - f0/df0
        }
        
        // Give up - shouldn't ever get here...I hope
        print("MarqueeLabel: Failed to find t for Y input!")
        return t0
    }

    func YforCurveAt(_ t: CGFloat, controlPoints: [CGPoint]) -> CGFloat {
        let P0 = controlPoints[0]
        let P1 = controlPoints[1]
        let P2 = controlPoints[2]
        let P3 = controlPoints[3]
        
        // Per http://en.wikipedia.org/wiki/Bezier_curve#Cubic_B.C3.A9zier_curves
        let y0 = (pow((1.0 - t), 3.0) * P0.y)
        let y1 = (3.0 * pow(1.0 - t, 2.0) * t * P1.y)
        let y2 = (3.0 * (1.0 - t) * pow(t, 2.0) * P2.y)
        let y3 = (pow(t, 3.0) * P3.y)
        
        return y0 + y1 + y2 + y3
    }
    
    func XforCurveAt(_ t: CGFloat, controlPoints: [CGPoint]) -> CGFloat {
        let P0 = controlPoints[0]
        let P1 = controlPoints[1]
        let P2 = controlPoints[2]
        let P3 = controlPoints[3]
        
        // Per http://en.wikipedia.org/wiki/Bezier_curve#Cubic_B.C3.A9zier_curves

        let x0 = (pow((1.0 - t), 3.0) * P0.x)
        let x1 = (3.0 * pow(1.0 - t, 2.0) * t * P1.x)
        let x2 = (3.0 * (1.0 - t) * pow(t, 2.0) * P2.x)
        let x3 = (pow(t, 3.0) * P3.x)
        
        return x0 + x1 + x2 + x3
    }
    
    func derivativeCurveYValueAt(_ t: CGFloat, controlPoints: [CGPoint]) -> CGFloat {
        let P0 = controlPoints[0]
        let P1 = controlPoints[1]
        let P2 = controlPoints[2]
        let P3 = controlPoints[3]
        
        let dy0 = (P0.y + 3.0 * P1.y + 3.0 * P2.y - P3.y) * -3.0
        let dy1 = t * (6.0 * P0.y + 6.0 * P2.y)
        let dy2 = (-3.0 * P0.y + 3.0 * P1.y)

        return dy0 * pow(t, 2.0) + dy1 + dy2
    }
    
    func controlPoints() -> [CGPoint] {
        // Create point array to point to
        var point: [Float] = [0.0, 0.0]
        var pointArray = [CGPoint]()
        for i in 0...3 {
            self.getControlPoint(at: i, values: &point)
            pointArray.append(CGPoint(x: CGFloat(point[0]), y: CGFloat(point[1])))
        }
        
        return pointArray
    }
}

import Security
import Foundation

/**

A collection of helper functions for saving text and data in the keychain.

*/
open class KeychainSwift {
  
  var lastQueryParameters: [String: Any]? // Used by the unit tests
  
  /// Contains result code from the last operation. Value is noErr (0) for a successful result.
  open var lastResultCode: OSStatus = noErr

  var keyPrefix = "" // Can be useful in test.
  
  /**

  Specify an access group that will be used to access keychain items. Access groups can be used to share keychain items between applications. When access group value is nil all application access groups are being accessed. Access group name is used by all functions: set, get, delete and clear.

  */
  open var accessGroup: String?
  
  
  /**
   
  Specifies whether the items can be synchronized with other devices through iCloud. Setting this property to true will
   add the item to other devices with the `set` method and obtain synchronizable items with the `get` command. Deleting synchronizable items will remove them from all devices. In order for keychain synchronization to work the user must enable "Keychain" in iCloud settings.
   
  Does not work on macOS.
   
  */
  open var synchronizable: Bool = false

  private let lock = NSLock()

  
  /// Instantiate a KeychainSwift object
  public init() { }
  
  /**
  
  - parameter keyPrefix: a prefix that is added before the key in get/set methods. Note that `clear` method still clears everything from the Keychain.

  */
  public init(keyPrefix: String) {
    self.keyPrefix = keyPrefix
  }
  
  /**
  
  Stores the text value in the keychain item under the given key.
  
  - parameter key: Key under which the text value is stored in the keychain.
  - parameter value: Text string to be written to the keychain.
  - parameter withAccess: Value that indicates when your app needs access to the text in the keychain item. By default the .AccessibleWhenUnlocked option is used that permits the data to be accessed only while the device is unlocked by the user.
   
   - returns: True if the text was successfully written to the keychain.

  */
  @discardableResult
  open func set(_ value: String, forKey key: String,
                  withAccess access: KeychainSwiftAccessOptions? = nil) -> Bool {
    
    if let value = value.data(using: String.Encoding.utf8) {
      return set(value, forKey: key, withAccess: access)
    }
    
    return false
  }

  /**
  
  Stores the data in the keychain item under the given key.
  
  - parameter key: Key under which the data is stored in the keychain.
  - parameter value: Data to be written to the keychain.
  - parameter withAccess: Value that indicates when your app needs access to the text in the keychain item. By default the .AccessibleWhenUnlocked option is used that permits the data to be accessed only while the device is unlocked by the user.
  
  - returns: True if the text was successfully written to the keychain.
  
  */
  @discardableResult
  open func set(_ value: Data, forKey key: String,
    withAccess access: KeychainSwiftAccessOptions? = nil) -> Bool {
    
    // The lock prevents the code to be run simultaneously
    // from multiple threads which may result in crashing
    lock.lock()
    defer { lock.unlock() }
    
    deleteNoLock(key) // Delete any existing key before saving it

    let accessible = access?.value ?? KeychainSwiftAccessOptions.defaultOption.value
      
    let prefixedKey = keyWithPrefix(key)
      
    var query: [String : Any] = [
      KeychainSwiftConstants.klass       : kSecClassGenericPassword,
      KeychainSwiftConstants.attrAccount : prefixedKey,
      KeychainSwiftConstants.valueData   : value,
      KeychainSwiftConstants.accessible  : accessible
    ]
      
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: true)
    lastQueryParameters = query
    
    lastResultCode = SecItemAdd(query as CFDictionary, nil)
    
    return lastResultCode == noErr
  }

  /**

  Stores the boolean value in the keychain item under the given key.

  - parameter key: Key under which the value is stored in the keychain.
  - parameter value: Boolean to be written to the keychain.
  - parameter withAccess: Value that indicates when your app needs access to the value in the keychain item. By default the .AccessibleWhenUnlocked option is used that permits the data to be accessed only while the device is unlocked by the user.

  - returns: True if the value was successfully written to the keychain.

  */
  @discardableResult
  open func set(_ value: Bool, forKey key: String,
    withAccess access: KeychainSwiftAccessOptions? = nil) -> Bool {
  
    let bytes: [UInt8] = value ? [1] : [0]
    let data = Data(bytes)

    return set(data, forKey: key, withAccess: access)
  }

  /**
  
  Retrieves the text value from the keychain that corresponds to the given key.
  
  - parameter key: The key that is used to read the keychain item.
  - returns: The text value from the keychain. Returns nil if unable to read the item.
  
  */
  open func get(_ key: String) -> String? {
    if let data = getData(key) {
      
      if let currentString = String(data: data, encoding: .utf8) {
        return currentString
      }
      
      lastResultCode = -67853 // errSecInvalidEncoding
    }

    return nil
  }

  /**
  
  Retrieves the data from the keychain that corresponds to the given key.
  
  - parameter key: The key that is used to read the keychain item.
  - parameter asReference: If true, returns the data as reference (needed for things like NEVPNProtocol).
  - returns: The text value from the keychain. Returns nil if unable to read the item.
  
  */
  open func getData(_ key: String, asReference: Bool = false) -> Data? {
    // The lock prevents the code to be run simultaneously
    // from multiple threads which may result in crashing
    lock.lock()
    defer { lock.unlock() }
    
    let prefixedKey = keyWithPrefix(key)
    
    var query: [String: Any] = [
      KeychainSwiftConstants.klass       : kSecClassGenericPassword,
      KeychainSwiftConstants.attrAccount : prefixedKey,
      KeychainSwiftConstants.matchLimit  : kSecMatchLimitOne
    ]
    
    if asReference {
      query[KeychainSwiftConstants.returnReference] = kCFBooleanTrue
    } else {
      query[KeychainSwiftConstants.returnData] =  kCFBooleanTrue
    }
    
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: false)
    lastQueryParameters = query
    
    var result: AnyObject?
    
    lastResultCode = withUnsafeMutablePointer(to: &result) {
      SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
    }
    
    if lastResultCode == noErr {
      return result as? Data
    }
    
    return nil
  }

  /**

  Retrieves the boolean value from the keychain that corresponds to the given key.

  - parameter key: The key that is used to read the keychain item.
  - returns: The boolean value from the keychain. Returns nil if unable to read the item.

  */
  open func getBool(_ key: String) -> Bool? {
    guard let data = getData(key) else { return nil }
    guard let firstBit = data.first else { return nil }
    return firstBit == 1
  }

  /**

  Deletes the single keychain item specified by the key.
  
  - parameter key: The key that is used to delete the keychain item.
  - returns: True if the item was successfully deleted.
  
  */
  @discardableResult
  open func delete(_ key: String) -> Bool {
    // The lock prevents the code to be run simultaneously
    // from multiple threads which may result in crashing
    lock.lock()
    defer { lock.unlock() }
    
    return deleteNoLock(key)
  }
  
  /**
  Return all keys from keychain
   
  - returns: An string array with all keys from the keychain.
   
  */
  public var allKeys: [String] {
    var query: [String: Any] = [
      KeychainSwiftConstants.klass : kSecClassGenericPassword,
      KeychainSwiftConstants.returnData : true,
      KeychainSwiftConstants.returnAttributes: true,
      KeychainSwiftConstants.returnReference: true,
      KeychainSwiftConstants.matchLimit: KeychainSwiftConstants.secMatchLimitAll
    ]
  
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: false)

    var result: AnyObject?

    let lastResultCode = withUnsafeMutablePointer(to: &result) {
      SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
    }
    
    if lastResultCode == noErr {
      return (result as? [[String: Any]])?.compactMap {
        $0[KeychainSwiftConstants.attrAccount] as? String } ?? []
    }
    
    return []
  }
    
  /**
   
  Same as `delete` but is only accessed internally, since it is not thread safe.
   
   - parameter key: The key that is used to delete the keychain item.
   - returns: True if the item was successfully deleted.
   
   */
  @discardableResult
  func deleteNoLock(_ key: String) -> Bool {
    let prefixedKey = keyWithPrefix(key)
    
    var query: [String: Any] = [
      KeychainSwiftConstants.klass       : kSecClassGenericPassword,
      KeychainSwiftConstants.attrAccount : prefixedKey
    ]
    
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: false)
    lastQueryParameters = query
    
    lastResultCode = SecItemDelete(query as CFDictionary)
    
    return lastResultCode == noErr
  }

  /**
  
  Deletes all Keychain items used by the app. Note that this method deletes all items regardless of the prefix settings used for initializing the class.
  
  - returns: True if the keychain items were successfully deleted.
  
  */
  @discardableResult
  open func clear() -> Bool {
    // The lock prevents the code to be run simultaneously
    // from multiple threads which may result in crashing
    lock.lock()
    defer { lock.unlock() }
    
    var query: [String: Any] = [ kSecClass as String : kSecClassGenericPassword ]
    query = addAccessGroupWhenPresent(query)
    query = addSynchronizableIfRequired(query, addingItems: false)
    lastQueryParameters = query
    
    lastResultCode = SecItemDelete(query as CFDictionary)
    
    return lastResultCode == noErr
  }
  
  /// Returns the key with currently set prefix.
  func keyWithPrefix(_ key: String) -> String {
    return "\(keyPrefix)\(key)"
  }
  
  func addAccessGroupWhenPresent(_ items: [String: Any]) -> [String: Any] {
    guard let accessGroup = accessGroup else { return items }
    
    var result: [String: Any] = items
    result[KeychainSwiftConstants.accessGroup] = accessGroup
    return result
  }
  
  /**
 
  Adds kSecAttrSynchronizable: kSecAttrSynchronizableAny` item to the dictionary when the `synchronizable` property is true.
   
   - parameter items: The dictionary where the kSecAttrSynchronizable items will be added when requested.
   - parameter addingItems: Use `true` when the dictionary will be used with `SecItemAdd` method (adding a keychain item). For getting and deleting items, use `false`.
   
   - returns: the dictionary with kSecAttrSynchronizable item added if it was requested. Otherwise, it returns the original dictionary.
 
  */
  func addSynchronizableIfRequired(_ items: [String: Any], addingItems: Bool) -> [String: Any] {
    if !synchronizable { return items }
    var result: [String: Any] = items
    result[KeychainSwiftConstants.attrSynchronizable] = addingItems == true ? true : kSecAttrSynchronizableAny
    return result
  }
}
import Foundation
import Security

/// Constants used by the library
public struct KeychainSwiftConstants {
  /// Specifies a Keychain access group. Used for sharing Keychain items between apps.
  public static var accessGroup: String { return toString(kSecAttrAccessGroup) }
  
  /**
   
   A value that indicates when your app needs access to the data in a keychain item. The default value is AccessibleWhenUnlocked. For a list of possible values, see KeychainSwiftAccessOptions.
   
   */
  public static var accessible: String { return toString(kSecAttrAccessible) }
  
  /// Used for specifying a String key when setting/getting a Keychain value.
  public static var attrAccount: String { return toString(kSecAttrAccount) }

  /// Used for specifying synchronization of keychain items between devices.
  public static var attrSynchronizable: String { return toString(kSecAttrSynchronizable) }
  
  /// An item class key used to construct a Keychain search dictionary.
  public static var klass: String { return toString(kSecClass) }
  
  /// Specifies the number of values returned from the keychain. The library only supports single values.
  public static var matchLimit: String { return toString(kSecMatchLimit) }
  
  /// A return data type used to get the data from the Keychain.
  public static var returnData: String { return toString(kSecReturnData) }
  
  /// Used for specifying a value when setting a Keychain value.
  public static var valueData: String { return toString(kSecValueData) }
    
  /// Used for returning a reference to the data from the keychain
  public static var returnReference: String { return toString(kSecReturnPersistentRef) }
  
  /// A key whose value is a Boolean indicating whether or not to return item attributes
  public static var returnAttributes : String { return toString(kSecReturnAttributes) }
    
  /// A value that corresponds to matching an unlimited number of items
  public static var secMatchLimitAll : String { return toString(kSecMatchLimitAll) }
    
  static func toString(_ value: CFString) -> String {
    return value as String
  }
}


import Security

/**

These options are used to determine when a keychain item should be readable. The default value is AccessibleWhenUnlocked.

*/
public enum KeychainSwiftAccessOptions {
  
  /**
  
  The data in the keychain item can be accessed only while the device is unlocked by the user.
  
  This is recommended for items that need to be accessible only while the application is in the foreground. Items with this attribute migrate to a new device when using encrypted backups.
  
  This is the default value for keychain items added without explicitly setting an accessibility constant.
  
  */
  case accessibleWhenUnlocked
  
  /**
  
  The data in the keychain item can be accessed only while the device is unlocked by the user.
  
  This is recommended for items that need to be accessible only while the application is in the foreground. Items with this attribute do not migrate to a new device. Thus, after restoring from a backup of a different device, these items will not be present.
  
  */
  case accessibleWhenUnlockedThisDeviceOnly
  
  /**
  
  The data in the keychain item cannot be accessed after a restart until the device has been unlocked once by the user.
  
  After the first unlock, the data remains accessible until the next restart. This is recommended for items that need to be accessed by background applications. Items with this attribute migrate to a new device when using encrypted backups.
  
  */
  case accessibleAfterFirstUnlock
  
  /**
  
  The data in the keychain item cannot be accessed after a restart until the device has been unlocked once by the user.
  
  After the first unlock, the data remains accessible until the next restart. This is recommended for items that need to be accessed by background applications. Items with this attribute do not migrate to a new device. Thus, after restoring from a backup of a different device, these items will not be present.
  
  */
  case accessibleAfterFirstUnlockThisDeviceOnly

  /**
  
  The data in the keychain can only be accessed when the device is unlocked. Only available if a passcode is set on the device.
  
  This is recommended for items that only need to be accessible while the application is in the foreground. Items with this attribute never migrate to a new device. After a backup is restored to a new device, these items are missing. No items can be stored in this class on devices without a passcode. Disabling the device passcode causes all items in this class to be deleted.
  
  */
  case accessibleWhenPasscodeSetThisDeviceOnly
  
  static var defaultOption: KeychainSwiftAccessOptions {
    return .accessibleWhenUnlocked
  }
  
  var value: String {
    switch self {
    case .accessibleWhenUnlocked:
      return toString(kSecAttrAccessibleWhenUnlocked)
      
    case .accessibleWhenUnlockedThisDeviceOnly:
      return toString(kSecAttrAccessibleWhenUnlockedThisDeviceOnly)
      
    case .accessibleAfterFirstUnlock:
      return toString(kSecAttrAccessibleAfterFirstUnlock)
      
    case .accessibleAfterFirstUnlockThisDeviceOnly:
      return toString(kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly)
      
    case .accessibleWhenPasscodeSetThisDeviceOnly:
      return toString(kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly)
    }
  }
  
  func toString(_ value: CFString) -> String {
    return KeychainSwiftConstants.toString(value)
  }
}
