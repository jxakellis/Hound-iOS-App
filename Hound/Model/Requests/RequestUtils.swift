//
//  RequestUtils.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/6/22.
//  Copyright Â© 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ResponseAutomaticErrorAlertTypes {
    /// If a HoundError is generated by a success, failure, or no response to a request, is it automatically alerted to
    case automaticallyAlertForAll
    /// If a HoundError is generated by a failure response to a request, is it automatically alerted to
    case automaticallyAlertOnlyForFailure
    /// If a HoundError is generated by a success, failure, or no response to a request, is it not automatically alerted to
    case automaticallyAlertForNone
}

enum ResponseStatus {
    /// 200...299
    case successResponse
    /// != 200...299, e.g. 400, 404, 500
    case failureResponse
    /// Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
    case noResponse
}

/// abstractions used by other endpoint classes to make their request to the server, not used anywhere else in hound so therefore internal to endpoints and api requests.
enum RequestUtils {
    static var baseURL: URL { URL(string: DevelopmentConstant.url) ?? URL(fileURLWithPath: "foo") }
    
    private static let session = URLSession(configuration: {
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.timeoutIntervalForRequest = 15.0
        sessionConfig.timeoutIntervalForResource = 30.0
        sessionConfig.waitsForConnectivity = false
        return sessionConfig
    }())
    
    /// Tracks the date at which a request was made to the Hound server in order to make sure the rate limit isn't exceeded
    private static let houndServerRequestDates: [Date] = []
    /// For a given rateLimitTimePeriod, this is the amount of requests that can be performed without getting a rate limit
    private static let numberOfRequestsAllowedInTimePeriod: Int = 20
    /// The time period in which a specified number of requests can be made to the hound server without getting a rate limit from cloudflare. The true value is multiplied by 1.1 to provide extra padding
    private static let rateLimitTimePeriod: TimeInterval = (10.0 * 1.1)
    
    /// Takes an already constructed URLRequest and executes it, returning it in a compeltion handler. This is the basis to all URL requests
    private static func genericRequest(
        forRequest originalRequest: URLRequest,
        errorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        guard NetworkManager.shared.isConnected else {
            DispatchQueue.main.async {
                // We can't perform the request because there is no internet connection. Have offline sync manager start monitoring for when connectivity is restored
                OfflineModeManager.startMonitoring()
                
                let houndError = ErrorConstant.GeneralRequestError.noInternetConnection()
                if errorAlert == .automaticallyAlertForAll {
                    houndError.alert()
                }
                
                completionHandler(nil, .noResponse, houndError)
            }
            return nil
        }
        
        var request = originalRequest
        if let userIdentifier = UserInformation.userIdentifier {
            request.setValue(userIdentifier, forHTTPHeaderField: "houndheader-useridentifier")
        }
        request.setValue(UIApplication.appVersion, forHTTPHeaderField: "houndheader-appversion")
        
        AppDelegate.APIRequestLogger.notice("\(request.httpMethod ?? VisualConstant.TextConstant.unknownText) Request for \(request.url?.description ?? VisualConstant.TextConstant.unknownText)")
        
        
        let delayNeededToAvoidRateLimit: TimeInterval = {
            // TODO TEST the delay to avoid rate limit works
            
            // Check if enough requests have been performed where we could have exceeded the rate limit
            guard let oldestRequestAtStartOfTimePeriod = houndServerRequestDates.safeIndex(houndServerRequestDates.count - numberOfRequestsAllowedInTimePeriod) else {
                return 0.0
            }
            
            // Find the delay in which we wait long enough to perform the next request, so the tail end of the rate limit requests is older than the rate limit period. This ensures that, for examples, we have a 10 second rate limit period where CloudFlare won't allow more than 20 requests, we wait long enough so that 20th request is older than 10 seconds. Ensuring CloudFlare is ready to accept a new request.
            // E.g. rateLimitTimePeriod 10 seconds
            // oldestRequestAtStartOfTimePeriod 30.0 seconds ago -> (10.0 - 30.0) -> -20.0 -> 0.0
            // oldestRequestAtStartOfTimePeriod 5.0 seconds ago -> (10.0 - 5.0) -> 5.0 -> 5.0
            return max(0.0, rateLimitTimePeriod - oldestRequestAtStartOfTimePeriod.distance(to: Date()))
        }()
        
        
        // Create the task that will send the request
        let task = session.dataTask(with: request) { data, response, error in
            genericRequestResponse(forRequest: request, forErrorAlert: errorAlert, completionHandler: completionHandler, forData: data, forURLResponse: response, forError: error)
        }
        DispatchQueue.global().asyncAfter(deadline: .now() + delayNeededToAvoidRateLimit) {
            // Send the task once its time for it
            task.resume()
        }
        
        return task.progress
    }
    
    /// Parses the response from session.dataTask(with: request). Depending on if the response was a success, failure, or no response, invokes a futher helper function
    private static func genericRequestResponse(
        forRequest: URLRequest,
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void,
        forData: Data?,
        forURLResponse: URLResponse?,
        forError: Error?
    ) {
        // extract status code from URLResponse
        let responseStatusCode: Int? = (forURLResponse as? HTTPURLResponse)?.statusCode
        
        // parse response from json
        let responseBody: [String: Any?]? = {
            // if no data or if no status code, then request failed
            guard let forData = forData else {
                return nil
            }
            
            // try to serialize data as "result" form with array of info first, if that fails, revert to regular "message" and "error" format
            return try?
            JSONSerialization.jsonObject(with: forData, options: .fragmentsAllowed) as? [String: [[String: Any?]]]
            ?? JSONSerialization.jsonObject(with: forData, options: .fragmentsAllowed) as? [String: Any?]
        }()
        
        guard forError == nil, let responseBody = responseBody, let responseStatusCode = responseStatusCode else {
            genericRequestNoResponse(
                forRequest: forRequest,
                errorAlert: forErrorAlert,
                completionHandler: completionHandler,
                forResponseBody: responseBody,
                forError: forError
            )
            return
        }
        
        guard 200...299 ~= responseStatusCode else {
            genericRequestFailureResponse(
                forRequest: forRequest,
                errorAlert: forErrorAlert,
                completionHandler: completionHandler,
                forResponseBody: responseBody
            )
            return
        }
        
        genericRequestSuccessResponse(
            forRequest: forRequest,
            completionHandler: completionHandler,
            forResponseBody: responseBody
        )
    }
    
    /// Handles a case of a no response from a data task query
    private static func genericRequestNoResponse(
        forRequest request: URLRequest,
        errorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void,
        forResponseBody responseBody: [String: Any?]?, forError error: Error?
    ) {
        // assume an error is no response as that implies request/response failure, meaning the end result of no response is the same
        AppDelegate.APIResponseLogger.warning(
            "No \(request.httpMethod ?? VisualConstant.TextConstant.unknownText) Response for \(request.url?.description ?? VisualConstant.TextConstant.unknownText)\nData Task Error: \(error?.localizedDescription ?? VisualConstant.TextConstant.unknownText)")
        
        let responseError: HoundError = {
            switch request.httpMethod {
            case "PATCH":
                return ErrorConstant.GeneralResponseError.getNoResponse()
            case "POST":
                return ErrorConstant.GeneralResponseError.postNoResponse()
            case "PUT":
                return ErrorConstant.GeneralResponseError.putNoResponse()
            case "DELETE":
                return ErrorConstant.GeneralResponseError.deleteNoResponse()
            default:
                return ErrorConstant.GeneralResponseError.getNoResponse()
            }
        }()
        
        DispatchQueue.main.async {
            // We the request failed because there is no connection to the Hound server. Have offline sync manager start monitoring for when connectivity is restored.
            OfflineModeManager.startMonitoring()
            
            if errorAlert == .automaticallyAlertForAll {
                responseError.alert()
            }
            
            completionHandler(responseBody, .noResponse, responseError)
        }
    }
    
    /// Handles a case of a failure response from a data task query
    private static func genericRequestFailureResponse(
        forRequest request: URLRequest,
        errorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void,
        forResponseBody responseBody: [String: Any?]
    ) {
        // Our request went through but was invalid
        AppDelegate.APIResponseLogger.warning(
            "Failure \(request.httpMethod ?? VisualConstant.TextConstant.unknownText) Response for \(request.url?.description ?? VisualConstant.TextConstant.unknownText)\n Message: \(responseBody[KeyConstant.message.rawValue] as? String ?? VisualConstant.TextConstant.unknownText)\n Code: \(responseBody[KeyConstant.code.rawValue] as? String ?? VisualConstant.TextConstant.unknownText)\n Type:\(responseBody[KeyConstant.name.rawValue] as? String ?? VisualConstant.TextConstant.unknownText)")
        
        let responseErrorCode: String? = responseBody[KeyConstant.code.rawValue] as? String
        let requestId: Int = responseBody[KeyConstant.requestId.rawValue] as? Int ?? -1
        let responseId: Int = responseBody[KeyConstant.responseId.rawValue] as? Int ?? -1
        
        let responseError: HoundError = {
            // attempt to construct an error from responseErrorCode
            if let responseErrorCode = responseErrorCode, let error = ErrorConstant.serverError(forErrorCode: responseErrorCode, forRequestId: requestId, forResponseId: responseId) {
                return error
            }
            
            // could not construct an error, use a default error message based upon the http method
            switch request.httpMethod {
            case "PATCH":
                return ErrorConstant.GeneralResponseError.getFailureResponse(forRequestId: requestId, forResponseId: responseId)
            case "POST":
                return ErrorConstant.GeneralResponseError.postFailureResponse(forRequestId: requestId, forResponseId: responseId)
            case "PUT":
                return ErrorConstant.GeneralResponseError.putFailureResponse(forRequestId: requestId, forResponseId: responseId)
            case "DELETE":
                return ErrorConstant.GeneralResponseError.deleteFailureResponse(forRequestId: requestId, forResponseId: responseId)
            default:
                return ErrorConstant.GeneralResponseError.getFailureResponse(forRequestId: requestId, forResponseId: responseId)
            }
        }()
        
        DispatchQueue.main.async {
        guard responseError.name != ErrorConstant.GeneralResponseError.appVersionOutdated(forRequestId: -1, forResponseId: -1).name else {
            // If the user's app is outdated, it no longer works for hound. Therefore, prevent them from doing anything until they update.
            // Ignore errorAlert
            responseError.alert()
            return
        }
        
            if errorAlert == .automaticallyAlertForAll || errorAlert == .automaticallyAlertOnlyForFailure {
                responseError.alert()
            }
            
            // if the error happened to be about the user's account or family disappearing or them losing access, then revert them to the login page
            if responseError.name == ErrorConstant.PermissionResponseError.noUser(forRequestId: -1, forResponseId: -1).name {
                PersistenceManager.clearStorageToReloginToAccount()
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncViewController.self, completionHandler: nil)
            }
            else if responseError.name == ErrorConstant.PermissionResponseError.noFamily(forRequestId: -1, forResponseId: -1).name {
                PersistenceManager.clearStorageToRejoinFamily()
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncViewController.self, completionHandler: nil)
            }
            // if the error happens to be because a dog, log, or reminder was deleted, then invoke a low level refresh to update the user's data.
            else if responseError.name == ErrorConstant.FamilyResponseError.deletedDog(forRequestId: -1, forResponseId: -1).name ||
                        responseError.name == ErrorConstant.FamilyResponseError.deletedLog(forRequestId: -1, forResponseId: -1).name ||
                        responseError.name == ErrorConstant.FamilyResponseError.deletedReminder(forRequestId: -1, forResponseId: -1).name {
                MainTabBarController.shouldRefreshDogManager = true
            }
            
            completionHandler(responseBody, .failureResponse, responseError)
        }
    }
    
    /// Handles a case of a success response from a data task query
    private static func genericRequestSuccessResponse(
        forRequest request: URLRequest,
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void,
        forResponseBody responseBody: [String: Any?]
    ) {
        // Our request was valid and successful
        AppDelegate.APIResponseLogger.notice("Success \(request.httpMethod ?? VisualConstant.TextConstant.unknownText) Response for \(request.url?.description ?? VisualConstant.TextConstant.unknownText)")
        DispatchQueue.main.async {
            completionHandler(responseBody, .successResponse, nil)
        }
    }
}

extension RequestUtils {
    
    // MARK: - Generic GET, POST, PUT, and DELETE requests
    
    /// Perform a generic get request at the specified url with NO body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericGetRequest(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        forURL: URL,
        forBody: [String: Any?],
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "PATCH"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONSerialization.data(withJSONObject: forBody)
        
        return genericRequest(
            forRequest: request,
            errorAlert: errorAlert
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
    }
    
    /// Perform a generic get request at the specified url with provided body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericPostRequest(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        forURL: URL,
        forBody: [String: Any?],
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "POST"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONSerialization.data(withJSONObject: forBody)
        
        return genericRequest(
            forRequest: request,
            errorAlert: errorAlert
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
        
    }
    
    /// Perform a generic get request at the specified url with provided body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericPutRequest(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        forURL: URL,
        forBody: [String: Any?],
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "PUT"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONSerialization.data(withJSONObject: forBody)
        
        return genericRequest(
            forRequest: request,
            errorAlert: errorAlert
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
        
    }
    
    /// Perform a generic get request at the specified url with NO body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericDeleteRequest(
        errorAlert: ResponseAutomaticErrorAlertTypes,
        forURL: URL,
        forBody: [String: Any?],
        completionHandler: @escaping ([String: Any?]?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "DELETE"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONSerialization.data(withJSONObject: forBody)
        
        return genericRequest(
            forRequest: request,
            errorAlert: errorAlert
        ) { responseBody, responseStatus, error  in
            completionHandler(responseBody, responseStatus, error)
        }
    }
    
}
