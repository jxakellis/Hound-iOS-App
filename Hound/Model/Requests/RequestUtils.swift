//
//  RequestUtils.swift
//  Hound
//
//  Created by Jonathan Xakellis on 4/6/22.
//  Copyright Â© 2023 Jonathan Xakellis. All rights reserved.
//

import UIKit

enum ResponseAutomaticErrorAlertTypes {
    /// If a HoundError is generated by a success, failure, or no response to a request, is it automatically alerted to
    case automaticallyAlertForAll
    /// If a HoundError is generated by a failure response to a request, is it automatically alerted to
    case automaticallyAlertOnlyForFailure
    /// If a HoundError is generated by a success, failure, or no response to a request, is it not automatically alerted to
    case automaticallyAlertForNone
}

enum RequestSourceFunctionTypes {
    /// The request function was invoked through normal means from somewhere in the Hound app
    case normal
    /// The request function was invoked from the OfflineModeManager to re-sync data
    case offlineModeManager
}

enum ResponseStatus {
    /// 200...299
    case successResponse
    /// != 200...299, e.g. 400, 404, 500
    case failureResponse
    /// Request couldn't be constructed, request wasn't sent, request didn't go through, server was down, response was lost, or some other error
    case noResponse
}

/// abstractions used by other endpoint classes to make their request to the server, not used anywhere else in hound so therefore internal to endpoints and api requests.
enum RequestUtils {
    static var baseURL: URL { URL(string: Constant.Development.url) ?? URL(fileURLWithPath: "foo") }
    
    private static let session = URLSession(configuration: {
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.timeoutIntervalForRequest = 15.0
        sessionConfig.timeoutIntervalForResource = 30.0
        sessionConfig.waitsForConnectivity = false
        return sessionConfig
    }())
    
    /// Takes an already constructed URLRequest and executes it, returning it in a compeltion handler. This is the basis to all URL requests
    private static func genericRequest(
        forRequest originalRequest: URLRequest,
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        // If there is no internet connection, return noResponse and invoke OfflineModeManager to start attempting to re-sync data once a connection is restored
        // If sourceFunction is normal and OfflineModeManager is actively syncing, return noResponse as we want OfflineModeManager to finish syncing before trying to perform any more requests
        guard (NetworkManager.shared.isConnected) && (forSourceFunction != .normal || OfflineModeManager.shared.isSyncInProgress == false) else {
            // Any completionHandlers or UI element changes must be done on the main thread
            DispatchQueue.main.async {
                let houndError = Constant.Error.GeneralRequestError.noInternetConnection()
                if forErrorAlert == .automaticallyAlertForAll {
                    houndError.alert()
                }
                
                completionHandler(nil, ResponseStatus.noResponse, houndError)
                
                // We can't perform the request because there is no internet connection. Have offline sync manager start monitoring for when connectivity is restored. This has to be after completionHandler, otherwise there will be nothing to sync so OfflineModeManager won't monitor anything
                OfflineModeManager.shared.startMonitoring()
            }
            return nil
        }
        
        var request = originalRequest
        if let userIdentifier = UserInformation.userIdentifier {
            request.setValue(userIdentifier, forHTTPHeaderField: "houndheader-useridentifier")
        }
        request.setValue(UIApplication.appVersion, forHTTPHeaderField: "houndheader-appversion")
        
        HoundLogger.apiRequest.notice("\(request.httpMethod ?? Constant.Visual.Text.unknownText) Request for \(request.url?.description ?? Constant.Visual.Text.unknownText)")
        //        HoundLogger.apiRequest.debug("\tRequest Body: \(String(data: request.httpBody ?? Data(), encoding: .utf8) ?? Constant.Visual.Text.unknownText)")
        
        // Create the task that will send the request
        let task = session.dataTask(with: request) { data, response, error in
            genericRequestResponse(forRequest: request, forErrorAlert: forErrorAlert, completionHandler: completionHandler, forData: data, forURLResponse: response, forError: error)
        }
        
        // Pass off the task to be executed when its time for it. Handles lots of requests coming in at once
        DataTaskManager.enqueueTask(forDataTask: task)
        
        return task.progress
    }
    
    /// Parses the response from session.dataTask(with: request). Depending on if the response was a success, failure, or no response, invokes a futher helper function
    private static func genericRequestResponse(
        forRequest: URLRequest,
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void,
        forData: Data?,
        forURLResponse: URLResponse?,
        forError: Error?
    ) {
        // extract status code from URLResponse
        let responseStatusCode: Int? = (forURLResponse as? HTTPURLResponse)?.statusCode
        
        // parse response from json
        let responseBody: JSONResponseBody? = {
            // if no data or if no status code, then request failed
            guard let forData = forData else {
                return nil
            }
            
            // try to serialize data as "result" form with array of info first, if that fails, revert to regular "message" and "error" format
            return try?
            JSONSerialization.jsonObject(with: forData, options: .fragmentsAllowed) as? [String: [JSONResponseBody]]
            ?? JSONSerialization.jsonObject(with: forData, options: .fragmentsAllowed) as? JSONResponseBody
        }()
        
        //        HoundLogger.apiResponse.debug("\tResponse Body: \(responseBody)")
        
        guard forError == nil, let responseBody = responseBody, let responseStatusCode = responseStatusCode else {
            genericRequestNoResponse(
                forRequest: forRequest,
                forErrorAlert: forErrorAlert,
                completionHandler: completionHandler,
                forResponseBody: responseBody,
                forError: forError
            )
            return
        }
        
        guard 200...299 ~= responseStatusCode else {
            genericRequestFailureResponse(
                forRequest: forRequest,
                forErrorAlert: forErrorAlert,
                completionHandler: completionHandler,
                forResponseBody: responseBody
            )
            return
        }
        
        genericRequestSuccessResponse(
            forRequest: forRequest,
            completionHandler: completionHandler,
            forResponseBody: responseBody
        )
    }
    
    /// Handles a case of a no response from a data task query
    private static func genericRequestNoResponse(
        forRequest request: URLRequest,
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void,
        forResponseBody: JSONResponseBody?, forError error: Error?
    ) {
        // assume an error is no response as that implies request/response failure, meaning the end result of no response is the same
        HoundLogger.apiResponse.warning(
            "No \(request.httpMethod ?? Constant.Visual.Text.unknownText) Response for \(request.url?.description ?? Constant.Visual.Text.unknownText)\nData Task Error: \(error?.localizedDescription ?? Constant.Visual.Text.unknownText)")
        
        let responseError: HoundError = {
            switch request.httpMethod {
            case "PATCH":
                return Constant.Error.GeneralResponseError.getNoResponse()
            case "POST":
                return Constant.Error.GeneralResponseError.postNoResponse()
            case "PUT":
                return Constant.Error.GeneralResponseError.putNoResponse()
            case "DELETE":
                return Constant.Error.GeneralResponseError.deleteNoResponse()
            default:
                return Constant.Error.GeneralResponseError.getNoResponse()
            }
        }()
        
        // Any completionHandlers or UI element changes must be done on the main thread
        DispatchQueue.main.async {
            if forErrorAlert == .automaticallyAlertForAll {
                responseError.alert()
            }
            
            completionHandler(forResponseBody, .noResponse, responseError)
            
            // We can't perform the request because there is no internet connection. Have offline sync manager start monitoring for when connectivity is restored. This has to be after completionHandler, otherwise there will be nothing to sync so OfflineModeManager won't monitor anything
            OfflineModeManager.shared.startMonitoring()
        }
    }
    
    /// Handles a case of a failure response from a data task query
    private static func genericRequestFailureResponse(
        forRequest request: URLRequest,
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void,
        forResponseBody responseBody: JSONResponseBody
    ) {
        // Our request went through but was invalid
        HoundLogger.apiResponse.warning(
            "Failure \(request.httpMethod ?? Constant.Visual.Text.unknownText) Response for \(request.url?.description ?? Constant.Visual.Text.unknownText)\n Message: \(responseBody[Constant.Key.message.rawValue] as? String ?? Constant.Visual.Text.unknownText)\n Code: \(responseBody[Constant.Key.code.rawValue] as? String ?? Constant.Visual.Text.unknownText)\n Type:\(responseBody[Constant.Key.name.rawValue] as? String ?? Constant.Visual.Text.unknownText)")
        
        let responseErrorCode: String? = responseBody[Constant.Key.code.rawValue] as? String
        let requestId: Int = responseBody[Constant.Key.requestId.rawValue] as? Int ?? -1
        let responseId: Int = responseBody[Constant.Key.responseId.rawValue] as? Int ?? -1
        
        let responseError: HoundError = {
            // attempt to construct an error from responseErrorCode
            if let responseErrorCode = responseErrorCode, let error = Constant.Error.serverError(forErrorCode: responseErrorCode, forRequestId: requestId, forResponseId: responseId) {
                return error
            }
            
            // could not construct an error, use a default error message based upon the http method
            switch request.httpMethod {
            case "PATCH":
                return Constant.Error.GeneralResponseError.getFailureResponse(forRequestId: requestId, forResponseId: responseId)
            case "POST":
                return Constant.Error.GeneralResponseError.postFailureResponse(forRequestId: requestId, forResponseId: responseId)
            case "PUT":
                return Constant.Error.GeneralResponseError.putFailureResponse(forRequestId: requestId, forResponseId: responseId)
            case "DELETE":
                return Constant.Error.GeneralResponseError.deleteFailureResponse(forRequestId: requestId, forResponseId: responseId)
            default:
                return Constant.Error.GeneralResponseError.getFailureResponse(forRequestId: requestId, forResponseId: responseId)
            }
        }()
        
        // Any completionHandlers or UI element changes must be done on the main thread
        DispatchQueue.main.async {
            
            guard responseError.name != Constant.Error.GeneralResponseError.appVersionOutdated(forRequestId: -1, forResponseId: -1).name else {
                // If the user's app is outdated, it no longer works for hound. Therefore, prevent them from doing anything until they update.
                // Ignore forErrorAlert
                responseError.alert()
                return
            }
            
            if forErrorAlert == .automaticallyAlertForAll || forErrorAlert == .automaticallyAlertOnlyForFailure {
                responseError.alert()
            }
            
            // if the error happened to be about the user's account or family disappearing or them losing access, then revert them to the login page
            if responseError.name == Constant.Error.PermissionResponseError.noUser(forRequestId: -1, forResponseId: -1).name {
                PersistenceManager.clearStorageToReloginToAccount()
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncVC.self, completionHandler: nil)
            }
            else if responseError.name == Constant.Error.PermissionResponseError.noFamily(forRequestId: -1, forResponseId: -1).name {
                PersistenceManager.clearStorageToRejoinFamily()
                PresentationManager.lastFromGlobalPresenterStack?.dismissToViewController(ofClass: ServerSyncVC.self, completionHandler: nil)
            }
            // if the error happens to be because a dog, log, or reminder was deleted, then invoke a low level refresh to update the user's data.
            else if responseError.name == Constant.Error.FamilyResponseError.deletedDog(forRequestId: -1, forResponseId: -1).name ||
                        responseError.name == Constant.Error.FamilyResponseError.deletedLog(forRequestId: -1, forResponseId: -1).name ||
                        responseError.name == Constant.Error.FamilyResponseError.deletedReminder(forRequestId: -1, forResponseId: -1).name ||
                        responseError.name == Constant.Error.FamilyResponseError.deletedTrigger(forRequestId: -1, forResponseId: -1).name {
                MainTabBarController.shouldSilentlyRefreshDogManager = true
            }
            else if responseError.name == Constant.Error.GeneralResponseError.rateLimitExceeded(forRequestId: -1, forResponseId: -1).name {
                DataTaskManager.lastDateRateLimitReceived = Date()
            }
            
            completionHandler(responseBody, .failureResponse, responseError)
        }
    }
    
    /// Handles a case of a success response from a data task query
    private static func genericRequestSuccessResponse(
        forRequest request: URLRequest,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void,
        forResponseBody responseBody: JSONResponseBody
    ) {
        // Our request was valid and successful
        HoundLogger.apiResponse.notice("Success \(request.httpMethod ?? Constant.Visual.Text.unknownText) Response for \(request.url?.description ?? Constant.Visual.Text.unknownText)")
        
        // Any completionHandlers or UI element changes must be done on the main thread
        DispatchQueue.main.async {
            completionHandler(responseBody, .successResponse, nil)
        }
    }
}

extension RequestUtils {
    
    // MARK: - Generic GET, POST, PUT, and DELETE requests
    
    /// Perform a generic get request at the specified url with NO body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericGetRequest(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        forURL: URL,
        forBody: JSONRequestBody,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "PATCH"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        let serializableBody = forBody.toAnyDictionary()
        request.httpBody = try? JSONSerialization.data(withJSONObject: serializableBody)
        
        return genericRequest(
            forRequest: request,
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
    }
    
    /// Perform a generic get request at the specified url with provided body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericPostRequest(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        forURL: URL,
        forBody: JSONRequestBody,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "POST"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        let serializableBody = forBody.toAnyDictionary()
        request.httpBody = try? JSONSerialization.data(withJSONObject: serializableBody)
        
        return genericRequest(
            forRequest: request,
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
        
    }
    
    /// Perform a generic get request at the specified url with provided body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericPutRequest(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        forURL: URL,
        forBody: JSONRequestBody,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "PUT"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        let serializableBody = forBody.toAnyDictionary()
        request.httpBody = try? JSONSerialization.data(withJSONObject: serializableBody)
        
        return genericRequest(
            forRequest: request,
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction
        ) { responseBody, responseStatus, error in
            completionHandler(responseBody, responseStatus, error)
        }
        
    }
    
    /// Perform a generic get request at the specified url with NO body; assumes URL params are already provided. completionHandler is on the .main thread.
    static func genericDeleteRequest(
        forErrorAlert: ResponseAutomaticErrorAlertTypes,
        forSourceFunction: RequestSourceFunctionTypes,
        forURL: URL,
        forBody: JSONRequestBody,
        completionHandler: @escaping (JSONResponseBody?, ResponseStatus, HoundError?) -> Void
    ) -> Progress? {
        
        // create request to send
        var request = URLRequest(url: forURL)
        
        // specify http method
        request.httpMethod = "DELETE"
        
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        let serializableBody = forBody.toAnyDictionary()
        request.httpBody = try? JSONSerialization.data(withJSONObject: serializableBody)
        
        return genericRequest(
            forRequest: request,
            forErrorAlert: forErrorAlert,
            forSourceFunction: forSourceFunction
        ) { responseBody, responseStatus, error  in
            completionHandler(responseBody, responseStatus, error)
        }
    }
    
}
